(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

exports.grid = [
'.hypergrid-container {',
'	position: relative;',
'	height: 500px;',
'}',
'.hypergrid-textfield {',
'	position: absolute;',
'	font-size: 12px;',
'	color: black;',
'	background-color: ivory;',
'	box-sizing: border-box;',
'	margin: 0;',
'	padding: 0 5px;',
'	border: 0; /*border: 1px solid #777;*/',
'	outline: 0;',
'}',
'',
'div.hypergrid-combobox {',
'	position: absolute;',
'	display: none;',
'	outline: 0;',
'	padding: 0;',
'	border: 0; /*border: 1px solid #777;*/',
'	box-sizing: border-box;',
'	background-color: ivory;',
'	color: black;',
'	font-size: 12px;',
'}',
'div.hypergrid-combobox > input {',
'	position: absolute;',
'	margin-top: -1px;',
'	height: 100%;',
'	right: 20px;',
'	left: 0;',
'	width: 100%;',
'	outline: 0;',
'	padding: 0;',
'',
'	border: 5px solid transparent;',
'	border-right-width: 20px;',
'	border-bottom-width: 0;',
'	border-top-width: 0;',
'	box-sizing: border-box;',
'',
'	font-size: 12px;',
'	color: black;',
'	background-color: transparent;',
'}',
'div.hypergrid-combobox > span {',
'	position: absolute;',
'	box-sizing: border-box;',
'	width: 20px;',
'	height: 100%;',
'	right: 0;',
'	text-align: center;',
'	font-size: 1.5em;',
'	line-height: 1em;',
'}',
'div.hypergrid-combobox span[title] {',
'	color: lightgrey;',
'	cursor: pointer;',
'	margin-top: -2px;',
'}',
'div.hypergrid-combobox span[title]:hover {',
'	color: grey;',
'}',
'div.hypergrid-combobox span[title]:active, div.hypergrid-combobox span[title].active {',
'	color: blue;',
'}',
'div.hypergrid-combobox > span {',
'	margin-top: -1px;',
'}',
'div.hypergrid-combobox > span::after {',
'	content: \'\\25BE\';',
'	font-size: 20px;',
'}',
'div.hypergrid-combobox > div {',
'	position: absolute;',
'	left: -1px;',
'	right: -1px;',
'	top: 14px;',
'	height: 0;',
'	transition: height .25s;',
'	visibility: hidden;',
'	/*box-shadow: white 0 0 1px 1px;*/',
'	box-sizing: border-box;',
'	border: 1px solid #777;',
'	background-color: ivory;',
'	-webkit-user-select: none;',
'	-moz-user-select: none;',
'	-ms-user-select: none;',
'}',
'div.hypergrid-combobox > div > div {',
'	position: absolute;',
'	height: 13px;',
'	width: 100%;',
'	text-align: center;',
'}',
'div.hypergrid-combobox > div span[title] {',
'	font-weight: bold;',
'	font-size: 12px;',
'	font-family: verdana, geneva, sans-serif;',
'	margin-left: 6px;',
'	margin-right: 6px;',
'}',
'div.hypergrid-combobox > div span:not([title]) {',
'	font-style: italic;',
'	padding-top: 1px;',
'}',
'div.hypergrid-combobox > div select {',
'	position: absolute;',
'	padding-top: 2px;',
'	border: 0;',
'	outline: 0;',
'	border-top: 1px solid #777;',
'	width: 100%;',
'	top: 15px;',
'	bottom: 0;',
'	left: 0;',
'	right: 0;',
'	background-color: transparent;',
'	font-family: sans-serif;',
'	font-weight: bold;',
'	font-size: 9px;',
'}',
'div.hypergrid-combobox > div select option:hover {',
'	background-color: #777;',
'	color: ivory;',
'}'
].join('\n');

exports['list-dragon-addendum'] = [
'div.dragon-list, li.dragon-pop {',
'	font-family: Roboto, sans-serif;',
'	text-transform: capitalize; }',
'div.dragon-list {',
'	position: absolute;',
'	top: 4%;',
'	left: 4%;',
'	height: 92%;',
'	width: 20%; }',
'div.dragon-list:nth-child(2) { left: 28%; }',
'div.dragon-list:nth-child(3) { left: 52%; }',
'div.dragon-list:nth-child(4) { left: 76%; }',
'div.dragon-list > div, div.dragon-list > ul > li, li.dragon-pop { line-height: 46px; }',
'div.dragon-list > ul { top: 46px; }',
'div.dragon-list > ul > li:not(:last-child)::before, li.dragon-pop::before {',
'	content: \'\\2b24\';',
'	color: #b6b6b6;',
'	font-size: 30px;',
'	margin: 8px 14px 8px 8px; }',
'li.dragon-pop { opacity:.8; }'
].join('\n');

},{}],2:[function(require,module,exports){
'use strict';

exports.CQL = [
'<li>',
'	<label title="${1}">',
'		<a type="button" class="filter-copy"></a>',
'		<div class="filter-tree-remove-button" title="delete conditional"></div>',
'		<strong>%{0}:</strong>',
'		<input name="${1}" class="filter-text-box ${3}" value="%{2}">',
'	</label>',
'	<div class="filter-tree-warn"></div>',
'</li>'
].join('\n');

exports.SQL = [
'<li>',
'	<label title="${1}">',
'		<a type="button" class="filter-copy"></a>',
'		<div class="filter-tree-remove-button" title="delete conditional"></div>',
'		<strong>%{0}:</strong>',
'		<textarea name="${1}" rows="1" class="filter-text-box ${3}">%{2}</textarea>',
'	</label>',
'	<div class="filter-tree-warn"></div>',
'</li>'
].join('\n');

exports.dialog = [
'<div id="hypergrid-dialog">',
'',
'	<style>',
'		#hypergrid-dialog {',
'			position: absolute;',
'			top: 0;',
'			left: 0;',
'			bottom: 0;',
'			right: 0;',
'			background-color: white;',
'			font: 10pt sans-serif;',
'			opacity: 0;',
'			transition: opacity 1s;',
'			box-shadow: rgba(0, 0, 0, 0.298039) 0px 19px 38px, rgba(0, 0, 0, 0.219608) 0px 15px 12px;',
'		}',
'		#hypergrid-dialog.hypergrid-dialog-visible {',
'			opacity: 1;',
'			transition: opacity 1s;',
'		}',
'',
'		#hypergrid-dialog .hypergrid-dialog-control-panel {',
'			position: absolute;',
'			top: 0px;',
'			right: 12px;',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-control-panel a {',
'			color: #999;',
'			font-size: 33px;',
'			transition: text-shadow .35s, color .35s;',
'			text-decoration: none;',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-close:after {',
'			content: \'\\D7\';',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-settings:after {',
'			font-family: Apple Symbols;',
'			content: \'\\2699\';',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-control-panel a:hover {',
'			color: black;',
'			text-shadow: 0 0 6px #337ab7;',
'			transition: text-shadow .35s, color .35s;',
'		}',
'		#hypergrid-dialog .hypergrid-dialog-control-panel a:active {',
'			color: #d00;',
'			transition: color 0s;',
'		}',
'	</style>',
'',
'	<span class="hypergrid-dialog-control-panel">',
'		<a class="hypergrid-dialog-settings" title="(There are no settings for Manage Filters at this time.)"></a>',
'		<a class="hypergrid-dialog-close"></a>',
'	</span>',
'',
'</div>'
].join('\n');

exports.filterTrees = [
'<style>',
'	#hypergrid-dialog > div {',
'		position: absolute;',
'		top: 0;',
'		left: 0;',
'		bottom: 0;',
'		right: 0;',
'	}',
'	#hypergrid-dialog > div:first-of-type {',
'		padding: 1em 1em 1em 0.5em;',
'		margin-left: 50%;',
'	}',
'	#hypergrid-dialog > div:last-of-type {',
'		padding: 1em 0.5em 1em 1em;',
'		margin-right: 50%;',
'	}',
'	#hypergrid-dialog > div > p:first-child {',
'		margin-top: 0;',
'	}',
'	#hypergrid-dialog > div > p > span:first-child {',
'		font-size: larger;',
'		letter-spacing: 2px;',
'		font-weight: bold;',
'		color: #666;',
'		margin-right: 1em;',
'	}',
'	#hypergrid-dialog input, #hypergrid-dialog textarea {',
'		outline: 0;',
'		line-height: initial;',
'	}',
'',
'	.tabz { z-index: 0 }',
'	.tabz > p:first-child, .tabz > section > p:first-child, .tabz > section > div > p:first-child { margin-top: 0 }',
'',
'	#hypergrid-dialog a.more-info { font-size: smaller; }',
'	#hypergrid-dialog a.more-info::after { content: \'(more info)\'; }',
'	#hypergrid-dialog a.more-info.hide-info { color: red; }',
'	#hypergrid-dialog a.more-info.hide-info::after { content: \'(hide info)\'; }',
'	#hypergrid-dialog div.more-info {',
'		border: 1px tan solid;',
'		border-radius: 8px;',
'		padding: 0 8px .2em;',
'		display: none;',
'		background-color: ivory;',
'		box-shadow: 3px 3px 5px #707070;',
'		margin-bottom: 1em;',
'	}',
'	#hypergrid-dialog div.more-info > p { margin: .5em 0; }',
'',
'	#hypergrid-dialog .tabz ul {',
'		padding-left: 1.5em;',
'		list-style-type: circle;',
'		font-weight: bold;',
'	}',
'	#hypergrid-dialog .tabz ul > li > ul {',
'		list-style-type: disc;',
'		font-weight: normal;',
'	}',
'	#hypergrid-dialog .tabz li {',
'		margin: .3em 0;',
'	}',
'	#hypergrid-dialog .tabz li > code {',
'		background: #e0e0e0;',
'		margin: 0 .1em;',
'		padding: 0 5px;',
'		border-radius: 4px;',
'	}',
'',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > div:last-child ol {',
'		padding-left: 1.6em;',
'	}',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > div:last-child ol > li > label {',
'		width: 100%;',
'		font-weight: normal;',
'		display: inline;',
'	}',
'	#hypergrid-dialog .tabz .filter-tree-warn {',
'		color: darkred;',
'		font-size: smaller;',
'		font-style: italic;',
'		line-height: initial;',
'	}',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > textarea,',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > div:last-child textarea,',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > div:last-child input {',
'		display: block;',
'		position: relative;',
'		min-width: 100%;',
'		max-width: 100%;',
'		box-sizing: border-box;',
'		border: 1px solid black;',
'		padding: .4em .7em;',
'		font-family: monospace;',
'		font-size: 9pt;',
'		margin-top: 3px;',
'	}',
'	#hypergrid-dialog .tabz > section.filter-expression-syntax > textarea {',
'		height: 96%;',
'	}',
'	#hypergrid-dialog .tabz a.filter-copy {',
'		display: block;',
'		float: right;',
'		font-size: smaller;',
'	}',
'	#hypergrid-dialog .tabz a.filter-copy:before {',
'		content: \'(copy\';',
'	}',
'	#hypergrid-dialog .tabz a.filter-copy:after {',
'		content: \')\';',
'	}',
'	#hypergrid-dialog .tabz a.filter-copy:active {',
'		color: red;',
'	}',
'</style>',
'',
'<div>',
'	<select id="add-column-filter-subexpression" style="float:right; margin-left:1em; margin-right:4em;">',
'		<option value="">New column filter&hellip;</option>',
'	</select>',
'',
'	<p>',
'		<span>Column Filters</span>',
'		<a class="more-info"></a>',
'	</p>',
'	<div class="more-info">',
'		<p>The table filter can be viewed in the Query Builder or as SQL WHERE clause syntax. Both interfaces manipulate the same underlying filter data structure.</p>',
'		<p>All column filters are AND&rsquo;d together. Each grid row is first qualified by the table filter and then successively qualified by each column filter subexpression.</p>',
'	</div>',
'',
'	<div class="tabz" id="columnFiltersPanel">',
'',
'		<header id="columnsQB" class="default-tab">',
'			Query Builder',
'		</header>',
'',
'		<section>',
'		</section>',
'',
'		<header id="columnsSQL" class="tabz-bg2">',
'			SQL',
'		</header>',
'',
'		<section class="filter-expression-syntax tabz-bg2">',
'			<div>',
'				<p>',
'					<span></span>',
'					<a type="button" class="filter-copy" title="The state of the column filters subtree expressed in SQL syntax (all the column filter subexpressions shown below AND&rsquo;d together).">',
'						all</a>',
'				</p>',
'				<ol></ol>',
'			</div>',
'		</section>',
'',
'		<header id="columnsCQL" class="tabz-bg1">',
'			CQL',
'		</header>',
'',
'		<section class="filter-expression-syntax tabz-bg1">',
'			<p>',
'				<em>',
'					<small>Column filter cells accept a simplified, compact, and intuitive syntax, which is however not as flexible or concise as SQL syntax or using the Query Builder.</small>',
'					<a class="more-info"></a>',
'				</em>',
'			</p>',
'			<div class="more-info">',
'				<ul>',
'					<li>',
'						Simple expressions',
'						<ul>',
'							<li>All simple expressions take the form <i>operator literal</i> or <i>operator identifier</i>. The (left side) column is always implied and is the same for all simple expressions in a compound expression. This is because column filters are always tied to a known column.</li>',
'',
'							<li>If the operator is an equals sign (=), it may be omitted.</li>',
'',
'							<li>Besides operators, no other punctuation is permitted, meaning that no quotation marks and no parentheses.</li>',
'',
'							<li>If a literal exactly matches a column name or alias, the operand is not taken literally and instead refers to the value in that column. (There are properties to control what constitutes such a match: Column name, alias, or either; and the case-sensitivity of the match.)</li>',
'',
'							<li>As literals are unquoted, any operator symbol or operator word (including logical operators for compound expressions) terminates a literal.</li>',
'',
'							<li>An important corollary to the above features is that operators may not appear in literals.</li>',
'						</ul>',
'					</li>',
'',
'					<li>',
'						Compound expressions',
'						<ul>',
'							<li>Compound expressions are formed by connecting simple expressions with the logical operators <code>AND</code>, <code>OR</code>, <code>NOR</code>, or <code>NAND</code> ("not and").</li>',
'',
'							<li>However, all logical operators used in a compound column filter expression must be homogeneous. You may not mix the above logical operators in a single column. (If you need to do this, create a table filter expression instead.)</li>',
'						</ul>',
'					</li>',
'',
'					<li>',
'						Hidden logic',
'						<ul>',
'							<li>If the column is also referenced in a table filter expression (on the left side of a simple expression), the column filter is flagged in its grid cell with a special star character. This is just a flag; it is not part of the syntax. <span style="color:red; font-style:italic">Not yet implemented.</span></li>',
'						</ul>',
'					</li>',
'				</ul>',
'			</div>',
'',
'			<div>',
'				<p><span></span></p>',
'				<ol></ol>',
'			</div>',
'		</section>',
'	</div>',
'</div>',
'',
'<div>',
'	<p>',
'		<span>Table Filter</span>',
'		<a class="more-info"></a>',
'	</p>',
'	<div class="more-info">',
'		<p>The table filter can be viewed in the Query Builder or as SQL WHERE clause syntax. Both interfaces manipulate the same underlying filter data structure.</p>',
'		<p>',
'			These filter subexpressions are both required (<code>AND</code>&rsquo;d together), resulting in a subset of <em>qualified rows</em> which have passed through both filters.',
'			It\'s called a <dfn>tree</dfn> because it contains both <dfn>branches</dfn> and <dfn>leaves</dfn>.',
'			The leaves represent <dfn>conditional expressions</dfn> (or simply <dfn>conditionals</dfn>).',
'			The branches, also known as <dfn>subtrees</dfn>, contain leaves and/or other branches and represent subexpressions that group conditionals together.',
'			Grouped conditionals are evaluated together, before conditionals outside the group.',
'		</p>',
'	</div>',
'',
'	<div class="tabz" id="tableFilterPanel">',
'		<header id="tableQB">',
'			Query Builder',
'		</header>',
'',
'		<section>',
'		</section>',
'',
'		<header id="tableSQL" class="tabz-bg2">',
'			SQL',
'		</header>',
'',
'		<section class="filter-expression-syntax tabz-bg2">',
'			<div>',
'				<p>',
'					SQL WHERE clause syntax with certain restrictions.',
'					<a class="more-info"></a>',
'				</p>',
'				<div class="more-info">',
'					<ul>',
'						<li>',
'							Simple expressions',
'							<ul>',
'								<li>All simple expressions must be of the form <i>column operator literal</i> or <i>column operator identifier</i>. That is, the left side must refer to a column (may not be a literal); whereas the right side may be either.</li>',
'',
'								<li>Column names may be quoted with the currently set quote characters (typically double-quotes). If unquoted, they must consist of classic identifier syntax (alphanumerics and underscore, but not beginning with a numeral).</li>',
'',
'								<li>All literals must be quoted strings (using single quotes). (In a future release we expect to support unquoted numeric syntax for columns explicitly typed as numeric.)</li>',
'							</ul>',
'						</li>',
'',
'						<li>',
'							Compound expressions',
'							<ul>',
'								<li>Compound expressions are formed by connecting simple expressions with the logical operators <code>AND</code> or <code>OR</code>.</li>',
'',
'								<li>However, all logical operators at each level in a complex expression (each parenthesized subexpression) must be homogeneous, <i>i.e.,</i> either <code>AND</code> or <code>OR</code> but not a mixture of the two. In other words, there is no implicit operator precedence; grouping of expressions must always be explicitly stated with parentheses.</li>',
'',
'								<li>The unary logical operator <code>NOT</code> is supoorted before parentheses only. While the Query Builder and the Column Filter allow they syntax <code>&hellip; NOT <i>operator</i> &hellip;</code> (where <code><i>operator</i></code> is <code>IN</code>, <code>LIKE</code>, <i>etc.</i>), these must be expressed here with parenthethes: <code>NOT (&hellip; <i>operator</i> &hellip;)</code>.</li>',
'',
'								<li>While the Query Builder and Column Filter syntax support the pseudo-operators <code>NOR</code> and <code>NAND</code>, in SQL these must be expressed as <code>NOT (&hellip; OR &hellip;)</code> and <code>NOT (&hellip; AND &hellip;)</code>, respectively.</li>',
'',
'								<li>The Query Builder and Column Filter syntax also support the pseudo-operators <code>BEGINS abc</code>, <code>ENDS xyz</code>, and <code>CONTAINS def</code>. These are expressed in SQL by <code>LIKE \'abc%\'</code>, <code>LIKE \'%xyz\'</code>, and <code>LIKE \'%def%\'</code>, respectively.</li>',
'							</ul>',
'						</li>',
'					</ul>',
'				</div>',
'			</div>',
'			<div class="filter-tree-warn"></div>',
'			<textarea></textarea>',
'		</section>',
'',
'	</div>',
'</div>'
].join('\n');

},{}],3:[function(require,module,exports){
module.exports = { // This file generated by gulp-imagine-64 at 11:23:49 AM on 10/28/2016
	"calendar": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAc0lEQVR4nIXQwQkCMRSE4U9ZLMCT9Xjaq2AfNhfYU5oQLMAOtoN48EWei5iBIRPe/yYQ3qrhf1lFG7iKcEaJxSfukUvMWgdHavt0uWHtg2QwxXnAnJZ2uOLyVZtybzzhgWNmfoFl0/YB87NbzR1cjP9xeQHSDC6mcL1xFQAAAABJRU5ErkJggg=="
	},
	"checked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAYJJREFUOE+NkstLglEQxf0fahG0iFrUxm2ElFDYLohCqCDaCAkWPaxIRbFFEJEaGEKLDCoMETRFUAMLyaIHBUG6sSKIMtKFqEhLT818ZUgmDhzu3DPn9z0uV1RrmUwmyGQyqNVqfFvViwBxu5RFPZuLSyGMKhz/qlEsRV19K8xm6y+w7bpBPFnAferjj3bdQX6DpHcAUwavAHUN2RGIZxBJZHH2mC/TUeydwwTZvBegLENNgw7sX6Wh1FswNmPEmjPCDyGRRwCtW9E3tMgdAtQw7GZjYcNX+gza2wJ3ZXsSZUuQ0vWCOV8SHfJJ/uluhbHUj1v8PKNMszIoQNRMHCShD6Wh8zyhrbOPwz8w+STKlCCJ7oRNUzQH63kBs5thBghePXxlj2aUoSxDPcuXPNiLAc5EEZ6HIkbmV2DYiXBPHs0o079+K0DTVj/s11mE00A0L+g4VcDp10qKZMAzytBhMaTRaPmYg885DlcSzSij0eoEiIouoUqlqqqaL2rlEok+Ad4vlfzPoVDsAAAAAElFTkSuQmCC"
	},
	"dialog": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAH4AAAAUCAMAAAB8knmGAAAAXVBMVEXn4tfm4dfn4tjn49no5Nrp5dzp5Nvm4dbi3NDg2s3o5Nvl4NTh287k39Pp5dvh3M/j3dHk39Tl4NXg287k3tPi3dHh3NDm4tfj3tLh28/o49ro49ng2s7l4dbl4Nb6VbEyAAAC1ElEQVR4AXVV0YKDKAwE4AAVK6SwC9bt/3/mnYJ2tF7ewMEJyWRgjHMuhFT/nEMb261hxbrqh23hRomYhxLrYfXATTm6DTv060q0vxh9+b+SYj3Muj3c5IORAFMBEtD0rKgoAHIJLWLlfpIG8qAAIk3wk9tJKz2E84GrHUvbVhLbyvw0iA2/6ota/Qbbvv+YbUekbUV6R/Dg3YWN+ZyzT/a8X6KpBLpW3cta2FCOLFMkLuZe97PgFJM7joaG9bUHlVyZWM63tGllZp+yzIwipGFJQwJ5rqgX2e7/w9KrwuYMAtBkgTbS73z0r9JD9IJyy2GJEjSQD9kJwiIeTSNxyC9Dz2VcGiKT6IHplr7VynbA+UpVA+bxQYi/kNPknJtSDn9CfebBNPSrZdK0r+6ImE8p5RzDm4szgFtIQNqme3ZkcBsP1rRvJZBbfr6c4O8Qc04pgfJrY5rs4dJ5hhZ0z9z6+x0vys8Oyj5nKEMTP8oLBw+7OAh9TkCdJ8/5Nno4dt6d506dybUYbhTDmFjtxwxjTvjVDhITiJVNoe5LyoGIQk4Ftd+QEcnlYPF+KY+DWc1WgPSqJeXjXxPpT9uXoBqGx6m7jylyvRvm8hGApuNAyWis98rXYvevZVSguzgfw8kGf3aR4gd2DNUcQX1qXHavvLFrpv6L/nt/d+9RXV8OFDCFEAhHBt+qSr6/FN+37JVS7BC9zwOXj6/JW04JLB7m984v/HIiX77m7iH5kL1198ov8OI0ziX01b32Fo9c3VHzce9xdcs+LC0TeHPKRfmulOLcZfTyW2ICz6Dr5Fl4F41o1q1nYeAts6buhieSy3e+kqzM7PP885AtfB0FJOCoUZnUQSyllAU3kmk4ckAuRqC2OXAh1b3ylaBj9Ka3PidQQxJcBEtGrWRncv2ejrEjVCnSX9tYOuBk07YI4J6MYppcBU0pEgOvDtv+xCCTrtwL5l87wVO3O/g5GQAAAABJRU5ErkJggg=="
	},
	"down-rectangle": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAECAYAAABcDxXOAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAABpJREFUGFdjgIL/eDAKIKgABggqgAE0BQwMAPTlD/Fpi0JfAAAAAElFTkSuQmCC"
	},
	"filter-off": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAChSURBVChTzZHBCoUgFET9TqEiskgyWoutQvRLRIr+cR7XQAjiJW/1BgZmMUevXsY5xy9OoDEGMcYiUzeB67qibVuwQjVNA6311V+WBeM4vsLDMEApde/1fY9pmtI453neHEKAlBJd1z0fXtc16PbjODK07zvmeUZVVd8nooc75zJIOX3Gm6i0bVsGKf8xKIRIuyJTLgJJ3nvQzsjW2geIsQ/pr9hMVrSncAAAAABJRU5ErkJggg=="
	},
	"filter-on": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAACoSURBVChTY3BqfP2fHAzWmDbj7f8p294RhVOBasEa02e+/e/VBmQQCTxaX/9PnvYGoj5ywpv/Qd2ENft3vv4f1gfVBAP+nW/+h/a+ATtn1q73KHjytvdgg3070DTBgHvL6/8g22fsQGiaDmSHA21xaybgIpDHixa8hWssnA8NDEIApCh3LkIjiD2INYJCL2X6W3B8gdhEaQQBUOCA4gyE8+e9xaKJgQEA/74BNE3cElkAAAAASUVORK5CYII="
	},
	"unchecked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAARBJREFUOE+9krtug1AQRPldSio7FQ1tZImOkoKOBomGT0EURC5ino54yTw90WywQhTkIkVWGoF2zuxdrlD+t0zThKZpT0Vmxb8CQRCg6zr0fb8rer7vfwcPxxdcrx+YpgnzPGNZlh9ibxxHlGUJshLSdV0at9tNpg7DIBrX5+OkPM9BVkKGYSBJEtR1jbZrBdiqbVtUVYU0TUFWQq+nE+I4xvvlImGaW7FHjwxZCVmWhbfzGVmWoSgKWXUr9uiRISshx3FkEldomubXauzRI0NWQp7nyUR+NG/rfr/jUXxnjx5vmKyEbNuWox9Xvid6ZMhK6HA4wnVdhGGIKIp2RY8MWQmx+JuoqvpUZFb8L6UonyYL3uOtrFH+AAAAAElFTkSuQmCC"
	},
	"up-down-spin": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGJJREFUOE+lkwEKACEIBH2Zb/PnHsoGeaVJDUjGOgRRpKpkiIj+y4MME3eDR7kaKOVNsJyMNjIHzGy9YnW6J7qIcrriQimeCqORNABd0fpRTkt8uVUj7EsxC6vs/q3e/Q6iD2bwnByjPXHNAAAAAElFTkSuQmCC"
	},
	"up-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGFJREFUOE+lkkEKQCEIRD2ZJ3Ph3iN4WD9GflpYhj0YYowpGgJmbikd3gjMDFokwbuT1iAiurG5nomgqo5QaPo9ERQRI6Jf7sfGjudy2je23+i0Wl2oQ85TOdlfrJQOazF8br+rqTXQKn0AAAAASUVORK5CYII="
	},
};

},{}],4:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

var images = require('./images'); // this is the file generated by gulpfile.js (and ignored by git)

_(images).each(function(image, key) {
    var element = new Image();
    element.src = 'data:' + image.type + ';base64,' + image.data;
    images[key] = element;
});

images.checkbox = function(state) {
    return images[state ? 'checked' : 'unchecked'];
};

images.filter = function(state) {
    return images[state ? 'filter-on' : 'filter-off'];
};

module.exports = images;

},{"./images":3,"object-iterators":42}],5:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/** @module automat */

var ENCODERS = /%\{(\d+)\}/g; // double $$ to encode

var REPLACERS = /\$\{(.*?)\}/g; // single $ to replace


/**
 * @summary String formatter.
 *
 * @desc String substitution is performed on numbered _replacer_ patterns like `${n}` or _encoder_ patterns like `%{n}` where n is the zero-based `arguments` index. So `${0}` would be replaced with the first argument following `text`.
 *
 * Encoders are just like replacers except the argument is HTML-encoded before being used.
 *
 * To change the format patterns, assign new `RegExp` patterns to `automat.encoders` and `automat.replacers`.
 *
 * @param {string|function} template - A template to be formatted as described above. Overloads:
 * * A string primitive containing the template.
 * * A function to be called with `this` as the calling context. The template is the value returned from this call.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @return {string} The formatted text.
 *
 * @memberOf module:automat
 */
function automat(template, replacements/*...*/) {
    var hasReplacements = arguments.length > 1;

    // if `template` is a function, convert it to text
    if (typeof template === 'function') {
        template = template.call(this); // non-template function: call it with context and use return value
    }

    if (hasReplacements) {
        var args = arguments;
        template = template.replace(automat.replacersRegex, function(match, key) {
            key -= -1; // convert to number and increment
            return args.length > key ? args[key] : '';
        });

        template = template.replace(automat.encodersRegex, function(match, key) {
            key -= -1; // convert to number and increment
            if (args.length > key) {
                var htmlEncoderNode = document.createElement('DIV');
                htmlEncoderNode.textContent = args[key];
                return htmlEncoderNode.innerHTML;
            } else {
                return '';
            }
        });
    }

    return template;
}

/**
 * @summary Replace contents of `el` with `Nodes` generated from formatted template.
 *
 * @param {string|function} template - See `template` parameter of {@link automat}.
 *
 * @param {HTMLElement} [el] - Node in which to return markup generated from template. If omitted, a new `<div>...</div>` element will be created and returned.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @return {HTMLElement} The `el` provided or a new `<div>...</div>` element, its `innerHTML` set to the formatted text.
 *
 * @memberOf module:automat
 */
function replace(template, el, replacements/*...*/) {
    var elOmitted = typeof el !== 'object',
        args = Array.prototype.slice.call(arguments, 1);

    if (elOmitted) {
        el = document.createElement('DIV');
        args.unshift(template);
    } else {
        args[0] = template;
    }

    el.innerHTML = automat.apply(null, args);

    return el;
}

/**
 * @summary Append or insert `Node`s generated from formatted template into given `el`.
 *
 * @param {string|function} template - See `template` parameter of {@link automat}.
 *
 * @param {HTMLElement} el
 *
 * @param {Node} [referenceNode=null] Inserts before this element within `el` or at end of `el` if `null`.
 *
 * @param {...*} [replacements] - Replacement values for numbered format patterns.
 *
 * @returns {Node[]} Array of the generated nodes (this is an actual Array instance; not an Array-like object).
 *
 * @memberOf module:automat
 */
function append(template, el, referenceNode, replacements/*...*/) {
    var replacementsStartAt = 3,
        referenceNodeOmitted = typeof referenceNode !== 'object';  // replacements are never objects

    if (referenceNodeOmitted) {
        referenceNode = null;
        replacementsStartAt = 2;
    }

    replacements = Array.prototype.slice.call(arguments, replacementsStartAt);
    var result = [],
        div = replace.apply(null, [template].concat(replacements));

    while (div.childNodes.length) {
        result.push(div.firstChild);
        el.insertBefore(div.firstChild, referenceNode); // removes child from div
    }

    return result;
}

/**
 * Use this convenience wrapper to return the first child node described in `template`.
 *
 * @param {string|function} template - If a function, extract template from comment within.
 *
 * @returns {HTMLElement} The first `Node` in your template.
 *
 * @memberOf module:automat
 */
function firstChild(template, replacements/*...*/) {
    return replace.apply(null, arguments).firstChild;
}

/**
 * Use this convenience wrapper to return the first child element described in `template`.
 *
 * @param {string|function} template - If a function, extract template from comment within.
 *
 * @returns {HTMLElement} The first `HTMLElement` in your template.
 *
 * @memberOf module:automat
 */
function firstElement(template, replacements/*...*/) {
    return replace.apply(null, arguments).firstElementChild;
}

/**
 * @summary Finds string substitution lexemes that require HTML encoding.
 * @desc Modify to suit.
 * @default %{n}
 * @type {RegExp}
 * @memberOf module:automat
 */
automat.encodersRegex = ENCODERS;

/**
 * @summary Finds string substitution lexemes.
 * @desc Modify to suit.
 * @default ${n}
 * @type {RegExp}
 * @memberOf module:automat
 */
automat.replacersRegex = REPLACERS;

automat.format = automat; // if you find using just `automat()` confusing
automat.replace = replace;
automat.append = append;
automat.firstChild = firstChild;
automat.firstElement = firstElement;

module.exports = automat;

},{}],6:[function(require,module,exports){
'use strict';

/* eslint-env browser */

/** @namespace cssInjector */

/**
 * @summary Insert base stylesheet into DOM
 *
 * @desc Creates a new `<style>...</style>` element from the named text string(s) and inserts it but only if it does not already exist in the specified container as per `referenceElement`.
 *
 * > Caveat: If stylesheet is for use in a shadow DOM, you must specify a local `referenceElement`.
 *
 * @returns A reference to the newly created `<style>...</style>` element.
 *
 * @param {string|string[]} cssRules
 * @param {string} [ID]
 * @param {undefined|null|Element|string} [referenceElement] - Container for insertion. Overloads:
 * * `undefined` type (or omitted): injects stylesheet at top of `<head>...</head>` element
 * * `null` value: injects stylesheet at bottom of `<head>...</head>` element
 * * `Element` type: injects stylesheet immediately before given element, wherever it is found.
 * * `string` type: injects stylesheet immediately before given first element found that matches the given css selector.
 *
 * @memberOf cssInjector
 */
function cssInjector(cssRules, ID, referenceElement) {
    if (typeof referenceElement === 'string') {
        referenceElement = document.querySelector(referenceElement);
        if (!referenceElement) {
            throw 'Cannot find reference element for CSS injection.';
        }
    } else if (referenceElement && !(referenceElement instanceof Element)) {
        throw 'Given value not a reference element.';
    }

    var container = referenceElement && referenceElement.parentNode || document.head || document.getElementsByTagName('head')[0];

    if (ID) {
        ID = cssInjector.idPrefix + ID;

        if (container.querySelector('#' + ID)) {
            return; // stylesheet already in DOM
        }
    }

    var style = document.createElement('style');
    style.type = 'text/css';
    if (ID) {
        style.id = ID;
    }
    if (cssRules instanceof Array) {
        cssRules = cssRules.join('\n');
    }
    cssRules = '\n' + cssRules + '\n';
    if (style.styleSheet) {
        style.styleSheet.cssText = cssRules;
    } else {
        style.appendChild(document.createTextNode(cssRules));
    }

    if (referenceElement === undefined) {
        referenceElement = container.firstChild;
    }

    container.insertBefore(style, referenceElement);

    return style;
}

/**
 * @summary Optional prefix for `<style>` tag IDs.
 * @desc Defaults to `'injected-stylesheet-'`.
 * @type {string}
 * @memberOf cssInjector
 */
cssInjector.idPrefix = 'injected-stylesheet-';

// Interface
module.exports = cssInjector;

},{}],7:[function(require,module,exports){
'use strict';

var overrider = require('overrider');

/** @namespace extend-me **/

/** @summary Extends an existing constructor into a new constructor.
 *
 * @returns {ChildConstructor} A new constructor, extended from the given context, possibly with some prototype additions.
 *
 * @desc Extends "objects" (constructors), with optional additional code, optional prototype additions, and optional prototype member aliases.
 *
 * > CAVEAT: Not to be confused with Underscore-style .extend() which is something else entirely. I've used the name "extend" here because other packages (like Backbone.js) use it this way. You are free to call it whatever you want when you "require" it, such as `var inherits = require('extend')`.
 *
 * Provide a constructor as the context and any prototype additions you require in the first argument.
 *
 * For example, if you wish to be able to extend `BaseConstructor` to a new constructor with prototype overrides and/or additions, basic usage is:
 *
 * ```javascript
 * var Base = require('extend-me').Base;
 * var BaseConstructor = Base.extend(basePrototype); // mixes in .extend
 * var ChildConstructor = BaseConstructor.extend(childPrototypeOverridesAndAdditions);
 * var GrandchildConstructor = ChildConstructor.extend(grandchildPrototypeOverridesAndAdditions);
 * ```
 *
 * This function (`extend()`) is added to the new extended object constructor as a property `.extend`, essentially making the object constructor itself easily "extendable." (Note: This is a property of each constructor and not a method of its prototype!)
 *
 * @param {string} [extendedClassName] - This is simply added to the prototype as $$CLASS_NAME. Useful for debugging because all derived constructors appear to have the same name ("Constructor") in the debugger.
 *
 * @param {extendedPrototypeAdditionsObject} [prototypeAdditions] - Object with members to copy to new constructor's prototype.
 *
 * @property {boolean} [debug] - See parameter `extendedClassName` _(above)_.
 *
 * @property {object} Base - A convenient base class from which all other classes can be extended.
 *
 * @memberOf extend-me
 */
function extend(extendedClassName, prototypeAdditions) {
    switch (arguments.length) {
        case 0:
            prototypeAdditions = {};
            break;
        case 1:
            switch (typeof extendedClassName) {
                case 'object':
                    prototypeAdditions = extendedClassName;
                    extendedClassName = undefined;
                    break;
                case 'string':
                    prototypeAdditions = {};
                    break;
                default:
                    throw 'Single-parameter overload must be either string or object.';
            }
            break;
        case 2:
            if (typeof extendedClassName !== 'string' || typeof prototypeAdditions !== 'object') {
                throw 'Two-parameter overload must be string, object.';
            }
            break;
        default:
            throw 'Too many parameters';
    }

    function Constructor() {
        if (prototypeAdditions.preInitialize) {
            prototypeAdditions.preInitialize.apply(this, arguments);
        }

        initializePrototypeChain.apply(this, arguments);

        if (prototypeAdditions.postInitialize) {
            prototypeAdditions.postInitialize.apply(this, arguments);
        }
    }

    Constructor.extend = extend;

    var prototype = Constructor.prototype = Object.create(this.prototype);
    prototype.constructor = Constructor;

    if (extendedClassName) {
        prototype.$$CLASS_NAME = extendedClassName;
    }

    overrider(prototype, prototypeAdditions);

    return Constructor;
}

function Base() {}
Base.prototype = {
    constructor: Base.prototype.constructor,
    get super() {
        return Object.getPrototypeOf(Object.getPrototypeOf(this));
    }
};
Base.extend = extend;
extend.Base = Base;

/** @typedef {function} extendedConstructor
 * @property prototype.super - A reference to the prototype this constructor was extended from.
 * @property [extend] - If `prototypeAdditions.extendable` was truthy, this will be a reference to {@link extend.extend|extend}.
 */

/** @typedef {object} extendedPrototypeAdditionsObject
 * @desc All members are copied to the new object. The following have special meaning.
 * @property {function} [initialize] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after similar function in all ancestors called with same signature.
 * @property {function} [preInitialize] - Called before the `initialize` cascade. Gets passed new object as context + same args as constructor itself.
 * @property {function} [postInitialize] - Called after the `initialize` cascade. Gets passed new object as context + same args as constructor itself.
 */

/** @summary Call all `initialize` methods found in prototype chain, beginning with the most senior ancestor's first.
 * @desc This recursive routine is called by the constructor.
 * 1. Walks back the prototype chain to `Object`'s prototype
 * 2. Walks forward to new object, calling any `initialize` methods it finds along the way with the same context and arguments with which the constructor was called.
 * @private
 * @memberOf extend-me
 */
function initializePrototypeChain() {
    var term = this,
        args = arguments;
    recur(term);

    function recur(obj) {
        var proto = Object.getPrototypeOf(obj);
        if (proto.constructor !== Object) {
            recur(proto);
            if (proto.hasOwnProperty('initialize')) {
                proto.initialize.apply(term, args);
            }
        }
    }
}

module.exports = extend;

},{"overrider":43}],8:[function(require,module,exports){
'use strict';

function DataSourceBase() {}

DataSourceBase.extend = require('extend-me');

DataSourceBase.prototype = {
    constructor: DataSourceBase.prototype.constructor,

    replaceIndent: '_',

    isNullObject: true,

    DataSourceError: DataSourceError,

    initialize: function(dataSource) {
        this.dataSource = dataSource;
    },

    // GETTERS/SETTERS

    get schema() {
        if (this.dataSource) {
            return this.dataSource.schema;
        }
    },
    set schema(schema) {
        if (this.dataSource) {
            this.dataSource.schema = schema;
        }
    },


    // "SET" METHODS (ALWAYS HAVE ARGS)

    setSchema: function() {
        if (this.dataSource) {
            return this.dataSource.setSchema.apply(this.dataSource, arguments);
        }
    },

    setData: function() {
        if (this.dataSource) {
            return this.dataSource.setData.apply(this.dataSource, arguments);
        }
    },

    setValue: function() {
        if (this.dataSource) {
            return this.dataSource.setValue.apply(this.dataSource, arguments);
        }
    },


    // "GET" METHODS WITHOUT ARGS

    getSchema: function() {
        if (this.dataSource) {
            return this.dataSource.getSchema();
        }
    },

    getRowCount: function() {
        if (this.dataSource) {
            return this.dataSource.getRowCount();
        }
    },

    getColumnCount: function() {
        if (this.dataSource) {
            return this.dataSource.getColumnCount();
        }
    },

    getGrandTotals: function() {
        //row: Ideally this should be set and get bottom/top totals
        //Currently this function is just sending the same for both in aggregations
        if (this.dataSource) {
            return this.dataSource.getGrandTotals();
        }
    },


    // "GET" METHODS WITH ARGS

    getProperty: function getProperty(propName) {
        if (propName in this) {
            return this[propName];
        }

        if (this.dataSource) {
            return getProperty.call(this.dataSource, propName);
        }
    },

    getDataIndex: function() {
        if (this.dataSource) {
            return this.dataSource.getDataIndex.apply(this.dataSource, arguments);
        }
    },

    getRow: function() {
        if (this.dataSource) {
            return this.dataSource.getRow.apply(this.dataSource, arguments);
        }
    },

    findRow: function() {
        if (this.dataSource) {
            return this.dataSource.findRow.apply(this.dataSource, arguments);
        }
    },

    revealRow: function() {
        if (this.dataSource) {
            return this.dataSource.revealRow.apply(this.dataSource, arguments);
        }
    },

    getValue: function() {
        if (this.dataSource) {
            return this.dataSource.getValue.apply(this.dataSource, arguments);
        }
    },

    click: function() {
        if (this.dataSource) {
            return this.dataSource.click.apply(this.dataSource, arguments);
        }
    },


    // BOOLEAN METHODS (NO ARGS)

    isDrillDown: function() {
        if (this.dataSource) {
            return this.dataSource.isDrillDown();
        }
    },

    viewMakesSense: function() {
        if (this.dataSource) {
            return this.dataSource.viewMakesSense();
        }
    },


    // OTHER METHODS

    apply: function() {
        throw new DataSourceError('Nothing to apply.');
    },


    /**
     * Get new object with name and index given the name or the index.
     * @param {string|number} [column] - Column name or index.
     * @param {string} [defaultName] - Name to use when column is omitted or undefined. May be omitted when column is definitely defined.
     * @returns {{name: string, index: number}}
     */
    getColumnInfo: function(column, defaultName) {
        var name, index;
        if (column === undefined) {
            column = defaultName;
        }
        if (typeof column === 'number') {
            name = this.getFields()[index = column];
        } else {
            index = this.getFields().indexOf(name = column);
        }
        if (name && index >= 0) {
            return {
                name: name,
                index: index
            };
        }
    },

    fixIndentForTableDisplay: function(string) {
        var count = string.search(/\S/);
        var end = string.substring(count);
        var result = Array(count + 1).join(this.replaceIndent) + end;
        return result;
    },

    dump: function(max) {
        max = Math.min(this.getRowCount(), max || Math.max(100, this.getRowCount()));
        var data = [];
        var fields = this.schema ? this.schema.map(function(cs) { return cs.name; }) : this.getHeaders();
        var cCount = this.getColumnCount();
        var viewMakesSense = this.viewMakesSense;
        for (var r = 0; r < max; r++) {
            var row = {};
            for (var c = 0; c < cCount; c++) {
                var val = this.getValue(c, r);
                if (c === 0 && viewMakesSense) {
                    val = this.fixIndentForTableDisplay(val);
                }
                row[fields[c]] = val;
            }
            data[r] = row;
        }
        console.table(data);
    }
};

function DataSourceError(message) {
    this.message = message;
}

// extend from `Error`
DataSourceError.prototype = Object.create(Error.prototype);

// override error name displayed in console
DataSourceError.prototype.name = 'DataSourceError';

module.exports = DataSourceBase;

},{"extend-me":7}],9:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

var cssInjector = require('css-injector');

/**
 * @constructor FinBar
 * @summary Create a scrollbar object.
 * @desc Creating a scrollbar is a three-step process:
 *
 * 1. Instantiate the scrollbar object by calling this constructor function. Upon instantiation, the DOM element for the scrollbar (with a single child element for the scrollbar "thumb") is created but is not insert it into the DOM.
 * 2. After instantiation, it is the caller's responsibility to insert the scrollbar, {@link FinBar#bar|this.bar}, into the DOM.
 * 3. After insertion, the caller must call {@link FinBar#resize|resize()} at least once to size and position the scrollbar and its thumb. After that, `resize()` should also be called repeatedly on resize events (as the content element is being resized).
 *
 * Suggested configurations:
 * * _**Unbound**_<br/>
 * The scrollbar serves merely as a simple range (slider) control. Omit both `options.onchange` and `options.content`.
 * * _**Bound to virtual content element**_<br/>
 * Virtual content is projected into the element using a custom event handler supplied by the programmer in `options.onchange`. A typical use case would be to handle scrolling of the virtual content. Other use cases include data transformations, graphics transformations, _etc._
 * * _**Bound to real content**_<br/>
 * Set `options.content` to the "real" content element but omit `options.onchange`. This will cause the scrollbar to use the built-in event handler (`this.scrollRealContent`) which implements smooth scrolling of the content element within the container.
 *
 * @param {finbarOptions} [options={}] - Options object. See the type definition for member details.
 */
function FinBar(options) {

    // make bound versions of all the mouse event handler
    var bound = this._bound = {};
    for (key in handlersToBeBound) {
        bound[key] = handlersToBeBound[key].bind(this);
    }

    /**
     * @name thumb
     * @summary The generated scrollbar thumb element.
     * @desc The thumb element's parent element is always the {@link FinBar#bar|bar} element.
     *
     * This property is typically referenced internally only. The size and position of the thumb element is maintained by `_calcThumb()`.
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var thumb = this.thumb = document.createElement('div');
    thumb.classList.add('thumb');
    thumb.onclick = bound.shortStop;
    thumb.onmouseover = bound.onmouseover;
    thumb.onmouseout = this._bound.onmouseout;

    /**
     * @name bar
     * @summary The generated scrollbar element.
     * @desc The caller inserts this element into the DOM (typically into the content container) and then calls its {@link FinBar#resize|resize()} method.
     *
     * Thus the node tree is typically:
     * * A **content container** element, which contains:
     *   * The content element(s)
     *   * This **scrollbar element**, which in turn contains:
     *     * The **thumb element**
     *
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var bar = this.bar = document.createElement('div');
    bar.classList.add('finbar-vertical');
    bar.onmousedown = this._bound.onmousedown;
    if (this.paging) { bar.onclick = bound.onclick; }
    bar.appendChild(thumb);

    options = options || {};

    // presets
    this.orientation = 'vertical';
    this._min = this._index = 0;
    this._max = 100;

    // options
    for (var key in options) {
        if (options.hasOwnProperty(key)) {
            var option = options[key];
            switch (key) {

                case 'index':
                    this._index = option;
                    break;

                case 'range':
                    validRange(option);
                    this._min = option.min;
                    this._max = option.max;
                    this.contentSize = option.max - option.min + 1;
                    break;

                default:
                    if (
                        key.charAt(0) !== '_' &&
                        typeof FinBar.prototype[key] !== 'function'
                    ) {
                        // override prototype defaults for standard ;
                        // extend with additional properties (for use in onchange event handlers)
                        this[key] = option;
                    }
                    break;

            }
        }
    }

    cssInjector(cssFinBars, 'finbar-base', options.cssStylesheetReferenceElement);
}

FinBar.prototype = {

    /**
     * @summary The scrollbar orientation.
     * @desc Set by the constructor to either `'vertical'` or `'horizontal'`. See the similarly named property in the {@link finbarOptions} object.
     *
     * Useful values are `'vertical'` (the default) or `'horizontal'`.
     *
     * Setting this property resets `this.oh` and `this.deltaProp` and changes the class names so as to reposition the scrollbar as per the CSS rules for the new orientation.
     * @default 'vertical'
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set orientation(orientation) {
        if (orientation === this._orientation) {
            return;
        }

        this._orientation = orientation;

        /**
         * @readonly
         * @name oh
         * @summary <u>O</u>rientation <u>h</u>ash for this scrollbar.
         * @desc Set by the `orientation` setter to either the vertical or the horizontal orientation hash. The property should always be synchronized with `orientation`; do not update directly!
         *
         * This object is used internally to access scrollbars' DOM element properties in a generalized way without needing to constantly query the scrollbar orientation. For example, instead of explicitly coding `this.bar.top` for a vertical scrollbar and `this.bar.left` for a horizontal scrollbar, simply code `this.bar[this.oh.leading]` instead. See the {@link orientationHashType} definition for details.
         *
         * This object is useful externally for coding generalized {@link finbarOnChange} event handler functions that serve both horizontal and vertical scrollbars.
         * @type {orientationHashType}
         * @memberOf FinBar.prototype
         */
        this.oh = orientationHashes[this._orientation];

        if (!this.oh) {
            error('Invalid value for `options._orientation.');
        }

        /**
         * @name deltaProp
         * @summary The name of the `WheelEvent` property this scrollbar should listen to.
         * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
         *
         * Useful values are `'deltaX'`, `'deltaY'`, or `'deltaZ'`. A value of `null` means to ignore mouse wheel events entirely.
         *
         * The mouse wheel is one-dimensional and only emits events with `deltaY` data. This property is provided so that you can override the default of `'deltaX'` with a value of `'deltaY'` on your horizontal scrollbar primarily to accommodate certain "panoramic" interface designs where the mouse wheel should control horizontal rather than vertical scrolling. Just give `{ deltaProp: 'deltaY' }` in your horizontal scrollbar instantiation.
         *
         * Caveat: Note that a 2-finger drag on an Apple trackpad emits events with _both_ `deltaX ` and `deltaY` data so you might want to delay making the above adjustment until you can determine that you are getting Y data only with no X data at all (which is a sure bet you on a mouse wheel rather than a trackpad).

         * @type {object|null}
         * @memberOf FinBar.prototype
         */
        this.deltaProp = this.oh.delta;

        this.bar.className = this.bar.className.replace(/(vertical|horizontal)/g, orientation);

        if (this.bar.style.cssText || this.thumb.style.cssText) {
            this.bar.removeAttribute('style');
            this.thumb.removeAttribute('style');
            this.resize();
        }
    },
    get orientation() {
        return this._orientation;
    },

    /**
     * @summary Callback for scroll events.
     * @desc Set by the constructor via the similarly named property in the {@link finbarOptions} object. After instantiation, `this.onchange` may be updated directly.
     *
     * This event handler is called whenever the value of the scrollbar is changed through user interaction. The typical use case is when the content is scrolled. It is called with the `FinBar` object as its context and the current value of the scrollbar (its index, rounded) as the only parameter.
     *
     * Set this property to `null` to stop emitting such events.
     * @type {function(number)|null}
     * @memberOf FinBar.prototype
     */
    onchange: null,

    /**
     * @summary Add a CSS class name to the bar element's class list.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * The bar element's class list will always include `finbar-vertical` (or `finbar-horizontal` based on the current orientation). Whenever this property is set to some value, first the old prefix+orientation is removed from the bar element's class list; then the new prefix+orientation is added to the bar element's class list. This property causes _an additional_ class name to be added to the bar element's class list. Therefore, this property will only add at most one additional class name to the list.
     *
     * To remove _classname-orientation_ from the bar element's class list, set this property to a falsy value, such as `null`.
     *
     * > NOTE: You only need to specify an additional class name when you need to have mulltiple different styles of scrollbars on the same page. If this is not a requirement, then you don't need to make a new class; you would just create some additional rules using the same selectors in the built-in stylesheet (../css/finbars.css):
     * *`div.finbar-vertical` (or `div.finbar-horizontal`) for the scrollbar
     * *`div.finbar-vertical > div` (or `div.finbar-horizontal > div`) for the "thumb."
     *
     * Of course, your rules should come after the built-ins.
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set classPrefix(prefix) {
        if (this._classPrefix) {
            this.bar.classList.remove(this._classPrefix + this.orientation);
        }

        this._classPrefix = prefix;

        if (prefix) {
            this.bar.classList.add(prefix + '-' + this.orientation);
        }
    },
    get classPrefix() {
        return this._classPrefix;
    },

    /**
     * @name increment
     * @summary Number of scrollbar index units representing a pageful. Used exclusively for paging up and down and for setting thumb size relative to content size.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * Can also be given as a parameter to the {@link FinBar#resize|resize} method, which is pertinent because content area size changes affect the definition of a "pageful." However, you only need to do this if this value is being used. It not used when:
     * * you define `paging.up` and `paging.down`
     * * your scrollbar is using `scrollRealContent`
     * @type {number}
     * @memberOf FinBar.prototype
     */
    increment: 1,

    /**
     * @name barStyles
     * @summary Scrollbar styles to be applied by {@link FinBar#resize|resize()}.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * This is a value to be assigned to {@link FinBar#styles|styles} on each call to {@link FinBar#resize|resize()}. That is, a hash of values to be copied to the scrollbar element's style object on resize; or `null` for none.
     *
     * @see {@link FinBar#style|style}
     * @type {finbarStyles|null}
     * @memberOf FinBar.prototype
     */
    barStyles: null,

    /**
     * @name style
     * @summary Additional scrollbar styles.
     * @desc See type definition for more details. These styles are applied directly to the scrollbar's `bar` element.
     *
     * Values are adjusted as follows before being applied to the element:
     * 1. Included "pseudo-property" names from the scrollbar's orientation hash, {@link FinBar#oh|oh}, are translated to actual property names before being applied.
     * 2. When there are margins, percentages are translated to absolute pixel values because CSS ignores margins in its percentage calculations.
     * 3. If you give a value without a unit (a raw number), "px" unit is appended.
     *
     * General notes:
     * 1. It is always preferable to specify styles via a stylesheet. Only set this property when you need to specifically override (a) stylesheet value(s).
     * 2. Can be set directly or via calls to the {@link FinBar#resize|resize} method.
     * 3. Should only be set after the scrollbar has been inserted into the DOM.
     * 4. Before applying these new values to the element, _all_ in-line style values are reset (by removing the element's `style` attribute), exposing inherited values (from stylesheets).
     * 5. Empty object has no effect.
     * 6. Falsey value in place of object has no effect.
     *
     * > CAVEAT: Do not attempt to treat the object you assign to this property as if it were `this.bar.style`. Specifically, changing this object after assigning it will have no effect on the scrollbar. You must assign it again if you want it to have an effect.
     *
     * @see {@link FinBar#barStyles|barStyles}
     * @type {finbarStyles}
     * @memberOf FinBar.prototype
     */
    set style(styles) {
        var keys = Object.keys(styles = extend({}, styles, this._auxStyles));

        if (keys.length) {
            var bar = this.bar,
                barRect = bar.getBoundingClientRect(),
                container = this.container || bar.parentElement,
                containerRect = container.getBoundingClientRect(),
                oh = this.oh;

            // Before applying new styles, revert all styles to values inherited from stylesheets
            bar.removeAttribute('style');

            keys.forEach(function (key) {
                var val = styles[key];

                if (key in oh) {
                    key = oh[key];
                }

                if (!isNaN(Number(val))) {
                    val = (val || 0) + 'px';
                } else if (/%$/.test(val)) {
                    // When bar size given as percentage of container, if bar has margins, restate size in pixels less margins.
                    // (If left as percentage, CSS's calculation will not exclude margins.)
                    var oriented = axis[key],
                        margins = barRect[oriented.marginLeading] + barRect[oriented.marginTrailing];
                    if (margins) {
                        val = parseInt(val, 10) / 100 * containerRect[oriented.size] - margins + 'px';
                    }
                }

                bar.style[key] = val;
            });
        }
    },

    /**
     * @readonly
     * @name paging
     * @summary Enable page up/dn clicks.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * If truthy, listen for clicks in page-up and page-down regions of scrollbar.
     *
     * If an object, call `.paging.up()` on page-up clicks and `.paging.down()` will be called on page-down clicks.
     *
     * Changing the truthiness of this value after instantiation currently has no effect.
     * @type {boolean|object}
     * @memberOf FinBar.prototype
     */
    paging: true,

    /**
     * @name range
     * @summary Setter for the minimum and maximum scroll values.
     * @desc Set by the constructor. These values are the limits for {@link FooBar#index|index}.
     *
     * The setter accepts an object with exactly two numeric properties: `.min` which must be less than `.max`. The values are extracted and the object is discarded.
     *
     * The getter returns a new object with `.min` and '.max`.
     *
     * @type {rangeType}
     * @memberOf FinBar.prototype
     */
    set range(range) {
        validRange(range);
        this._min = range.min;
        this._max = range.max;
        this.contentSize = range.max - range.min + 1;
        this.index = this.index; // re-clamp
    },
    get range() {
        return {
            min: this._min,
            max: this._max
        };
    },

    /**
     * @summary Index value of the scrollbar.
     * @desc This is the position of the scroll thumb.
     *
     * Setting this value clamps it to {@link FinBar#min|min}..{@link FinBar#max|max}, scroll the content, and moves thumb.
     *
     * Getting this value returns the current index. The returned value will be in the range `min`..`max`. It is intentionally not rounded.
     *
     * Use this value as an alternative to (or in addition to) using the {@link FinBar#onchange|onchange} callback function.
     *
     * @see {@link FinBar#_setScroll|_setScroll}
     * @type {number}
     * @memberOf FinBar.prototype
     */
    set index(idx) {
        idx = Math.min(this._max, Math.max(this._min, idx)); // clamp it
        this._setScroll(idx);
        // this._setThumbSize();
    },
    get index() {
        return this._index;
    },

    /**
     * @private
     * @summary Move the thumb.
     * @desc Also displays the index value in the test panel and invokes the callback.
     * @param idx - The new scroll index, a value in the range `min`..`max`.
     * @param [scaled=f(idx)] - The new thumb position in pixels and scaled relative to the containing {@link FinBar#bar|bar} element, i.e., a proportional number in the range `0`..`thumbMax`. When omitted, a function of `idx` is used.
     * @memberOf FinBar.prototype
     */
    _setScroll: function (idx, scaled) {
        this._index = idx;

        // Display the index value in the test panel
        if (this.testPanelItem && this.testPanelItem.index instanceof Element) {
            this.testPanelItem.index.innerHTML = Math.round(idx);
        }

        // Call the callback
        if (this.onchange) {
            this.onchange.call(this, Math.round(idx));
        }

        // Move the thumb
        if (scaled === undefined) {
            scaled = (idx - this._min) / (this._max - this._min) * this._thumbMax;
        }
        this.thumb.style[this.oh.leading] = scaled + 'px';
    },

    scrollRealContent: function (idx) {
        var containerRect = this.content.parentElement.getBoundingClientRect(),
            sizeProp = this.oh.size,
            maxScroll = Math.max(0, this.content[sizeProp] - containerRect[sizeProp]),
            //scroll = Math.min(idx, maxScroll);
            scroll = (idx - this._min) / (this._max - this._min) * maxScroll;
        //console.log('scroll: ' + scroll);
        this.content.style[this.oh.leading] = -scroll + 'px';
    },

    /**
     * @summary Recalculate thumb position.
     *
     * @desc This method recalculates the thumb size and position. Call it once after inserting your scrollbar into the DOM, and repeatedly while resizing the scrollbar (which typically happens when the scrollbar's parent is resized by user.
     *
     * > This function shifts args if first arg omitted.
     *
     * @param {number} [increment=this.increment] - Resets {@link FooBar#increment|increment} (see).
     *
     * @param {finbarStyles} [barStyles=this.barStyles] - (See type definition for details.) Scrollbar styles to be applied to the bar element.
     *
     * Only specify a `barStyles` object when you need to override stylesheet values. If provided, becomes the new default (`this.barStyles`), for use as a default on subsequent calls.
     *
     * It is generally the case that the scrollbar's new position is sufficiently described by the current styles. Therefore, it is unusual to need to provide a `barStyles` object on every call to `resize`.
     *
     * @returns {FinBar} Self for chaining.
     * @memberOf FinBar.prototype
     */
    resize: function (increment, barStyles) {
        var bar = this.bar;

        if (!bar.parentNode) {
            return; // not in DOM yet so nothing to do
        }

        var container = this.container || bar.parentElement,
            containerRect = container.getBoundingClientRect();

        // shift args if if 1st arg omitted
        if (typeof increment === 'object') {
            barStyles = increment;
            increment = undefined;
        }

        this.style = this.barStyles = barStyles || this.barStyles;

        // Bound to real content: Content was given but no onchange handler.
        // Set up .onchange, .containerSize, and .increment.
        // Note this only makes sense if your index unit is pixels.
        if (this.content) {
            if (!this.onchange) {
                this.onchange = this.scrollRealContent;
                this.contentSize = this.content[this.oh.size];
                this._min = 0;
                this._max = this.contentSize - 1;
            }
        }
        if (this.onchange === this.scrollRealContent) {
            this.containerSize = containerRect[this.oh.size];
            this.increment = this.containerSize / (this.contentSize - this.containerSize) * (this._max - this._min);
        } else {
            this.containerSize = 1;
            this.increment = increment || this.increment;
        }

        var index = this.index;
        this.testPanelItem = this.testPanelItem || this._addTestPanelItem();
        this._setThumbSize();
        this.index = index;

        if (this.deltaProp !== null) {
            container.addEventListener('wheel', this._bound.onwheel);
        }

        return this;
    },

    /**
     * @summary Shorten trailing end of scrollbar by thickness of some other scrollbar.
     * @desc In the "classical" scenario where vertical scroll bar is on the right and horizontal scrollbar is on the bottom, you want to shorten the "trailing end" (bottom and right ends, respectively) of at least one of them so they don't overlay.
     *
     * This convenience function is an programmatic alternative to hardcoding the correct style with the correct value in your stylesheet; or setting the correct style with the correct value in the {@link FinBar#barStyles|barStyles} object.
     *
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     *
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenBy: function (otherFinBar) { return this.shortenEndBy('trailing', otherFinBar); },

    /**
     * @summary Shorten leading end of scrollbar by thickness of some other scrollbar.
     * @desc Supports non-classical scrollbar scenarios where vertical scroll bar may be on left and horizontal scrollbar may be on top, in which case you want to shorten the "leading end" rather than the trailing end.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    foreshortenBy: function (otherFinBar) { return this.shortenEndBy('leading', otherFinBar); },

    /**
     * @summary Generalized shortening function.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     * @param {string} whichEnd - a CSS style property name or an orientation hash name that translates to a CSS style property name.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenEndBy: function (whichEnd, otherFinBar) {
        if (!otherFinBar) {
            delete this._auxStyles;
        } else if (otherFinBar instanceof FinBar && otherFinBar.orientation !== this.orientation) {
            var otherStyle = window.getComputedStyle(otherFinBar.bar),
                ooh = orientationHashes[otherFinBar.orientation];
            this._auxStyles = {};
            this._auxStyles[whichEnd] = otherStyle[ooh.thickness];
        }
        return this; // for chaining
    },

    /**
     * @private
     * @summary Sets the proportional thumb size and hides thumb when 100%.
     * @desc The thumb size has an absolute minimum of 20 (pixels).
     * @memberOf FinBar.prototype
     */
    _setThumbSize: function () {
        var oh = this.oh,
            thumbComp = window.getComputedStyle(this.thumb),
            thumbMarginLeading = parseInt(thumbComp[oh.marginLeading]),
            thumbMarginTrailing = parseInt(thumbComp[oh.marginTrailing]),
            thumbMargins = thumbMarginLeading + thumbMarginTrailing,
            barSize = this.bar.getBoundingClientRect()[oh.size],
            thumbSize = Math.max(20, barSize * this.containerSize / this.contentSize);

        if (this.containerSize < this.contentSize) {
            this.bar.style.visibility = 'visible';
            this.thumb.style[oh.size] = thumbSize + 'px';
        } else {
            this.bar.style.visibility = 'hidden';
        }

        /**
         * @private
         * @name _thumbMax
         * @summary Maximum offset of thumb's leading edge.
         * @desc This is the pixel offset within the scrollbar of the thumb when it is at its maximum position at the extreme end of its range.
         *
         * This value takes into account the newly calculated size of the thumb element (including its margins) and the inner size of the scrollbar (the thumb's containing element, including _its_ margins).
         *
         * NOTE: Scrollbar padding is not taken into account and assumed to be 0 in the current implementation and is assumed to be `0`; use thumb margins in place of scrollbar padding.
         * @type {number}
         * @memberOf FinBar.prototype
         */
        this._thumbMax = barSize - thumbSize - thumbMargins;

        this._thumbMarginLeading = thumbMarginLeading; // used in mousedown
    },

    /**
     * @summary Remove the scrollbar.
     * @desc Unhooks all the event handlers and then removes the element from the DOM. Always call this method prior to disposing of the scrollbar object.
     * @memberOf FinBar.prototype
     */
    remove: function () {
        this.bar.onmousedown = null;
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        (this.container || this.bar.parentElement)._removeEvt('wheel', this._bound.onwheel);

        this.bar.onclick =
            this.thumb.onclick =
                this.thumb.onmouseover =
                    this.thumb.transitionend =
                        this.thumb.onmouseout = null;

        this.bar.remove();
    },

    /**
     * @private
     * @function _addTestPanelItem
     * @summary Append a test panel element.
     * @desc If there is a test panel in the DOM (typically an `<ol>...</ol>` element) with class names of both `this.classPrefix` and `'test-panel'` (or, barring that, any element with class name `'test-panel'`), an `<li>...</li>` element will be created and appended to it. This new element will contain a span for each class name given.
     *
     * You should define a CSS selector `.listening` for these spans. This class will be added to the spans to alter their appearance when a listener is added with that class name (prefixed with 'on').
     *
     * (This is an internal function that is called once by the constructor on every instantiation.)
     * @returns {Element|undefined} The appended `<li>...</li>` element or `undefined` if there is no test panel.
     * @memberOf FinBar.prototype
     */
    _addTestPanelItem: function () {
        var testPanelItem,
            testPanelElement = document.querySelector('.' + this._classPrefix + '.test-panel') || document.querySelector('.test-panel');

        if (testPanelElement) {
            var testPanelItemPartNames = [ 'mousedown', 'mousemove', 'mouseup', 'index' ],
                item = document.createElement('li');

            testPanelItemPartNames.forEach(function (partName) {
                item.innerHTML += '<span class="' + partName + '">' + partName.replace('mouse', '') + '</span>';
            });

            testPanelElement.appendChild(item);

            testPanelItem = {};
            testPanelItemPartNames.forEach(function (partName) {
                testPanelItem[partName] = item.getElementsByClassName(partName)[0];
            });
        }

        return testPanelItem;
    },

    _addEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.add('listening'); }
        window.addEventListener(evtName, this._bound['on' + evtName]);
    },

    _removeEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.remove('listening'); }
        window.removeEventListener(evtName, this._bound['on' + evtName]);
    }
};

function extend(obj) {
    for (var i = 1; i < arguments.length; ++i) {
        var objn = arguments[i];
        if (objn) {
            for (var key in objn) {
                obj[key] = objn[key];
            }
        }
    }
    return obj;
}

function validRange(range) {
    var keys = Object.keys(range),
        valid =  keys.length === 2 &&
            typeof range.min === 'number' &&
            typeof range.max === 'number' &&
            range.min <= range.max;

    if (!valid) {
        error('Invalid .range object.');
    }
}

/**
 * @private
 * @name handlersToBeBound
 * @type {object}
 * @desc The functions defined in this object are all DOM event handlers that are bound by the FinBar constructor to each new instance. In other words, the `this` value of these handlers, once bound, refer to the FinBar object and not to the event emitter. "Do not consume raw."
 */
var handlersToBeBound = {
    shortStop: function (evt) {
        evt.stopPropagation();
    },

    onwheel: function (evt) {
        this.index += evt[this.deltaProp];
        evt.stopPropagation();
        evt.preventDefault();
    },

    onclick: function (evt) {
        var thumbBox = this.thumb.getBoundingClientRect(),
            goingUp = evt[this.oh.coordinate] < thumbBox[this.oh.leading];

        if (typeof this.paging === 'object') {
            this.index = this.paging[goingUp ? 'up' : 'down'](Math.round(this.index));
        } else {
            this.index += goingUp ? -this.increment : this.increment;
        }

        // make the thumb glow momentarily
        this.thumb.classList.add('hover');
        var self = this;
        this.thumb.addEventListener('transitionend', function waitForIt() {
            this.removeEventListener('transitionend', waitForIt);
            self._bound.onmouseup(evt);
        });

        evt.stopPropagation();
    },

    onmouseover: function () {
        this.thumb.classList.add('hover');
    },

    onmouseout: function () {
        this.thumb.classList.remove('hover');
    },

    onmousedown: function (evt) {
        var thumbBox = this.thumb.getBoundingClientRect();
        this.pinOffset = evt[this.oh.axis] - thumbBox[this.oh.leading] + this.bar.getBoundingClientRect()[this.oh.leading] + this._thumbMarginLeading;
        document.documentElement.style.cursor = 'default';

        this._addEvt('mousemove');
        this._addEvt('mouseup');

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmousemove: function (evt) {
        var scaled = Math.min(this._thumbMax, Math.max(0, evt[this.oh.axis] - this.pinOffset));
        var idx = scaled / this._thumbMax * (this._max - this._min) + this._min;

        this._setScroll(idx, scaled);

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmouseup: function (evt) {
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        document.documentElement.style.cursor = 'auto';

        var thumbBox = this.thumb.getBoundingClientRect();
        if (
            thumbBox.left <= evt.clientX && evt.clientX <= thumbBox.right &&
            thumbBox.top <= evt.clientY && evt.clientY <= thumbBox.bottom
        ) {
            this._bound.onmouseover(evt);
        } else {
            this._bound.onmouseout(evt);
        }

        evt.stopPropagation();
        evt.preventDefault();
    }
};

var orientationHashes = {
    vertical: {
        coordinate:     'clientY',
        axis:           'pageY',
        size:           'height',
        outside:        'right',
        inside:         'left',
        leading:        'top',
        trailing:       'bottom',
        marginLeading:  'marginTop',
        marginTrailing: 'marginBottom',
        thickness:      'width',
        delta:          'deltaY'
    },
    horizontal: {
        coordinate:     'clientX',
        axis:           'pageX',
        size:           'width',
        outside:        'bottom',
        inside:         'top',
        leading:        'left',
        trailing:       'right',
        marginLeading:  'marginLeft',
        marginTrailing: 'marginRight',
        thickness:      'height',
        delta:          'deltaX'
    }
};

var axis = {
    top:    'vertical',
    bottom: 'vertical',
    height: 'vertical',
    left:   'horizontal',
    right:  'horizontal',
    width:  'horizontal'
};

var cssFinBars; // definition inserted by gulpfile between following comments
/* inject:css */
cssFinBars = 'div.finbar-horizontal,div.finbar-vertical{position:absolute;margin:3px}div.finbar-horizontal>.thumb,div.finbar-vertical>.thumb{position:absolute;background-color:#d3d3d3;-webkit-box-shadow:0 0 1px #000;-moz-box-shadow:0 0 1px #000;box-shadow:0 0 1px #000;border-radius:4px;margin:2px;opacity:.4;transition:opacity .5s}div.finbar-horizontal>.thumb.hover,div.finbar-vertical>.thumb.hover{opacity:1;transition:opacity .5s}div.finbar-vertical{top:0;bottom:0;right:0;width:11px}div.finbar-vertical>.thumb{top:0;right:0;width:7px}div.finbar-horizontal{left:0;right:0;bottom:0;height:11px}div.finbar-horizontal>.thumb{left:0;bottom:0;height:7px}';
/* endinject */

function error(msg) {
    throw 'finbars: ' + msg;
}

// Interface
module.exports = FinBar;

},{"css-injector":6}],10:[function(require,module,exports){
/* eslint-env browser */

'use strict';

if (typeof window.CustomEvent !== 'function') {
    window.CustomEvent = function(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: undefined };
        var evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
    };

    window.CustomEvent.prototype = window.Event.prototype;
}

var rectangular = require('rectangular');

var GraphicsContext = require('./js/GraphicsContext.js');

var RESIZE_POLLING_INTERVAL = 200,
    paintables = [],
    resizables = [],
    paintLoopRunning = true,
    resizeLoopRunning = true,
    charMap = makeCharMap();

function Canvas(div, component, options) {
    var self = this;

    this.div = div;
    this.component = component;

    options = options || {};
    this.doubleClickDelay = options.doubleClickDelay || 325;

    this.dragEndtime = Date.now();

    this.canvas = document.createElement('canvas');
    this.div.appendChild(this.canvas);

    this.canvas.style.outline = 'none';

    // this.focuser = document.createElement('button');
    // this.focuser.style.position = 'absolute';
    // this.focuser.style.top = '0px';
    // this.focuser.style.left = '0px';
    // this.focuser.style.zIndex = '-1';
    // this.focuser.style.outline = 'none';
    // this.div.appendChild(this.focuser);

    this.canvasCTX = this.canvas.getContext('2d');
    this.gc = new GraphicsContext(this.canvasCTX);

    this.buffer = document.createElement('canvas');
    this.bufferCTX = this.buffer.getContext('2d');
    this.bufferGC = new GraphicsContext(this.bufferCTX);

    this.mouseLocation = new rectangular.Point(-1, -1);
    this.dragstart = new rectangular.Point(-1, -1);
    //this.origin = new rectangular.Point(0, 0);
    this.bounds = new rectangular.Rectangle(0, 0, 0, 0);
    this.hasMouse = false;

    document.addEventListener('mousemove', function(e) {
        if (self.hasMouse || self.isDragging()) {
            self.finmousemove(e);
        }
    });
    document.addEventListener('mouseup', function(e) {
        self.finmouseup(e);
    });
    document.addEventListener('wheel', function(e) {
        self.finwheelmoved(e);
    });
    document.addEventListener('keydown', function(e) {
        self.finkeydown(e);
    });
    document.addEventListener('keyup', function(e) {
        self.finkeyup(e);
    });

    this.canvas.onmouseover = function() {
        self.hasMouse = true;
    };
    this.canvas.addEventListener('focus', function(e) {
        self.finfocusgained(e);
    });
    this.canvas.addEventListener('blur', function(e) {
        self.finfocuslost(e);
    });
    this.canvas.addEventListener('mousedown', function(e) {
        self.finmousedown(e);
    });
    this.canvas.addEventListener('mouseout', function(e) {
        self.hasMouse = false;
        self.finmouseout(e);
    });
    this.canvas.addEventListener('click', function(e) {
        self.finclick(e);
    });
    this.canvas.addEventListener('contextmenu', function(e) {
        self.fincontextmenu(e);
        e.preventDefault();
        return false;
    });

    this.canvas.setAttribute('tabindex', 0);
    this.canvas.contentEditable = true;

    this.resize();

    this.beginResizing();
    this.beginPainting();
}

Canvas.prototype = {
    constructor: Canvas.prototype.constructor,
    div: null,
    component: null,
    canvas: null,
    canvasCTX: null,
    focuser: null,
    buffer: null,
    ctx: null,
    mouseLocation: null,
    dragstart: null,
    origin: null,
    bounds: null,
    dirty: false,
    size: null,
    mousedown: false,
    dragging: false,
    repeatKeyCount: 0,
    repeatKey: null,
    repeatKeyStartTime: 0,
    currentKeys: [],
    hasMouse: false,
    lastDoubleClickTime: 0,
    dragEndTime: 0,
    lastRepaintTime: 0,
    currentPaintCount: 0,
    currentFPS: 0,
    lastFPSComputeTime: 0,

    addEventListener: function(name, callback) {
        this.canvas.addEventListener(name, callback);
    },

    stopPaintLoop: function() {
        paintLoopRunning = false;
    },

    restartPaintLoop: function() {
        if (paintLoopRunning) {
            return; // already running
        }
        paintLoopRunning = true;
        requestAnimationFrame(paintLoopFunction);
    },

    stopResizeLoop: function() {
        resizeLoopRunning = false;
    },

    restartResizeLoop: function() {
        if (resizeLoopRunning) {
            return; // already running
        }
        resizeLoopRunning = true;
        setInterval(resizablesLoopFunction, 200);
    },

    detached: function() {
        this.stopPainting();
        this.stopResizing();
    },

    useHiDPI: function() {
        return this.component.resolveProperty('useHiDPI');
    },

    useBitBlit: function() {
        return this.component.resolveProperty('useBitBlit');
    },

    getFPS: function() {
        var fps = this.component.resolveProperty('repaintIntervalRate');
        return fps ? parseInt(fps) : 0;
    },

    getEnableContinuousRepaint: function () {
        return this.component.resolveProperty('enableContinuousRepaint');
    },

    getCurrentFPS:function () {
        return this.currentFPS;
    },


    tickPaint: function(now) {
        var fps = this.getFPS();
        var isContinuousRepaint = this.getEnableContinuousRepaint();
        if (fps === 0) {
            return;
        }
        var interval = 1000 / fps;

        var elapsed = now - this.lastRepaintTime;
        if (elapsed > interval && (isContinuousRepaint || this.dirty)) {
            this.paintNow();
            this.lastRepaintTime = now;
            /* - (elapsed % interval);*/
            if (isContinuousRepaint) {
                this.currentPaintCount++;
                if (now - this.lastFPSComputeTime >= 1000) {
                    this.currentFPS = (this.currentPaintCount * 1000) / (now - this.lastFPSComputeTime);
                    this.currentPaintCount = 0;
                    this.lastFPSComputeTime = now;
                }
            }
        }
    },

    beginPainting: function() {
        var self = this;
        this.dirty = true;
        this.tickPainter = function(now) {
            self.tickPaint(now);
        };
        paintables.push(this);
    },

    stopPainting: function() {
        paintables.splice(paintables.indexOf(this), 1);
    },

    beginResizing: function() {
        var self = this;
        this.tickResizer = function() {
            self.checksize();
        };
        resizables.push(this);
    },

    stopResizing: function() {
        resizables.splice(resizables.indexOf(this), 1);
    },

    start: function() {
        this.beginPainting();
        this.beginResizing();
    },

    stop: function() {
        this.stopPainting();
        this.stopResizing();
    },

    checksize: function() {
        //this is expensive lets do it at some modulo
        var sizeNow = this.div.getBoundingClientRect();
        if (sizeNow.width !== this.size.width || sizeNow.height !== this.size.height) {
            this.sizeChangedNotification();
        }
    },

    sizeChangedNotification: function() {
        this.resize();
    },

    resize: function() {
        var box = this.size = this.div.getBoundingClientRect();

        this.width = box.width;
        this.height = box.height;

        //fix ala sir spinka, see
        //http://www.html5rocks.com/en/tutorials/canvas/hidpi/
        //just add 'hdpi' as an attribute to the fin-canvas tag
        var ratio = 1;
        var useBitBlit = this.useBitBlit();
        var isHIDPI = window.devicePixelRatio && this.useHiDPI();
        if (isHIDPI) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = this.canvasCTX.webkitBackingStorePixelRatio ||
                this.canvasCTX.mozBackingStorePixelRatio ||
                this.canvasCTX.msBackingStorePixelRatio ||
                this.canvasCTX.oBackingStorePixelRatio ||
                this.canvasCTX.backingStorePixelRatio || 1;

            ratio = devicePixelRatio / backingStoreRatio;
            //this.canvasCTX.scale(ratio, ratio);
        }

        this.buffer.width = this.canvas.width = this.width * ratio;
        this.buffer.height = this.canvas.height = this.height * ratio;

        this.canvas.style.width = this.buffer.style.width = this.width + 'px';
        this.canvas.style.height = this.buffer.style.height = this.height + 'px';

        this.bufferCTX.scale(ratio, ratio);
        if (isHIDPI && !useBitBlit) {
            this.canvasCTX.scale(ratio, ratio);
        }

        //this.origin = new rectangular.Point(Math.round(this.size.left), Math.round(this.size.top));
        this.bounds = new rectangular.Rectangle(0, 0, this.width, this.height);
        //setTimeout(function() {
        var comp = this.component;
        if (comp) {
            comp.setBounds(this.bounds);
        }
        this.resizeNotification();
        this.paintNow();
        //});
    },

    resizeNotification: function() {
        //to be overridden
    },

    getBounds: function() {
        return this.bounds;
    },

    paintNow: function() {
        var self = this;
        this.safePaintImmediately(function(gc) {
            gc.clearRect(0, 0, self.width, self.height);

            var comp = self.component;
            if (comp) {
                comp.paint(gc);
            }

            self.dirty = false;
        });
    },

    safePaintImmediately: function(paintFunction) {
        var useBitBlit = this.useBitBlit(),
            gc = useBitBlit ? this.bufferGC : this.gc;
        try {
            gc.save();
            paintFunction(gc);
        } catch (e) {
            console.error(e);
        } finally {
            gc.restore();
        }
        if (useBitBlit) {
            this.flushBuffer();
        }
    },

    flushBuffer: function() {
        if (this.buffer.width > 0 && this.buffer.height > 0) {
            this.canvasCTX.drawImage(this.buffer, 0, 0);
        }
    },

    dispatchNewEvent: function(event, name, detail) {
        detail = {
            detail: detail || {}
        };
        detail.detail.primitiveEvent = event;
        return this.canvas.dispatchEvent(new CustomEvent(name, detail));
    },

    dispatchNewMouseKeysEvent: function(event, name, detail) {
        detail = detail || {};
        detail.mouse = this.mouseLocation;
        detail.keys = this.currentKeys;
        return this.dispatchNewEvent(event, name, detail);
    },

    finmousemove: function(e) {
        if (!this.isDragging() && this.mousedown) {
            this.beDragging();
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragstart', {
                isRightClick: this.isRightClick(e)
            });
            this.dragstart = new rectangular.Point(this.mouseLocation.x, this.mouseLocation.y);
        }
        this.mouseLocation = this.getLocal(e);
        //console.log(this.mouseLocation);
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-drag', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
        }
        if (this.bounds.contains(this.mouseLocation)) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousemove');
        }
    },

    finmousedown: function(e) {
        this.mouseLocation = this.mouseDownLocation = this.getLocal(e);
        this.mousedown = true;

        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousedown', {
            isRightClick: this.isRightClick(e)
        });
        this.takeFocus();
    },

    finmouseup: function(e) {
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragend', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
            this.beNotDragging();
            this.dragEndtime = Date.now();
        }
        this.mousedown = false;
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseup', {
            isRightClick: this.isRightClick(e)
        });
        //this.mouseLocation = new rectangular.Point(-1, -1);
    },

    finmouseout: function(e) {
        if (!this.mousedown) {
            this.mouseLocation = new rectangular.Point(-1, -1);
        }
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseout');
    },

    finwheelmoved: function(e) {
        if (this.isDragging() || !this.hasFocus()) {
            return;
        }
        e.preventDefault();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-wheelmoved', {
            isRightClick: this.isRightClick(e)
        });
    },

    finclick: function(e) {
        if (this.doubleClickTimer && Date.now() - this.lastClickTime < this.doubleClickDelay) {
            //this is a double click...
            clearTimeout(this.doubleClickTimer); // prevent click event
            this.doubleClickTimer = undefined;
            this.findblclick(e);
        } else {
            this.lastClickTime = Date.now();

            this.doubleClickTimer = setTimeout(function() {
                this.doubleClickTimer = undefined;
                this.mouseLocation = this.getLocal(e);
                this.dispatchNewMouseKeysEvent(e, 'fin-canvas-click', {
                    isRightClick: this.isRightClick(e)
                });
            }.bind(this), this.doubleClickDelay);
        }
    },

    findblclick: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.lastDoubleClickTime = Date.now();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dblclick', {
            isRightClick: this.isRightClick(e)
        });
        //console.log('dblclick', this.currentKeys);
    },

    getCharMap: function() { //TODO: This is static. Make it a property of the constructor.
        return charMap;
    },

    finkeydown: function(e) {
        if (!this.hasFocus()) {
            return;
        }

        //e.preventDefault();
        var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
        if (e.repeat) {
            if (this.repeatKey === keyChar) {
                this.repeatKeyCount++;
            } else {
                this.repeatKey = keyChar;
                this.repeatKeyStartTime = Date.now();
            }
        } else {
            this.repeatKey = null;
            this.repeatKeyCount = 0;
            this.repeatKeyStartTime = 0;
        }
        if (this.currentKeys.indexOf(keyChar) === -1) {
            this.currentKeys.push(keyChar);
        }
        //console.log(keyChar, e.keyCode);
        this.dispatchNewEvent(e, 'fin-canvas-keydown', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeatCount: this.repeatKeyCount,
            repeatStartTime: this.repeatKeyStartTime,
            shift: e.shiftKey,
            identifier: e.key,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finkeyup: function(e) {
        var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
        this.currentKeys.splice(this.currentKeys.indexOf(keyChar), 1);
        if (!this.hasFocus()) {
            return;
        }
        this.repeatKeyCount = 0;
        this.repeatKey = null;
        this.repeatKeyStartTime = 0;
        this.dispatchNewEvent(e, 'fin-canvas-keyup', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeat: e.repeat,
            shift: e.shiftKey,
            identifier: e.key,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finfocusgained: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-gained');
    },

    finfocuslost: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-lost');
    },

    fincontextmenu: function(e) {
        if (e.ctrlKey && this.currentKeys.indexOf('CTRL') === -1) {
            this.currentKeys.push('CTRL');
        }
        if (this.doubleRightClickTimer && Date.now() - this.lastClickTime < this.doubleClickDelay) {
            //this is a double click...
            clearTimeout(this.doubleRightClickTimer); // prevent context menu event
            this.doubleRightClickTimer = undefined;
            this.findblclick(e);
        } else {
            this.lastClickTime = Date.now();

            this.doubleRightClickTimer = setTimeout(function() {
                this.doubleRightClickTimer = undefined;
                this.dispatchNewMouseKeysEvent(e, 'fin-canvas-context-menu', {
                    isRightClick: this.isRightClick(e)
                });
            }.bind(this), this.doubleClickDelay);
        }
    },

    repaint: function() {
        var fps = this.getFPS();
        this.dirty = true;
        if (!paintLoopRunning || fps === 0) {
            this.paintNow();
        }
    },

    getMouseLocation: function() {
        return this.mouseLocation;
    },

    getOrigin: function() {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(rect.left, rect.top);
        return p;
    },

    getLocal: function(e) {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(e.clientX - rect.left, e.clientY - rect.top);
        return p;
    },

    hasFocus: function() {
        return document.activeElement === this.canvas;
    },

    takeFocus: function() {
        var self = this;
        if (!this.hasFocus()) {
            setTimeout(function() {
                self.canvas.focus();
            }, 10);
        }
    },

    beDragging: function() {
        this.dragging = true;
        this.disableDocumentElementSelection();
    },

    beNotDragging: function() {
        this.dragging = false;
        this.enableDocumentElementSelection();
    },

    isDragging: function() {
        return this.dragging;
    },

    disableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText + '-webkit-user-select: none';
    },

    enableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText.replace('-webkit-user-select: none', '');
    },

    setFocusable: function(truthy) {
        this.focuser.style.display = truthy ? '' : 'none';
    },

    isRightClick: function(e) {
        var isRightMB;
        e = e || window.event;

        if ('which' in e) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
            isRightMB = e.which === 3;
        } else if ('button' in e) { // IE, Opera
            isRightMB = e.button === 2;
        }
        return isRightMB;
    },

    dispatchEvent: function(e) {
        return this.canvas.dispatchEvent(e);
    }
};

function paintLoopFunction(now) {
    if (!paintLoopRunning) {
        return;
    }
    for (var i = 0; i < paintables.length; i++) {
        try {
            paintables[i].tickPainter(now);
        } catch (e) {
            console.error(e);
        }
    }
    requestAnimationFrame(paintLoopFunction);
}
requestAnimationFrame(paintLoopFunction);

function resizablesLoopFunction(now) {
    if (!resizeLoopRunning) {
        return;
    }
    for (var i = 0; i < resizables.length; i++) {
        try {
            resizables[i].tickResizer(now);
        } catch (e) {
            console.error(e);
        }
    }
}
setInterval(resizablesLoopFunction, RESIZE_POLLING_INTERVAL);

function makeCharMap() {
    var map = [];

    var empty = ['', ''];

    for (var i = 0; i < 256; i++) {
        map[i] = empty;
    }

    map[27] = ['ESC', 'ESCSHIFT'];
    map[192] = ['`', '~'];
    map[49] = ['1', '!'];
    map[50] = ['2', '@'];
    map[51] = ['3', '#'];
    map[52] = ['4', '$'];
    map[53] = ['5', '%'];
    map[54] = ['6', '^'];
    map[55] = ['7', '&'];
    map[56] = ['8', '*'];
    map[57] = ['9', '('];
    map[48] = ['0', ')'];
    map[189] = ['-', '_'];
    map[187] = ['=', '+'];
    map[8] = ['BACKSPACE', 'BACKSPACESHIFT'];
    map[46] = ['DELETE', 'DELETESHIFT'];
    map[9] = ['TAB', 'TABSHIFT'];
    map[81] = ['q', 'Q'];
    map[87] = ['w', 'W'];
    map[69] = ['e', 'E'];
    map[82] = ['r', 'R'];
    map[84] = ['t', 'T'];
    map[89] = ['y', 'Y'];
    map[85] = ['u', 'U'];
    map[73] = ['i', 'I'];
    map[79] = ['o', 'O'];
    map[80] = ['p', 'P'];
    map[219] = ['[', '{'];
    map[221] = [']', '}'];
    map[220] = ['\\', '|'];
    map[220] = ['CAPSLOCK', 'CAPSLOCKSHIFT'];
    map[65] = ['a', 'A'];
    map[83] = ['s', 'S'];
    map[68] = ['d', 'D'];
    map[70] = ['f', 'F'];
    map[71] = ['g', 'G'];
    map[72] = ['h', 'H'];
    map[74] = ['j', 'J'];
    map[75] = ['k', 'K'];
    map[76] = ['l', 'L'];
    map[186] = [';', ':'];
    map[222] = ['\'', '|'];
    map[13] = ['RETURN', 'RETURNSHIFT'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[90] = ['z', 'Z'];
    map[88] = ['x', 'X'];
    map[67] = ['c', 'C'];
    map[86] = ['v', 'V'];
    map[66] = ['b', 'B'];
    map[78] = ['n', 'N'];
    map[77] = ['m', 'M'];
    map[188] = [',', '<'];
    map[190] = ['.', '>'];
    map[191] = ['/', '?'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[17] = ['CTRL', 'CTRLSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[91] = ['COMMANDLEFT', 'COMMANDLEFTSHIFT'];
    map[32] = ['SPACE', 'SPACESHIFT'];
    map[93] = ['COMMANDRIGHT', 'COMMANDRIGHTSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[38] = ['UP', 'UPSHIFT'];
    map[37] = ['LEFT', 'LEFTSHIFT'];
    map[40] = ['DOWN', 'DOWNSHIFT'];
    map[39] = ['RIGHT', 'RIGHTSHIFT'];

    map[33] = ['PAGEUP', 'PAGEUPSHIFT'];
    map[34] = ['PAGEDOWN', 'PAGEDOWNSHIFT'];
    map[35] = ['PAGERIGHT', 'PAGERIGHTSHIFT']; // END
    map[36] = ['PAGELEFT', 'PAGELEFTSHIFT']; // HOME

    map[112] = ['F1', 'F1SHIFT'];
    map[113] = ['F2', 'F2SHIFT'];
    map[114] = ['F3', 'F3SHIFT'];
    map[115] = ['F4', 'F4SHIFT'];
    map[116] = ['F5', 'F5SHIFT'];
    map[117] = ['F6', 'F6SHIFT'];
    map[118] = ['F7', 'F7SHIFT'];
    map[119] = ['F8', 'F8SHIFT'];
    map[120] = ['F9', 'F9SHIFT'];
    map[121] = ['F10', 'F10SHIFT'];
    map[122] = ['F11', 'F1S1HIFT'];
    map[123] = ['F12', 'F121HIFT'];

    return map;
}

module.exports = Canvas;
},{"./js/GraphicsContext.js":11,"rectangular":45}],11:[function(require,module,exports){
'use strict';

var consoleLogger = require('./gc-console-logger');

/**
 * @constructor
 * @param gc - The 2-D graphics context from your canvas
 * @param {boolean|apiLogger} [logger=true]
 * * `true` uses `gc-console-logger` function bound to 'gc.' as prefix
 * * string uses `gc-console-logger` function bound to string
 * * function used as is
 */
function GraphicsContext(gc, logger) {
    this.gc = gc;

    var self = this;
    var reWEBKIT = /^webkit/;

    switch (typeof logger) {

        case 'string':
            logger =  consoleLogger.bind(undefined, logger + '.');
            break;

        case 'boolean':
            if (logger === true) {
                logger = consoleLogger.bind(undefined, 'gc.');
            }
            break;

        case 'function':
            if (logger.length !== 3) {
                throw 'GraphicsContext: User-supplied API logger function does not accept three parameters.';
            }
            break;

        default:
            logger = false;
    }

    // Stub out all the prototype members of the canvas 2D graphics context:
    Object.keys(Object.getPrototypeOf(gc)).forEach(MakeStub);

    // Some older browsers (e.g., Chrome 40) did not have all members of canvas
    // 2D graphics context in the prototype so we make this additional call:
    Object.keys(gc).forEach(MakeStub);

    function MakeStub(key) {
        if (key in GraphicsContext.prototype || reWEBKIT.test(key)) {
            return;
        }
        if (typeof gc[key] === 'function') {
            self[key] = !logger ? gc[key].bind(gc) : function() {
                return logger(key, arguments, gc[key].apply(gc, arguments));
            };
        } else {
            Object.defineProperty(self, key, {
                get: function() {
                    var result = gc[key];
                    return logger ? logger(key, 'getter', result) : result;
                },
                set: function(value) {
                    gc[key] = logger ? logger(key, 'setter', value) : value;
                }
            });
        }
    }
}

module.exports = GraphicsContext;

},{"./gc-console-logger":12}],12:[function(require,module,exports){
'use strict';

var YIELDS = '\u27F9'; // LONG RIGHTWARDS DOUBLE ARROW

function consoleLogger(prefix, name, args, value) {
    var result = value;

    if (typeof value === 'string') {
        result = '"' + result + '"';
    }

    name = prefix + name;

    switch (args) {
        case 'getter':
            console.log(name, '=', result);
            break;

        case 'setter':
            console.log(name, YIELDS, result);
            break;

        default: // method call
            name += '(' + Array.prototype.slice.call(args).join(', ') + ')';
            if (result === undefined) {
                console.log(name);
            } else {
                console.log(name, YIELDS, result);
            }
    }

    return value;
}

module.exports = consoleLogger;

},{}],13:[function(require,module,exports){
'use strict';

module.exports = {
    JSDataSource: require('./js/DataSource'),
    DataSourceSorter: require('./js/DataSourceSorter'),
    DataSourceSorterComposite: require('./js/DataSourceSorterComposite'),
    DataSourceGlobalFilter: require('./js/DataSourceGlobalFilter'),
    DataSourceGroupView: require('./js/DataSourceGroupView'),
    DataSourceAggregator: require('./js/DataSourceAggregator'),
    DataSourceTreeview: require('./js/DataSourceTreeview'),
    DataSourceTreeviewFilter: require('./js/DataSourceTreeviewFilter'),
    DataSourceTreeviewSorter: require('./js/DataSourceTreeviewSorter'),
    DataNodeGroupSorter: require('./js/DataNodeGroupSorter'),
    util: {
        aggregations: require('./js/util/aggregations'),
        Mappy: require('./js/util/Mappy'),
        stableSort: require('./js/util/stableSort'),
        headerify: require('./js/util/headerify')
    }
};

},{"./js/DataNodeGroupSorter":21,"./js/DataSource":24,"./js/DataSourceAggregator":25,"./js/DataSourceGlobalFilter":27,"./js/DataSourceGroupView":28,"./js/DataSourceSorter":30,"./js/DataSourceSorterComposite":31,"./js/DataSourceTreeview":32,"./js/DataSourceTreeviewFilter":33,"./js/DataSourceTreeviewSorter":34,"./js/util/Mappy":35,"./js/util/aggregations":36,"./js/util/headerify":37,"./js/util/stableSort":38}],14:[function(require,module,exports){
'use strict';


var AggregatorNodeBaseMixin = {
    getRowData: function(aggregator) {
        var index = this.getIndex();

        if (index.length) {
            var groupsOffset = Number(aggregator.hasGroups());

            // redimension the data
            var data = this.data;
            data.length = groupsOffset + aggregator.aggregates.length;

            var sorter = aggregator.sorterInstance;
            sorter.index = index;

            aggregator.aggregates.forEach(function(aggregate, i) {
                data[groupsOffset + i] = aggregate(sorter);
            });
        }
    }
};

module.exports = AggregatorNodeBaseMixin;

},{}],15:[function(require,module,exports){
'use strict';

var AggregatorNodeBaseMixin = require('./AggregatorNodeBaseMixin');
var DataNodeGroup = require('./DataNodeGroup');

/**
 * @constructor
 * @extends DataNodeBase
 */
var AggregatorNodeGroup = DataNodeGroup.extend('AggregatorNodeGroup', {
    getRowData: function (drillDown) {
        AggregatorNodeBaseMixin.getRowData.apply(this, arguments);
        if (this.expanded) {
            this.children.forEach(function (child) {
                child.getRowData(drillDown);
            });
        }
    }
});

module.exports = AggregatorNodeGroup;

},{"./AggregatorNodeBaseMixin":14,"./DataNodeGroup":20}],16:[function(require,module,exports){
'use strict';

var AggregatorNodeBaseMixin = require('./AggregatorNodeBaseMixin');
var DataNodeLeaf = require('./DataNodeLeaf');

/**
 * @constructor
 * @extends DataNodeBase
 */
var AggregatorNodeLeaf = DataNodeLeaf.extend('AggregatorNodeLeaf', AggregatorNodeBaseMixin);

module.exports = AggregatorNodeLeaf;

},{"./AggregatorNodeBaseMixin":14,"./DataNodeLeaf":22}],17:[function(require,module,exports){
'use strict';

var AggregatorNodeBaseMixin = require('./AggregatorNodeBaseMixin');
var DataNodeTree = require('./DataNodeTree');

/**
 * @constructor
 * @extends DataNodeBase
 */
var AggregatorNodeTree = DataNodeTree.extend('AggregatorNodeTree', {
    getRowData: function (drillDown) {
        AggregatorNodeBaseMixin.getRowData.apply(this, arguments);
        if (this.expanded) {
            this.children.forEach(function (child) {
                child.getRowData(drillDown);
            });
        }
    }
});

module.exports = AggregatorNodeTree;

},{"./AggregatorNodeBaseMixin":14,"./DataNodeTree":23}],18:[function(require,module,exports){
'use strict';

var Base = require('fin-hypergrid-data-source-base');

// Following are for legacy methods

Base.prototype.getFields = function() {
    if (this.dataSource) {
        return this.dataSource.getFields();
    }
};

Base.prototype.getHeaders = function() {
    if (this.dataSource) {
        return this.dataSource.getHeaders();
    }
};

Base.prototype.getCalculators = function() {
    if (this.dataSource) {
        return this.dataSource.revealRow();
    }
};

Base.prototype.setFields = function(arr) {
    if (this.dataSource) {
        return this.dataSource.setFields.call(this.dataSource, arr);
    }
};

Base.prototype.setHeaders = function(arr) {
    if (this.dataSource) {
        return this.dataSource.setHeaders.call(this.dataSource, arr);
    }
};

module.exports = Base;

},{"fin-hypergrid-data-source-base":8}],19:[function(require,module,exports){
'use strict';

var Base = require('./Base');

/**
 * See {@link DataBaseNode#initialize|initialize()} method for parameters.
 * @constructor
 */
var DataNodeBase = Base.extend('DataNodeBase', {

    isNullObject: false,

    INDENT: '   ', // 3 spaces

    /**
     * @memberOf DataNodeBase#
     * @param {string} key
     */
    initialize: function(key) {
        /**
         * @memberOf DataNodeBase#
         * @type {string}
         */

        this.label = key;

        /**
         * @memberOf DataNodeBase#
         * @type {string[]}
         * @default false
         */
        this.data = [''];

        /**
         * @memberOf DataNodeBase#
         * @type {number[]}
         * @default ['']
         */
        this.index = []; // formerly rowIndex

        /**
         * @memberOf DataNodeBase#
         * @type {boolean}
         * @default false
         */
        this.hasChildren = true;

        /**
         * @memberOf DataNodeBase#
         * @type {number}
         * @default 0
         */
        this.depth = 0;

        /**
         * @memberOf DataNodeBase#
         * @type {number}
         * @default 1
         */
        this.height = 1;

        /**
         * @memberOf DataNodeBase#
         * @type {boolean}
         * @default false
         */
        this.expanded = false;
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param x
     * @returns {*}
     */
    getValue: function(x) {
        return this.data[x];
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeLeaf#
     * @returns {string}
     */
    computeDepthString: function() {
        return Array(this.depth + 1).join(this.INDENT) + '  ' + this.label;
    },

    /**
     * @memberOf DataNodeLeaf#
     * @returns {number}
     */
    computeHeight: function() {
        return 1;
    },

    /**
     * @memberOf DataNodeLeaf#
     * @returns {Array}
     */
    getIndex: function() { // TODO: formerly getAllRowIndexes
        return this.index;
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param drillDown
     */
    getRowData: function(drillDown) {
        var index = this.getIndex();

        if (index.length) {
            // Group and Tree nodes will have no data besides the tree column
            this.data.length = drillDown.getColumnCount();
        }
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param drillDown
     */
    buildView: function(drillDown) {
        drillDown.addView(this);
    },

    /**
     * @memberOf DataNodeLeaf#
     */
    toggleExpansionState: function() {
        //do nothing by default
    },

    sortGroups: function(groupSorter) {
    }
});


module.exports = DataNodeBase;

},{"./Base":18}],20:[function(require,module,exports){
'use strict';

var Map = require('./util/Mappy');
var DataNodeBase = require('./DataNodeBase');

var expandedMap = {
    true: '\u25bc', // BLACK DOWN-POINTING TRIANGLE aka ''
    false: '\u25b6' // BLACK RIGHT-POINTING TRIANGLE aka ''
};

/**
 * > See {@link DataNodeGroup#initialize|initialize()} method for constructor parameters.
 * @constructor
 * @extends DataNodeBase
 */
var DataNodeGroup = DataNodeBase.extend('DataNodeGroup', {

    extendable: true,

    /**
     * @memberOf DataNodeGroup#
     * @param key
     */
    initialize: function(key) {
        this.children = new Map();
    },

    /**
     * @memberOf DataNodeGroup#
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.children = this.children.values;
        this.children.forEach(function(child) {
            child.toArray(depth + 1);
        });
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeGroup#
     * @returns {string}
     */
    computeDepthString: function() {
        var string = Array(this.depth + 1).join(this.INDENT) +
            expandedMap[this.expanded] + ' ' +
            this.label;
        return string;
    },

    /**
     * @memberOf DataNodeGroup#
     * @returns {*}
     */
    getIndex: function() {
        if (this.index.length === 0) {
            this.index = this.computeIndex();
        }
        return this.index;
    },

    /**
     * @memberOf DataNodeGroup#
     * @returns {Array}
     */
    computeIndex: function() { // TODO: formerly computeAllRowIndexes
        var result = [];
        result.append = append;
        this.children.forEach(function(child) {
            result.append(child.getIndex());
        });
        return result;
    },

    /**
     * @memberOf DataNodeGroup#
     * @param drillDown
     * @param {boolean} [expand] - One of:
     * * `true` - Expand all rows that are currently collapsed.
     * * `false` - Collapse all rows that are currently expanded.
     * * `undefined` (or omitted) - Expand all currently collapsed rows; collapse all currently expanded rows.
     * @returns {boolean} If this call resulted in a state change.
     */
    toggleExpansionState: function(drillDown, expand) { /* aggregator */
        if (expand === undefined) {
            expand = !this.expanded;
        }
        var changed = this.expanded ^ expand;
        this.expanded = expand;
        this.data[0] = this.computeDepthString();
        if (this.expanded) {
            this.getRowData(drillDown);
        }
        return !!changed;
    },

    /**
     * @memberOf DataNodeGroup#
     * @param drillDown
     */
    getRowData: function(drillDown) {
        DataNodeBase.prototype.getRowData.call(this, drillDown); // call base class's version
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.getRowData(drillDown);
            });
        }
    },

    /**
     * @memberOf DataNodeGroup#
     * @param aggregator
     */
    buildView: function(drillDown) {
        drillDown.view.push(this);
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.buildView(drillDown);
            });
        }
    },

    /**
     * @memberOf DataNodeGroup#
     * @returns {number}
     */
    computeHeight: function() {
        var height = 1;

        if (this.expanded) {
            this.children.forEach(function(child) {
                height = height + child.computeHeight();
            });
        }

        return (this.height = height);
    },

    sortWith: function(sorter) {
        if (this.expanded) {
            sorter.sortGroup(this);
            this.children.forEach(function(child) {
                child.sortWith(sorter);
            });
        }
    },
    clearGroupSorts: function() {
        if (this.originalOrder) {
            for (var i = 0; i < this.originalOrder.length; i++) {
                this.children[i] = this.originalOrder[i];
            }
        }
        this.children.forEach(function(child) {
            child.clearGroupSorts();
        });
    }

});

/**
 * @private
 * @summary Array mixin to append another array to end of `this` one.
 * @desc Appends in place, unlike `this.concat()` which creates a new array.
 * Uses less memory than concat, important when `appendix` is huge.
 * > CAUTION: Mutates `this` array!
 * @param {Array} appendix
 * @returns {Array} Reference to `this` (for convenience)
 */
function append(appendix) {
    this.splice.bind(this, this.length, 0).apply(this, appendix);
    return this;
}

module.exports = DataNodeGroup;

},{"./DataNodeBase":19,"./util/Mappy":35}],21:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var stableSort = require('./util/stableSort').sort;

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataNodeGroupSorter = Base.extend('DataNodeGroupSorter', {

    /**
     * @memberOf DataNodeGroupSorter#
     */
    initialize: function(dataSource) {
        this.dataSource = dataSource;
        this.sorts = [];

    },
    /**
     *  @memberOf DataSourceSorterComposite#
     *  @param columnIndex
     *  @param direction
     */

    sortOn: function(columnIndex, direction) {
        this.sorts.push({ columnIndex: columnIndex, direction: direction });
    },
    /**
     *
     * @memberOf DataNodeGroupSorter#
     * @param {sorterFunction} [sorter] - If undefined, deletes sorter.
     */
    set: function(sorter) {
        if (sorter) {
            /**
             * @implements sorterInterfacei
             * @memberOf DataSourceSorterComposite#
             */
            this.sorter = sorter;
        } else {
            delete this.sorter;
        }
    },

    get: function() {
        return this.sorter;
    },

    /**
     * @memberOf DataNodeGroupSorter#
     */
    apply: function() {
        this.dataSource.sortGroups(this);
    },

    /**
     * @memberOf DataSourceSorterComposite#
     */
    clearSorts: function() {
        this.sorts.length = 0;
        this.dataSource.buildView();
    },

    sortGroup: function(group) {
        if (!group.originalOrder) {
            group.originalOrder = group.children.slice(0);
        }

        // get list of sorts from either API or use existing
        this.sorts = (this.sorter && this.sorter.prop('sorts')) || this.sorts;
        for (var i = this.sorts.length - 1; i >= 0; i--) {
            this.sortGroupOnEach(group, this.sorts[this.sorts.length - i - 1]);
        }
    },

    sortGroupOnEach: function(group, sortSpec) {
        // we actually sort the children here....
        var children = group.children.slice(0);
        var indexVector = [];

        for (var i = 0; i < children.length; i++) {
            indexVector[i] = i;
        }

        stableSort(indexVector, function(rowNumber) {
            var child = children[rowNumber];
            if (sortSpec.columnIndex === 0) {
                return child.label;
            }
            return child.data[sortSpec.columnIndex];
        }, sortSpec.direction);

        for (i = 0; i < children.length; i++) {
            group.children[i] = children[indexVector[i]];
        }
    }

});

DataNodeGroupSorter.prototype.applySorts = function() {
    (console.warn || console.log).call(console, 'applySorts deprecated; use apply');
    this.apply();
};

Object.defineProperty(DataNodeGroupSorter.prototype, 'type', { value: 'sorter' }); // read-only property

module.exports = DataNodeGroupSorter;

},{"./Base":18,"./util/stableSort":38}],22:[function(require,module,exports){
'use strict';

var DataNodeBase = require('./DataNodeBase');

/**
 * @constructor
 * @extends DataNodeBase
 */
var DataNodeLeaf = DataNodeBase.extend('DataNodeLeaf', {

    /**
     * @memberOf DataNodeLeaf#
     * @param {string} key
     */
    initialize: function(key) {
        this.hasChildren = false;
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param depth
     */
    toArray: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    /**
     * @memberOf DataNodeLeaf#
     * @returns {numer[]}
     */
    getIndex: function() {
        return this.index;
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param drillDown
     */
    buildView: function(drillDown) {
        drillDown.addView(this);
    },

    /**
     * @memberOf DataNodeLeaf#
     * @param aggregator
     */
    getRowData: function(drillDown) {
        var index = this.getIndex();

        if (index.length) {
            var groupsOffset = Number(drillDown.hasGroups()),
                data = this.data,
                dataLen = drillDown.getColumnCount() + groupsOffset,
                i = 0,
                sorter = drillDown.sorterInstance;

            sorter.index = index;

            for (i; i < dataLen; i++) {
                data[groupsOffset + i] = sorter.getValue(i, 0);
            }
        }
    },

    /**
     * @memberOf DataNodeLeaf#
     * @returns {number}
     */
    computeHeight: function() {
        return 1;
    },

    sortWith: function(sorter) {
      // do nothing we have no children to sort
    },

    clearGroupSorts: function() {
      // do nothing we have no children to sort
    }

});

module.exports = DataNodeLeaf;

},{"./DataNodeBase":19}],23:[function(require,module,exports){
'use strict';

var DataNodeGroup = require('./DataNodeGroup');

/**
 * See {@link DataNodeGroup#initialize|initialize()} method for parameters.
 * @constructor
 * @extends DataNodeGroup
 */
var DataNodeTree = DataNodeGroup.extend('DataNodeTree', {

    /**
     * @memberOf DataNodeGroup#
     * @param {string} key
     */
    initialize: function(key) {
        this.height = 0;
        this.expanded = true;
    },

    /**
     * @memberOf DataNodeGroup#
     */
    toArray: function() {
        this.children = this.children.values;
        this.children.forEach(function(child) {
            child.toArray(0);
        });
    },

    /**
     * @memberOf DataNodeGroup#
     * @param drillDown
     */
    buildView: function(drillDown) {
        this.children.forEach(function(child) {
            child.buildView(drillDown);
        });
    },

    /**
     * @memberOf DataNodeGroup#
     * @returns {number}
     */
    computeHeight: function() {
        var height = 1;

        this.children.forEach(function(child) {
            height = height + child.computeHeight();
        });

        return (this.height = height);
    }

});

module.exports = DataNodeTree;

},{"./DataNodeGroup":20}],24:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var headerify = require('./util/headerify');

/**
 * @constructor
 * @param {object[]} data
 * @param {string[]} fields
 */
var DataSource = Base.extend('DataSource', {
    initialize: function(data, fields, calculators) {
        /**
         * @summary The array of data row objects.
         * @desc Access through {@link DataSource#getRow|getRow()}.
         * @name data
         * @type {object[]}
         * @memberOf DataSource#
         */
        this.data = data;

        /**
         * @summary The list of field names.
         * @desc These are all the members of the data row objects visible to Hypergrid.
         *
         * Access through {@link DataSource#getFields|getFields()}.
         * @name fields
         * @type {string[]}
         * @memberOf DataSource#
         */
        this.fields = fields || computeFieldNames(data[0]);

        /**
         * @summary The list of calculators that implement computed columns.
         * @desc Congruent to {@link DataSource#fields|fields}.
         *
         * Elements representing regular (non-computed) fields should contain `undefined`.
         * @name calculators
         * @type {function[]}
         * @memberOf DataSource#
         */
        this.calculators = calculators || Array(this.fields.length);
    },

    isNullObject: false,

    getDataIndex: function(y) {
        return y;
    },

    /**
     * @memberOf DataSource#
     * @param y
     * @returns {object[]}
     */
    getRow: function(y) {
        return this.data[y];
    },

        /**
     * @summary Find, replace, or update a row by it's primary key column.
     * @param {string|object} columnName - One of:
     * * _string_ - Column name. See `value`.
     * * _object_ - Hash of 0 or more key-value pairs to search for.
     * @param {string[]|*} [value] - One of:
     * _omitted_ - When `columnName` is a hash and you want to search all its keys.
     * _string[]_ - When `columnName` is a hash but you only want to search certain keys.
     * _otherwise_ - When `columnName` is a string. Value to search for.
     * Note that `null` is a valid search value.
     * @param {object|null|undefined} [replacement] - One of:
     * * _omitted_ - Ignored.
     * * _object_ - Replacement for the data row if found.
     * * `null` - Flag to delete the data row if found. The found data row is nonetheless returned.
     * * `undefined` - Flag to return index of found row instead of row object itself.
     * @returns {object|number|undefined} One of:
     * * `undefined` - data row not found
     * * _object_ - found data row object (will have been deleted if `replacement` was `null`)
     * * _number_ - index of found data row object in `this.data` (if `replacement` was `undefined`)
     * @todo Use a binary search (rather than `Array..find`) when column is known to be indexed (sorted).
     * @memberOf DataSource#
     */
    findRow: function findRow(columnName, value, replacement) {
        var result, index, keys, hash, args;

        if (typeof columnName === 'object') {
            hash = columnName;

            if (value instanceof Array) {
                args = 2;
                keys = value;
                if (keys.reduce(function(sum, key) {
                    if (key in hash) {
                        sum++;
                    }
                    return sum;
                }, 0) !== keys.length) {
                    throw 'Expected all keys given in 2nd arg to be found in hash given in 1st arg.';
                }
            } else {
                args = 1;
                keys = Object.keys(hash);
                replacement = value; // promote
            }

            if (keys.length === 1) {
                columnName = keys[0];
                value = hash[columnName];
                hash = undefined;
            } else if (keys.length) {
                result = this.data.find(function(row, idx) {
                    if (!row) {
                        return;
                    }
                    index = idx;
                    for (var key in keys) {
                        columnName = keys[key];
                        if (row[columnName] !== hash[columnName]) {
                            return; // bail
                        }
                    }
                    return true; // found!
                });
            }
        } else {
            if (arguments.length < 2) {
                throw 'Expected at least 2 arguments when first argument not object but found ' + arguments.length + '.';
            }
            args = 2;
        }

        if (!hash) {
            result = this.data.find(function(row, idx) {
                if (!row) { return; }
                index = idx;
                return row[columnName] === value;
            });
        }

        if (result) {
            this.foundRowIndex = index;
            if (replacement === null) {
                this.data.splice(index, 1);
            } else if (typeof replacement === 'object') {
                this.data[index] = replacement;
            } else if (replacement === undefined) {
                if (arguments.length > args) {
                    delete this.data[index];
                }
            } else {
                throw 'Expected null, undefined, or object but found ' + typeof replacement + '.';
            }
        } else {
            this.foundRowIndex = undefined;
        }

        return result;
    },

    /**
     * @memberOf DataSource#
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        var row = this.getRow(y);
        if (!row) {
            return null;
        }
        return row[this.fields[x]];
    },

    /**
     * @memberOf DataSource#
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        this.getRow(y)[this.fields[x]] = value;
    },

    /**
     * @memberOf DataSource#
     * @returns {number}
     */
    getRowCount: function() {
        return this.data.length;
    },

    /**
     * @memberOf DataSource#
     * @returns {number}
     */
    getColumnCount: function() {
        return this.getFields().length;
    },

    /**
     * @memberOf DataSource#
     * @returns {number[]}
     */
    getFields: function() {
        return this.fields;
    },

    /**
     * @memberOf DataSource#
     * @returns {string[]}
     */
    getHeaders: function() {
        return (
            /**
             * @summary The list of header strings.
             * @desc Congruent to {@link DataSource#fields|fields}.
             *
             * Access through {@link DataSource#getHeaders|getHeaders()}.
             * @name headers
             * @type {string[]}
             * @memberOf DataSource#
             */
            this.headers = this.headers || this.getDefaultHeaders().map(function(each) {
                return headerify.transform(each);
            })
        );
    },

    /**
     * @memberOf DataSource#
     * @returns {string[]}
     */
    getDefaultHeaders: function() {
        return this.getFields();
    },

    /**
     * @memberOf DataSource#
     * @param {string[]} fields
     */
    setFields: function(fields) {
        this.fields = fields;
    },

    /**
     * @memberOf DataSource#
     * @param {string[]} headers
     */
    setHeaders: function(headers) {
        if (!(headers instanceof Array)) {
            error('setHeaders', 'param #1 `headers` not array');
        }
        this.headers = headers;
    },

    /**
     * @memberOf DataSource#
     */
    getGrandTotals: function() {
        //nothing here
    },

    /**
     * @memberOf DataSource#
     * @param arrayOfUniformObjects
     */
    setData: function(arrayOfUniformObjects) {
        this.data = arrayOfUniformObjects;
    }
});

function error(methodName, message) {
    throw new Error('DataSource.' + methodName + ': ' + message);
}

/**
 * @private
 * @param {object} object
 * @returns {string[]}
 */
function computeFieldNames(object) {
    if (!object) {
        return [];
    }
    return Object.getOwnPropertyNames(object || []).filter(function(e) {
        return e.substr(0, 2) !== '__';
    });
}

module.exports = DataSource;

},{"./Base":18,"./util/headerify":37}],25:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var DataSourceSorter = require('./DataSourceSorter');
var DataNodeTree = require('./AggregatorNodeTree');
var DataNodeGroup = require('./AggregatorNodeGroup');
var DataNodeLeaf = require('./AggregatorNodeLeaf');
var headerify = require('./util/headerify');

/**
 * @constructor
 * @param {DataSource} dataSource
 */
var DataSourceAggregator = Base.extend('DataSourceAggregator', {
    initialize: function(dataSource) {

        /**
         * @memberOf DataSourceAggregator#
         * @type {DataSource}
         */
        this.dataSource = dataSource;

        /**
         * @memberOf DataSourceAggregator#
         * @type {DataSource}
         */
        this.treeColumnIndex = 0;

        /**
         * @memberOf DataSourceAggregator#
         * @type {DataNodeTree}
         */
        this.tree = new DataNodeTree('Totals');

        /**
         * @memberOf DataSourceAggregator#
         * @type {number[]}
         * @default []
         */
        this.index = [];

        /**
         * @memberOf DataSourceAggregator#
         * @type {Array}
         * @default []
         */
        this.aggregates = [];

        /**
         * @memberOf DataSourceAggregator#
         * @type {Array}
         * @default []
         */
        this.groupBys = [];

        /**
         * @memberOf DataSourceAggregator#
         * @type {Array}
         * @default []
         */
        this.view = [];

        /**
         * @memberOf DataSourceAggregator#
         * @type {object}
         * @default {}
         */
        this.sorterInstance = {};

        /**
         * @memberOf DataSourceAggregator#
         * @type {boolean}
         * @default true
         */
        this.presortGroups = true;

        /**
         * @memberOf DataSourceAggregator#
         * @type {object}
         * @default {}
         */
        this.lastAggregate = {};

        this.setAggregates({});
    },

    isNullObject: false,


    /**
     * @memberOf DataSourceAggregator#
     * @param aggregations, groups
     */
    setAggregateGroups: function(aggregations, groups) {
        this.setGroupBys(groups);
        this.setAggregates(aggregations);
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param aggregations
     */
    setAggregates: function(aggregations) {
        this.lastAggregate = aggregations;
        this.clearAggregations();

        for (var key in aggregations) {
            this.addAggregate(key, aggregations[key]);
        }

    },

    getFields: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getFields();
        }
        var fields = this.getHeaders().map(function(e) {
            return e.toLowerCase().split(' ').join('_');
        });
        return fields;
    },

    getHeaders: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getHeaders();
        }
        var headers = this.aggregates.map(function(e) {
            return e.header;
        });
        if (this.hasGroups()) {
            headers.unshift('Tree');
        }
        return headers;
    },
    /**
     * @memberOf DataSourceAggregator#
     * @param label
     * @param func
     */
    addAggregate: function(label, func) {
        func.header = headerify.transform(label);
        this.aggregates.push(func);
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param columnIndexArray
     */
    setGroupBys: function(columnIndexArray) {
        var groupBys = this.groupBys;
        groupBys.length = 0;
        columnIndexArray.forEach(function(columnIndex) {
            groupBys.push(columnIndex);
        });
        this.setAggregates(this.lastAggregate);
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param index
     */
    addGroupBy: function(index) {
        this.groupBys.push(index);
    },

    /**
     * @memberOf DataSourceAggregator#
     * @returns {boolean}
     */
    hasGroups: function() {
        return !!this.groupBys.length;
    },

    /**
     * @memberOf DataSourceAggregator#
     * @returns {boolean}
     */
    hasAggregates: function() {
        return !!this.aggregates.length;
    },

    /**
     * @memberOf DataSourceAggregator#
     * @params [options]
     */
    apply: function(options) {
        options  = options || {};
        if (!options.rowClick && !options.columnSort){
            this.buildGroupTree();
        }
    },

    /**
     * @memberOf DataSourceAggregator#
     */
    clearGroups: function() {
        this.groupBys.length = 0;
    },

    /**
     * @memberOf DataSourceAggregator#
     */
    clearAggregations: function() {
        this.aggregates.length = 0;
    },

    /**
     * @memberOf DataSourceAggregator#
     */
    buildGroupTree: function() {
        var reversedGroupBys = this.groupBys.slice(0).reverse(),
            leafDepth = this.groupBys.length - 1,
            source = this.dataSource,
            rowCount = source.getRowCount(),
            tree = this.tree = new DataNodeTree('Totals');

        // first sort data
        if (this.presortGroups) {
            reversedGroupBys.forEach(function(groupBy) {
                source = new DataSourceSorter(source);
                source.sortOn(groupBy);
            });
        }

        for (var r = 0; r < rowCount; r++) {
            var path = tree;

            this.groupBys.forEach(function(g, c) { // eslint-disable-line no-loop-func
                var key = source.getValue(g, r),
                    factoryDataNode = (c === leafDepth) ? factoryDataNodeLeaf : factoryDataNodeGroup;
                path = path.children.getIfUndefined(key, factoryDataNode);
            });

            path.index.push(r);
        }

        this.sorterInstance = new DataSourceSorter(source);
        tree.toArray();
        tree.getRowData(this);
        this.buildView();
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param dataNode
     */
    addView: function(dataNode) {
        this.view.push(dataNode);
    },

    /**
     * @memberOf DataSourceAggregator#
     */
    buildView: function() {
        this.view.length = 0;
        this.tree.computeHeight();
        this.tree.buildView(this);
    },

    /**
     * @memberOf DataSourceAggregator#
     * @returns {*|boolean}
     */
    viewMakesSense: function() {
        return this.hasAggregates() && this.hasGroups();
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param {number} columnIndex
     * @returns {*|boolean}
     */
    isDrillDown: function(columnIndex) {
        var result = this.viewMakesSense();
        if (result && columnIndex) {
            result = columnIndex === this.treeColumnIndex;
        }
        return result;
    },

    getDataIndex: function(y) {
        return this.viewMakesSense() ? y : this.dataSource.getDataIndex(y);
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getValue(x, y);
        }
        var row = this.view[y];
        return row ? row.getValue(x) : null;
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param x
     * @param y
     * @param value
     * @returns {*}
     */
    setValue: function(x, y, value) {
        if (!this.viewMakesSense()) {
            return this.dataSource.setValue(x, y, value);
        }
    },

    /**
     * @memberOf DataSourceAggregator#
     * @returns {*}
     */
    getColumnCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getColumnCount();
        }
        return this.getHeaders().length;
    },

    /**
     * @memberOf DataSourceAggregator#
     * @returns {*}
     */
    getRowCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRowCount();
        }
        return this.view.length; //header column
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param y
     * @param {boolean} [expand] - One of:
     * * `true` - Expand all rows that are currently collapsed.
     * * `false` - Collapse all rows that are currently expanded.
     * * `undefined` (or omitted) - Expand all currently collapsed rows; collapse all currently expanded rows.
     * @param {number} [depth=Infinity] - One of:
     * * number > 0 - Apply only if row depth is above the given depth.
     * * number <= 0 - Apply only if row depth is below the given depth.
     * @returns {undefined|boolean} One of:
     * * `undefined` - row was not expandable
     * * `true` - row was expandable _and_ state changed
     * * `false` - row was expandable _but_ state did _not_ change
     */
    click: function(y, expand, depth) {
        if (!this.viewMakesSense()) {
            return this.dataSource.click.apply(this.dataSource, arguments);
        }
        var group = this.view[y], expandable, changed;
        if (
            group && (
                depth === undefined ||
                depth > 0 && group.depth < depth ||
                depth <= 0 && group.depth >= -depth
            )
        ) {
            changed = group.toggleExpansionState(this, expand);
            if ((expandable = group.children)) {
                this.buildView();
            }
        }

        return expandable ? changed : undefined;
    },

    /**
     * @memberOf DataSourceAggregator#
     * @returns {object[]}
     */
    getGrandTotals: function() {
        var view = this.tree;
        return [view.data];
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param y
     * @returns {*}
     */
    getRow: function(y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRow(y);
        }

        var rollups = this.view[y];

        return rollups ? rollups : this.tree;
    },

    /**
     * @memberOf DataSourceAggregator#
     * @param arrayOfUniformObjects
     */
    setData: function(arrayOfUniformObjects) {
        this.dataSource.setData(arrayOfUniformObjects);
        this.apply();
    },

    sortGroups: function(groupSorter) {
        this.tree.clearGroupSorts();
        this.tree.sortWith(groupSorter);
        this.buildView();
    }
});

function factoryDataNodeLeaf(key) {
    return new DataNodeLeaf(key);
}

function factoryDataNodeGroup(key) {
    return new DataNodeGroup(key);
}

Object.defineProperty(DataSourceAggregator.prototype, 'type', { value: 'aggregator' }); // read-only property

module.exports = DataSourceAggregator;

},{"./AggregatorNodeGroup":15,"./AggregatorNodeLeaf":16,"./AggregatorNodeTree":17,"./Base":18,"./DataSourceSorter":30,"./util/headerify":37}],26:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var stableSort = require('./util/stableSort');

/**
 * @classdesc Sorts on non-terminal tree node rows only (_i.e.,_ expandable rows with children).
 *
 * One of these sorters is created by {@link DataSourceTreeviewSorter} for each grouping level, starting with the maximum group level depth, and then one for each group level through the top level (0) sort depth.
 * @constructor
 * @param dataSource
 * @extends DataSourceIndexed
 */
var DataSourceDepthSorter = DataSourceIndexed.extend('DataSourceDepthSorter', {
    initialize: function(dataSource, treeView) {
        this.idColumnName = treeView.idColumn.name;
        this.parentIdColumnName = treeView.parentIdColumn.name;
    },

    /**
     * @desc Stable-sorts non-terminal tree node rows. Terminal (leaf) rows remain stable.
     * @param {number} groupLevel - If greater than row depth, sorts on an _edge value_ value, which is a value lexically inferior to (ascending sort) or superior to (descending sort) the row value.
     * Otherwise sorts on value of ancestor of this depth.
     *
     * @param {number} [direction=1] - One of:
     * `1` - Sort ascending.
     * `-1` - Sort descending.
     * @param {number} [columnIndex] - Sorts on the values in this column. Otherwise sorts on the row index.
     * @memberOf DataSourceDepthSorter#
     */
    sortOn: function(groupLevel, direction, columnIndex) {
        switch (direction) {
            case 0:
                this.clearIndex();
                break;

            case undefined:
            case 1:
            case -1:
                if (this.dataSource.getRowCount()) {
                    var getValue;

                    this.buildIndex();

                    // used in getValue:
                    this.depth = 0;
                    this.edge = direction === -1 ? +Infinity : -Infinity; // for numbers, date objects

                    if (columnIndex === undefined) {
                        getValue = getRowIndex.bind(this);
                    } else {
                        getValue = getColumnValue.bind(this);
                        this.columnName = this.dataSource.getFields()[columnIndex];
                        this.calculator = this.dataSource.getProperty('calculators')[columnIndex];
                        if (typeof getValue(0) === 'string') {
                            this.edge = direction === -1 ? '\uffff' : ''; // for strings
                        }
                    }

                    this.depth = groupLevel;
                    stableSort.sort(this.index, getValue, direction);
                }
                break;
        }
    }
});

function getRowIndex(rowIdx) {
    var parentID,
        dataRow = this.dataSource.getRow(rowIdx);

    if (dataRow.__DEPTH < this.depth) {
        return this.edge;
    }

    rowIdx = this.getDataIndex(rowIdx);

    // bubble up to group label of requested depth while either...
    while (
        // ...this is a leaf row
        dataRow.__EXPANDED === undefined ||
        // ...or: still deeper than the requested depth
        dataRow.__DEPTH > this.depth
    ) {
        parentID = dataRow[this.parentIdColumnName];
        if (parentID == null) { break; }
        dataRow = this.findRow(this.idColumnName, parentID);
        rowIdx = this.getProperty('foundRowIndex');
    }

    return rowIdx;
}

function getColumnValue(rowIdx) {
    var parentID,
        dataRow = this.dataSource.getRow(rowIdx);

    if (dataRow.__DEPTH < this.depth) {
        return this.edge;
    }

    // bubble up to group label of requested depth while either...
    while (
        // ...this is a leaf row
        dataRow.__EXPANDED === undefined ||
        // ...or: still deeper than the requested depth
        dataRow.__DEPTH > this.depth
    ) {
        parentID = dataRow[this.parentIdColumnName];
        if (parentID == null) { break; }
        dataRow = this.findRow(this.idColumnName, parentID);
    }

    return DataSourceIndexed.valOrFunc.call(dataRow, this.columnName, this.calculator);
}

module.exports = DataSourceDepthSorter;

},{"./DataSourceIndexed":29,"./util/stableSort":38}],27:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

/**
 * @interface filterInterface
 */

/**
 * @name filterInterface#test
 * @method
 * @param {object} dataRow - Object representing a row in the grid containing all the fields listed in {@link DataSource#fields|fields}.
 * @returns {boolean}
 * * `true` - include in grid (row passes through filter)
 * * `false` - exclude from grid (row is blocked by filter)
 */

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceGlobalFilter = DataSourceIndexed.extend('DataSourceGlobalFilter', {

    /**
     *
     * @memberOf DataSourceGlobalFilter#
     * @param {filterFunction} [filter] - If undefined, deletes filter.
     */
    set: function(filter) {
        if (filter) {
            /**
             * @implements filterInterface
             * @memberOf DataSourceGlobalFilter#
             */
            this.filter = filter;
        } else {
            delete this.filter;
        }
    },

    get: function(filter) {
        return this.filter;
    },

    sortGroups: function(sorter){
        this.dataSource.sortGroups(sorter);
    },

    /**
     *
     * @memberOf DataSourceGlobalFilter#
     */
    apply: function() {
        if (this.filter && this.filter.test) {
            this.buildIndex(this.filterTest);
        } else {
            this.clearIndex();
        }
    },

    /**
     * @implements filterPredicate
     * @memberOf DataSourceGlobalFilter#
     */
    filterTest: function(r, rowObject) {
        return this.filter.test(rowObject);
    },


    /**
     *
     * @memberOf DataSourceGlobalFilter#
     * @returns {number}
     */
    getRowCount: function() {
        return this.filter && this.filter.test ? this.index.length : this.dataSource.getRowCount();
    }
});

Object.defineProperty(DataSourceGlobalFilter.prototype, 'type', { value: 'filter' }); // read-only property

module.exports = DataSourceGlobalFilter;

},{"./DataSourceIndexed":29}],28:[function(require,module,exports){
'use strict';

var Base = require('./Base');
var DataSourceSorter = require('./DataSourceSorter');
var DataNodeTree = require('./DataNodeTree');
var DataNodeGroup = require('./DataNodeGroup');
var DataNodeLeaf = require('./DataNodeLeaf');

/**
 * @constructor
 * @param {DataSource} dataSource
 */
var DataSourceGroupView = Base.extend('DataSourceGroupView', {
    initialize: function(dataSource) {

        /**
         * @memberOf DataSourceGroupView#
         * @type {DataSource}
         */
        this.dataSource = dataSource;

        /**
         * @memberOf DataSourceGroupView#
         * @type {DataNodeTree}
         */
        this.tree = new DataNodeTree('Group');

        /**
         * @memberOf DataSourceGroupView#
         * @type {number[]}
         * @default []
         */
        this.index = [];

        /**
         * @memberOf DataSourceGroupView#
         * @type {Array}
         * @default []
         */
        this.groupBys = [];

        /**
         * @memberOf DataSourceGroupView#
         * @type {Array}
         * @default []
         */
        this.view = [];

        /**
         * @memberOf DataSourceGroupView#
         * @type {object}
         * @default {}
         */
        this.treeColumnIndex = 0;

        /**
         * @memberOf DataSourceGroupView#
         * @type {object}
         * @default {}
         */
        this.sorterInstance = {};

        /**
         * @memberOf DataSourceGroupView#
         * @type {boolean}
         * @default true
         */
        this.presortGroups = true;

    },

    isNullObject: false,

    getFields: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getFields();
        }
        var fields = this.getHeaders().map(function(e) {
            return e.toLowerCase().split(' ').join('_');
        });
        return fields;
    },

    getHeaders: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getHeaders();
        }
        var headers = this.dataSource.getHeaders().slice(0);

        if (this.hasGroups()) {
            headers.unshift('Tree');
        }
        return headers;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param columnIndexArray
     */
    setGroupBys: function(columnIndexArray) {
        var groupBys = this.groupBys;
        groupBys.length = 0;
        columnIndexArray.forEach(function(columnIndex) {
            groupBys.push(columnIndex);
        });
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param index
     */
    addGroupBy: function(index) {
        this.groupBys.push(index);
    },

    /**
     * @memberOf DataSourceGroupView#
     * @returns {boolean}
     */
    hasGroups: function() {
        return !!this.groupBys.length;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @params [options]
     */
    apply: function(options) {
        options  = options || {};
        if (!options.rowClick && !options.columnSort){
            this.buildGroupTree();
        }
    },

    /**
     * @memberOf DataSourceGroupView#
     */
    clearGroups: function() {
        this.groupBys.length = 0;
    },

    /**
     * @memberOf DataSourceGroupView#
     */
    buildGroupTree: function() {
        var reversedGroupBys = this.groupBys.slice(0).reverse(),
            leafDepth = this.groupBys.length - 1,
            source = this.dataSource,
            rowCount = source.getRowCount(),
            tree = this.tree = new DataNodeTree('Group');

        // first sort data
        if (this.presortGroups) {
            reversedGroupBys.forEach(function(groupBy) {
                source = new DataSourceSorter(source);
                source.sortOn(groupBy);
            });
        }

        for (var r = 0; r < rowCount; r++) {
            var path = tree;

            this.groupBys.forEach(function(g, c) { // eslint-disable-line no-loop-func
                var key = source.getValue(g, r),
                    factoryDataNode = (c === leafDepth) ? factoryDataNodeLeaf : factoryDataNodeGroup;
                path = path.children.getIfUndefined(key, factoryDataNode);
            });

            path.index.push(r);
        }

        this.sorterInstance = new DataSourceSorter(source);
        tree.toArray();
        tree.getRowData(this);
        this.buildView();
        //this.dump();
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param dataNode
     */
    addView: function(dataNode) {
        this.view.push(dataNode);
    },

    /**
     * @memberOf DataSourceGroupView#
     */
    buildView: function() {
        this.view.length = 0;
        this.tree.computeHeight();
        this.tree.buildView(this);
    },

    /**
     * @memberOf DataSourceGroupView#
     * @returns {*|boolean}
     */
    viewMakesSense: function() {
        return this.hasGroups();
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param {number} columnIndex
     * @returns {*|boolean}
     */
    isDrillDown: function(columnIndex) {
        var result = this.viewMakesSense();
        if (result && columnIndex) {
            result = columnIndex === this.treeColumnIndex;
        }
        return result;
    },

    getDataIndex: function(y) {
        return this.viewMakesSense() ? y : this.dataSource.getDataIndex(y);
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getValue(x, y);
        }
        var row = this.view[y];
        return row ? row.getValue(x) : null;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param x
     * @param y
     * @param value
     * @returns {*}
     */
    setValue: function(x, y, value) {
        if (!this.viewMakesSense()) {
            return this.dataSource.setValue(x, y, value);
        }
    },

    /**
     * @memberOf DataSourceGroupView#
     * @returns {*}
     */
    getColumnCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getColumnCount();
        }
        return this.getHeaders().length;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @returns {*}
     */
    getRowCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRowCount();
        }
        return this.view.length; //header column
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param y
     * @param {boolean} [expand] - One of:
     * * `true` - Expand all rows that are currently collapsed.
     * * `false` - Collapse all rows that are currently expanded.
     * * `undefined` (or omitted) - Expand all currently collapsed rows; collapse all currently expanded rows.
     * @param {number} [depth=Infinity] - One of:
     * * number > 0 - Apply only if row depth is above the given depth.
     * * number <= 0 - Apply only if row depth is below the given depth.
     * @returns {undefined|boolean} One of:
     * * `undefined` - row was not expandable
     * * `true` - row was expandable _and_ state changed
     * * `false` - row was expandable _but_ state did _not_ change
     */
    click: function(y, expand, depth) {
        if (!this.viewMakesSense()) {
            return this.dataSource.click.apply(this.dataSource, arguments);
        }
        var group = this.view[y], expandable, changed;
        if (
            group && (
                depth === undefined ||
                depth > 0 && group.depth < depth ||
                depth <= 0 && group.depth >= -depth
            )
        ) {
            changed = group.toggleExpansionState(this, expand);
            if ((expandable = group.children)) {
                this.buildView();
            }
        }

        return expandable ? changed : undefined;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param headers
     */
    setHeaders: function(headers) {
        this.dataSource.setHeaders(headers);
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param fields
     * @returns {*}
     */
    setFields: function(fields) {
        return this.dataSource.setFields(fields);
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param y
     * @returns {*}
     */
    getRow: function(y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRow(y);
        }

        var groups = this.view[y];

        return groups ? groups : this.tree;
    },

    /**
     * @memberOf DataSourceGroupView#
     * @param arrayOfUniformObjects
     */
    setData: function(arrayOfUniformObjects) {
        this.dataSource.setData(arrayOfUniformObjects);
        this.apply();
    },

    /**
     * @memberOf DataSourceGroupView#
     */
    getGrandTotals: function (){

    },

    sortGroups: function(groupSorter) {
        this.tree.clearGroupSorts();
        this.tree.sortWith(groupSorter);
        this.buildView();
    }
});

function factoryDataNodeLeaf(key) {
    return new DataNodeLeaf(key);
}

function factoryDataNodeGroup(key) {
    return new DataNodeGroup(key);
}

Object.defineProperty(DataSourceGroupView.prototype, 'type', { value: 'groupviewer' }); // read-only property

module.exports = DataSourceGroupView;

},{"./Base":18,"./DataNodeGroup":20,"./DataNodeLeaf":22,"./DataNodeTree":23,"./DataSourceSorter":30}],29:[function(require,module,exports){
'use strict';

var Base = require('./Base');

/**
 * @param dataSource
 * @constructor
 */
var DataSourceIndexed = Base.extend('DataSourceIndexed', {

    isNullObject: false,

    /**
     * @memberOf DataSourceIndexed#
     * @param dataSource
     */
    initialize: function(dataSource) {
        this.dataSource = dataSource;
        this.index = [];
    },

    /**
     * @memberOf DataSourceIndexed#
     * @param y
     * @returns {*}
     */
    transposeY: function(y) {
        return this.index.length ? this.index[y] : y;
    },

    getDataIndex: function(y) {
        return this.dataSource.getDataIndex(this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed#
     * @param y
     * @returns {object}
     */
    getRow: function(y) {
        return this.dataSource.getRow(this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed#
     * @param x
     * @param y
     * @returns {*|Mixed}
     */
    getValue: function(x, y) {
        return this.dataSource.getValue(x, this.transposeY(y));
    },

    /**
     * @memberOf DataSourceIndexed#
     * @param {number} x
     * @param {number} y
     * @param {*} value
     */
    setValue: function(x, y, value) {
        this.dataSource.setValue(x, this.transposeY(y), value);
    },

    /**
     * @memberOf DataSourceIndexed#
     * @returns {Number|*}
     */
    getRowCount: function() {
        return this.index.length || this.dataSource.getRowCount();
    },

    /**
     * @memberOf DataSourceIndexed#
     */
    clearIndex: function() {
        this.index.length = 0;
    },

    /**
     * @memberOf DataSourceIndexed#
     * @param {filterPredicate} predicate
     * @returns {number[]}
     */
    buildIndex: function(predicate) {
        var rowCount = this.dataSource.getRowCount(),
            index = this.index;

        this.clearIndex();

        for (var r = 0; r < rowCount; r++) {
            if (!predicate || predicate.call(this, r, this.dataSource.getRow(r))) {
                index.push(r);
            }
        }

        return index;
    }
});

/** @typedef {function} filterPredicate
 * @summary Applies filter to given row.
 * @this {DataSourceGlobalFilter}
 * @param {nubmer} r - Row index of row data within rows array `this.dataSource.data[]`.
 * @param {object} rowObject - Row data; element of `this.dataSource.data[]`.
 * @returns {boolean} Row qualifies (passes through filter).
 */

/**
 * Used by the sorters (`DataSourceSorter` and `DataSourceTreeviewSorter`).
 * @this {dataRowObject}
 * @param {string} columnName
 * @returns {*}
 */
DataSourceIndexed.valOrFunc = function(columnName, calculator) {
    var result;
    if (this) {
        result = this[columnName];
        calculator = (typeof result)[0] === 'f' && result || calculator;
        if (calculator) {
            result = calculator.call(this, columnName);
        }
    }
    return result;
};

module.exports = DataSourceIndexed;

},{"./Base":18}],30:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var stableSort = require('./util/stableSort');

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceSorter = DataSourceIndexed.extend('DataSourceSorter', {
    /**
     * @memberOf DataSourceSorter#
     * @param {number} columnIndex
     * @param {number} [direction=1]
     */
    sortOn: function(columnIndex, direction) {
        var dataSource = this.dataSource,
             columnSchema = dataSource.schema.find(function(columnSchema, i) {
                return i === columnIndex;
             }),
            columnName = columnSchema && columnSchema["name"],
            calculator = dataSource.schema[columnIndex].calculator;

        switch (direction) {
            case 0:
                this.clearIndex();
                break;

            case undefined:
            case 1:
            case -1:
                stableSort.sort(this.buildIndex(), getValue, direction,  dataSource.schema[columnIndex].type);
                break;
        }

        function getValue(rowIdx) {
            var dataRow = dataSource.getRow(rowIdx);
            return DataSourceIndexed.valOrFunc.call(dataRow, columnName, calculator);
        }
    }
});

module.exports = DataSourceSorter;

},{"./DataSourceIndexed":29,"./util/stableSort":38}],31:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var DataSourceSorter = require('./DataSourceSorter');

/**
 * @constructor
 * @extends DataSourceIndexed
 */
var DataSourceSorterComposite = DataSourceIndexed.extend('DataSourceSorterComposite', {

    /**
     * @memberOf DataSourceSorterComposite#
     */
    initialize: function() {
        /**
         * Caveats:
         *
         * 1. Columns should be uniquely represented (i.e., no repeats with same columnIndex)
         * 2. Columns should be added low- to high-order (i.e., most grouped columns come last)
         *
         * @type {number[]}
         * @memberOf DataSourceSorterComposite#
         */
        this.sorts = [];

        /**
         * @type {DataSource}
         * @memberOf DataSourceSorterComposite#
         */
        this.last = this.dataSource;
    },

    /**
     * @memberOf DataSourceSorterComposite#
     * @param {number} y
     * @returns {Object}
     */
    getRow: function(y) {
        return this.last.getRow(y);
    },

    /**
     * @memberOf DataSourceSorterComposite#
     * @param columnIndex
     * @param direction
     */
    sortOn: function(columnIndex, direction) {
        this.sorts.push({ columnIndex: columnIndex, direction: direction });
    },

    /**
     *
     * @memberOf DataSourceSorterComposite#
     * @param {sorterFunction} [sorter] - If undefined, deletes sorter.
     */
    set: function(sorter) {
        if (sorter) {
            /**
             * @implements sorterInterfacei
             * @memberOf DataSourceSorterComposite#
             */
            this.sorter = sorter;
        } else {
            delete this.sorter;
        }
    },

    get: function() {
        return this.sorter;
    },

    /**
     * @memberOf DataSourceSorterComposite#
     */
    apply: function() {
        var each = this.dataSource;
        // get list of sorts from either API or use existing
        this.sorts = (this.sorter && this.sorter.prop('sorts')) || this.sorts;

        if (this.sorts) {
            this.sorts.forEach(function(sortSpec) {
                each = new DataSourceSorter(each);
                each.sortOn(sortSpec.columnIndex, sortSpec.direction, sortSpec.type);
            });
            this.last = each;
        }
    },

    /**
     * @memberOf DataSourceSorterComposite#
     */
    clearSorts: function() {
        this.sorts.length = 0;
        this.last = this.dataSource;
    },

    getDataIndex: function(y) {
        return this.last.getDataIndex(y);
    },

    /**
     * @memberOf DataSourceSorterComposite#
     * @param {number} x
     * @param {number} y
     * @returns {*}
     */
    getValue: function(x, y) {
        return this.last.getValue(x, y);
    },

    /**
     * @memberOf DataSourceSorterComposite#
     * @param {number} x
     * @param {number} y
     * @param {*} value
     */
    setValue: function(x, y, value) {
        this.last.setValue(x, y, value);
    }
});

DataSourceSorterComposite.prototype.applySorts = function() {
    (console.warn || console.log).call(console, 'applySorts deprecated; use apply');
    this.apply();
};

Object.defineProperty(DataSourceSorterComposite.prototype, 'type', { value: 'sorter' }); // read-only property

module.exports = DataSourceSorterComposite;

},{"./DataSourceIndexed":29,"./DataSourceSorter":30}],32:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

var expandedMap = {
    true: '\u25bc', // BLACK DOWN-POINTING TRIANGLE aka ''
    false: '\u25b6', // BLACK RIGHT-POINTING TRIANGLE aka ''
    undefined: '' // for leaf rows
};

/** @typedef columnAddress
 * @property {string} name - The name of a column listed in the fields array. See the {@link DataSourceTreeview#getFields|getFields()} method.
 * @property {number} index - The index of the column in the fields array. See the {@link DataSourceTreeview#getFields|getFields()} method.
 */


/**
 * @classdesc For proper sorting, include `DataSourceTreeviewSorter` in your data source pipeline, _ahead of_ (closer to the data than) this data source.
 *
 * For proper filtering, include `DataSourceTreeviewFilter` in your data source pipeline, _ahead of_ `DataSourceTreeviewSorter`, if included; or at any rate ahead of this data source.
 * @constructor
 * @param dataSource
 * @extends DataSourceIndexed
 */
var DataSourceTreeview = DataSourceIndexed.extend('DataSourceTreeview', {

    /** @summary Initialize a new instance.
     * @desc Set up {@link DataSourceTreeviewSorter} access to this object. Access is provided to the whole object although only instance variables `joined`, `idColumn`, and `parentIdColumn` are needed by the sorter. The two ID columns are passed to the {@link DataSourceDepthSorter} constructor. (If dataSource is not the sorter, this is not used but harmless.)
     *
     * Note that all ancestor classes' `initialize` methods are called (top-down) before this one. See {@link http://npmjs.org/extend-me} for more info.
     * @param dataSource
     * @memberOf DataSourceTreeview#
     */
    initialize: function(dataSource) {
        while (dataSource) {
            if (/treeview/i.test(dataSource.$$CLASS_NAME)) {
                dataSource.treeview = this;
            }
            dataSource = dataSource.dataSource;
        }
    },

    /** @summary Reference to the primary key column address object.
     * @desc The primary key column uniquely identifies a data row.
     * Used to relate a child row to a parent row.
     *
     * Redefined each time tree-view is turned *ON* by a call to {@link DataSourceTreeview#setRelation|setRelation()}.
     * @param {number|string} indexOrName
     * @returns {columnAddress} Getter returns column address object; setter however always returns its input.
     */
    set idColumn(indexOrName) {
        this._idColumn = this.getColumnInfo(indexOrName || 'ID');
    },
    get idColumn() {
        return this._idColumn;
    },

    /** @summary Reference to the foreign key column address object.
     * @desc The foreign key column defines grouping; it relates this tree node row to its parent tree node row. Top-level tree nodes have no parent. In that case the value in the column is `null`.
     *
     * Redefined each time tree-view is turned *ON* by a call to {@link DataSourceTreeview#setRelation|setRelation()}.
     * @param {number|string} indexOrName
     * @returns {columnAddress} Getter returns column address object; setter however always returns its input.
     */
    set parentIdColumn(indexOrName) {
        this._parentIdColumn = this.getColumnInfo(indexOrName || 'parentID');
    },
    get parentIdColumn() {
        return this._parentIdColumn;
    },

    /** @summary Reference to the drill-down column address object.
     * @desc The drill-down column is the column that is indented and decorated with drill-down controls (triangles). A column with the given index or name must exist.
     *
     * Redefined each time tree-view is turned *ON* by a call to {@link DataSourceTreeview#setRelation|setRelation()}.
     * @param {number|string} indexOrName
     * @returns {columnAddress} Getter returns column address object; setter however always returns its input.
     */
    set treeColumn(indexOrName) {
        this._treeColumn = this.getColumnInfo(indexOrName || 'name');
    },
    get treeColumn() {
        return this._treeColumn;
    },

    /**
     /** @summary Reference to the group name column address object.
     * @desc The group name column is the column whose content describes the group. A column with the given index or name must exist.
     *
     * The treeview sorter treats the group name column differently than other columns,
     * apply a "group sort" to it, which means only the group rows (rows with children)
     * are sorted and the leaves are left alone (stable sorted).
     *
     * Normally refers to the same column as {@link DataSourceTreeview#treeColumn|treeColumn}.
     *
     * Redefined each time tree-view is turned *ON* by a call to {@link DataSourceTreeview#setRelation|setRelation()}.
     * @param {number|string} indexOrName
     * @returns {columnAddress} Getter returns column address object; setter however always returns its input.
     */
    set groupColumn(indexOrName) {
        this._groupColumn = this.getColumnInfo(indexOrName || this._treeColumn.name);
    },
    get groupColumn() {
        return this._groupColumn;
    },

    /**
     * TEMPORARY. This function included here until next version of base is published.
     * The change was to use schema rather than getFields().
     * (The current version in base is not in use because it's only used from here.)
     *
     * Get new object with name and index given the name or the index.
     * @param {string|number} columnOrIndex - Column name or index.
     * @returns {{name: string, index: number}}
     */
    getColumnInfo: function(columnOrIndex) {
        var name, index, result;

        if (typeof columnOrIndex === 'number') {
            index = columnOrIndex;
            name = this.schema[index].name;
        } else {
            name = columnOrIndex;
            index = this.schema.findIndex(function(columnSchema) {
                return columnSchema.name === name;
            });
        }

        if (name && index >= 0) {
            result = {
                name: name,
                index: index
            };
        }

        return result;
    },

    /**
     * @summary Toggle the tree-view.
     * @desc Calculates or recalculates nesting depth of each row and marks it as "expandable" iff it has children.
     *
     * If resetting previously set data, the state of expansion of all rows that still have children is retained. (All expanded rows will still be expanded when tree-view is turned back *ON*.)
     *
     * All of the columns referenced by the `options` properties `idColumn`, `parentIdColumn`, `treeColumn`, and `groupColumn` must exist. These four columns have default references (names) as listed below. The references may be overridden in `options` by supplying alternate column names or indexes.
     *
     * @param {boolean|object} [options] - Falsy value (or omitted) turns tree-view **OFF**. Truthy value turns tree-view **ON** using following options:
     * @param {number|string} [options.idColumn='ID'] - Name or index of the primary key column.
     * @param {number|string} [options.parentIdColumn='parentID'] - Name or index of the foreign key column for grouping.
     * @param {number|string} [options.treeColumn='name'] - Name or index of the drill-down column to decorate with triangles.
     * @param {number|string} [options.groupColumn=this._treeColumn.name] - Name or index of the column that contains the group names. This is normally the same as the drill-down column. You only need to specify a different value when you want the drill down to this column, such as when the drill-down is in a column of its own. See {@link http://openfin.github.io/fin-hypergrid/tree-view-separate-drill-down.html} for an example.
     * @returns {boolean} Joined state.
     *
     * @memberOf DataSourceTreeview#
     */
    setRelation: function(options) {
        var r, parentID, depth, leafRow, row, ID;

        // successful join requires that options object be given and that all columns exist
        if (options) {
            this.idColumn = options.idColumn;
            this.parentIdColumn = options.parentIdColumn;
            this.treeColumn = options.treeColumn;
            this.groupColumn = options.groupColumn;
            this.joined = !!(this.idColumn && this.parentIdColumn && this.treeColumn && this.groupColumn);
        }

        this.buildIndex(); // make all rows visible to getRow()

        r = this.getRowCount();
        if (this.joined) {
            // mutate data row with __DEPTH (all rows) and __EXPANDED (all "parent" rows)
            var idColumnName = this.idColumn.name,
                parentIdColumnName = this.parentIdColumn.name;

            this.maxDepth = 0;

            while (r--) {
                depth = 0;
                leafRow = this.getRow(r);
                row = leafRow;
                ID = row[idColumnName];

                while ((parentID = row[parentIdColumnName]) != null) {
                    row = this.findRow(idColumnName, parentID);
                    ++depth;
                }

                if (this.maxDepth < depth) {
                    this.maxDepth = depth;
                }

                leafRow.__DEPTH = depth;

                if (!this.findRow(parentIdColumnName, ID)) {
                    delete leafRow.__EXPANDED; // no longer expandable
                } else if (leafRow.__EXPANDED === undefined) { // retain previous setting for old rows
                    leafRow.__EXPANDED = false; // default for new row is unexpanded
                }
            }
        } else {
            // flatten the tree so group sorter sees it as a single group
            while (r--) {
                this.getRow(r).__DEPTH = 0;
            }
        }

        // look for DataSourceTreeviewFilter

        return this.joined;
    },

    /**
     * @summary Rebuild the index.
     * @desc Rebuild the index to show only "revealed" rows. (Rows that are not inside a collapsed parent node row.)
     * @memberOf DataSourceTreeview#
     */
    apply: function() {
        if (!this.viewMakesSense()) {
            this.clearIndex();
        } else {
            this.buildIndex(this.joined && rowIsRevealed);
        }
    },

    /**
     * @summary Get the value for the specified cell.
     * @desc Intercepts tree column values and indents and decorates them.
     * @param x
     * @param y
     * @returns {*}
     * @memberOf DataSourceTreeview#
     */
    getValue: function(x, y) {
        var value = DataSourceIndexed.prototype.getValue.call(this, x, y);

        if (this.viewMakesSense() && x === this._treeColumn.index) {
            var row = this.getRow(y);

            if (!(value === '' && row.__EXPANDED === undefined)) {
                value = Array(row.__DEPTH + 1).join('   ') + expandedMap[row.__EXPANDED] + value;
            }
        }

        return value;
    },

    viewMakesSense: function() {
        return this.joined;
    },
    /**
     * @memberOf DataSourceTreeview#
     * @param {number} columnIndex
     * @returns {*|boolean}
     */
    isDrillDown: function(columnIndex) {
        var result = this.viewMakesSense();
        if (result && columnIndex) {
            result = columnIndex === this.treeColumnIndex;
        }
        return result;
    },

    /**
     * @summary Handle a click event in the drill-down column.
     * @desc Operates only on the following rows:
     * * Expandable rows - Rows with a drill-down control.
     * * Revealed rows - Rows not hidden inside of collapsed drill-downs.
     * @param y - Revealed row number. (This is not the row ID.)
     * @param {boolean} [expand] - One of:
     * * `true` - Expand all rows that are currently collapsed.
     * * `false` - Collapse all rows that are currently expanded.
     * * `undefined` (or omitted) - Expand all currently collapsed rows; collapse all currently expanded rows.
     * @param {number} [depth=Infinity] - One of:
     * * number > 0 - Apply only if row depth is above the given depth.
     * * number <= 0 - Apply only if row depth is below the given depth.
     * @returns {undefined|boolean} One of:
     * * `undefined` - Row was not expandable.
     * * `true` - Row had drill-down _and_ state changed.
     * * `false` - Row had drill-down _but_ state did _not_ change.
     * @memberOf DataSourceTreeview#
     */
    click: function(y, expand, depth) {
        if (!this.viewMakesSense()) {
            return this.dataSource.click.apply(this.dataSource, arguments);
        }

        var changed, row = this.getRow(y);
        if (row && row.__EXPANDED !== undefined) {
            if (depth !== undefined && (
                depth > 0 && row.__DEPTH >= depth ||
                depth <= 0 && row.__DEPTH < -depth
            )) {
                changed = false;
            } else {
                if (expand === undefined) {
                    expand = !row.__EXPANDED;
                }
                changed = row.__EXPANDED && !expand || !row.__EXPANDED && expand;
                row.__EXPANDED = expand;
            }
        }
        return changed;
    },

    /**
     * @summary Expand nested drill-downs containing this row.
     * @param ID - The unique row ID.
     * @returns {boolean} If any rows expanded.
     * @memberOf DataSourceTreeview#
     */
    revealRow: function(ID) {
        if (!this.viewMakesSense()) {
            return this.dataSource.revealRow.apply(this.dataSource, arguments);
        }

        var row, parent, changed = false;
        while ((row = this.findRow(this._idColumn.name, ID))) {
            if (parent && row.__EXPANDED === false) {
                row.__EXPANDED = changed = true;
            }
            parent = true;
            ID = row[this._parentIdColumn.name];
        }
        return changed;
    }
});

function rowIsRevealed(r, row) {
    var parentID;

    // are any of the row's ancestors collapsed?
    while ((parentID = row[this._parentIdColumn.name]) != null) {
        // walk up through each parent...
        row = this.findRow(this._idColumn.name, parentID);
        if (row.__EXPANDED === false) { // an ancestor is collapsed
            return false; // exclude row from build
        }
    }

    // no ancestors were collapsed
    return true; // include row in build
}

Object.defineProperty(DataSourceTreeview.prototype, 'type', { value: 'treeviewer' }); // read-only property

module.exports = DataSourceTreeview;

},{"./DataSourceIndexed":29}],33:[function(require,module,exports){
'use strict';

var DataSourceGlobalFilter = require('./DataSourceGlobalFilter');

/**
 * @classdesc Should be positioned in the data source pipeline _ahead of_ (closer to the data than) the optional `DataSourceTreeviewSorter` and the required `DataSourceTreeview` (which sets `this.treeview`).
 * @constructor
 * @param dataSource
 * @extends DataSourceSorterComposite
 * @extends DataSourceGlobalFilter
 */
var DataSourceTreeviewFilter = DataSourceGlobalFilter.extend('DataSourceTreeviewFilter', {

    /**
     * @implements filterPredicate
     * @memberOf DataSourceGlobalFilter#
     */
    filterTest: function(r, rowObject) {
        return this.treeview.viewMakesSense() && rowObject.__EXPANDED !== undefined || this.filter.test(rowObject);
    }

});

module.exports = DataSourceTreeviewFilter;

},{"./DataSourceGlobalFilter":27}],34:[function(require,module,exports){
'use strict';

var DataSourceSorterComposite = require('./DataSourceSorterComposite');
var DataSourceDepthSorter = require('./DataSourceDepthSorter');
var DataSourceSorter = require('./DataSourceSorter');

/**
 * @classdesc Should be positioned in the data source pipeline _ahead of_ (closer to the data than) the required `DataSourceTreeview` (which sets `this.treeview`) but _behind_ the optional `DataSourceTreeviewFilter`.
 * @constructor
 * @param dataSource
 * @extends DataSourceSorterComposite
 */
var DataSourceTreeviewSorter = DataSourceSorterComposite.extend('DataSourceTreeviewSorter', {

    /**
     * @summary Rebuild the index.
     * @memberOf DataSourceSorterComposite#
     */
    apply: function() {
        var joined = this.treeview.viewMakesSense(),
            each = this.dataSource,
            last, // last sort spec ("first" sort) when and only when joined AND it is the group column
            lastIsGroup, columnIndex, direction;
        // get list of sorts from either API or use existing
        this.sorts = (this.sorter && this.sorter.prop('sorts')) || this.sorts;

        if (this.sorts.length) {
            if (joined) {
                last = this.sorts[this.sorts.length - 1];
                lastIsGroup = last.columnIndex === this.treeview.groupColumn.index;
            }

            this.sorts.forEach(function(sortSpec) {
                if (!(lastIsGroup && sortSpec === last)) {
                    each = new DataSourceSorter(each);
                    each.sortOn(sortSpec.columnIndex, sortSpec.direction);
                }
            });
        }

        if (joined) {
            if (lastIsGroup || this.sorts.length === 1) {
                columnIndex = last.columnIndex;
                direction = last.direction;
            } else {
                columnIndex = undefined;
                direction = 1;
            }

            // Finally, apply a "depth sort" to either the group column (if last) or the ID column to group it properly
            for (var depth = this.treeview.maxDepth; depth >= 0; --depth) {
                each = new DataSourceDepthSorter(each, this.treeview);
                each.sortOn(depth, direction, columnIndex);
            }
        }

        this.last = each;
    }

});

module.exports = DataSourceTreeviewSorter;

},{"./DataSourceDepthSorter":26,"./DataSourceSorter":30,"./DataSourceSorterComposite":31}],35:[function(require,module,exports){
'use strict';

/**
 * @constructor
 */
function Mappy() {
    this.keys = [];
    this.data = {};
    this.values = [];
}

Mappy.prototype = {

    constructor: Mappy.prototype.constructor, // preserve constructor

    /**
     * @memberOf Mappy#
     * @param key
     * @param value
     */
    set: function(key, value) {
        var hashCode = hash(key);
        if (!(hashCode in this.data)) {
            this.keys.push(key);
            this.values.push(value);
        }
        this.data[hashCode] = value;
    },

    /**
     * @memberOf Mappy#
     * @param key
     * @returns {*}
     */
    get: function(key) {
        var hashCode = hash(key);
        return this.data[hashCode];
    },

    /**
     *
     * @memberOf Mappy#
     * @param key
     * @param {function} ifUndefinedFunc - Value getter when value is otherwise undefined.
     * @returns {*}
     */
    getIfUndefined: function(key, ifUndefinedFunc) {
        var value = this.get(key);
        if (value === undefined) {
            value = ifUndefinedFunc(key);
            this.set(key, value);
        }
        return value;
    },

    size: function() {
        return this.keys.length;
    },

    /**
     * @memberOf Mappy#
     */
    clear: function() {
        this.keys.length = 0;
        this.values.length = 0;
        this.data = {};
    },

    /**
     * @memberOf Mappy#
     * @param key
     */
    delete: function(key) {
        var hashCode = hash(key);
        if (this.data[hashCode] !== undefined) {
            var index = betterIndexOf(this.keys, key);
            this.keys.splice(index, 1);
            this.values.splice(index, 1);
            delete this.data[hashCode];
        }
    },

    /**
     * @memberOf Mappy#
     * @param {function} iteratee
     */
    forEach: function(iteratee) {
        if (typeof iteratee === 'function') {
            var keys = this.keys,
                self = this;
            keys.forEach(function(key) {
                var value = self.get(key);
                iteratee(value, key, self);
            });
        }
    },

    /**
     * @memberOf Mappy#
     * @param {function} iteratee
     * @returns {Mappy}
     */
    map: function(iteratee) {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;

        if (!(typeof iteratee === 'function')) {
            iteratee = reflection;
        }

        keys.forEach(function(key) {
            var value = self.get(key),
                transformed = iteratee(value, key, self);
            newMap.set(key, transformed);
        });
        return newMap;
    },

    /**
     * @memberOf Mappy#
     * @returns {Mappy}
     */
    copy: function() {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;
        keys.forEach(function(key) {
            var value = self.get(key);
            newMap.set(key, value);
        });
        return newMap;
    }

};

var OID_PREFIX = '.~.#%_'; //this should be something we never will see at the beginning of a string
var counter = 0;

function hash(key) {
    var typeOf = typeof key;

    switch (typeOf) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'symbol':
            return OID_PREFIX + typeOf + '_' + key;

        case 'undefined':
            return 'UNDEFINED';

        case 'object':
            if (key === null) {
                return 'NULL';
            }
            // fall through when not null:
        case 'function':
            return (key.___finhash = key.___finhash || OID_PREFIX + counter++);
    }
}

// Object.is polyfill, courtesy of @WebReflection
var is = Object.is || function(a, b) {
    return a === b ? a !== 0 || 1 / a == 1 / b : a != a && b != b; // eslint-disable-line eqeqeq
};

function reflection(val) {
    return val;
}

// More reliable indexOf, courtesy of @WebReflection
function betterIndexOf(arr, value) {
    if (value != value || value === 0) { // eslint-disable-line eqeqeq
        var i = arr.length;
        while (i-- && !is(arr[i], value)) {
            // eslint-disable-line no-empty
        }
    } else {
        i = [].indexOf.call(arr, value);
    }
    return i;
}

module.exports = Mappy;

},{}],36:[function(require,module,exports){
'use strict';

/**
 * @module aggregations
 */

/**
 * @typedef {function} aggregationFunction
 * @summary A bound function.
 * @desc An aggregation function bound to the `columnIndex` value supplied to one of the above factory functions.
 * @param {object} group
 * @returns {*} Aggregated value.
 */

module.exports = {
    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    count: function(columnIndex) {
        return count;
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    sum: function(columnIndex) {
        return sum.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    min: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.min, Infinity);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    max: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.max, -Infinity);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    avg: function(columnIndex) {
        return avg.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    first: function(columnIndex) {
        return first.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    last: function(columnIndex) {
        return last.bind(this, columnIndex);
    },

    /**
     * @instance
     * @param {number} columnIndex
     * @returns {aggregationFunction} Bound function.
     */
    stddev: function(columnIndex) {
        return stddev.bind(this, columnIndex);
    }
};

function count(group) {
    return group.getRowCount();
}

function sum(columnIndex, group) {
    var r = group.getRowCount(),
        n = 0;

    while (r--) {
        n += group.getValue(columnIndex, r);
    }

    return n;
}

function minmax(columnIndex, method, n, group) {
    var r = group.getRowCount();

    while (r--) {
        n = method(n, group.getValue(columnIndex, r));
    }

    return n;
}

function avg(columnIndex, group) {
    return sum(columnIndex, group) / group.getRowCount();
}

function first(columnIndex, group) {
    return group.getValue(columnIndex, 0);
}

function last(columnIndex, group) {
    return group.getValue(columnIndex, group.getRowCount() - 1);
}

function stddev(columnIndex, group) {
    var rows = group.getRowCount(),
        mean = avg(columnIndex, group);

    for (var dev, r = rows, variance = 0; r--; variance += dev * dev) {
        dev = group.getValue(columnIndex, r) - mean;
    }

    return Math.sqrt(variance / rows);
}

},{}],37:[function(require,module,exports){
'use strict';

// NOTE: For backwards compatibility, `capitalize` is still a function, doubling now as the API.

function capitalize(string) {
    return (/[a-z]/.test(string) ? string : string.toLowerCase())
        .replace(/[\s\-_]*([^\s\-_])([^\s\-_]+)/g, replacer)
        .replace(/[A-Z]/g, ' $&')
        .trim();
}

function replacer(a, b, c) {
    return b.toUpperCase() + c;
}

function set(methodName) {
    capitalize.transform = capitalize[methodName];
}

function passthrough(string) {
    return string;
}

capitalize.transform = passthrough;
capitalize.set = set;
capitalize.passthrough = passthrough;
capitalize.capitalize = capitalize;

module.exports = capitalize;

},{}],38:[function(require,module,exports){
'use strict';

/**
 * Note that {@link module:stableSort#sort|sort()} is the only exposed method.
 * @module stableSort
 */

/**
 * @private
 * @instance
 * @param {function} comparator
 * @param {boolean} descending
 * @param {Array} arr1
 * @param {Array} arr2
 * @returns {function}
 */
function stabilize(comparator, descending, arr1, arr2) { // eslint-disable-line no-shadow
    var x = arr1[0];
    var y = arr2[0];

    if (x === y) {
        x = descending ? arr2[1] : arr1[1];
        y = descending ? arr1[1] : arr2[1];
    } else {
        if (y === null) {
            return -1;
        }
        if (x === null) {
            return 1;
        }
    }

    return comparator(x, y);
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function ascendingNumbers(x, y) {
    return x - y;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function descendingNumbers(x, y) {
    return y - x;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function ascendingAllOthers(x, y) {
    return x < y ? -1 : 1;
}

/**
 * @private
 * @instance
 * @param x
 * @param y
 * @returns {number}
 */
function descendingAllOthers(x, y) {
    return y < x ? -1 : 1;
}

/**
 * @private
 * @instance
 * @param typeOfData
 * @returns {function(this:ascending)}
 */
function ascending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? ascendingNumbers : ascendingAllOthers, false);
}

/**
 * @private
 * @instance
 * @param typeOfData
 * @returns {function(this:descending)}
 */
function descending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? descendingNumbers : descendingAllOthers, true);
}

/**
 * @instance
 * @param {number} index
 * @param {function} getValue
 * @param {number} [direction=1]
 */
function sort(index, getValue, direction, type) {

    var compare, i;

    // apply defaults
    if (direction === undefined) {
        direction = 1;
    }

    if (index.length) { // something to do
        switch (direction) {
            case 0:
                return; // bail: nothing to sort

            case undefined: // eslint-disable-line no-fallthrough
                direction = 1;
            case 1:  // eslint-disable-line no-fallthrough
                compare = ascending(type || typeof getValue(0));
                break;

            case -1:
                compare = descending(type || typeof getValue(0));
                break;
        }

        // set up the sort.....
        var tmp = new Array(index.length);

        // add the index for "stability"
        for (i = 0; i < index.length; i++) {
            tmp[i] = [getValue(i), i];
        }

        // do the actual sort
        tmp.sort(compare);

        // copy the sorted values into our index vector
        for (i = 0; i < index.length; i++) {
            index[i] = tmp[i][1];
        }
    }

}

exports.sort = sort;

},{}],39:[function(require,module,exports){
// list-dragon node module
// https://github.com/joneit/list-dragon

/* eslint-env node, browser */

'use strict';

var cssInjector = require('css-injector');
var format = require('templex');

var REVERT_TO_STYLESHEET_VALUE = null;  // null removes the style

var transform, timer, scrollVelocity, cssListDragon;

/* inject:css */
cssListDragon = 'div.dragon-list{position:relative;background-color:#fff}div.dragon-list>div,div.dragon-list>ul{position:absolute;left:0;right:0}div.dragon-list>div{text-align:center;background-color:#00796b;color:#fff;box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);overflow:hidden;white-space:nowrap}div.dragon-list>ul{overflow-y:auto;bottom:0;margin:0;padding:0;box-shadow:0 1px 3px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.24)}div.dragon-list>ul>li,li.dragon-pop{white-space:nowrap;list-style-type:none;border:0 solid #f4f4f4;border-bottom:1px solid #e0e0e0;cursor:move;transition:border-top-width .2s}div.dragon-list>ul>li:last-child{height:0;border-bottom:none}li.dragon-pop{position:fixed;background-color:#fff;border:1px solid #e0e0e0;left:0;top:0;overflow-x:hidden;box-shadow:rgba(0,0,0,.188235) 0 10px 20px,rgba(0,0,0,.227451) 0 6px 6px}';
/* endinject */

/**
 * @constructor ListDragon
 *
 * @desc This object services a set of item lists that allow dragging and dropping items within and between lists in a set.
 *
 * Two strategies are supported:
 *
 * 1. Supply your own HTML markup and let the API build the item models for you.
 *    To use this strategy, script your HTML and provide one of these:
 *    * an array of all the list item (`<li>`) tags
 *    * a CSS selector that points to all the list item tags
 * 2. Supply your own item models and let the API build the HTML markup for you.
 *    To use this strategy, provide an array of model lists.
 *
 * The new ListDragon object's `modelLists` property references the array of model lists the API constructed for you in strategy #1 or the array of model lists you supplied for strategy #2.
 *
 * After the user performs a successful drag-and-drop operation, the position of the model references within the `modelLists` array is rearranged. (The models themselves are the original objects as supplied in the model lists; they are not rebuilt or altered in any way. Just the references to them are moved around.)
 *
 * @param {string|Element[]|modelListType[]} selectorOrModelLists - You must supply one of the items in **bold** below:
 *
 * 1. _For strategy #1 above (API creates models from supplied elements):_ All the list item (`<li>`) DOM elements of all the lists you want the new object to manage, as either:
 *    1. **A CSS selector;** _or_
 *    2. **An array of DOM elements**
 * 2. _For strategy #2 above (API creates elements from supplied models):_ **An array of model lists,** each of which is in one of the following forms:
 *    1. An array of item models (with various option properties hanging off of it); _and/or_
 *    2. A {@link modelListType} object with those same various option properties including the required `models` property containing that same array of item models.
 *
 * In either case (2.1 or 2.2), each element of such arrays of item models may take the form of:
 * * A string primitive; _or_
 * * A {@link itemModelType} object with a various option properties including the required `label` property containing a string primitive.
 *
 * Regarding these string primitives, each is either:
 * * A string to be displayed in the list item; _or_
 * * A format string with other property values merged in, the result of which is to be displayed in the list item.
 *
 * @param {object} [options={}] - You may supply "global" template variables here, representing the "outer scope," after first searching each model and then each model list.
 * @param {undefined|null|Element|string} [cssStylesheetReferenceElement] - Determines where to insert the stylesheet. (This is the only formal option.) Passed to css-injector, the overloads are (from css-injector docs):
 * * `undefined` type (or omitted): injects stylesheet at top of `<head>...</head>` element
 * * `null` value: injects stylesheet at bottom of `<head>...</head>` element
 * * `Element` type: injects stylesheet immediately before given element, wherever it is found.
 * * `string` type: injects stylesheet immediately before given first element found that matches the given css selector.
 */
function ListDragon(selectorOrModelLists, options) {

    if (!(this instanceof ListDragon)) {
        throw error('Not called with "new" keyword.');
    }

    var self = this, modelLists, items;

    options = options || {};

    if (typeof selectorOrModelLists === 'string') {
        items = toArray(document.querySelectorAll(selectorOrModelLists));
        modelLists = createModelListsFromListElements(items);
    } else if (selectorOrModelLists[0] instanceof Element) {
        items = toArray(selectorOrModelLists);
        modelLists = createModelListsFromListElements(items);
    } else {
        // param is array of model lists
        // build new <ul> element(s) for each list and put in `.modelLists`;
        // fill `.items` array with <li> elements from these new <ul> elements
        items = [];
        modelLists = createListElementsFromModelLists(selectorOrModelLists, options);
        modelLists.forEach(function (list) {
            items = items.concat(toArray(list.element.querySelectorAll('li')));
        });
    }

    // grab wheel events and don't let 'em bubble
    modelLists.forEach(function (modelList) {
        modelList.element.addEventListener('wheel', captureEvent);
    });

    items.forEach(function (itemElement, index) {
        var item = (itemElement !== itemElement.parentElement.lastElementChild)
            ? self.addEvt(itemElement, 'mousedown', itemElement, true)
            : { element: itemElement };

        /* `item.model` not currently needed so commented out here.
         * (Originally used for rebuilding modelLists for final
         * reporting, modelLists are now spliced on every successful
         * drag-and-drop operation so they're always up to date.)

         var origin = this.itemCoordinates(itemElement);
         item.model = this.modelLists[origin.list].models[origin.item];

         */

        items[index] = item;
    });

    transform = 'transform' in items[0].element.style
        ? 'transform' // Chrome 45 and Firefox 40
        : '-webkit-transform'; // Safari 8

    // set up the new object
    this.modelLists = modelLists;
    this.items = items;
    this.bindings = {};
    this.callback = {};

    cssInjector(cssListDragon, 'list-dragon-base', options.cssStylesheetReferenceElement);

}

ListDragon.prototype = {

    addEvt: function (target, type, listener, doNotBind) {
        var binding = {
            handler: handlers[type].bind(target, this),
            element: listener || window
        };

        if (!doNotBind) {
            this.bindings[type] = binding;
        }

        binding.element.addEventListener(type, binding.handler);

        return binding;
    },

    removeEvt: function (type) {
        var binding = this.bindings[type];
        delete this.bindings[type];
        binding.element.removeEventListener(type, binding.handler);
    },

    removeAllEventListeners: function () {
        // remove drag & drop events (mousemove, mouseup, and transitionend)
        for (var type in this.bindings) {
            var binding = this.bindings[type];
            binding.element.removeEventListener(type, binding.handler);
        }
        // remove the mousedown events from all list items
        this.items.forEach(function (item) {
            if (item.handler) {
                item.element.removeEventListener('mousedown', item.handler);
            }
        });
        // wheel events on the list elements
        this.modelLists.forEach(function (modelList) {
            modelList.element.removeEventListener('wheel', captureEvent);
        });
    },

    pointInListRects: function (point) {
        return this.modelLists.find(function (modelList) {
            var rect = modelList.element.getBoundingClientRect();

            rect = {
                left:   window.scrollX + rect.left,
                top:    window.scrollY + rect.top,
                right:  window.scrollX + rect.right,
                bottom: window.scrollY + rect.bottom,
                width:  rect.width,
                height: rect.height
            };

            modelList.rect = rect;

            if (pointInRect(point, rect)) {
                modelList.rect = rect;
                return true; // found
            } else {
                return false;
            }
        });
    },

    pointInItemRects: function (point, except1, except2) {
        return this.items.find(function (item) {
            var element = item.element;
            return (
                element !== except1 &&
                element !== except2 &&
                pointInRect(point, item.rect)
            );
        });
    },

    // get positions of all list items in page coords (normalized for window and list scrolling)
    getAllItemBoundingRects: function () {
        var modelLists = this.modelLists, height;
        this.items.forEach(function (item) {
            var itemElement = item.element,
                listElement = itemElement.parentElement,
                list = modelLists.find(function (list) { return list.element === listElement; });

            if (
                // omitted: default to true
                list.isDropTarget === undefined ||

                // function: use return value
                typeof list.isDropTarget === 'function' && list.isDropTarget() ||

                // otherwise: use truthiness of given value
                list.isDropTarget
            ) {
                var rect = itemElement.getBoundingClientRect(),
                    bottom = rect.bottom;

                if (itemElement === listElement.lastElementChild) {
                    bottom = listElement.getBoundingClientRect().bottom;
                    if (bottom < rect.top) {
                        bottom = rect.top + (height || 50);
                    }
                } else {
                    height = rect.height;
                }

                rect = {
                    left:   window.scrollX + rect.left,
                    right:  window.scrollX + rect.right,
                    top:    window.scrollY + rect.top    + listElement.scrollTop,
                    bottom: window.scrollY + bottom + listElement.scrollTop
                };

                item.rect = rect;
            }
        });
    },

    reinsert: function (target) {
        var style = target.style;
        style.width = style[transform] = style.transition = REVERT_TO_STYLESHEET_VALUE;

        target.classList.remove('dragon-pop');

        this.drop.style.transitionDuration = '0s';
        this.drop.style.borderTopWidth = REVERT_TO_STYLESHEET_VALUE;
        this.drop.parentElement.insertBefore(target, this.drop);

        delete this.drop;
    },

    // return an object { item: <item index within list>, list: <list index within list of lists> }
    itemCoordinates: function (item) {
        var listElement = item.parentElement,
            coords = { item: 0 };

        while ((item = item.previousElementSibling)) {
            ++coords.item;
        }

        this.modelLists.find(function (list, index) {
            coords.list = index;
            return list.element === listElement; // stop when we find the one we belong to
        });

        return coords;
    }

};

var handlers = {
    mousedown: function (dragon, evt) {

        evt.stopPropagation();
        evt.preventDefault();  //prevents user selection of rendered nodes during drag

        if (dragon.drop) {
            return;
        }

        var rect = this.getBoundingClientRect();

        dragon.rect = rect = {
            left:   Math.round(rect.left - 1),
            top:    Math.round(rect.top - 1),
            right:  Math.round(rect.right),
            bottom: Math.round(rect.bottom),
            width:  Math.round(rect.width),
            height: Math.round(rect.height)
        };

        dragon.pin = {
            x: window.scrollX + evt.clientX,
            y: window.scrollY + evt.clientY
        };

        dragon.origin = dragon.itemCoordinates(this);

        if (dragon.callback.grabbed) {
            dragon.callback.grabbed.call(this, dragon);
        }

        dragon.getAllItemBoundingRects();

        dragon.drop = this.nextElementSibling;
        dragon.drop.style.transitionDuration = '0s';
        dragon.drop.style.borderTopWidth = rect.height + 'px';

        this.style.width = rect.width + 'px';
        this.style.transitionDuration = '0s';
        this.style[transform] = translate(
            rect.left - window.scrollX,
            rect.top  - window.scrollY
        );
        this.classList.add('dragon-pop');
        this.style.zIndex = window.getComputedStyle(dragon.modelLists[0].container.parentElement).zIndex;

        if (!dragon.container) {
            // walk back to closest shadow root OR body tag OR root tag
            var container = this;
            while (container.parentNode) {
                container = container.parentNode;
                if (
                    typeof ShadowRoot !== 'undefined' && container instanceof ShadowRoot ||
                    container.tagName === 'BODY'
                ){
                    break;
                }
            }
            dragon.container = container;
        }

        dragon.container.appendChild(this);

        rect.left   += window.scrollX;
        rect.top    += window.scrollY;
        rect.right  += window.scrollX;
        rect.bottom += window.scrollY;

        dragon.addEvt(this, 'mousemove');
        dragon.addEvt(this, 'mouseup');
    },

    mousemove: function (dragon, evt) {
        dragon.drop.style.transition = REVERT_TO_STYLESHEET_VALUE;

        var hoverList = dragon.pointInListRects({ x: evt.clientX, y: evt.clientY }) || dragon.mostRecentHoverList;

        if (hoverList) {
            var dx = evt.clientX - dragon.pin.x,
                dy = evt.clientY - dragon.pin.y;

            dragon.mostRecentHoverList = hoverList;

            var maxScrollY = hoverList.element.scrollHeight - hoverList.rect.height,
                y = evt.clientY + window.scrollY,
                magnitude;

            if (maxScrollY > 0) {
                // list is scrollable (is taller than rect)
                if (hoverList.element.scrollTop > 0 && (magnitude = y - (hoverList.rect.top + 5)) < 0) {
                    // mouse near or above top and list is not scrolled to top yet
                    resetAutoScrollTimer(magnitude, 0, hoverList.element);
                } else if (hoverList.element.scrollTop < maxScrollY && (magnitude = y - (hoverList.rect.bottom - 1 - 5)) > 0) {
                    // mouse near or below bottom and list not scrolled to bottom yet
                    resetAutoScrollTimer(magnitude, maxScrollY, hoverList.element);
                } else {
                    // mouse inside
                    resetAutoScrollTimer();
                }
            }

            var other = dragon.pointInItemRects({
                x: evt.clientX,
                y: dragon.rect.bottom + window.scrollY + dy + hoverList.element.scrollTop
            }, this, dragon.drop);

            this.style[transform] = translate(
                dragon.rect.left - window.scrollX + dx,
                dragon.rect.top - window.scrollY + dy
            );

            if (other) {
                var element = other.element;
                element.style.transition = REVERT_TO_STYLESHEET_VALUE;
                element.style.borderTopWidth = dragon.drop.style.borderTopWidth;
                dragon.drop.style.borderTopWidth = null;
                dragon.drop = element;
            }
        }
    },

    mouseup: function (dragon, evt) {
        resetAutoScrollTimer();
        dragon.removeEvt('mousemove');
        dragon.removeEvt('mouseup');

        evt.stopPropagation();

        var newRect = this.getBoundingClientRect();

        if (
            window.scrollX + newRect.left === dragon.rect.left &&
            window.scrollY + newRect.top === dragon.rect.top
        ) {
            dragon.reinsert(this);
        } else {
            var dropRect = dragon.drop.getBoundingClientRect();

            dragon.addEvt(this, 'transitionend', this);
            this.style.transitionDuration = REVERT_TO_STYLESHEET_VALUE; //reverts to 200ms
            this.style.transitionProperty = transform;
            this.style[transform] = translate(
                dropRect.left - window.scrollX,
                dropRect.top - window.scrollY
            );
        }
    },

    transitionend: function (dragon, evt) {
        if (evt.propertyName === transform) {
            dragon.removeEvt('transitionend');
            dragon.reinsert(this);

            this.style.transitionProperty = REVERT_TO_STYLESHEET_VALUE; //reverts to border-top-width

            var originList = dragon.modelLists[dragon.origin.list];
            var model = originList.splice(dragon.origin.item, 1)[0];
            var destination = dragon.itemCoordinates(this);
            var destinationList = dragon.modelLists[destination.list];
            var interListDrop = originList !== destinationList;
            var listChanged = interListDrop || dragon.origin.item !== destination.item;
            destinationList.splice(destination.item, 0, model);

            if (listChanged) {
                originList.element.dispatchEvent(new CustomEvent('listchanged'));
                if (interListDrop) {
                    destinationList.element.dispatchEvent(new CustomEvent('listchanged'));
                }
            }

            if (dragon.callback.dropped) {
                dragon.callback.dropped.call(this, dragon);
            }
        }
    }
};

function resetAutoScrollTimer(magnitude, limit, element) {
    if (!magnitude) {
        clearInterval(timer);
        scrollVelocity = 0;
    } else {
        var changeDirection =
            scrollVelocity  <  0 && magnitude  >= 0 ||
            scrollVelocity === 0 && magnitude !== 0 ||
            scrollVelocity  >  0 && magnitude  <= 0;
        scrollVelocity = magnitude > 0 ? Math.min(50, magnitude) : Math.max(-50, magnitude);
        if (changeDirection) {
            clearInterval(timer);
            timer = setInterval(function (limit) {
                var scrollTop = element.scrollTop + scrollVelocity;
                if (scrollVelocity < 0 && scrollTop < limit || scrollVelocity > 0 && scrollTop > limit) {
                    element.scrollTop = limit;
                    clearInterval(timer);
                } else {
                    element.scrollTop = scrollTop;
                }
            }, 125);
        }
    }
}

function toArray(arrayLikeObject) {
    return Array.prototype.slice.call(arrayLikeObject);
}

function pointInRect(point, rect) {
    return rect.top <= point.y && point.y <= rect.bottom
        && rect.left <= point.x && point.x <= rect.right;
}

function translate(left, top) {
    return 'translate('
        + Math.floor(left + window.scrollX) + 'px,'
        + Math.floor(top + window.scrollY) + 'px)';
}

function htmlEncode(string) {
    var textNode = document.createTextNode(string);

    return document
        .createElement('a')
        .appendChild(textNode)
        .parentNode
        .innerHTML;
}

/**
 * Creates `<ul>...</ul>` elements and inserts them into an `element` property on each model.
 * @param {object} modelLists
 * @returns `modelLists`
 */
function createListElementsFromModelLists(modelLists, options) {
    var templateLabel = options.label || '{label}';

    modelLists.forEach(function (modelList, listIndex) {
        var listLabel = modelList.label || templateLabel,
            listHtmlEncode = modelList.htmlEncode !== undefined && modelList.htmlEncode || options.htmlEncode,
            container = document.createElement('div'),
            listElement = document.createElement('ul');

        if (modelList.models) {
            Object.keys(modelList).forEach(function (key) {
                if (key !== 'models') {
                    modelList.models[key] = modelList[key];
                }
            });
            modelLists[listIndex] = modelList = modelList.models;
        } else if (modelList instanceof Array) {
            modelList.models = modelList; // point to self
        } else {
            throw error('List [{1}] not an array of models (with or without additional properties) OR ' +
                'an object (with a `models` property containing an array of models).', listIndex);
        }

        modelList.forEach(function (model) {
            var modelLabel = model.label || listLabel,
                modelHtmlEncode = model.htmlEncode !== undefined && model.htmlEncode || listHtmlEncode,
                modelObject = typeof model === 'object' ? model : { label: model},
                label = format.call([modelObject, modelList, options], modelLabel),
                itemElement = document.createElement('li');

            itemElement.innerHTML = modelHtmlEncode ? htmlEncode(label) : label;

            listElement.appendChild(itemElement);
        });

        // append the final "fencepost" item -- drop target at bottom of list after all items
        var itemElement = document.createElement('li');
        itemElement.innerHTML = '&nbsp;';
        listElement.appendChild(itemElement);

        // append header to container
        if (modelList.title) {
            var header = document.createElement('div');
            header.innerHTML = listHtmlEncode ? htmlEncode(modelList.title) : modelList.title;
            container.appendChild(header);
        }

        container.appendChild(listElement);
        container.className = modelList.cssClassNames || options.cssClassNames || 'dragon-list';
        modelList.element = listElement;
        modelList.container = container;
    });

    return modelLists;
}

/**
 * Create a `.modelLists` array with these <li> elements' parent <ul> elements
 * @param {Element[]} listItemElements
 * @returns {Array}
 */
function createModelListsFromListElements(listItemElements) {
    var modelLists = [];

    listItemElements.forEach(function (itemElement) {
        var listElement = itemElement.parentElement,
            container = listElement.parentElement,
            models = [];
        if (!modelLists.find(function (list) { return list.element === listElement; })) {
            toArray(listElement.querySelectorAll('li')).forEach(function (itemElement) {
                if (itemElement !== listElement.lastElementChild) {
                    models.push(itemElement.innerHTML);
                }
            });
            models.element = listElement;
            models.container = container;
            modelLists.push(models);
        }
    });

    return modelLists;
}

function captureEvent(evt) {
    evt.stopPropagation();
}

function error() {
    return 'list-dragon: ' + format.apply(this, Array.prototype.slice.call(arguments));
}

// this interface consists solely of the prototypal object constructor
module.exports = ListDragon;

},{"css-injector":6,"templex":48}],40:[function(require,module,exports){
;(function () { // closure for web browsers

if (typeof module === 'object' && module.exports) {
  module.exports = LRUCache
} else {
  // just set the global for non-node platforms.
  this.LRUCache = LRUCache
}

function hOP (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key)
}

function naiveLength () { return 1 }

function LRUCache (options) {
  if (!(this instanceof LRUCache))
    return new LRUCache(options)

  if (typeof options === 'number')
    options = { max: options }

  if (!options)
    options = {}

  this._max = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!this._max || !(typeof this._max === "number") || this._max <= 0 )
    this._max = Infinity

  this._lengthCalculator = options.length || naiveLength
  if (typeof this._lengthCalculator !== "function")
    this._lengthCalculator = naiveLength

  this._allowStale = options.stale || false
  this._maxAge = options.maxAge || null
  this._dispose = options.dispose
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, "max",
  { set : function (mL) {
      if (!mL || !(typeof mL === "number") || mL <= 0 ) mL = Infinity
      this._max = mL
      if (this._length > this._max) trim(this)
    }
  , get : function () { return this._max }
  , enumerable : true
  })

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, "lengthCalculator",
  { set : function (lC) {
      if (typeof lC !== "function") {
        this._lengthCalculator = naiveLength
        this._length = this._itemCount
        for (var key in this._cache) {
          this._cache[key].length = 1
        }
      } else {
        this._lengthCalculator = lC
        this._length = 0
        for (var key in this._cache) {
          this._cache[key].length = this._lengthCalculator(this._cache[key].value)
          this._length += this._cache[key].length
        }
      }

      if (this._length > this._max) trim(this)
    }
  , get : function () { return this._lengthCalculator }
  , enumerable : true
  })

Object.defineProperty(LRUCache.prototype, "length",
  { get : function () { return this._length }
  , enumerable : true
  })


Object.defineProperty(LRUCache.prototype, "itemCount",
  { get : function () { return this._itemCount }
  , enumerable : true
  })

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  var i = 0
  var itemCount = this._itemCount

  for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {
    i++
    var hit = this._lruList[k]
    if (isStale(this, hit)) {
      del(this, hit)
      if (!this._allowStale) hit = undefined
    }
    if (hit) {
      fn.call(thisp, hit.value, hit.key, this)
    }
  }
}

LRUCache.prototype.keys = function () {
  var keys = new Array(this._itemCount)
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    keys[i++] = hit.key
  }
  return keys
}

LRUCache.prototype.values = function () {
  var values = new Array(this._itemCount)
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    values[i++] = hit.value
  }
  return values
}

LRUCache.prototype.reset = function () {
  if (this._dispose && this._cache) {
    for (var k in this._cache) {
      this._dispose(k, this._cache[k].value)
    }
  }

  this._cache = Object.create(null) // hash of items by key
  this._lruList = Object.create(null) // list of items in order of use recency
  this._mru = 0 // most recently used
  this._lru = 0 // least recently used
  this._length = 0 // number of items in the list
  this._itemCount = 0
}

LRUCache.prototype.dump = function () {
  var arr = []
  var i = 0

  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    if (!isStale(this, hit)) {
      //Do not store staled hits
      ++i
      arr.push({
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      });
    }
  }
  //arr has the most read first
  return arr
}

LRUCache.prototype.dumpLru = function () {
  return this._lruList
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this._maxAge
  var now = maxAge ? Date.now() : 0
  var len = this._lengthCalculator(value)

  if (hOP(this._cache, key)) {
    if (len > this._max) {
      del(this, this._cache[key])
      return false
    }
    // dispose of the old one before overwriting
    if (this._dispose)
      this._dispose(key, this._cache[key].value)

    this._cache[key].now = now
    this._cache[key].maxAge = maxAge
    this._cache[key].value = value
    this._length += (len - this._cache[key].length)
    this._cache[key].length = len
    this.get(key)

    if (this._length > this._max)
      trim(this)

    return true
  }

  var hit = new Entry(key, value, this._mru++, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this._max) {
    if (this._dispose) this._dispose(key, value)
    return false
  }

  this._length += hit.length
  this._lruList[hit.lu] = this._cache[key] = hit
  this._itemCount ++

  if (this._length > this._max)
    trim(this)

  return true
}

LRUCache.prototype.has = function (key) {
  if (!hOP(this._cache, key)) return false
  var hit = this._cache[key]
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var hit = this._lruList[this._lru]
  del(this, hit)
  return hit || null
}

LRUCache.prototype.del = function (key) {
  del(this, this._cache[key])
}

LRUCache.prototype.load = function (arr) {
  //reset the cache
  this.reset();

  var now = Date.now()
  //A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l-- ) {
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      //the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      //dont add already expired items
      if (maxAge > 0) this.set(hit.k, hit.v, maxAge)
    }
  }
}

function get (self, key, doUse) {
  var hit = self._cache[key]
  if (hit) {
    if (isStale(self, hit)) {
      del(self, hit)
      if (!self._allowStale) hit = undefined
    } else {
      if (doUse) use(self, hit)
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale(self, hit) {
  if (!hit || (!hit.maxAge && !self._maxAge)) return false
  var stale = false;
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self._maxAge && (diff > self._maxAge)
  }
  return stale;
}

function use (self, hit) {
  shiftLU(self, hit)
  hit.lu = self._mru ++
  self._lruList[hit.lu] = hit
}

function trim (self) {
  while (self._lru < self._mru && self._length > self._max)
    del(self, self._lruList[self._lru])
}

function shiftLU (self, hit) {
  delete self._lruList[ hit.lu ]
  while (self._lru < self._mru && !self._lruList[self._lru]) self._lru ++
}

function del (self, hit) {
  if (hit) {
    if (self._dispose) self._dispose(hit.key, hit.value)
    self._length -= hit.length
    self._itemCount --
    delete self._cache[ hit.key ]
    shiftLU(self, hit)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, lu, length, now, maxAge) {
  this.key = key
  this.value = value
  this.lu = lu
  this.length = length
  this.now = now
  if (maxAge) this.maxAge = maxAge
}

})()

},{}],41:[function(require,module,exports){
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache (global, factory) {
  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory); // AMD
  } else {
    global.Mustache = {};
    factory(Mustache); // script, wsh, asp
  }
}(this, function mustacheFactory (mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill (object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction (object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr (obj) {
    return isArray(obj) ? 'array' : typeof obj;
  }

  function escapeRegExp (string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty (obj, propName) {
    return obj != null && typeof obj === 'object' && (propName in obj);
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp (re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace (string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;'
  };

  function escapeHtml (string) {
    return String(string).replace(/[&<>"'\/]/g, function fromEntityMap (s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate (template, tags) {
    if (!template)
      return [];

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace () {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags (tagsToCompile) {
      if (typeof tagsToCompile === 'string')
        tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push([ 'text', chr, start, start + 1 ]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n')
            stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe))
        break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe))
        throw new Error('Unclosed tag at ' + scanner.pos);

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens (tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens (tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
      case '#':
      case '^':
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case '/':
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner (string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos () {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan (re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0)
      return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil (re) {
    var index = this.tail.search(re), match;

    switch (index) {
    case -1:
      match = this.tail;
      this.tail = '';
      break;
    case 0:
      match = '';
      break;
    default:
      match = this.tail.substring(0, index);
      this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context (view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup (name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, names, index, lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           **/
          while (value != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit)
          break;

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value))
      value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer () {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache () {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse (template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null)
      tokens = cache[template] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function render (template, view, partials) {
    var tokens = this.parse(template);
    var context = (view instanceof Context) ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context);
      else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined)
        buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender (template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null)
      return this.renderTokens(this.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };

  Writer.prototype.escapedValue = function escapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue (token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '2.2.0';
  mustache.tags = [ '{{', '}}' ];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function render (template, view, partials) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' +
                          'but "' + typeStr(template) + '" was given as the first ' +
                          'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html (template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

}));

},{}],42:[function(require,module,exports){
/* object-iterators.js - Mini Underscore library
 * by Jonathan Eiten
 *
 * The methods below operate on objects (but not arrays) similarly
 * to Underscore (http://underscorejs.org/#collections).
 *
 * For more information:
 * https://github.com/joneit/object-iterators
 */

'use strict';

/**
 * @constructor
 * @summary Wrap an object for one method call.
 * @Desc Note that the `new` keyword is not necessary.
 * @param {object|null|undefined} object - `null` or `undefined` is treated as an empty plain object.
 * @return {Wrapper} The wrapped object.
 */
function Wrapper(object) {
    if (object instanceof Wrapper) {
        return object;
    }
    if (!(this instanceof Wrapper)) {
        return new Wrapper(object);
    }
    this.originalValue = object;
    this.o = object || {};
}

/**
 * @name Wrapper.chain
 * @summary Wrap an object for a chain of method calls.
 * @Desc Calls the constructor `Wrapper()` and modifies the wrapper for chaining.
 * @param {object} object
 * @return {Wrapper} The wrapped object.
 */
Wrapper.chain = function (object) {
    var wrapped = Wrapper(object); // eslint-disable-line new-cap
    wrapped.chaining = true;
    return wrapped;
};

Wrapper.prototype = {
    /**
     * Unwrap an object wrapped with {@link Wrapper.chain|Wrapper.chain()}.
     * @return {object|null|undefined} The value originally wrapped by the constructor.
     * @memberOf Wrapper.prototype
     */
    value: function () {
        return this.originalValue;
    },

    /**
     * @desc Mimics Underscore's [each](http://underscorejs.org/#each) method: Iterate over the members of the wrapped object, calling `iteratee()` with each.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is undefined; an `.each` loop cannot be broken out of (use {@link Wrapper#find|.find} instead).
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {Wrapper} The wrapped object for chaining.
     * @memberOf Wrapper.prototype
     */
    each: function (iteratee, context) {
        var o = this.o;
        Object.keys(o).forEach(function (key) {
            iteratee.call(this, o[key], key, o);
        }, context || o);
        return this;
    },

    /**
     * @desc Mimics Underscore's [find](http://underscorejs.org/#find) method: Look through each member of the wrapped object, returning the first one that passes a truth test (`predicate`), or `undefined` if no value passes the test. The function returns the value of the first acceptable member, and doesn't necessarily traverse the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The found property's value, or undefined if not found.
     * @memberOf Wrapper.prototype
     */
    find: function (predicate, context) {
        var o = this.o;
        var result;
        if (o) {
            result = Object.keys(o).find(function (key) {
                return predicate.call(this, o[key], key, o);
            }, context || o);
            if (result !== undefined) {
                result = o[result];
            }
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [filter](http://underscorejs.org/#filter) method: Look through each member of the wrapped object, returning the values of all members that pass a truth test (`predicate`), or empty array if no value passes the test. The function always traverses the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} An array containing the filtered values.
     * @memberOf Wrapper.prototype
     */
    filter: function (predicate, context) {
        var o = this.o;
        var result = [];
        if (o) {
            Object.keys(o).forEach(function (key) {
                if (predicate.call(this, o[key], key, o)) {
                    result.push(o[key]);
                }
            }, context || o);
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [map](http://underscorejs.org/#map) method: Produces a new array of values by mapping each value in list through a transformation function (`iteratee`). The function always traverses the entire object.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is concatenated to the end of the new array.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} An array containing the filtered values.
     * @memberOf Wrapper.prototype
     */
    map: function (iteratee, context) {
        var o = this.o;
        var result = [];
        if (o) {
            Object.keys(o).forEach(function (key) {
                result.push(iteratee.call(this, o[key], key, o));
            }, context || o);
        }
        return result;
    },

    /**
     * @desc Mimics Underscore's [reduce](http://underscorejs.org/#reduce) method: Boil down the values of all the members of the wrapped object into a single value. `memo` is the initial state of the reduction, and each successive step of it should be returned by `iteratee()`.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with four arguments: `(memo, value, key, object)`. The return value of this function becomes the new value of `memo` for the next iteration.
     * @param {*} [memo] - If no memo is passed to the initial invocation of reduce, the iteratee is not invoked on the first element of the list. The first element is instead passed as the memo in the invocation of the iteratee on the next element in the list.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The value of `memo` "reduced" as per `iteratee`.
     * @memberOf Wrapper.prototype
     */
    reduce: function (iteratee, memo, context) {
        var o = this.o;
        if (o) {
            Object.keys(o).forEach(function (key, idx) {
                memo = (!idx && memo === undefined) ? o[key] : iteratee(memo, o[key], key, o);
            }, context || o);
        }
        return memo;
    },

    /**
     * @desc Mimics Underscore's [extend](http://underscorejs.org/#extend) method: Copy all of the properties in each of the `source` object parameter(s) over to the (wrapped) destination object (thus mutating it). It's in-order, so the properties of the last `source` object will override properties with the same name in previous arguments or in the destination object.
     * > This method copies own members as well as members inherited from prototype chain.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extend: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            if (object) {
                for (var key in object) {
                    o[key] = object[key];
                }
            }
        });
        return this.chaining ? this : o;
    },

    /**
     * @desc Mimics Underscore's [extendOwn](http://underscorejs.org/#extendOwn) method: Like {@link Wrapper#extend|extend}, but only copies its "own" properties over to the destination object.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extendOwn: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            Wrapper(object).each(function (val, key) { // eslint-disable-line new-cap
                o[key] = val;
            });
        });
        return this.chaining ? this : o;
    }
};

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
if (!Array.prototype.find) {
    Array.prototype.find = function (predicate) { // eslint-disable-line no-extend-native
        if (this === null) {
            throw new TypeError('Array.prototype.find called on null or undefined');
        }
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return value;
            }
        }
        return undefined;
    };
}

module.exports = Wrapper;

},{}],43:[function(require,module,exports){
'use strict';

/** @module overrider */

/**
 * Mixes members of all `sources` into `target`, handling getters and setters properly.
 *
 * Any number of `sources` objects may be given and each is copied in turn.
 *
 * @example
 * var overrider = require('overrider');
 * var target = { a: 1 }, source1 = { b: 2 }, source2 = { c: 3 };
 * target === overrider(target, source1, source2); // true
 * // target object now has a, b, and c; source objects untouched
 *
 * @param {object} object - The target object to receive sources.
 * @param {...object} [sources] - Object(s) containing members to copy to `target`. (Omitting is a no-op.)
 * @returns {object} The target object (`target`)
 */
function overrider(target, sources) { // eslint-disable-line no-unused-vars
    for (var i = 1; i < arguments.length; ++i) {
        mixIn.call(target, arguments[i]);
    }

    return target;
}

/**
 * Mix `this` members into `target`.
 *
 * @example
 * // A. Simple usage (using .call):
 * var mixInTo = require('overrider').mixInTo;
 * var target = { a: 1 }, source = { b: 2 };
 * target === overrider.mixInTo.call(source, target); // true
 * // target object now has both a and b; source object untouched
 *
 * @example
 * // B. Semantic usage (when the source hosts the method):
 * var mixInTo = require('overrider').mixInTo;
 * var target = { a: 1 }, source = { b: 2, mixInTo: mixInTo };
 * target === source.mixInTo(target); // true
 * // target object now has both a and b; source object untouched
 *
 * @this {object} Target.
 * @param target
 * @returns {object} The target object (`target`)
 * @memberOf module:overrider
 */
function mixInTo(target) {
    var descriptor;
    for (var key in this) {
        if ((descriptor = Object.getOwnPropertyDescriptor(this, key))) {
            Object.defineProperty(target, key, descriptor);
        }
    }
    return target;
}

/**
 * Mix `source` members into `this`.
 *
 * @example
 * // A. Simple usage (using .call):
 * var mixIn = require('overrider').mixIn;
 * var target = { a: 1 }, source = { b: 2 };
 * target === overrider.mixIn.call(target, source) // true
 * // target object now has both a and b; source object untouched
 *
 * @example
 * // B. Semantic usage (when the target hosts the method):
 * var mixIn = require('overrider').mixIn;
 * var target = { a: 1, mixIn: mixIn }, source = { b: 2 };
 * target === target.mixIn(source) // true
 * // target now has both a and b (and mixIn); source untouched
 *
 * @param source
 * @returns {object} The target object (`this`)
 * @memberOf overrider
 * @memberOf module:overrider
 */
function mixIn(source) {
    var descriptor;
    for (var key in source) {
        if ((descriptor = Object.getOwnPropertyDescriptor(source, key))) {
            Object.defineProperty(this, key, descriptor);
        }
    }
    return this;
}

overrider.mixInTo = mixInTo;
overrider.mixIn = mixIn;

module.exports = overrider;

},{}],44:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var REGEXP_INDIRECTION = /^(\w+)\((\w+)\)$/;  // finds complete pattern a(b) where both a and b are regex "words"

/** @typedef {object} valueItem
 * You should supply both `name` and `alias` but you could omit one or the other and whichever you provide will be used for both.
 * > If you only give the `name` property, you might as well just give a string for {@link menuItem} rather than this object.
 * @property {string} [name=alias] - Value of `value` attribute of `<option>...</option>` element.
 * @property {string} [alias=name] - Text of `<option>...</option>` element.
 * @property {string} [type] One of the keys of `this.converters`. If not one of these (including `undefined`), field values will be tested with a string comparison.
 * @property {boolean} [hidden=false]
 */

/** @typedef {object|menuItem[]} submenuItem
 * @summary Hierarchical array of select list items.
 * @desc Data structure representing the list of `<option>...</option>` and `<optgroup>...</optgroup>` elements that make up a `<select>...</select>` element.
 *
 * > Alternate form: Instead of an object with a `menu` property containing an array, may itself be that array. Both forms have the optional `label` property.
 * @property {string} [label] - Defaults to a generated string of the form "Group n[.m]..." where each decimal position represents a level of the optgroup hierarchy.
 * @property {menuItem[]} submenu
 */

/** @typedef {string|valueItem|submenuItem} menuItem
 * May be one of three possible types that specify either an `<option>....</option>` element or an `<optgroup>....</optgroup>` element as follows:
 * * If a `string`, specifies the text of an `<option>....</option>` element with no `value` attribute. (In the absence of a `value` attribute, the `value` property of the element defaults to the text.)
 * * If shaped like a {@link valueItem} object, specifies both the text and value of an `<option....</option>` element.
 * * If shaped like a {@link submenuItem} object (or its alternate array form), specifies an `<optgroup>....</optgroup>` element.
 */

/**
 * @summary Builds a new menu pre-populated with items and groups.
 * @desc This function creates a new pop-up menu (a.k.a. "drop-down"). This is a `<select>...</select>` element, pre-populated with items (`<option>...</option>` elements) and groups (`<optgroup>...</optgroup>` elements).
 * > Bonus: This function also builds `input type=text` elements.
 * > NOTE: This function generates OPTGROUP elements for subtrees. However, note that HTML5 specifies that OPTGROUP elemnents made not nest! This function generates the markup for them but they are not rendered by most browsers, or not completely. Therefore, for now, do not specify more than one level subtrees. Future versions of HTML may support it. I also plan to add here options to avoid OPTGROUPS entirely either by indenting option text, or by creating alternate DOM nodes using `<li>` instead of `<select>`, or both.
 * @memberOf popMenu
 *
 * @param {Element|string} el - Must be one of (case-sensitive):
 * * text box - an `HTMLInputElement` to use an existing element or `'INPUT'` to create a new one
 * * drop-down - an `HTMLSelectElement` to use an existing element or `'SELECT'` to create a new one
 * * submenu - an `HTMLOptGroupElement` to use an existing element or `'OPTGROUP'` to create a new one (meant for internal use only)
 *
 * @param {menuItem[]} [menu] - Hierarchical list of strings to add as `<option>...</option>` or `<optgroup>....</optgroup>` elements. Omitting creates a text box.
 *
 * @param {null|string} [options.prompt=''] - Adds an initial `<option>...</option>` element to the drop-down with this value in parentheses as its `text`; and empty string as its `value`. Default is empty string, which creates a blank prompt; `null` suppresses prompt altogether.
 *
 * @param {boolean} [options.sort] - Whether to alpha sort or not. If truthy, sorts each optgroup on its `label`; and each select option on its text (its `alias` if given; or its `name` if not).
 *
 * @param {string[]} [options.blacklist] - Optional list of menu item names to be ignored.
 *
 * @param {number[]} [options.breadcrumbs] - List of option group section numbers (root is section 0). (For internal use.)
 *
 * @param {boolean} [options.append=false] - When `el` is an existing `<select>` Element, giving truthy value adds the new children without first removing existing children.
 *
 * @returns {Element} Either a `<select>` or `<optgroup>` element.
 */
function build(el, menu, options) {
    options = options || {};

    var prompt = options.prompt,
        blacklist = options.blacklist,
        sort = options.sort,
        breadcrumbs = options.breadcrumbs || [],
        path = breadcrumbs.length ? breadcrumbs.join('.') + '.' : '',
        subtreeName = popMenu.subtree,
        groupIndex = 0,
        tagName;

    if (el instanceof Element) {
        tagName = el.tagName;
        if (!options.append) {
            el.innerHTML = ''; // remove all <option> and <optgroup> elements
        }
    } else {
        tagName = el;
        el = document.createElement(tagName);
    }

    if (menu) {
        var add, newOption;
        if (tagName === 'SELECT') {
            add = el.add;
            if (prompt) {
                newOption = new Option(prompt, '');
                newOption.innerHTML += '&hellip;';
                el.add(newOption);
            } else if (prompt !== null) {
                el.add(new Option());
            }
        } else {
            add = el.appendChild;
            el.label = prompt;
        }

        if (sort) {
            menu = menu.slice().sort(itemComparator); // sorted clone
        }

        menu.forEach(function(item) {
            // if item is of form a(b) and there is an function a in options, then item = options.a(b)
            if (options && typeof item === 'string') {
                var indirection = item.match(REGEXP_INDIRECTION);
                if (indirection) {
                    var a = indirection[1],
                        b = indirection[2],
                        f = options[a];
                    if (typeof f === 'function') {
                        item = f(b);
                    } else {
                        throw 'build: Expected options.' + a + ' to be a function.';
                    }
                }
            }

            var subtree = item[subtreeName] || item;
            if (subtree instanceof Array) {

                var groupOptions = {
                    breadcrumbs: breadcrumbs.concat(++groupIndex),
                    prompt: item.label || 'Group ' + path + groupIndex,
                    options: sort,
                    blacklist: blacklist
                };

                var optgroup = build('OPTGROUP', subtree, groupOptions);

                if (optgroup.childElementCount) {
                    el.appendChild(optgroup);
                }

            } else if (typeof item !== 'object') {

                if (!(blacklist && blacklist.indexOf(item) >= 0)) {
                    add.call(el, new Option(item));
                }

            } else if (!item.hidden) {

                var name = item.name || item.alias;
                if (!(blacklist && blacklist.indexOf(name) >= 0)) {
                    add.call(el, new Option(
                        item.alias || item.name,
                        name
                    ));
                }

            }
        });
    } else {
        el.type = 'text';
    }

    return el;
}

function itemComparator(a, b) {
    a = a.alias || a.name || a.label || a;
    b = b.alias || b.name || b.label || b;
    return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * @summary Recursively searches the context array of `menuItem`s for a named `item`.
 * @memberOf popMenu
 * @this Array
 * @param {object} [options]
 * @param {string} [options.keys=[popMenu.defaultKey]] - Properties to search each menuItem when it is an object.
 * @param {boolean} [options.caseSensitive=false] - Ignore case while searching.
 * @param {string} value - Value to search for.
 * @returns {undefined|menuItem} The found item or `undefined` if not found.
 */
function lookup(options, value) {
    if (arguments.length === 1) {
        value = options;
        options = undefined;
    }

    var shallow, deep, item, prop,
        keys = options && options.keys || [popMenu.defaultKey],
        caseSensitive = options && options.caseSensitive;

    value = toString(value, caseSensitive);

    shallow = this.find(function(item) {
        var subtree = item[popMenu.subtree] || item;

        if (subtree instanceof Array) {
            return (deep = lookup.call(subtree, options, value));
        }

        if (typeof item !== 'object') {
            return toString(item, caseSensitive) === value;
        } else {
            for (var i = 0; i < keys.length; ++i) {
                prop = item[keys[i]];
                if (prop && toString(prop, caseSensitive) === value) {
                    return true;
                }
            }
        }
    });

    item = deep || shallow;

    return item && (item.name ? item : { name: item });
}

function toString(s, caseSensitive) {
    var result = '';
    if (s) {
        result += s; // convert s to string
        if (!caseSensitive) {
            result = result.toUpperCase();
        }
    }
    return result;
}

/**
 * @summary Recursively walks the context array of `menuItem`s and calls `iteratee` on each item therein.
 * @desc `iteratee` is called with each item (terminal node) in the menu tree and a flat 0-based index. Recurses on member with name of `popMenu.subtree`.
 *
 * The node will always be a {@link valueItem} object; when a `string`, it is boxed for you.
 *
 * @memberOf popMenu
 *
 * @this Array
 *
 * @param {function} iteratee - For each item in the menu, `iteratee` is called with:
 * * the `valueItem` (if the item is a primative string, it is wrapped up for you)
 * * a 0-based `ordinal`
 *
 * The `iteratee` return value can be used to replace the item, as follows:
 * * `undefined` - do nothing
 * * `null` - splice out the item; resulting empty submenus are also spliced out (see note)
 * * anything else - replace the item with this value; if value is a subtree (i.e., an array) `iteratee` will then be called to walk it as well (see note)
 *
 * > Note: Returning anything (other than `undefined`) from `iteratee` will (deeply) mutate the original `menu` so you may want to copy it first (deeply, including all levels of array nesting but not the terminal node objects).
 *
 * @returns {number} Number of items (terminal nodes) in the menu tree.
 */
function walk(iteratee) {
    var menu = this,
        ordinal = 0,
        subtreeName = popMenu.subtree,
        i, item, subtree, newVal;

    for (i = menu.length - 1; i >= 0; --i) {
        item = menu[i];
        subtree = item[subtreeName] || item;

        if (!(subtree instanceof Array)) {
            subtree = undefined;
        }

        if (!subtree) {
            newVal = iteratee(item.name ? item : { name: item }, ordinal);
            ordinal += 1;

            if (newVal !== undefined) {
                if (newVal === null) {
                    menu.splice(i, 1);
                    ordinal -= 1;
                } else {
                    menu[i] = item = newVal;
                    subtree = item[subtreeName] || item;
                    if (!(subtree instanceof Array)) {
                        subtree = undefined;
                    }
                }
            }
        }

        if (subtree) {
            ordinal += walk.call(subtree, iteratee);
            if (subtree.length === 0) {
                menu.splice(i, 1);
                ordinal -= 1;
            }
        }
    }

    return ordinal;
}

/**
 * @summary Format item name with it's alias when available.
 * @memberOf popMenu
 * @param {string|valueItem} item
 * @returns {string} The formatted name and alias.
 */
function formatItem(item) {
    var result = item.name || item;
    if (item.alias) {
        result = '"' + item.alias + '" (' + result + ')';
    }
    return result;
}


function isGroupProxy(s) {
    return REGEXP_INDIRECTION.test(s);
}

/**
 * @namespace
 */
var popMenu = {
    build: build,
    walk: walk,
    lookup: lookup,
    formatItem: formatItem,
    isGroupProxy: isGroupProxy,
    subtree: 'submenu',
    defaultKey: 'name'
};

module.exports = popMenu;

},{}],45:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

/**
 * Creates a new read-only property and attaches it to the provided context.
 * @private
 * @param {string} name - Name for new property.
 * @param {*} [value] - Value of new property.
 */
function addReadOnlyProperty(name, value) {
    Object.defineProperty(this, name, {
        value: value,
        writable: false,
        enumerable: true,
        configurable: false
    });
}

/**
 * @constructor Point
 *
 * @desc This object represents a single point in an abstract 2-dimensional matrix.
 *
 * The unit of measure is typically pixels.
 * (If used to model computer graphics, vertical coordinates are typically measured downwards
 * from the top of the window. This convention however is not inherent in this object.)
 *
 * Note: This object should be instantiated with the `new` keyword.
 *
 * @param {number} x - the new point's `x` property
 * @param {number} y - the new point's `y` property
 */
function Point(x, y) {

    /**
     * @name x
     * @type {number}
     * @summary This point's horizontal coordinate.
     * @desc Created upon instantiation by the {@link Point|constructor}.
     * @memberOf Point.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'x', Number(x) || 0);

    /**
     * @name y
     * @type {number}
     * @summary This point's vertical coordinate.
     * @desc Created upon instantiation by the {@link Point|constructor}.
     * @memberOf Point.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'y', Number(y) || 0);

}

Point.prototype = {

    /**
     * @returns {Point} A new point which is this point's position increased by coordinates of given `offset`.
     * @param {Point} offset - Horizontal and vertical values to add to this point's coordinates.
     * @memberOf Point.prototype
     */
    plus: function(offset) {
        return new Point(
            this.x + offset.x,
            this.y + offset.y
        );
    },

    /**
     * @returns {Point} A new point which is this point's position increased by given offsets.
     * @param {number} [offsetX=0] - Value to add to this point's horizontal coordinate.
     * @param {number} [offsetY=0] - Value to add to this point's horizontal coordinate.
     * @memberOf Point.prototype
     */
    plusXY: function(offsetX, offsetY) {
        return new Point(
            this.x + (offsetX || 0),
            this.y + (offsetY || 0)
        );
    },

    /**
     * @returns {Point} A new point which is this point's position decreased by coordinates of given `offset`.
     * @param {Point} offset - Horizontal and vertical values to subtract from this point's coordinates.
     * @memberOf Point.prototype
     */
    minus: function(offset) {
        return new Point(
            this.x - offset.x,
            this.y - offset.y
        );
    },

    /**
     * @returns {Point} A new `Point` positioned to least x and least y of this point and given `offset`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    min: function(point) {
        return new Point(
            Math.min(this.x, point.x),
            Math.min(this.y, point.y)
        );
    },

    /**
     * @returns {Point} A new `Point` positioned to greatest x and greatest y of this point and given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    max: function(point) {
        return new Point(
            Math.max(this.x, point.x),
            Math.max(this.y, point.y)
        );
    },

    /**
     * @returns {number} Distance between given `point` and this point using Pythagorean Theorem formula.
     * @param {Point} point - A point from which to compute the distance to this point.
     * @memberOf Point.prototype
     */
    distance: function(point) {
        var deltaX = point.x - this.x,
            deltaY = point.y - this.y;

        return Math.sqrt(
            deltaX * deltaX +
            deltaY * deltaY
        );
    },

    /**
     * _(Formerly: `equal`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are exactly equal to those of given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    equals: function(point) {
        var result = false;

        if (point) {
            result =
                this.x === point.x &&
                this.y === point.y;
        }

        return result;
    },

    /**
     * @returns {boolean} `true` iff _both_ coordinates of this point are greater than those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    greaterThan: function(point) {
        return (
            this.x > point.x &&
            this.y > point.y
        );
    },

    /**
     * @returns {boolean} `true` iff _both_ coordinates of this point are less than those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    lessThan: function(point) {
        return (
            this.x < point.x &&
            this.y < point.y
        );
    },

    /**
     * _(Formerly `greaterThanEqualTo`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are greater than or equal to those of given `point`.
     * @param {Point} point - A point to compare to this point
     * @memberOf Point.prototype
     */
    greaterThanOrEqualTo: function(point) {
        return (
            this.x >= point.x &&
            this.y >= point.y
        );
    },

    /**
     * _(Formerly `lessThanEqualTo`.)_
     * @returns {boolean} `true` iff _both_ coordinates of this point are less than or equal to those of given `point`.
     * @param {Point} point - A point to compare to this point.
     * @memberOf Point.prototype
     */
    lessThanOrEqualTo: function(point) {
        return (
            this.x <= point.x &&
            this.y <= point.y
        );
    },

    /**
     * _(Formerly `isContainedWithinRectangle`.)_
     * @param rect {Rectangle} - Rectangle to test this point against.
     * @returns {boolean} `true` iff this point is within given `rect`.
     * @memberOf Point.prototype
     */
    within: function(rect) {
        var minX = rect.origin.x,
            maxX = minX + rect.extent.x;
        var minY = rect.origin.y,
            maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        return (
            minX <= this.x && this.x < maxX &&
            minY <= this.y && this.y < maxY
        );
    }
};

Point.prototype.EQ = Point.prototype.equals;
Point.prototype.GT = Point.prototype.greaterThan;
Point.prototype.LT = Point.prototype.lessThan;
Point.prototype.GE = Point.prototype.greaterThanOrEqualTo;
Point.prototype.LE = Point.prototype.lessThanOrEqualTo;


/**
 * @constructor Rectangle
 *
 * @desc This object represents a rectangular area within an abstract 2-dimensional matrix.
 *
 * The unit of measure is typically pixels.
 * (If used to model computer graphics, vertical coordinates are typically measured downwards
 * from the top of the window. This convention however is not inherent in this object.)
 *
 * Normally, the `x` and `y` parameters to the constructor describe the upper left corner of the rect.
 * However, negative values of `width` and `height` will be added to the given `x` and `y`. That is,
 * a negative value of the `width` parameter will extend the rect to the left of the given `x` and
 * a negative value of the `height` parameter will extend the rect above the given `y`.
 * In any case, after instantiation the following are guaranteed to always be true:
 * * The `extent`, `width`, and `height` properties _always_ give positive values.
 * * The `origin`, `top`, and `left` properties _always_ reflect the upper left corner.
 * * The `corner`, `bottom`, and `right` properties _always_ reflect the lower right corner.
 *
 * Note: This object should be instantiated with the `new` keyword.
 *
 * @param {number} [x=0] - Horizontal coordinate of some corner of the rect.
 * @param {number} [y=0] - Vertical coordinate of some corner of the rect.
 * @param {number} [width=0] - Width of the new rect. May be negative (see above).
 * @param {number} [height=0] - Height of the new rect. May be negative (see above).
 */
function Rectangle(x, y, width, height) {

    x = Number(x) || 0;
    y = Number(y) || 0;
    width = Number(width) || 0;
    height = Number(height) || 0;

    if (width < 0) {
        x += width;
        width = -width;
    }

    if (height < 0) {
        y += height;
        height = -height;
    }

    /**
     * @name origin
     * @type {Point}
     * @summary Upper left corner of this rect.
     * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'origin', new Point(x, y));

    /**
     * @name extent
     * @type {Point}
     * @summary this rect's width and height.
     * @desc Unlike the other `Point` properties, `extent` is not a global coordinate pair; rather it consists of a _width_ (`x`, always positive) and a _height_ (`y`, always positive).
     *
     * This object might be more legitimately typed as something like `Area` with properties `width` and `height`; however we wanted it to be able to use it efficiently with a point's `plus` and `minus` methods (that is, without those methods having to check and branch on the type of its parameter).
     *
     * Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @see The {@link Rectangle#corner|corner} method.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'extent', new Point(width, height));

    /**
     * @name corner
     * @type {Point}
     * @summary Lower right corner of this rect.
     * @desc This is a calculated value created upon instantiation by the {@linkplain Rectangle|constructor}. It is `origin` offset by `extent`.
     *
     * **Note:** These coordinates actually point to the pixel one below and one to the right of the rect's actual lower right pixel.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'corner', new Point(x + width, y + height));

    /**
     * @name center
     * @type {Point}
     * @summary Center of this rect.
     * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
     * @memberOf Rectangle.prototype
     * @abstract
     */
    addReadOnlyProperty.call(this, 'center', new Point(x + (width / 2), y + (height / 2)));

}

Rectangle.prototype = {

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Minimum vertical coordinate of this rect.
     * @memberOf Rectangle.prototype
     */
    get top() {
        return this.origin.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Minimum horizontal coordinate of this rect.
     * @memberOf Rectangle.prototype
     */
    get left() {
        return this.origin.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Maximum vertical coordinate of this rect + 1.
     * @memberOf Rectangle.prototype
     */
    get bottom() {
        return this.corner.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Maximum horizontal coordinate of this rect + 1.
     * @memberOf Rectangle.prototype
     */
    get right() {
        return this.corner.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Width of this rect (always positive).
     * @memberOf Rectangle.prototype
     */
    get width() {
        return this.extent.x;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Height of this rect (always positive).
     * @memberOf Rectangle.prototype
     */
    get height() {
        return this.extent.y;
    },

    /**
     * @type {number}
     * @desc _(Formerly a function; now a getter.)_
     * @summary Area of this rect.
     * @memberOf Rectangle.prototype
     */
    get area() {
        return this.width * this.height;
    },

    /**
     * @returns {Rectangle} A copy of this rect but with horizontal position reset to given `x` and no width.
     * @param {number} x - Horizontal coordinate of the new rect.
     * @memberOf Rectangle.prototype
     */
    flattenXAt: function(x) {
        return new Rectangle(x, this.origin.y, 0, this.extent.y);
    },

    /**
     * @returns {Rectangle} A copy of this rect but with vertical position reset to given `y` and no height.
     * @param {number} y - Vertical coordinate of the new rect.
     * @memberOf Rectangle.prototype
     */
    flattenYAt: function(y) {
        return new Rectangle(this.origin.x, y, this.extent.x, 0);
    },

    /**
     * @returns {boolean} `true` iff given `point` entirely contained within this rect.
     * @param {Point} pointOrRect - The point or rect to test for containment.
     * @memberOf Rectangle.prototype
     */
    contains: function(pointOrRect) {
        return pointOrRect.within(this);
    },

    /**
     * _(Formerly `isContainedWithinRectangle`.)_
     * @returns {boolean} `true` iff `this` rect is entirely contained within given `rect`.
     * @param {Rectangle} rect - Rectangle to test against this rect.
     * @memberOf Rectangle.prototype
     */
    within: function(rect) {
        return (
            rect.origin.lessThanOrEqualTo(this.origin) &&
            rect.corner.greaterThanOrEqualTo(this.corner)
        );
    },

    /**
     * _(Formerly: `insetBy`.)_
     * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
     * @param {number} padding - Amount by which to increase (+) or decrease (-) this rect
     * @see The {@link Rectangle#shrinkBy|shrinkBy} method.
     * @memberOf Rectangle.prototype
     */
    growBy: function(padding) {
        return new Rectangle(
            this.origin.x + padding,
            this.origin.y + padding,
            this.extent.x - padding - padding,
            this.extent.y - padding - padding);
    },

    /**
     * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
     * @param {number} padding - Amount by which to decrease (+) or increase (-) this rect.
     * @see The {@link Rectangle#growBy|growBy} method.
     * @memberOf Rectangle.prototype
     */
    shrinkBy: function(padding) {
        return this.growBy(-padding);
    },

    /**
     * @returns {Rectangle} Bounding rect that contains both this rect and the given `rect`.
     * @param {Rectangle} rect - The rectangle to union with this rect.
     * @memberOf Rectangle.prototype
     */
    union: function(rect) {
        var origin = this.origin.min(rect.origin),
            corner = this.corner.max(rect.corner),
            extent = corner.minus(origin);

        return new Rectangle(
            origin.x, origin.y,
            extent.x, extent.y
        );
    },

    /**
     * iterate over all points within this rect, invoking `iteratee` for each.
     * @param {function(number,number)} iteratee - Function to call for each point.
     * Bound to `context` when given; otherwise it is bound to this rect.
     * Each invocation of `iteratee` is called with two arguments:
     * the horizontal and vertical coordinates of the point.
     * @param {object} [context=this] - Context to bind to `iteratee` (when not `this`).
     * @memberOf Rectangle.prototype
     */
    forEach: function(iteratee, context) {
        context = context || this;
        for (var x = this.origin.x, x2 = this.corner.x; x < x2; x++) {
            for (var y = this.origin.y, y2 = this.corner.y; y < y2; y++) {
                iteratee.call(context, x, y);
            }
        }
    },

    /**
     * @returns {Rectangle} One of:
     * * _If this rect intersects with the given `rect`:_
     *      a new rect representing that intersection.
     * * _If it doesn't intersect and `ifNoneAction` defined:_
     *      result of calling `ifNoneAction`.
     * * _If it doesn't intersect and `ifNoneAction` undefined:_
     *      `null`.
     * @param {Rectangle} rect - The rectangle to intersect with this rect.
     * @param {function(Rectangle)} [ifNoneAction] - When no intersection, invoke and return result.
     * Bound to `context` when given; otherwise bound to this rect.
     * Invoked with `rect` as sole parameter.
     * @param {object} [context=this] - Context to bind to `ifNoneAction` (when not `this`).
     * @memberOf Rectangle.prototype
     */
    intersect: function(rect, ifNoneAction, context) {
        var result = null,
            origin = this.origin.max(rect.origin),
            corner = this.corner.min(rect.corner),
            extent = corner.minus(origin);

        if (extent.x > 0 && extent.y > 0) {
            result = new Rectangle(
                origin.x, origin.y,
                extent.x, extent.y
            );
        } else if (typeof ifNoneAction === 'function') {
            result = ifNoneAction.call(context || this, rect);
        }

        return result;
    },

    /**
     * @returns {boolean} `true` iff this rect overlaps with given `rect`.
     * @param {Rectangle} rect - The rectangle to intersect with this rect.
     * @memberOf Rectangle.prototype
     */
    intersects: function(rect) {
        return (
            rect.corner.x > this.origin.x &&
            rect.corner.y > this.origin.y &&
            rect.origin.x < this.corner.x &&
            rect.origin.y < this.corner.y
        );
    }
};

// Interface
exports.Point = Point;
exports.Rectangle = Rectangle;

},{}],46:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

(function (module) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See https://github.com/joneit/mnm.

    /**
     * @constructor RangeSelectionModel
     *
     * @desc This object models selection of "cells" within an abstract single-dimensional matrix.
     *
     * Disjoint selections can be built with calls to the following methods:
     * * {@link RangeSelectionModel#select|select(start, stop)} - Add a range to the matrix.
     * * {@link RangeSelectionModel#deselect|deselect(start, stop)} - Remove a range from the matrix.
     *
     * Two more methods are available:
     * * Test a cell to see if it {@link RangeSelectionModel#isSelected|isSelected(cell)}
     * * {@link RangeSelectionModel#clear|clear()} the matrix
     *
     * Internally, the selection is run-length-encoded. It is therefore a "sparse" matrix
     * with undefined bounds. A single data property called `selection` is an array that
     * contains all the "runs" (ranges) of selected cells albeit in no particular order.
     * This property should not normally need to be accessed directly.
     *
     * Note: This object should be instantiated with the `new` keyword.
     *
     * @returns {RangeSelectionModel} Self (i.e., `this` object).
     */
    function RangeSelectionModel() {
        /**
         * @name selection
         * @type {Array.Array.number}
         * @summary Unordered list of runs.
         * @desc A "run" is defined as an Array(2) where:
         * * element [0] is the beginning of the run
         * * element [1] is the end of the run (inclusive) and is always >= element [0]
         * The order of the runs within is undefined.
         * @memberOf RangeSelectionModel.prototype
         * @abstract
         */
        this.selection = [];

        //we need to be able to go back in time
        //the states field
        this.states = [];

        //clone and store my current state
        //so we can unwind changes if need be
        this.storeState = function () {
            var sels = this.selection;
            var state = [];
            var copy;
            for (var i = 0; i < sels.length; i++) {
                copy = [].concat(sels[i]);
                state.push(copy);
            }
            this.states.push(state);
        };
    }

    RangeSelectionModel.prototype = {

        /**
         * @summary Add a contiguous run of points to the selection.
         * @desc Insert a new run into `this.selection`.
         * The new run will be merged with overlapping and adjacent runs.
         *
         * The two parameters may be given in either order.
         * The start and stop elements in the resulting run will however always be ordered.
         * (However, note that the order of the runs within `this.selection` is itself always unordered.)
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        select: function (start, stop) {
            this.storeState();
            var run = makeRun(start, stop);
            var splicer = [0, 1];
            this.selection.forEach(function (each) {
                if (overlaps(each, run) || abuts(each, run)) {
                    run = merge(each, run);
                } else {
                    splicer.push(each);
                }
            });
            splicer.push(run);
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Remove a contiguous run of points from the selection.
         * @desc Truncate and/or remove run(s) from `this.selection`.
         * Removing part of existing runs will (correctly) shorten them or break them into two fragments.
         *
         * The two parameters may be given in either order.
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        deselect: function (start, stop) {
            var run = makeRun(start, stop);
            var splicer = [0, 0];
            this.selection.forEach(function (each) {
                if (overlaps(each, run)) {
                    var pieces = subtract(each, run);
                    splicer = splicer.concat(pieces);
                } else {
                    splicer.push(each);
                }
            });
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Empties `this.selection`, effectively removing all runs.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        clear: function () {
            this.states.length = 0;
            this.selection.length = 0;
            return this;
        },

        clearMostRecentSelection: function () {
            if (this.states.length === 0) {
                return;
            }
            this.selection = this.states.pop();
        },

        /**
         * @summary Determines if the given `cell` is selected.
         * @returns {boolean} `true` iff given `cell` is within any of the runs in `this.selection`.
         * @param {number} cell - The cell to test for inclusion in the selection.
         * @memberOf RangeSelectionModel.prototype
         */
        isSelected: function (cell) {
            return this.selection.some(function (each) {
                return each[0] <= cell && cell <= each[1];
            });
        },

        isEmpty: function (){
            return this.selection.length === 0;
        },

        /**
         * @summary Return the indexes that are selected.
         * @desc Return the indexes that are selected.
         * @returns {Array.Array.number}
         * @memberOf RangeSelectionModel.prototype
         */
        getSelections: function (){
            var result = [];
            this.selection.forEach(function (each) {
                for (var i = each[0]; i <= each[1]; i++) {
                    result.push(i);
                }
            });
            result.sort(function (a, b){
                return a - b;
            });
            return result;
        }

    };

    /**
     * @private
     * @summary Preps `start` and `stop` params into order array
     * @function makeRun
     * @desc Utility function called by both `select()` and `deselect()`.
     * @param {number|number[]} start - Start of run. if array, `start` and `stop` are taken from first two elements.
     * @param {number} [stop=start] - End of run (inclusive).
     */
    function makeRun(start, stop) {
        return (
            start instanceof Array
                ? makeRun.apply(this, start) // extract params from given array
                : stop === undefined
                ? [ start, start ] // single param is a run that stops where it starts
                : start <= stop
                ? [ start, stop ]
                : [ stop, start ] // reverse descending params into ascending order
        );
    }

    /**
     * @private
     * @function overlaps
     * @returns {boolean} `true` iff `run1` overlaps `run2`
     * @summary Comparison operator that determines if given runs overlap with one another.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Overlap is defined to include the case where one run completely contains the other.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function overlaps(run1, run2) {
        return (
            run1[0] <= run2[0] && run2[0] <= run1[1] || // run2's start is within run1 OR...
            run1[0] <= run2[1] && run2[1] <= run1[1] || // run2's stop is within run1 OR...
            run2[0] <  run1[0] && run1[1] <  run2[1]    // run2 completely contains run1
        );
    }

    /**
     * @private
     * @function abuts
     * @summary Comparison operator that determines if given runs are consecutive with one another.
     * @returns {boolean} `true` iff `run1` is consecutive with `run2`
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function abuts(run1, run2) {
        return (
            run1[1] === run2[0] - 1 || // run1's top immediately precedes run2's start OR...
            run2[1] === run1[0] - 1    // run2's top immediately precedes run1's start
        );
    }

    /**
     * @private
     * @function subtract
     * @summary Operator that subtracts one run from another.
     * @returns {Array.Array.number} The remaining pieces of `minuend` after removing `subtrahend`.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * This function _does not assumes_ that `overlap()` has already been called with the same runs and has returned `true`.
     *
     * Returned array contains 0, 1, or 2 runs which are the portion(s) of `minuend` that do _not_ include `subtrahend`.
     *
     * Caveat: This operator is *not* commutative.
     * @param {number[]} minuend - a run from which to "subtract" `subtrahend`
     * @param {number[]} subtrahend - a run to "subtracted" from `minuend`
     */
    function subtract(minuend, subtrahend) {
        var m0 = minuend[0];
        var m1 = minuend[1];
        var s0 = subtrahend[0];
        var s1 = subtrahend[1];
        var result = [];

        if (s0 <= m0 && s1 < m1) {
            //subtrahend extends before minuend: return remaining piece of `minuend`
            result.push([s1 + 1, m1]);
        } else if (s0 > m0 && s1 >= m1) {
            //subtrahend extends after minuend: return remaining piece of `minuend`
            result.push([m0, s0 - 1]);
        } else if (m0 < s0 && s1 < m1) {
            //completely inside: return 2 smaller pieces resulting from the hole
            result.push([m0, s0 - 1]);
            result.push([s1 + 1, m1]);
        } else if (s1 < m0 || s0 > m1) {
            // completely outside: return `minuend` untouched
            result.push(minuend);
        }

        //else subtrahend must completely overlap minuend so return no pieces

        return result;
    }


    // Local utility functions

    /**
     * @private
     * @function merge
     * @summary Operator that merges given runs.
     * @returns {number[]} A single merged run.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * The runs are assumed to be overlapping or adjacent to one another.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - a run to merge with `run2`
     * @param {number[]} run2 - a run to merge with `run1`
     */
    function merge(run1, run2) {
        var min = Math.min(Math.min.apply(Math, run1), Math.min.apply(Math, run2));
        var max = Math.max(Math.max.apply(Math, run1), Math.max.apply(Math, run2));
        return [min, max];
    }

    // Interface
    module.exports = RangeSelectionModel;
})(
    typeof module === 'object' && module || (window.RangeSelectionModel = {}),
    typeof module === 'object' && module.exports || (window.RangeSelectionModel.exports = {})
) || (
    typeof module === 'object' || (window.RangeSelectionModel = window.RangeSelectionModel.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.RangeSelectionModel`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `window` object undefined, we're in NodeJs so assume there is a `module` object with an `exports` property
 * 2. If `window` object defined, we're in browser
 * 2.a. If `module` object predefined, use it
 * 2.b. If `module` object undefined, create a `RangeSelectionModel` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will execute:
 * 1. If `window` object undefined, then we're in NodeJs so we're done
 * 2. If `window` object defined, then we're in browser
 * 2.a. If `module` object predefined, we're done; results are in `moudule.exports`
 * 2.b. If `module` object undefined, redefine`RangeSelectionModel` to be the `RangeSelectionModel.exports` object
 */

},{}],47:[function(require,module,exports){
// tabz node module
// https://github.com/joneit/tabz

/* eslint-env node, browser */

'use strict';

var cssInjector = require('css-injector');

/**
 * Register/deregister click handler on all tab collections.
 * @param {Element} [options.root=document] - Where to look for tab panels (`.tabz` elements) containing tabs and folders.
 * @param {boolean} [options.unhook=false] - Remove event listener from tab panels (`.tabz` elements).
 * @param {Element} [options.referenceElement] - Passed to cssInjector's insertBefore() call.
 * @param {string} [options.defaultTabSelector='.default-tab'] - .classname or #id of the tab to select by default
 * @param {object} [options.onEnable] - Handler implementation. See {@link Tabz#onEnable|onEnable}.
 * @param {object} [options.onDisable] - Handler implementation. See {@link Tabz#onDisable|onEnable}.
 * @param {object} [options.onEnabled] - Handler implementation. See {@link Tabz#onEnabled|onEnable}.
 * @param {object} [options.onDisabled] - Handler implementation. See {@link Tabz#onDisabled|onEnable}.
 * @constructor
 */
function Tabz(options) {
    var i, el;

    options = options || {};
    var root = options.root || document,
        unhook = options.unhook,
        referenceElement = options.referenceElement,
        defaultTabSelector = options.defaultTabSelector || '.default-tab';

    if (!unhook) {
        var css;
        /* inject:css */
        css = '.tabz{position:relative;visibility:hidden;height:100%}.tabz>header{position:relative;display:inline-block;background-color:#fff;margin-left:1em;padding:5px .6em;border:1px solid #666;border-bottom-color:transparent;border-radius:6px 6px 0 0;cursor:default;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.tabz>header+section{position:absolute;display:none;background-color:#fff;margin-top:-1px;padding:8px;border:1px solid #666;border-radius:6px;left:0;right:0;bottom:0;top:0;z-index:0}.tabz>header+section.tabz-enable{z-index:1}.tabz>header.tabz-enable{z-index:2}.tabz-bg0{background-color:#eee!important}.tabz-bg1{background-color:#eef!important}.tabz-bg2{background-color:#efe!important}.tabz-bg3{background-color:#eff!important}.tabz-bg4{background-color:#fee!important}.tabz-bg5{background-color:#fef!important}.tabz-bg6{background-color:#ffe!important}';
        /* endinject */

        if (!referenceElement) {
            // find first <link> or <style> in <head>
            var headStuff = document.querySelector('head').children;
            for (i = 0; !referenceElement && i < headStuff.length; ++i) {
                el = headStuff[i];
                if (el.tagName === 'STYLE' || el.tagName === 'LINK' && el.rel === 'stylesheet') {
                    referenceElement = el;
                }
            }
        }
        cssInjector(css, 'tabz-css-base', referenceElement);

        for (var key in options) {
            if (this[key] === noop) {
                this[key] = options[key];
            }
        }

        /**
         * @summary The context of this tab object.
         * @desc The context may encompass any number of tab panels (`.tabz` elements).
         * @type {HTMLDocumen|HTMLElement}
         */
        this.root = root;

        // enable first tab on each tab panel (`.tabz` element)
        forEachEl('.tabz>header:first-of-type,.tabz>section:first-of-type', function(el) {
            el.classList.add('tabz-enable');
        }, root);

        // enable default tab and all its parents (must be a tab)
        this.tabTo(root.querySelector('.tabz > header' + defaultTabSelector));

        setTimeout(function() {
            forEachEl('.tabz > section', function(el) {

                // Step 1: A bug in older versions of Chrome (like v40) that inserted a break at mark-up location of an absolute positioned block. The work-around is to hide those blocks until after first render; then show them. I don't know why this works but it does. Seems to be durable.
                el.style.display = 'block';

                // Step 2: Adjust absolute top of each rendered folder to the bottom of its tab
                el.style.top = el.previousElementSibling.getBoundingClientRect().bottom - el.parentElement.getBoundingClientRect().top + 'px';

            }, root);
        }, 0);
    }

    var method = unhook ? 'removeEventListener' : 'addEventListener';
    var boundClickHandler = onclick.bind(this);
    forEachEl('.tabz', function(tabBar) {
        tabBar.style.visibility = 'visible';
        tabBar[method]('click', boundClickHandler);
    }, root);
}

function onclick(evt) {
    click.call(this, evt.currentTarget, evt.target);
}

/**
 * @summary Selects the given tab.
 * @desc If it is a nested tab, also reveals all its ancestor tabs.
 * @param {string|HTMLElement} [el] - May be one of:
 * * `HTMLElement`
 *   * `<header>` - tab element
 *   * `<section>` - folder element
 * * `string` - CSS selector to one of the above
 * * falsy - fails silently
 * @memberOf Tabz.prototype
 */
Tabz.prototype.tabTo = function(el) {
    while ((el = this.tab(el))) {
        click.call(this, el.parentElement, el);
        el = el.parentElement.parentElement; // loop to click on each containing tab...
    }
};

/**
 * Current selected tab.
 * @param {HTMLElement|number} el - An element that is (or is within) the tab panel (`.tabz` element) to look in.
 * @returns {undefined|HTMLElement} Returns tab (`<header>`) element.  Returns `undefined` if `el` is neither of the above or an out of range index.
 */
Tabz.prototype.enabledTab = function(el) {
    el = this.panel(el);
    return el && el.querySelector(':scope>header.tabz-enable');
};

/**
 * @summary Get tab element.
 * @desc Get tab element if given tab or folder element; or an element within such; or find tab.
 * @param {string|Element} [el] - May be one of:
 * * a tab (a `<header>` element)
 * * a folder (a `<section>` element)
 * * an element within one of the above
 * * `string` - CSS selector to one of the above, searching within the root or document
 * @returns {null|Element} tab (`<header>...</header>`) element or `null` if not found
 * @memberOf Tabz.prototype
 */
Tabz.prototype.tab = function(el) {
    el = lookForEl.call(this, el);
    return !(el instanceof HTMLElement) ? null : el.tagName === 'HEADER' ? el : el.tagName === 'SECTION' ? el.previousElementSibling : null;
};

/**
 * @summary Get folder element.
 * @desc Get folder element if given tab or folder element; or an element within such; or find folder.
 * @param {string|Element} [el] - May be one of:
 * * a tab (a `<header>` element)
 * * a folder (a `<section>` element)
 * * an element within one of the above
 * * `string` - CSS selector to one of the above, searching within the root or document
 * @returns {null|Element} tab (`<header>...</header>`) element or `null` if not found
 * @memberOf Tabz.prototype
 */
Tabz.prototype.folder = function(el) {
    el = lookForEl.call(this, el);
    return !(el instanceof HTMLElement) ? null : el.tagName === 'SECTION' ? el : el.tagName === 'HEADER' ? el.nextElementSibling : null;
};

/**
 * @summary Get tab panel element.
 * @desc Get panel element if given tab panel element; or an element within a tab panel; or find tab panel.
 * @param {string|Element} [el] - May be one of:
 * * a tab panel (an `HTMLElement` with class `tabz`)
 * * an element within a tab panel
 * * `string` - CSS selector to one a tab panel, searching within the root or document
 * @returns {null|Element} tab panel element or `null` if not found
 * @memberOf Tabz.prototype
 */
Tabz.prototype.panel = function(el) {
    while (el && !el.classList.contains('tabz')) {
        el = el.parentElement;
    }
    return !(el instanceof HTMLElement) ? null : el.classList.contains('tabz') ? el : null;
};

function lookForEl(el) {
    if (el instanceof Element) {
        while (el && el.tagName !== 'HEADER' && el.tagName !== 'SECTION') {
            el = el.parentElement;
        }
    } else {
        el = this.root.querySelector(el);
    }
    return el;
}

/** Enables the tab/folder pair of the clicked tab.
 * Disables all the other pairs in this scope which will include the previously enabled pair.
 * @private
 * @this Tabz
 * @param {Element} div - The tab panel (`.tabz` element) that's handling the click event.
 * @param {Element} target - The element that received the click.
 * @returns {undefined|Element} The `<header>` element (tab) the was clicked; or `undefined` when click was not within a tab.
 */
function click(div, target) {
    var newTab, oldTab;

    forEachEl(':scope>header:not(.tabz-enable)', function(tab) { // todo: use a .find() polyfill here
        if (tab.contains(target)) {
            newTab = tab;
        }
    }, div);

    if (newTab) {
        oldTab = this.enabledTab(div);
        toggleTab.call(this, oldTab, false);
        toggleTab.call(this, newTab, true);
    }

    return newTab;
}

/**
 * @private
 * @this Tabz
 * @param {Element} tab - The `<header>` element of the tab to enable or disable.
 * @param {boolean} enable - Enable (vs. disable) the tab.
 */
function toggleTab(tab, enable) {
    if (tab) {
        var folder = this.folder(tab),
            method = enable ? 'onEnable' : 'onDisable';

        this[method].call(this, tab, folder);

        tab.classList.toggle('tabz-enable', enable);
        folder.classList.toggle('tabz-enable', enable);

        method += 'd';
        this[method].call(this, tab, folder);
    }
}

/**
 * @typedef tabEvent
 * @type {function}
 * @param {tabEventObject}
 */

/**
 * @typedef tabEventObject
 * @property {Tabz} tabz - The tab object issuing the callback.
 * @property {Element} target - The tab (`<header>` element).
 */

/**
 * Called before a previously disabled tab is enabled.
 * @type {tabEvent}
 * @abstract
 * @memberOf Tabz.prototype
 */
Tabz.prototype.onEnable = noop;

/**
 * Called before a previously enabled tab is disabled by another tab being enabled.
 * @type {tabEvent}
 * @abstract
 * @memberOf Tabz.prototype
 */
Tabz.prototype.onDisable = noop;

/**
 * Called after a previously disabled tab is enabled.
 * @type {tabEvent}
 * @abstract
 * @memberOf Tabz.prototype
 */
Tabz.prototype.onEnabled = noop;

/**
 * Called after a previously enabled tab is disabled by another tab being enabled.
 * @type {tabEvent}
 * @abstract
 * @memberOf Tabz.prototype
 */
Tabz.prototype.onDisabled = noop;

function noop() {} // null pattern

function forEachEl(selector, iteratee, context) {
    return Array.prototype.forEach.call((context || document).querySelectorAll(selector), iteratee);
}


module.exports = Tabz;

},{"css-injector":6}],48:[function(require,module,exports){
// templex node module
// https://github.com/joneit/templex

/* eslint-env node */

/**
 * Merges values of execution context properties named in template by {prop1},
 * {prop2}, etc., or any javascript expression incorporating such prop names.
 * The context always includes the global object. In addition you can specify a single
 * context or an array of contexts to search (in the order given) before finally
 * searching the global context.
 *
 * Merge expressions consisting of simple numeric terms, such as {0}, {1}, etc., deref
 * the first context given, which is assumed to be an array. As a convenience feature,
 * if additional args are given after `template`, `arguments` is unshifted onto the context
 * array, thus making first additional arg available as {1}, second as {2}, etc., as in
 * `templex('Hello, {1}!', 'World')`. ({0} is the template so consider this to be 1-based.)
 *
 * If you prefer something other than braces, redefine `templex.regexp`.
 *
 * See tests for examples.
 *
 * @param {string} template
 * @param {...string} [args]
 */
function templex(template) {
    var contexts = this instanceof Array ? this : [this];
    if (arguments.length > 1) { contexts.unshift(arguments); }
    return template.replace(templex.regexp, templex.merger.bind(contexts));
}

templex.regexp = /\{(.*?)\}/g;

templex.with = function (i, s) {
    return 'with(this[' + i + ']){' + s + '}';
};

templex.cache = [];

templex.deref = function (key) {
    if (!(this.length in templex.cache)) {
        var code = 'return eval(expr)';

        for (var i = 0; i < this.length; ++i) {
            code = templex.with(i, code);
        }

        templex.cache[this.length] = eval('(function(expr){' + code + '})'); // eslint-disable-line no-eval
    }
    return templex.cache[this.length].call(this, key);
};

templex.merger = function (match, key) {
    // Advanced features: Context can be a list of contexts which are searched in order.
    var replacement;

    try {
        replacement = isNaN(key) ? templex.deref.call(this, key) : this[0][key];
    } catch (e) {
        replacement = '{' + key + '}';
    }

    return replacement;
};

// this interface consists solely of the templex function (and it's properties)
module.exports = templex;

},{}],49:[function(require,module,exports){
'use strict';

/**
 * @constructor
 * @desc Extend from this base class using `Base.extend` per example.
 * @example
 * var prototype = { ... };
 * var descendantClass = Base.extend(prototype};
 * @classdesc This is an abstract base class available for all Hypergrid classes.
 */
var Base = require('extend-me').Base;

Base.prototype.deprecated = require('./lib/deprecated');
Base.prototype.HypergridError = require('./lib/error');

/**
 * Convenience function for getting the value when that value can be defined as a function that needs to be called to get the actual (primitive) value.
 * @param value
 * @returns {*}
 */
Base.prototype.unwrap = function(value) {
    if (typeof value === 'function') {
        value = value();
    }
    return value;
};

/**
 * @method
 * @summary Mixes source members into calling context.
 * @desc Context is typically either an instance or the (shared) prototype of a "class" extended from {@link Base} (see examples).
 *
 * Typically used by plug-ins.
 * @example
 * // define instance members: myGrid.fix(), etc.
 * myGrid.mixIn({ fix: function() {...}, ... });
 * @example
 * // define prototype members: Hypergrid.prototype.fix(), etc.
 * Hypergrid.prototype.mixIn({ fix: function() {...}, ... });
 * @See {@link https://joneit.github.io/overrider/module-overrider.htm#.mixIn}
 * @param {object} source
 */
Base.prototype.mixIn = require('overrider').mixIn;


module.exports = Base;

},{"./lib/deprecated":117,"./lib/error":118,"extend-me":7,"overrider":43}],50:[function(require,module,exports){
/* eslint-env browser */

'use strict';

require('./lib/polyfills'); // Installs misc. polyfills into global objects, as needed

var FinBar = require('finbars');
var Canvas = require('fincanvas');
var Point = require('rectangular').Point;
var Rectangle = require('rectangular').Rectangle;
var _ = require('object-iterators'); // fyi: installs the Array.prototype.find polyfill, as needed

var Base = require('./Base');
var defaults = require('./defaults');
var Renderer = require('./lib/Renderer');
var SelectionModel = require('./lib/SelectionModel');
var stylesheet = require('./lib/stylesheet');
var Localization = require('./lib/Localization');
//var behaviors = require('./behaviors');
var CellRenderers = require('./cellRenderers');
var CellEditors = require('./cellEditors');
var BehaviorJSON = require('./behaviors/JSON');

var themeInitialized = false,
    gridTheme = Object.create(defaults),
    globalProperties = Object.create(gridTheme);

var warned = {};

/**s
 * @constructor
 * @param {string|Element} [container] - CSS selector or Element
 * @param {object} [options]
 * @param {function} [options.Behavior=behaviors.JSON] - A behavior constructor or instance
 * @param {function[]} [options.pipeline] - A list function constructors to use for passing data through a series of transforms to occur on reindex call
 * @param {function|object[]} [options.data] - Passed to behavior constructor. May be:
 * * An array of congruent raw data objects
 * * A function returning same
 * @param {function|menuItem[]} [options.schema=derivedSchema] - Passed to behavior constructor. May be:
 * * A schema array
 * * A function returning a schema array. Called at filter reset time with behavior as context.
 * * Omit to generate a basic schema from `this.behavior.columns`.
 * @param {Behavior} [options.Behavior=JSON] - A grid behavior (descendant of Behavior "class").
 * @param {pluginSpec|pluginSpec[]} [options.plugins]
 * @param {DataModels[]} [options.subgrids]
 * @param {string} [options.localization=Hypergrid.localization]
 * @param {string|Element} [options.container] - CSS selector or Element
 * @param {string|string[]} [options.localization.locale=Hypergrid.localization.locale] - The default locale to use when an explicit `locale` is omitted from localizer constructor calls. Passed to Intl.NumberFomrat` and `Intl.DateFomrat`. See {@ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Locale identification and negotiation} for more information.
 * @param {string} [options.localization.numberOptions=Hypergrid.localization.numberOptions] - Options passed to `Intl.NumberFomrat` for creating the basic "number" localizer.
 * @param {string} [options.localization.dateOptions=Hypergrid.localization.dateOptions] - Options passed to `Intl.DateFomrat` for creating the basic "date" localizer.
 * @param {object} [options.schema]
 * @param {object} [options.margin] - optional canvas margins
 * @param {string} [options.margin.top=0]
 * @param {string} [options.margin.right=0]
 * @param {string} [options.margin.bottom=0]
 * @param {string} [options.margin.left=0]
 * @param {object} [options.boundingRect] - optional grid container argument
 * @param {string} [options.boundingRect.height=300]
 * @param {string} [options.boundingRect.width=300]
 * @param {string} [options.boundingRect.postion=relative]
 */
var Hypergrid = Base.extend('Hypergrid', {
    initialize: function(container, options) {
        if (!themeInitialized) {
            themeInitialized = true;
            gridTheme = buildTheme(gridTheme);
        }

        //Optional container argument
        if (!(typeof container === 'string') && !(container instanceof HTMLElement)) {
            options = container;
            container = null;
        }

        this.options = options = options || {};

        // Install shared plug-ins (those with a `preinstall` method)
        Object.getPrototypeOf(this).installPlugins(options.plugins);

        this.lastEdgeSelection = [0, 0];
        this.lnfProperties = Object.create(globalProperties);
        this.isWebkit = navigator.userAgent.toLowerCase().indexOf('webkit') > -1;
        this.selectionModel = new SelectionModel(this);
        this.renderOverridesCache = {};
        this.allowEventHandlers = true;
        this.dragExtent = new Point(0, 0);
        this.numRows = 0;
        this.numColumns = 0;
        this.clearMouseDown();
        this.setFormatter(options.localization);

        /**
         * @name cellRenderers
         * @type {CellRenderer}
         * @memberOf Hypergrid.prototype
         */
        this.cellRenderers = new CellRenderers();

        /**
         * @name cellEditors
         * @type {CellEditor}
         * @memberOf Hypergrid.prototype
         */
        this.cellEditors = new CellEditors(this);

        //Set up the container for a grid instance
        container = container || options.container;
        container = container || findOrCreateContainer(options.boundingRect);
        this.setContainer(container);

        if (this.options.Behavior) {
            this.setBehavior(this.options); // also sets this.options.pipeline and this.options.data
        } else if (this.options.data) {
            this.setData(this.options.data, this.options); // if no behavior has yet been set, `setData` sets a default behavior and this.options.pipeline
        }

        /**
         * @name plugins
         * @summary Dictionary of named instance plug-ins.
         * @desc See examples for how to reference (albeit there is normally no need to reference plugins directly).
         *
         * For the dictionary of _shared_ plugins, see {@link Hypergrid.plugins|plugins} (a property of the constructor).
         * @example
         * var instancePlugins = myGrid.plugins;
         * var instancePlugins = this.plugins // internal use
         * var myInstancePlugin = myGrid.plugins.myInstancePlugin;
         * @type {object}
         * @memberOf Hypergrid.prototype
         */
        this.plugins = {};

        // Install instance plug-ins (those that are constructors OR have an `install` method)
        this.installPlugins(options.plugins);

        // Listen for propagated mouseclicks. Used for aborting edit mode.
        document.addEventListener('mousedown', this.mouseCatcher = function() {
            this.abortEditing();
        }.bind(this));
    },

    terminate: function() {
        document.removeEventListener('mousedown', this.mouseCatcher);
    },

    registerCellEditor: function(Constructor, name) {
        return this.deprecated('registerCellEditor(Constructor, name)', 'cellEditors.add(name, Constructor)', '1.0.6', arguments);
    },
    createCellEditor: function(name) {
        return this.deprecated('createCellEditor(name)', 'cellEditors.create(name)', '1.0.6', arguments);
    },
    getCellProvider: function(name) {
        return this.deprecated('getCellProvider()', 'cellRenderers', '1.0.6', arguments);
    },
    registerLocalizer: function(name, localizer, baseClassName, newClassName) {
        return this.deprecated('registerLocalizer(name, localizer, baseClassName, newClassName)', 'localization.add(name, localizer)', '1.0.6', arguments,
            'STRUCTURAL CHANGE: No longer supports deriving and registering a new cell editor class. Use .cellEditors.get(baseClassName).extend(newClassName || name, {...}) for that.');
    },
    getRenderer: function() {
        return this.deprecated('getRenderer()', 'renderer', '1.1.0');
    },

    /**
     *
     * A null object behavior serves as a place holder.
     * @type {object}
     * @memberOf Hypergrid.prototype
     */
    behavior: null,

    /**
     * Cached resulan}
     * @memberOf Hypergrid.prototype
     */
    isWebkit: true,

    /**
     * The pixel location of an initial mousedown click, either for editing a cell or for dragging a selection.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */
    mouseDown: [],

    /**
     * The extent from the mousedown point during a drag operation.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */

    dragExtent: null,

    /**
     * A float value between 0.0 - 1.0 of the vertical scroll position.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    vScrollValue: 0,

    /**
     * A float value between 0.0 - 1.0 of the horizontal scroll position.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    hScrollValue: 0,

    /**
     * @property {fin-hypergrid-selection-model} selectionModel - A [fin-hypergrid-selection-model](module-._selection-model.html) instance.
     * @memberOf Hypergrid.prototype
     */
    selectionModel: null,

    /**
     * @property {fin-hypergrid-cell-editor} cellEditor - The current instance of [fin-hypergrid-cell-editor](module-cell-editors_base.html).
     * @memberOf Hypergrid.prototype
     */
    cellEditor: null,

    /**
     * @property {fin-vampire-bar} sbHScroller - An instance of {@link https://github.com/openfin/finbars|FinBar}.
     * @memberOf Hypergrid.prototype
     */
    sbHScroller: null,

    /**
     * @property {fin-vampire-bar} sbVScroller - An instance of {@link https://github.com/openfin/finbars|FinBar}.
     * @memberOf Hypergrid.prototype
     */
    sbVScroller: null,

    /**
     * The previous value of sbVScrollVal.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    sbPrevVScrollValue: null,

    /**
     * The previous value of sbHScrollValue.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    sbPrevHScrollValue: null,

    /**
     * is the short term memory of what column I might be dragging around
     * @type {object}
     * @memberOf Hypergrid.prototype
     */

    renderOverridesCache: {},

    /**
     * The pixel location of the current hovered cell.
     * @todo Need to detect hovering over bottom totals.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */
    hoverCell: null,

    scrollingNow: false,

    lastEdgeSelection: null,

    /**
     * @memberOf Hypergrid.prototype
     */
    setAttribute: function(attribute, value) {
        this.div.setAttribute(attribute, value);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear out all state and data of a grid instance.
     */
    reset: function() {
        this.lastEdgeSelection = [0, 0];
        this.lnfProperties = Object.create(globalProperties);
        this.selectionModel = new SelectionModel(this);
        this.renderOverridesCache = {};
        this.clearMouseDown();
        this.dragExtent = new Point(0, 0);

        this.numRows = 0;
        this.numColumns = 0;

        this.vScrollValue = 0;
        this.hScrollValue = 0;

        this.cancelEditing();

        this.sbPrevVScrollValue = null;
        this.sbPrevHScrollValue = null;

        this.hoverCell = null;
        this.scrollingNow = false;
        this.lastEdgeSelection = [0, 0];

        this.behavior.reset();
        this.renderer.reset();
        this.getCanvas().resize();
        this.behaviorChanged();

        this.refreshProperties();
    },

    /** @typedef {object|function|Array} pluginSpec
     * @desc One of:
     * * simple API - a plain object with an `install` method
     * * object API - an object constructor
     * * array:
     *    * first element is an optional name for the API or the newly instantiated object
     *    * next element (or first element when not a string) is the simple or object API
     *    * remaining arguments are optional arguments for the object constructor
     * * falsy value such as `undefined` - ignored
     *
     * The API may have a `name` or `$$CLASS_NAME` property.
     */
    /**
     * @summary Install plugins.
     * @desc Plugin installation:
     * * Each simple API is installed by calling it's `install` method with `this` as first arg + any additional args listed in the `pluginSpec` (when it is an array).
     * * Each object API is installed by instantiating it's constructor with `this` as first arg + any additional args listed in the `pluginSpec` (when it is an array).
     *
     * The resulting plain object or instantiated objects may be named by (in priority order):
     * 1. if `pluginSpec` contains an array and first element is a string
     * 2. object has a `name` property
     * 3. object has a `$$CLASS_NAME` property
     *
     * If named, a reference to each object is saved in `this.plugins`. If the plug-in is unnamed, no reference is kept.
     *
     * There are two types of plugin installations:
     * * Preinstalled plugins which are installed on the prototype. These are simple API plugins with a `preinstall` method called with the `installPlugins` calling context as the first argument. Preinstallations are automatically performed whenever a grid is instantiated (at the beginning of the constructor), by calling `installPlugins` with `Hypergrid.prototype` as the calling context.
     * * Regular plugins which are installed on the instance. These are simple API plugins with an `install` method, as well as all object API plugins (constructors), called with the `installPlugins` calling context as the first argument. These installations are automatically performed whenever a grid is instantiated (at the end of the constructor), called with the new grid instance as the calling context.
     *
     * Plugins may have both `preinstall` _and_ `install` methods, in which case both will be called. However, note that in any case, `install` methods on object API plugins are ignored.
     *
     * @this {Hypergrid|Hypergrid.prototype}
     * @param {pluginSpec|pluginSpec[]} [plugins] - The plugins to install. This call is a no-op if omitted.
     */
    installPlugins: function(plugins) {
        var shared = this === Hypergrid.prototype; // Do shared ("preinstalled") plugins (if any)

        if (!plugins) {
            return;
        } else if (!Array.isArray(plugins)) {
            plugins = [plugins];
        }

        plugins.forEach(function(plugin) {
            var name, args, hash;

            if (!plugin) {
                return; // ignore falsy plugin spec
            }

            // set first arg to constructor to `this` (the grid instance)
            // set first arg to `install` method to `this` (the grid instance)
            // set first arg to `preinstall` method to `this` (the Hypergrid prototype)
            args = [this];

            if (Array.isArray(plugin)) {
                if (!plugin.length) {
                    plugin = undefined;
                } else if (typeof plugin[0] !== 'string') {
                    args = args.concat(plugin.slice(1));
                    plugin = plugin[0];
                } else if (plugin.length >= 2) {
                    args = args.concat(plugin.slice(2));
                    name = plugin[0];
                    plugin = plugin[1];
                } else {
                    plugin = undefined;
                }
            }

            if (!plugin) {
                return; // ignore empty array or array with single string element
            }

            // Derive API name if not given in pluginSpec
            name = name || plugin.name || plugin.$$CLASS_NAME;
            if (name) {
                // Translate first character to lower case
                name = name.substr(0, 1).toLowerCase() + name.substr(1);
            }

            if (shared) {
                // Execute the `preinstall` method
                hash = this.constructor.plugins;
                if (plugin.preinstall && !hash[name]) {
                    plugin.preinstall.apply(plugin, args);
                }
            } else { // instance plug-ins:
                hash = this.plugins;
                if (typeof plugin === 'function') {
                    // Install "object API" by instantiating
                    args.unshift(null); // context for the `bind` call
                    plugin = new (Function.prototype.bind.apply(plugin, args));
                } else if (plugin.install) {
                    // Install "simple API" by calling its `install` method
                    plugin.install.apply(plugin, args);
                } else if (!plugin.preinstall) {
                    throw new Base.prototype.HypergridError('Expected plugin (a constructor; or an API with a `preinstall` method and/or an `install` method).');
                }
            }

            if (name) {
                hash[name] = plugin;
            }

        }, this);
    },

    /**
     * @summary Uninstall all uninstallable plugins or just named plugins.
     * @desc Calls `uninstall` on plugins that define such a method.
     *
     * To uninstall "preinstalled" plugins, call with `Hypergrid.prototype` as context.
     *
     * For convenience, the following args are passed to the call:
     * * `this` - the plugin to be uninstalled
     * * `grid` - the hypergrid object
     * * `key` - name of the plugin to be uninstalled (_i.e.,_ key in `plugins`)
     * * `plugins` - the plugins hash (a.k.a. `grid.plugins`)
     * @param {string|stirng[]} [pluginNames] If provided, limit uninstall to the named plugin (string) or plugins (string[]).
     */
    uninstallPlugins: function(pluginNames) {
        if (!pluginNames) {
            pluginNames = [];
        } else if (!Array.isArray(pluginNames)) {
            pluginNames = [pluginNames];
        }
        _(this.plugins).each(function(plugin, key, plugins) {
            if (
                plugins.hasOwnProperty(key) &&
                pluginNames.indexOf(key) >= 0 &&
                plugin.uninstall
            ) {
                plugin.uninstall(this, key, plugins);
            }
        }, this);
    },

    getProperties: function() {
        return this.deprecated('getProperties()', 'properties', '1.2.0');
    },

    _getProperties: function() {
        return this.lnfProperties;
    },

    computeCellsBounds: function() {
        this.renderer.computeCellsBounds();
    },

    setFormatter: function(options) {
        options = options || {};
        this.localization = new Localization(
            options.locale || Hypergrid.localization.locale,
            options.numberOptions || Hypergrid.localization.numberOptions,
            options.dateOptions || Hypergrid.localization.dateOptions
        );
    },
    getFormatter: function(localizerName) {
        return this.localization.get(localizerName).format;
    },

    formatValue: function(localizerName, value) {
        var formatter = this.getFormatter(localizerName);
        return formatter(value);
    },

    isRowResizeable: function() {
        return this.properties.rowResize;
    },

    isCheckboxOnlyRowSelections: function() {
        return this.properties.checkboxOnlyRowSelections;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Point} The cell over which the cursor is hovering.
     */
    getHoverCell: function() {
        return this.deprecated('getHoverCell()', 'hoverCell', 'v1.2.0');
    },


    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the cell under the cursor.
     * @param {Point} point
     */
    setHoverCell: function(point) {
        var me = this.hoverCell;
        var newPoint = new Point(point.x, point.y);
        if (me && me.equals(newPoint)) {
            return;
        }
        this.hoverCell = newPoint;
        if (me) { this.fireSyntheticOnCellExitEvent(me); } //Exit first
        this.fireSyntheticOnCellEnterEvent(newPoint);
        this.repaint();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for all hypergrids in this process.
     * @param {object} properties - A simple properties hash.
     */
    addGlobalProperties: function(properties) {
        //we check for existence to avoid race condition in initialization
        if (!globalProperties) {
            var self = this;
            setTimeout(function() {
                self.addGlobalProperties(properties);
            }, 10);
        } else {
            this._addGlobalProperties(properties);
        }

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Amend properties for all hypergrids in this process.
     * @param {object} properties - A simple properties hash.
     * @private
     */
    _addGlobalProperties: function(properties) {
        _(properties).each(function(property, key) {
            globalProperties[key] = property;
        });
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Utility function to push out properties if we change them.
     * @param {object} properties - An object of various key value pairs.
     */
    refreshProperties: function() {
        var state = this.properties;
        this.selectionModel.multipleSelections = state.multipleSelections;

        // this.canvas = this.shadowRoot.querySelector('fin-canvas');
        //this.canvas = new Canvas(this.divCanvas, this.renderer); //TODO: Do we really need to be recreating it here?

        this.computeCellsBounds();
        this.checkScrollbarVisibility();
        this.behavior.defaultRowHeight = null;
        if (this.isColumnAutosizing()) {
            this.behavior.autosizeAllColumns();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Amend properties for this hypergrid only.
     * @param {object} moreProperties - A simple properties hash.
     */
    addProperties: function(moreProperties) {
        var properties = this.properties;
        addDeepProperties(properties, moreProperties);
        this.refreshProperties();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} The state object for remembering our state.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    getPrivateState: function() {
        return this.deprecate('getPrivateState()', 'properties', '1.2.0');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the state object to return to the given user configuration.
     * @param {object} state - A memento object.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    setState: function(state) {
        var self = this;
        this.behavior.setState(state);
        this.refreshProperties();
        setTimeout(function() {
            self.behaviorChanged();
            self.synchronizeScrollingBoundaries();
        }, 100);
    },

    getState: function() {
        return this.behavior.getState();
    },
    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} The initial mouse position on a mouse down event for cell editing or a drag operation.
     * @memberOf Hypergrid.prototype
     */
    getMouseDown: function() {
        var last = this.mouseDown.length - 1;
        if (last < 0) {
            return null;
        }
        return this.mouseDown[last];
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Remove the last item from the mouse down stack.
     */
    popMouseDown: function() {
        if (this.mouseDown.length !== 0) {
            this.mouseDown.length = this.mouseDown.length - 1;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Empty out the mouse down stack.
     */
    clearMouseDown: function() {
        this.mouseDown = [new Point(-1, -1)];
        this.dragExtent = null;
    },

    /**
     * Set the mouse point that initiated a cell edit or drag operation.
     * @param {Point} point
     * @memberOf Hypergrid.prototype
     */
    setMouseDown: function(point) {
        this.mouseDown.push(point);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Point} The extent point of the current drag selection rectangle.
     */
    getDragExtent: function() {
        return this.dragExtent;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set the extent point of the current drag selection operation.
     * @param {Point} point
     */
    setDragExtent: function(point) {
        this.dragExtent = point;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc This function is a callback from the HypergridRenderer sub-component. It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        if (this.cellEditor) {
            this.cellEditor.gridRenderedNotification();
        }
        this.checkColumnAutosizing();
        this.fireSyntheticGridRenderedEvent();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The grid has just been rendered, make sure the column widths are optimal.
     */
    checkColumnAutosizing: function() {
        var behavior = this.behavior;
        behavior.autoSizeRowNumberColumn();
        if (this.isColumnAutosizing() && behavior.checkColumnAutosizing(false)) {
            setTimeout(function() {
                behavior.grid.synchronizeScrollingBoundaries();
            });
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Conditionally copy to clipboard.
     * @desc If we have focus, copy our current selection data to the system clipboard.
     * @param {event} event - The copy system event.
     */
    checkClipboardCopy: function(event) {
        if (this.hasFocus()) {
            event.preventDefault();
            var csvData = this.getSelectionAsTSV();
            event.clipboardData.setData('text/plain', csvData);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have any selections.
     */
    hasSelections: function() {
        if (!this.getSelectionModel) {
            return; // were not fully initialized yet
        }
        return this.selectionModel.hasSelections();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {string} Tab separated value string from the selection and our data.
     */
    getSelectionAsTSV: function() {
        var sm = this.selectionModel;
        if (sm.hasSelections()) {
            var selections = this.getSelectionMatrix();
            selections = selections[selections.length - 1];
            return this.getMatrixSelectionAsTSV(selections);
        } else if (sm.hasRowSelections()) {
            return this.getMatrixSelectionAsTSV(this.getRowSelectionMatrix());
        } else if (sm.hasColumnSelections()) {
            return this.getMatrixSelectionAsTSV(this.getColumnSelectionMatrix());
        }
    },

    getMatrixSelectionAsTSV: function(selections) {
        var result = '';

        //only use the data from the last selection
        if (selections.length) {
            var width = selections.length,
                height = selections[0].length,
                area = width * height,
                lastCol = width - 1,
                //Whitespace will only be added on non-singular rows, selections
                whiteSpaceDelimiterForRow = (height > 1 ? '\n' : '');

            //disallow if selection is too big
            if (area > 20000) {
                alert('selection size is too big to copy to the paste buffer'); // eslint-disable-line no-alert
                return '';
            }

            for (var h = 0; h < height; h++) {
                for (var w = 0; w < width; w++) {
                    result += selections[w][h] + (w < lastCol ? '\t' : whiteSpaceDelimiterForRow);
                }
            }
        }

        return result;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have focus.
     */
    hasFocus: function() {
        return this.getCanvas().hasFocus();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear all the selections.
     */
    clearSelections: function() {
        var dontClearRows = this.isCheckboxOnlyRowSelections();
        this.selectionModel.clear(dontClearRows);
        this.clearMouseDown();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent selection.
     */
    clearMostRecentSelection: function() {
        var dontClearRows = this.isCheckboxOnlyRowSelections();
        this.selectionModel.clearMostRecentSelection(dontClearRows);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent column selection.
     */
    clearMostRecentColumnSelection: function() {
        this.selectionModel.clearMostRecentColumnSelection();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent row selection.
     */
    clearMostRecentRowSelection: function() {
        //this.selectionModel.clearMostRecentRowSelection(); // commented off as per GRID-112
    },

    clearRowSelection: function() {
        this.selectionModel.clearRowSelection();
        this.behavior.dataModel.clearSelectedData();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Select given region.
     * @param {number} ox - origin x
     * @param {number} oy - origin y
     * @param {number} ex - extent x
     * @param {number} ex - extent y
     */
    select: function(ox, oy, ex, ey) {
        if (ox < 0 || oy < 0) {
            //we don't select negative area
            //also this means there is no origin mouse down for a selection rect
            return;
        }
        this.selectionModel.select(ox, oy, ex, ey);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} Given point is selected.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    isSelected: function(x, y) {
        return this.selectionModel.isSelected(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given column is selected anywhere in the entire table.
     * @param {number} y - The row index.
     */
    isCellSelectedInRow: function(y) {
        return this.selectionModel.isCellSelectedInRow(y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given row is selected anywhere in the entire table.
     * @param {number} x - The column index.
     */
    isCellSelectedInColumn: function(x) {
        return this.selectionModel.isCellSelectedInColumn(x);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set the Behavior (model) object for this grid control.
     * @desc This can be done dynamically.
     * @param {object} options - _(See {@link behaviors.JSON#setData}.)_
     * @param {Behavior} [options.behavior=BehaviorJSON] - The behavior (model) can be either a constructor or an instance.
     * @param {dataRowObject[]} [options.data] - _(See {@link behaviors.JSON#setData}.)_
     * @param {pipelineSchema} [options.pipeline] - New pipeline description.
     */
    setBehavior: function(options) {
        var Behavior = options.Behavior || BehaviorJSON;
        this.behavior = new Behavior(this, options);
        this.initCanvas();
        this.initScrollbars();
        this.refreshProperties();
        this.behavior.reindex();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set the underlying datasource.
     * @desc This can be done dynamically.
     * @param {function|object[]} dataRows - May be:
     * * An array of congruent raw data objects.
     * * A function returning same.
     * @param {object} [options] - _(See {@link behaviors.JSON#setData}.)_
     */
    setData: function(dataRows, options) {
        if (!this.behavior) {
            // If we get hear it means:
            // 1. `Behavior` option wasn't given to constructor.
            // 2. `setBehavior` wasn't called explicitly.
            // So we call it now to set the default behavior (by not specifying a `Behavior`) with the unused constructor `pipeline` option.
            this.setBehavior({ pipeline: this.options.pipeline });
        }
        this.behavior.setData(dataRows, options);
        this.behavior.changed();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary _(See {@link Hypergrid.prototype#setData}.)_
     * @desc Binds the data and reshapes the grid (new column objects created)
     * @param {function|object[]} dataRows - May be:
     * * An array of congruent raw data objects.
     * * A function returning same.
     * @param {object} [options]
     */
    updateData: function(dataRows, options){
        if (!this.behavior){
            this.setData(dataRows, options);
        } else {
            this.behavior.updateData(dataRows, options);
            this.behavior.changed();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @param {object} [pipelines] - New pipeline description. _(See {@link dataModels.JSON#setPipeline}.)_
     * @param {object} [options] - _(See {@link dataModels.JSON#setPipeline}.)_
     */
    setPipeline: function(DataSources, options){
        this.behavior.setPipeline(DataSources, options);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc I've been notified that the behavior has changed.
     */
    behaviorChanged: function() {
        if (this.divCanvas) {
            if (this.numColumns !== this.getColumnCount() || this.numRows !== this.getRowCount()) {
                this.numColumns = this.getColumnCount();
                this.numRows = this.getRowCount();
                this.behaviorShapeChanged();
            } else {
                this.behaviorStateChanged();
            }
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorShapeChanged: function() {
        if (this.divCanvas) {
            this.synchronizeScrollingBoundaries();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorStateChanged: function() {
        if (this.divCanvas) {
            this.computeCellsBounds();
            this.repaint();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Rectangle} My bounds.
     */
    getBounds: function() {
        return this.renderer.getBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {string} The value of a lnf property.
     * @param {string} key - A look-and-feel key.
     */
    resolveProperty: function(key) {
        // todo: when we remove this method, also remove forwards from Behavior.js and Renderer.js
        if (!warned.resolveProperty) {
            warned.resolveProperty = true;
            console.warn('resolveProperty(key) deprecated as of v1.2.0 in favor of grid.properties[key] and will be removed in a future version.');
        }
        return this.properties[key];
    },

    repaint: function() {
        var now = this.properties.repaintImmediately;
        var canvas = this.getCanvas();
        if (canvas) {
            if (now === true) {
                canvas.paintNow();
            } else {
                canvas.repaint();
            }
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Paint immediately in this microtask.
     */
    paintNow: function() {
        this.getCanvas().paintNow();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} In HiDPI mode (has an attribute as such).
     */
    useHiDPI: function() {
        return this.properties.useHiDPI !== false;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set the container for a grid instance
     * @private
     */
    setContainer: function(div) {
        this.initContainer(div);
        this.initRenderer();
        // injectGridElements.call(this);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize container
     * @private
     */
    initContainer: function(div) {
        if (typeof div === 'string') {
            div = document.querySelector(div);
        }

        //Default Position and height to ensure DnD works
        if (!div.style.position) {
            div.style.position = null; // revert to stylesheet value
        }

        if (div.clientHeight < 1) {
            div.style.height = null; // revert to stylesheet value
        }

        stylesheet.inject('grid');

        //prevent the default context menu for appearing
        div.oncontextmenu = function(event) {
            event.stopPropagation();
            event.preventDefault();
            return false;
        };

        div.removeAttribute('tabindex');

        div.classList.add('hypergrid-container');
        div.id = div.id || 'hypergrid' + (document.querySelectorAll('.hypergrid-container').length - 1 || '');

        this.div = div;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize drawing surface.
     * @private
     */
    initCanvas: function() {
        if (this.divCanvas) {
            return;
        }

        var self = this,
            margin = this.options.margin || {},
            divCanvas = this.divCanvas = document.createElement('div'),
            style = divCanvas.style;

        style.position = 'absolute';
        style.top = margin.top || 0;
        style.right = margin.right || 0;
        style.bottom = margin.bottom || 0;
        style.left = margin.left || 0;

        this.div.appendChild(divCanvas);

        this.canvas = new Canvas(divCanvas, this.renderer);
        this.canvas.canvas.classList.add('hypergrid');
        this.canvas.canvas.style.backgroundColor = this.properties.lineColor;
        this.canvas.resize();

        function getMouseEvent(e) {
            return Object.defineProperty(
                self.getGridCellFromMousePoint(e.detail.mouse),
                'primitiveEvent',
                {
                    value: e,
                    enumerable: false,
                    configurable: true,
                    writable: true
                }
            );
        }

        this.canvas.resizeNotification = function() {
            self.resized();
        };

        this.addEventListener('fin-canvas-mousemove', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            self.delegateMouseMove(getMouseEvent(e));
        });

        this.addEventListener('fin-canvas-mousedown', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            if (!self.abortEditing()) {
                event.stopPropagation();
                return;
            }
            var mouseEvent = getMouseEvent(e);
            mouseEvent.keys = e.detail.keys;
            self.mouseDownState = mouseEvent;
            self.delegateMouseDown(mouseEvent);
            self.fireSyntheticMouseDownEvent(mouseEvent);
            self.repaint();
        });

        this.addEventListener('fin-canvas-click', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            var mouseEvent = getMouseEvent(e);
            mouseEvent.keys = e.detail.keys; // todo: this was in fin-tap but wasn't here
            self.fireSyntheticClickEvent(mouseEvent);
            self.delegateClick(mouseEvent);
        });

        this.addEventListener('fin-canvas-mouseup', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            self.dragging = false;
            if (self.isScrollingNow()) {
                self.setScrollingNow(false);
            }
            if (self.columnDragAutoScrolling) {
                self.columnDragAutoScrolling = false;
            }
            var mouseEvent = getMouseEvent(e);
            self.delegateMouseUp(mouseEvent);
            if (self.mouseDownState) {
                self.fireSyntheticButtonPressedEvent(self.mouseDownState);
            }
            self.mouseDownState = null;
            self.fireSyntheticMouseUpEvent(mouseEvent);
        });

        this.addEventListener('fin-canvas-dblclick', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            var mouseEvent = getMouseEvent(e);
            self.fireSyntheticDoubleClickEvent(mouseEvent, e);
            self.delegateDoubleClick(mouseEvent);
        });

        this.addEventListener('fin-canvas-drag', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            self.dragging = true;
            self.delegateMouseDrag(getMouseEvent(e));
        });

        this.addEventListener('fin-canvas-keydown', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            self.fireSyntheticKeydownEvent(e);
            self.delegateKeyDown(e);
        });

        this.addEventListener('fin-canvas-keyup', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            self.fireSyntheticKeyupEvent(e);
            self.delegateKeyUp(e);
        });

        this.addEventListener('fin-canvas-wheelmoved', function(e) {
            self.delegateWheelMoved(getMouseEvent(e));
        });

        this.addEventListener('fin-canvas-mouseout', function(e) {
            if (self.properties.readOnly) {
                return;
            }
            self.delegateMouseExit(getMouseEvent(e));
        });

        this.addEventListener('fin-canvas-context-menu', function(e) {
            self.delegateContextMenu(getMouseEvent(e));
        });

        //Register a listener for the copy event so we can copy our selected region to the pastebuffer if conditions are right.
        document.body.addEventListener('copy', function(evt) {
            self.checkClipboardCopy(evt);
        });
    },

    convertViewPointToDataPoint: function(unscrolled) {
        return this.behavior.convertViewPointToDataPoint(unscrolled);
    },

    convertDataPointToViewPoint: function(dataPoint) {
        return this.behavior.convertDataPointToViewPoint(dataPoint);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Add an event listener to me.
     * @param {string} eventName - The type of event we are interested in.
     * @param {function} callback - The event handler.
     */
    addEventListener: function(eventName, callback) {
        var self = this;
        var decorator = function(e) {
            if (self.allowEventHandlers){
                callback(e);
            }
        };
        this.canvas.addEventListener(eventName, decorator);
    },

    allowEvents: function(allow){
        if ((this.allowEventHandlers = !!allow)){
            this.behavior.featureChain.attachChain();
        } else {
            this.behavior.featureChain.detachChain();
        }

        this.behavior.changed();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set for `scrollingNow` field.
     * @param {boolean} isItNow - The type of event we are interested in.
     */
    setScrollingNow: function(isItNow) {
        this.scrollingNow = isItNow;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The `scrollingNow` field.
     */
    isScrollingNow: function() {
        return this.scrollingNow;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The index of the column divider under the mouse coordinates.
     * @param {MouseEvent} mouseEvent - The event to interogate.
     */
    overColumnDivider: function(mouseEvent) {
        return this.renderer.overColumnDivider(mouseEvent.primitiveEvent.detail.mouse.x);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The index of the row divider under the mouse coordinates.
     * @param {MouseEvent} mouseEvent - The event to interogate.
     */
    overRowDivider: function(mouseEvent) {
        return this.renderer.overRowDivider(mouseEvent.primitiveEvent.detail.mouse.y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Switch the cursor for a grid instance.
     * @param {string} cursorName - A well know cursor name.
     * @see [cursor names](http://www.javascripter.net/faq/stylesc.htm)
     */
    beCursor: function(cursorName) {
        if (!cursorName) {
            cursorName = 'default';
        }
        this.div.style.cursor = cursorName;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate the wheel moved event to the behavior.
     * @param {Event} event - The pertinent event.
     */
    delegateWheelMoved: function(event) {
        this.behavior.onWheelMoved(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateMouseExit: function(event) {
        this.behavior.handleMouseExit(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateContextMenu: function(event) {
        this.behavior.onContextMenu(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseMove to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseMove: function(mouseDetails) {
        this.behavior.onMouseMove(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mousedown to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDown: function(mouseDetails) {
        this.behavior.handleMouseDown(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mouseup to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseUp: function(mouseDetails) {
        this.behavior.onMouseUp(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate click to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateClick: function(mouseDetails) {
        this.behavior.onClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mouseDrag to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDrag: function(mouseDetails) {
        this.behavior.onMouseDrag(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc We've been doubleclicked on. Delegate through the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateDoubleClick: function(mouseDetails) {
        this.behavior.onDoubleClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyDown: function(event) {
        this.behavior.onKeyDown(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyUp: function(event) {
        this.behavior.onKeyUp(this, event);
    },

    /**
     * @summary Shut down the current cell editor and save the edited value.
     * @returns {boolean} One of:
     * * `false` - Editing BUT could not abort.
     * * `true` - Not editing OR was editing AND abort was successful.
     * @memberOf Hypergrid.prototype
     */
    stopEditing: function() {
        return !this.cellEditor || this.cellEditor.stopEditing();
    },

    /**
     * @summary Shut down the current cell editor without saving the edited val
     * @returns {boolean} One of:
     * * `false` - Editing BUT could not abort.
     * * `true` - Not editing OR was editing AND abort was successful.
     * @memberOf Hypergrid.prototype
     */
    cancelEditing: function() {
        return !this.cellEditor || this.cellEditor.cancelEditing();
    },

    /**
     * @summary Give cell editor opportunity to cancel (or something) instead of stop .
     * @returns {boolean} One of:
     * * `false` - Editing BUT could not abort.
     * * `true` - Not editing OR was editing AND abort was successful.
     * @memberOf Hypergrid.prototype
     */
    abortEditing: function() {
        return !this.cellEditor || (
            this.cellEditor.abortEditing ? this.cellEditor.abortEditing() : this.cellEditor.stopEditing()
        );
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Rectangle} The pixel coordinates of just the center 'main" data area.
     */
    getDataBounds: function() {
        var b = this.canvas.bounds;
        return new Rectangle(0, 0, b.origin.x + b.extent.x, b.origin.y + b.extent.y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Canvas} Our fin-canvas instance.
     */
    getCanvas: function() {
        return this.canvas;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Open the cell-editor for the cell at the given coordinates.
     * @param {Point} editPoint - The grid cell coordinate mixed with the data row coordinate.
     * @return {undefined|CellEditor} The cellEditor determined from the cell's render properties, which may be modified by logic added by overriding {@link DataModel#getCellEditorAt|getCellEditorAt}.
     */
    editAt: function(event) {
        var cellEditor;

        if (arguments.length === 2) {
            return this.deprecated('editAt(cellEditor, event)', 'editAt(event)', '1.0.6', arguments);
        }

        this.abortEditing(); // if another editor is open, close it first

        if (
            event.isGridColumn &&
            event.getCellProperty(event.isGridRow ? 'editable' : 'filterable')
        ) {
            this.setMouseDown(event.gridCell);
            this.setDragExtent(new Point(0, 0));

            cellEditor = this.getCellEditorAt(event);
            if (cellEditor) {
                cellEditor.beginEditing();
            }
        }

        return cellEditor;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @param {number} columnIndex - The column index in question.
     * @returns {boolean} The given column is fully visible.
     */
    isColumnVisible: function(columnIndex) {
        return this.renderer.isColumnVisible(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @param {number} r - The raw row index in question.
     * @returns {boolean} The given row is fully visible.
     */
    isDataRowVisible: function(r) {
        return this.renderer.isRowVisible(r);
    },

    /**
     * @todo refac and move to CellEvent
     * @memberOf Hypergrid.prototype
     * @param {number} c - The column index in question.
     * @param {number} rn - The grid row index in question.
     * @returns {boolean} The given cell is fully is visible.
     */
    isDataVisible: function(c, rn) {
        return this.isDataRowVisible(rn) && this.isColumnVisible(c);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll in the `offsetX` direction if column index `colIndex` is not visible.
     * @param {number} colIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     * @return {boolean} Column is visible.
     */
    insureModelColIsVisible: function(colIndex, offsetX) {
        var maxCols = this.getColumnCount() - 1, // -1 excludes partially visible columns
            indexToCheck = colIndex + (offsetX > 0),
            visible = !this.isColumnVisible(indexToCheck) || colIndex === maxCols;

        if (visible) {
            //the scroll position is the leftmost column
            this.scrollBy(offsetX, 0);
        }

        return visible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll in the `offsetY` direction if column index c is not visible.
     * @param {number} rowIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     * @return {boolean} Row is visible.
     */
    insureModelRowIsVisible: function(rowIndex, offsetY) {
        var maxRows = this.getRowCount() - 1, // -1 excludes partially visible rows
            indexToCheck = rowIndex + (offsetY > 0),
            visible = !this.isDataRowVisible(indexToCheck) || rowIndex === maxRows;

        if (visible) {
            //the scroll position is the topmost row
            this.scrollBy(0, offsetY);
        }

        return visible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll horizontal and vertically by the provided offsets.
     * @param {number} offsetX - Scroll in the x direction this much.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollBy: function(offsetX, offsetY) {
        this.scrollHBy(offsetX);
        this.scrollVBy(offsetY);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll vertically by the provided offset.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollVBy: function(offsetY) {
        var max = this.sbVScroller.range.max;
        var oldValue = this.getVScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetY));
        if (newValue !== oldValue) {
            this.setVScrollValue(newValue);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll horizontally by the provided offset.
     * @param {number} offsetX - Scroll in the x direction this much.
     */
    scrollHBy: function(offsetX) {
        var max = this.sbHScroller.range.max;
        var oldValue = this.getHScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetX));
        if (newValue !== oldValue) {
            this.setHScrollValue(newValue);
        }
    },

    scrollToMakeVisible: function(c, r) {
        var delta,
            dw = this.renderer.dataWindow,
            fixedColumnCount = this.properties.fixedColumnCount,
            fixedRowCount = this.properties.fixedRowCount;

        if (
            c >= fixedColumnCount && // scroll only if target not in fixed columns
            (
                // target is to left of scrollable columns; negative delta scrolls left
                (delta = c - dw.origin.x) < 0 ||

                // target is to right of scrollable columns; positive delta scrolls right
                // Note: The +1 forces right-most column to scroll left (just in case it was only partially in view)
                (delta = c - dw.corner.x + 1) > 0
            )
        ) {
            this.sbHScroller.index += delta;
        }

        if (
            r >= fixedRowCount && // scroll only if target not in fixed rows
            (
                // target is above scrollable rows; negative delta scrolls up
                (delta = r - dw.origin.y) < 0 ||

                // target is below scrollable rows; positive delta scrolls down
                (delta = r - dw.corner.y) > 0
            )
        ) {
            this.sbVScroller.index += delta;
        }
    },

    selectCellAndScrollToMakeVisible: function(c, r) {
        this.selectCell(c, r, true);
        this.scrollToMakeVisible(c, r);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Answer which data cell is under a pixel value mouse point.
     * @param {mousePoint} mouse - The mouse point to interrogate.
     */

    getGridCellFromMousePoint: function(mouse) {
        return this.renderer.getGridCellFromMousePoint(mouse);
    },

    /**
     * @param {Point} gridCell - The pixel location of the mouse in physical grid coordinates.
     * @returns {Rectangle} The pixel based bounds rectangle given a data cell point.
     * @memberOf Hypergrid.prototype
     */
    getBoundsOfCell: function(gridCell) {
        var b = this.renderer.getBoundsOfCell(gridCell.x, gridCell.y);

        //convert to a proper rectangle
        return new Rectangle(b.x, b.y, b.width, b.height);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc This is called by the fin-canvas when a resize occurs.
     */
    resized: function() {
        this.synchronizeScrollingBoundaries();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A click event occurred.
     * @desc Determine the cell and delegate to the behavior (model).
     * @param {MouseEvent} event - The mouse event to interrogate.
     * @returns {boolean|undefined} Changed. Specifically, one of:
     * * `undefined` row had no drill-down control
     * * `true` drill-down changed
     * * `false` drill-down unchanged (was already in requested state)
     */
    cellClicked: function(event) {
        var result = false;

        //click occurred in background area
        if (
            event.gridCell.x <= this.getColumnCount() &&
            event.gridCell.y <= this.getRowCount()
        ) {
            result = this.behavior.cellClicked(event);

            if (result !== undefined) {
                this.behavior.changed();
            }
        }

        return result;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @param {number} c - grid column index.
     * @param {string[]} keys
     */
    fireSyntheticColumnSortEvent: function(c, keys) {
        var event = new CustomEvent('fin-column-sort', {
            detail: {
                column: c,
                keys: keys
            }
        });
        this.canvas.dispatchEvent(event);
    },

    fireSyntheticEditorKeyUpEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-keyup', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent,
                char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyDownEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-keydown', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent,
                char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyPressEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-keypress', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent,
                char: this.canvas.getCharMap()[keyEvent.keyCode][keyEvent.shiftKey ? 1 : 0]
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorDataChangeEvent: function(inputControl, oldValue, newValue) {
        var clickEvent = new CustomEvent('fin-editor-data-change', {
            detail: {
                input: inputControl,
                oldValue: oldValue,
                newValue: newValue
            },
            cancelable: true
        });
        return this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-row-selection-changed` event.
     */
    fireSyntheticRowSelectionChangedEvent: function() {
        var selectionEvent = new CustomEvent('fin-row-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },

    fireSyntheticColumnSelectionChangedEvent: function() {
        var selectionEvent = new CustomEvent('fin-column-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections()
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and dispatch a `fin-selection-changed` event.
     */
    selectionChanged: function() {
        var selectedRows = this.getSelectedRows();
        var selectionEvent = new CustomEvent('fin-selection-changed', {
            detail: {
                rows: selectedRows,
                columns: this.getSelectedColumns(),
                selections: this.selectionModel.getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },

    getRowSelection: function(includeHiddenColumns) {
        var column, rows, getColumn,
            self = this,
            selectedRowIndexes = this.selectionModel.getSelectedRows(),
            numColumns = this.getColumnCount(),
            result = {};

        if (includeHiddenColumns) {
            numColumns += this.getHiddenColumns().length;
            getColumn = this.behavior.getColumn;
        } else {
            getColumn = this.behavior.getActiveColumn;
        }
        getColumn = getColumn.bind(this.behavior);

        for (var c = 0; c < numColumns; c++) {
            column = getColumn(c);
            rows = result[column.name] = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(getValue);
        }

        function getValue(selectedRowIndex, j) {
            var dataRow = self.getRow(selectedRowIndex);
            rows[j] = valOrFunc.call(dataRow, column);
        }

        return result;
    },

    getHiddenColumns: function(){
        //A non in-memory behavior will be more troublesome
        return this.behavior.getHiddenColumns();
    },

    getRowSelectionMatrix: function() {
        var self = this,
            selectedRowIndexes = this.selectionModel.getSelectedRows(),
            numCols = this.getColumnCount(),
            result = new Array(numCols);

        for (var c = 0; c < numCols; c++) {
            var column = this.behavior.getActiveColumn(c);
            result[c] = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(getValue);
        }

        function getValue(selectedRowIndex, r) {
            var dataRow = self.getRow(selectedRowIndex);
            result[c][r] = valOrFunc.call(dataRow, column);
        }

        return result;
    },

    getColumnSelectionMatrix: function() {
        var dataRow,
            self = this,
            headerRowCount = this.getHeaderRowCount(),
            selectedColumnIndexes = this.getSelectedColumns(),
            numRows = this.getRowCount(),
            result = new Array(selectedColumnIndexes.length);

        selectedColumnIndexes.forEach(function(selectedColumnIndex, c) {
            var column = self.behavior.getActiveColumn(selectedColumnIndex),
                values = result[c] = new Array(numRows);

            for (var r = headerRowCount; r < numRows; r++) {
                dataRow = self.getRow(r);
                values[r] = valOrFunc.call(dataRow, column);
            }
        });

        return result;
    },

    getColumnSelection: function() {
        var dataRow,
            self = this,
            headerRowCount = this.getHeaderRowCount(),
            selectedColumnIndexes = this.getSelectedColumns(),
            result = {},
            rowCount = this.getRowCount();

        selectedColumnIndexes.forEach(function(selectedColumnIndex) {
            var column = self.behavior.getActiveColumn(selectedColumnIndex),
                values = result[column.name] = new Array(rowCount);

            for (var r = headerRowCount; r < rowCount; r++) {
                dataRow = self.getRow(r);
                values[r] = valOrFunc.call(dataRow, column);
            }
        });

        return result;
    },

    getSelection: function() {
        var dataRow,
            self = this,
            selections = this.getSelections(),
            rects = new Array(selections.length);

        selections.forEach(getRect);

        function getRect(selectionRect, i) {
            var rect = normalizeRect(selectionRect),
                colCount = rect.extent.x + 1,
                rowCount = rect.extent.y + 1,
                columns = {};

            for (var c = 0, x = rect.origin.x; c < colCount; c++, x++) {
                var column = self.behavior.getActiveColumn(x),
                    values = columns[column.name] = new Array(rowCount);

                for (var r = 0, y = rect.origin.y; r < rowCount; r++, y++) {
                    dataRow = self.getRow(y);
                    values[r] = valOrFunc.call(dataRow, column);
                }
            }

            rects[i] = columns;
        }

        return rects;
    },

    getSelectionMatrix: function() {
        var dataRow,
            self = this,
            selections = this.getSelections(),
            rects = new Array(selections.length);

        selections.forEach(getRect);

        function getRect(selectionRect, i) {
            var rect = normalizeRect(selectionRect),
                colCount = rect.extent.x + 1,
                rowCount = rect.extent.y + 1,
                rows = [];

            for (var c = 0, x = rect.origin.x; c < colCount; c++, x++) {
                var values = rows[c] = new Array(rowCount),
                    column = self.behavior.getActiveColumn(x);

                for (var r = 0, y = rect.origin.y; r < rowCount; r++, y++) {
                    dataRow = self.getRow(y);
                    values[r] = valOrFunc.call(dataRow, column);
                }
            }

            rects[i] = rows;
        }

        return rects;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-context-menu` event
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticContextMenuEvent: function(event) {
        event.rows = this.getSelectedRows();
        event.columns = this.getSelectedColumns();
        event.selections = this.selectionModel.getSelections();
        this.canvas.dispatchEvent(
            new CustomEvent('fin-context-menu', { detail: event })
        );
    },

    fireSyntheticMouseUpEvent: function(event) {
        event.rows = this.getSelectedRows();
        event.columns = this.getSelectedColumns();
        event.selections = this.selectionModel.getSelections();
        this.canvas.dispatchEvent(
            new CustomEvent('fin-mouseup', { detail: event })
        );
    },

    fireSyntheticMouseDownEvent: function(event) {
        event.rows = this.getSelectedRows();
        event.columns = this.getSelectedColumns();
        event.selections = this.selectionModel.getSelections();
        this.canvas.dispatchEvent(
            new CustomEvent('fin-mousedown', { detail: event })
        );
    },

    isViewableButton: function(c, r) {
        return this.renderer.isViewableButton(c, r);
    },

    fireSyntheticButtonPressedEvent: function(event) {
        if (this.isViewableButton(event.dataCell.x, event.gridCell.y)) {
            this.canvas.dispatchEvent(
                new CustomEvent('fin-button-pressed', { detail: event })
            );
        }
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-column-drag-start` event.
     */
    fireSyntheticOnColumnsChangedEvent: function() {
        var detail = {
            time: Date.now(),
            grid: this
        };
        var cEvent = new CustomEvent('fin-column-changed-event', {
            detail: detail
        });
        this.canvas.dispatchEvent(cEvent);
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-keydown` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeydownEvent: function(keyEvent) {
        var clickEvent = new CustomEvent('fin-keydown', {
            detail: keyEvent.detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-keyup` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeyupEvent: function(keyEvent) {
        var clickEvent = new CustomEvent('fin-keyup', {
            detail: keyEvent.detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticFilterAppliedEvent: function() {
        var filterEvent = new CustomEvent('fin-filter-applied');
        this.canvas.dispatchEvent(filterEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-enter` event
     * @param {Point} cell - The pixel location of the cell in which the click event occurred.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellEnterEvent: function(cell) {
        var detail = {
            gridCell: cell,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-cell-enter', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-exit` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellExitEvent: function(cell) {
        var detail = {
            gridCell: cell,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-cell-exit', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-click` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticClickEvent: function(mouseEvent) {
        var cell = mouseEvent.gridCell;
        var detail = {
            gridCell: cell,
            mousePoint: mouseEvent.mousePoint,
            keys: mouseEvent.keys,
            primitiveEvent: mouseEvent,
            time: Date.now(),
            grid: this
        };
        this.behavior.enhanceDoubleClickEvent(detail);
        var clickEvent = new CustomEvent('fin-click', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-double-click` event.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticDoubleClickEvent: function(mouseEvent) {
        if (!this.abortEditing()) { return; }
        var cell = mouseEvent.gridCell;
        var detail = {
            gridCell: cell,
            mousePoint: mouseEvent.mousePoint,
            time: Date.now(),
            grid: this
        };
        this.behavior.enhanceDoubleClickEvent(mouseEvent);
        var clickEvent = new CustomEvent('fin-double-click', {
            detail: detail
        });
        this.behavior.cellDoubleClicked(cell, mouseEvent);
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a rendered event.
     */
    fireSyntheticGridRenderedEvent: function() {
        var event = new CustomEvent('fin-grid-rendered', {
            detail: {
                source: this,
                time: Date.now()
            }
        });
        if (this.canvas) {
            this.canvas.dispatchEvent(event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a scroll event.
     * @param {string} type - Should be either `fin-scroll-x` or `fin-scroll-y`.
     * @param {number} oldValue - The old scroll value.
     * @param {number} newValue - The new scroll value.
     */
    fireScrollEvent: function(type, oldValue, newValue) {
        var event = new CustomEvent(type, {
            detail: {
                oldValue: oldValue,
                value: newValue,
                time: Date.now()
            }
        });
        this.canvas.dispatchEvent(event);

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the vertical scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setVScrollValue: function(y) {
        var self = this;
        y = Math.min(this.sbVScroller.range.max, Math.max(0, Math.round(y)));
        if (y !== this.vScrollValue) {
            this.behavior._setScrollPositionY(y);
            var oldY = this.vScrollValue;
            this.vScrollValue = y;
            this.scrollValueChangedNotification();
            setTimeout(function() {
                // self.sbVRangeAdapter.subjectChanged();
                self.fireScrollEvent('fin-scroll-y', oldY, y);
            });
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @return {number} The vertical scroll value.
     */
    getVScrollValue: function() {
        return this.vScrollValue;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the horizontal scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setHScrollValue: function(x) {
        var self = this;
        x = Math.min(this.sbHScroller.range.max, Math.max(0, Math.round(x)));
        if (x !== this.hScrollValue) {
            this.behavior._setScrollPositionX(x);
            var oldX = this.hScrollValue;
            this.hScrollValue = x;
            this.scrollValueChangedNotification();
            setTimeout(function() {
                //self.sbHRangeAdapter.subjectChanged();
                self.fireScrollEvent('fin-scroll-x', oldX, x);
                //self.synchronizeScrollingBoundries(); // todo: Commented off to prevent the grid from bouncing back, but there may be repurcussions...
            });
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns The vertical scroll value.
     */
    getHScrollValue: function() {
        return this.hScrollValue;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Request input focus.
     */
    takeFocus: function() {
        var wasCellEditor = this.cellEditor;
        this.stopEditing();
        if (!wasCellEditor) {
            this.getCanvas().takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Request focus for our cell editor.
     */
    editorTakeFocus: function() {
        if (this.cellEditor) {
            return this.cellEditor.takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Initialize the scroll bars.
     */
    initScrollbars: function() {
        if (this.sbHScroller && this.sbVScroller){
            return;
        }

        var self = this;

        var horzBar = new FinBar({
            orientation: 'horizontal',
            onchange: self.setHScrollValue.bind(self),
            cssStylesheetReferenceElement: this.div
        });

        var vertBar = new FinBar({
            orientation: 'vertical',
            onchange: self.setVScrollValue.bind(self),
            paging: {
                up: self.pageUp.bind(self),
                down: self.pageDown.bind(self)
            }
        });

        this.sbHScroller = horzBar;
        this.sbVScroller = vertBar;

        var hPrefix = this.properties.hScrollbarClassPrefix;
        var vPrefix = this.properties.vScrollbarClassPrefix;

        if (hPrefix && hPrefix !== '') {
            this.sbHScroller.classPrefix = hPrefix;
        }

        if (vPrefix && vPrefix !== '') {
            this.sbVScroller.classPrefix = vPrefix;
        }

        this.div.appendChild(horzBar.bar);
        this.div.appendChild(vertBar.bar);

        this.resizeScrollbars();
    },

    resizeScrollbars: function() {
        this.sbHScroller.shortenBy(this.sbVScroller).resize();
        //this.sbVScroller.shortenBy(this.sbHScroller);
        this.sbVScroller.resize();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll values have changed, we've been notified.
     */
    setVScrollbarValues: function(max) {
        this.sbVScroller.range = {
            min: 0,
            max: max
        };
    },

    setHScrollbarValues: function(max) {
        this.sbHScroller.range = {
            min: 0,
            max: max
        };
    },

    scrollValueChangedNotification: function() {

        if (this.hScrollValue === this.sbPrevHScrollValue && this.vScrollValue === this.sbPrevVScrollValue) {
            return;
        }

        this.sbPrevHScrollValue = this.hScrollValue;
        this.sbPrevVScrollValue = this.vScrollValue;

        if (this.cellEditor) {
            this.cellEditor.scrollValueChangedNotification();
        }

        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Get data value at given cell.
     * @desc Delegates to the behavior.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     * @param {*} value
     */
    getValue: function(x, y) {
        return this.behavior.getValue.apply(this.behavior, arguments);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set a data value into the behavior (model) at the given point
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    setValue: function(x, y, value) {
        this.behavior.setValue.apply(this.beahvior, arguments);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The data dimensions have changed, or our pixel boundries have changed.
     * Adjust the scrollbar properties as necessary.
     */
    synchronizeScrollingBoundaries: function() {
        var numFixedColumns = this.getFixedColumnCount();
        var numFixedRows = this.getFixedRowCount();

        var numColumns = this.getColumnCount();
        var numRows = this.getRowCount();

        var bounds = this.getBounds();
        if (!bounds) {
            return;
        }

        // 15px padding at bottom and right side
        var scrollableHeight = bounds.height - this.behavior.getFixedRowsMaxHeight() - 15;
        var scrollableWidth = bounds.width - this.behavior.getFixedColumnsMaxWidth() - 15;

        for (
            var columnsWidth = 0, lastPageColumnCount = 0;
            lastPageColumnCount < numColumns && columnsWidth <= scrollableWidth;
            lastPageColumnCount++
        ) {
            columnsWidth += this.getColumnWidth(numColumns - lastPageColumnCount - 1);
        }

        for (
            var rowsHeight = 0, lastPageRowCount = 0;
            lastPageRowCount < numRows && rowsHeight <= scrollableHeight;
            lastPageRowCount++
        ) {
            rowsHeight += this.getRowHeight(numRows - lastPageRowCount - 1);
        }

        // inform scroll bars
        if (this.sbHScroller) {
            var hMax = 1 + Math.max(0, numColumns - numFixedColumns - lastPageColumnCount);
            this.setHScrollbarValues(hMax);
            this.setHScrollValue(Math.min(this.getHScrollValue(), hMax));
        }
        if (this.sbVScroller) {
            var vMax = Math.max(0, numRows - numFixedRows - lastPageRowCount);
            this.setVScrollbarValues(vMax);
            this.setVScrollValue(Math.min(this.getVScrollValue(), vMax));
        }

        //this.getCanvas().resize();
        this.behaviorStateChanged();

        this.resizeScrollbars();
    },
    synchronizeScrollingBoundries: function() {
        this.deprecated('synchronizeScrollingBoundries', 'synchronizeScrollingBoundaries', '1.2.0');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Note that "viewable rows" includes any partially viewable rows.
     * @returns {number} The number of viewable rows.
     */
    getVisibleRows: function() {
        return this.renderer.getVisibleRows();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Note that "viewable columns" includes any partially viewable columns.
     * @returns {number} The number of viewable columns.
     */
    getVisibleColumns: function() {
        return this.renderer.getVisibleColumns();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize the renderer sub-component.
     */
    initRenderer: function() {
        this.renderer = this.renderer || new Renderer(this);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     */
    getColumnWidth: function(columnIndex) {
        return this.behavior.getColumnWidth(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     * @param {number} columnWidth - The width in pixels.
     */
    setColumnWidth: function(columnIndex, columnWidth) {
        if (this.abortEditing()) {
            this.behavior.setColumnWidth(columnIndex, columnWidth);
        }
    },

    getColumnEdge: function(c) {
        return this.behavior.getColumnEdge(c, this.getRenderer());
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The total width of all the fixed columns.
     */
    getFixedColumnsWidth: function() {
        return this.behavior.getFixedColumnsWidth();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The height of the given row
     * @param {number} rowIndex - The untranslated fixed column index.
     */
    getRowHeight: function(rowIndex, dataModel) {
        return this.behavior.getRowHeight(rowIndex, dataModel);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the height of the given row.
     * @param {number} rowIndex - The row index.
     * @param {number} rowHeight - The width in pixels.
     */
    setRowHeight: function(rowIndex, rowHeight, dataModel) {
        if (this.abortEditing()) {
            this.behavior.setRowHeight(rowIndex, rowHeight, dataModel);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The total fixed rows height
     */
    getFixedRowsHeight: function() {
        return this.behavior.getFixedRowsHeight();
    },

    /**
     * Number of _visible_ columns.
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.behavior.getActiveColumnCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of fixed rows.
     */
    getRowCount: function() {
        return this.behavior.getRowCount();
    },

    getUnfilteredRowCount: function() {
        return this.deprecated('getUnfilteredRowCount()', null, '1.2.0', arguments, 'No longer supported');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.behavior.getFixedColumnCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.behavior.getFixedRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary The top left area has been clicked on
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    topLeftClicked: function(mouse) {
        this.behavior.topLeftClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A fixed row has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    rowHeaderClicked: function(mouse) {
        this.behavior.rowHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A fixed column has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    columnHeaderClicked: function(mouse) {
        this.behavior.columnHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc An edit event has occurred. Activate the editor at the given coordinates.
     * @param {number} event.gridCell.x - The horizontal coordinate.
     * @param {number} event.gridCell.y - The vertical coordinate.
     * @param {boolean} [event.primitiveEvent.type]
     * @returns {undefined|CellEditor} The editor object or `undefined` if no editor or editor already open.
     */
    onEditorActivate: function(event) {
        return this.editAt(event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Get the cell editor.
     * @desc Delegates to the behavior.
     * @returns The cell editor at the given coordinates.
     * @param {Point} cellEvent - The grid cell coordinates.
     */
    getCellEditorAt: function(event) {
        return this.behavior.getCellEditorAt(event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Toggle HiDPI support.
     * @desc HiDPI support is now *on* by default.
     * > There used to be a bug in Chrome that caused severe slow down on bit blit of large images, so this HiDPI needed to be optional.
     */
    toggleHiDPI: function() {
        if (this.useHiDPI()) {
            this.removeAttribute('hidpi');
        } else {
            this.setAttribute('hidpi', null);
        }
        this.canvas.resize();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} Te HiDPI ratio.
     */
    getHiDPI: function(ctx) {
        if (window.devicePixelRatio && this.useHiDPI()) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                ctx.mozBackingStorePixelRatio ||
                ctx.msBackingStorePixelRatio ||
                ctx.oBackingStorePixelRatio ||
                ctx.backingStorePixelRatio || 1;

            var ratio = devicePixelRatio / backingStoreRatio;
            return ratio;
        } else {
            return 1;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The width of the given (recently rendered) column.
     * @param {number} colIndex - The column index.
     */
    getRenderedWidth: function(colIndex) {
        return this.renderer.getRenderedWidth(colIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The height of the given (recently rendered) row.
     * @param {number} rowIndex - Tthe row index.
     */
    getRenderedHeight: function(rowIndex) {
        return this.renderer.getRenderedHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Update the cursor under the hover cell.
     */
    updateCursor: function() {
        var cursor = this.behavior.getCursorAt(-1, -1);
        var hoverCell = this.hoverCell;
        if (
            hoverCell &&
            hoverCell.x > -1 &&
            hoverCell.y > -1
        ) {
            var x = hoverCell.x + this.getHScrollValue();
            cursor = this.behavior.getCursorAt(x, hoverCell.y + this.getVScrollValue());
        }
        this.beCursor(cursor);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Repaint the given cell.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     */
    repaintCell: function(x, y) {
        this.renderer.repaintCell(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The user is currently dragging a column to reorder it.
     */
    isDraggingColumn: function() {
        return !!this.renderOverridesCache.dragger;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll up one full page.
     * @returns {number}
     */
    pageUp: function() {
        var rowNum = this.renderer.getPageUpRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll down one full page.
     * @returns {number}
     */
    pageDown: function() {
        var rowNum = this.renderer.getPageDownRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Not yet implemented.
     */
    pageLeft: function() {
        throw 'page left not yet implemented';
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Not yet implemented.
     */
    pageRight: function() {
        throw 'page right not yet implemented';
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object[]} Objects with the values that were just rendered.
     */
    getRenderedData: function() {
        // assumes one row of headers
        var behavior = this.behavior,
            colCount = this.getColumnCount().length,
            rowCount = this.renderer.visibleRows.length,
            headers = new Array(colCount),
            results = new Array(rowCount),
            row;

        headers.forEach(function(header, c) {
            headers[c] = behavior.getActiveColumn(c).header;
        });

        results.forEach(function(result, r) {
            row = results[r] = {
                hierarchy: behavior.getFixedColumnValue(0, r)
            };
            headers.forEach(function(field, c) {
                row[field] = behavior.getValue(c, r);
            });
        });

        return results;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} An object that represents the currently selection row.
     */
    getSelectedRow: function() {
        var sels = this.selectionModel.getSelections();
        if (sels.length) {
            var behavior = this.behavior,
                colCount = this.getColumnCount(),
                topRow = sels[0].origin.y,
                row = {
                    //hierarchy: behavior.getFixedColumnValue(0, topRow)
                };

            for (var c = 0; c < colCount; c++) {
                row[behavior.getActiveColumn(c).header] = behavior.getValue(c, topRow);
            }

            return row;
        }
    },

    fireRequestCellEdit: function(cell, value) {
        var clickEvent = new CustomEvent('fin-request-cell-edit', {
            cancelable: true,
            detail: {
                value: value,
                gridCell: cell,
                time: Date.now()
            }
        });
        return this.canvas.dispatchEvent(clickEvent); //I wasn't cancelled
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a fin-before-cell-edit event.
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} value - The current value.
     * @returns {boolean} Proceed (don't cancel).
     */
    fireBeforeCellEdit: function(cell, oldValue, newValue, control) {
        var clickEvent = new CustomEvent('fin-before-cell-edit', {
            cancelable: true,
            detail: {
                oldValue: oldValue,
                newValue: newValue,
                gridCell: cell,
                time: Date.now(),
                input: control,
                row: this.getRow(cell.y)
            }
        });
        return this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Renderer} sub-component
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} oldValue - The old value.
     * @param {Object} newValue - The new value.
     */
    fireAfterCellEdit: function(cell, oldValue, newValue, control) {
        var clickEvent = new CustomEvent('fin-after-cell-edit', {
            detail: {
                newValue: newValue,
                oldValue: oldValue,
                gridCell: cell,
                time: Date.now(),
                input: control,
                row: this.getRow(cell.y)
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Autosize the column at colIndex for best fit.
     * @param {number} colIndex - The column index to modify at
     */
    autosizeColumn: function(activeColumnIndex) {
        var column = this.behavior.getActiveColumn(activeColumnIndex);
        column.checkColumnAutosizing(true);
        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Enable/disable if this component can receive the focus.
     * @param {boolean} - canReceiveFocus
     */
    setFocusable: function(canReceiveFocus) {
        this.getCanvas().setFocusable(canReceiveFocus);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of columns that were just rendered
     */
    getVisibleColumnsCount: function() {
        return this.renderer.getVisibleColumnsCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of rows that were just rendered
     */
    getVisibleRowsCount: function() {
        return this.renderer.getVisibleRowsCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Update the size of a grid instance.
     */
    updateSize: function() {
        this.canvas.checksize();
    },


    /**
     * @memberOf Hypergrid.prototype
     * @desc Stop the global repainting flag thread.
     */
    stopPaintThread: function() {
        this.canvas.stopPaintThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Stop the global resize check flag thread.
     */
    stopResizeThread: function() {
        this.canvas.stopResizeThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Restart the global resize check flag thread.
     */
    restartResizeThread: function() {
        this.canvas.restartResizeThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Restart the global repainting check flag thread.
     */
    restartPaintThread: function() {
        this.canvas.restartPaintThread();
    },

    swapColumns: function(source, target) {
        //Turns out this is called during dragged 'i.e' when the floater column is reshuffled
        //by the currently dragged column. The column positions are constantly reshuffled
        this.behavior.swapColumns(source, target);
    },

    endDragColumnNotification: function() {
        this.behavior.endDragColumnNotification();
    },

    getFixedColumnsMaxWidth: function() {
        return this.behavior.getFixedColumnsMaxWidth();
    },

    isMouseDownInHeaderArea: function() {
        var headerRowCount = this.getHeaderRowCount();
        var mouseDown = this.getMouseDown();
        return mouseDown.x < 0 || mouseDown.y < headerRowCount;
    },

    isHeaderWrapping: function() {
        return this.properties.headerTextWrapping;
    },

    _getBoundsOfCell: function(x, y) {
        return this.deprecated('_getBoundsOfCell()', 'getBoundsOfCell()', '1.2.0', arguments);
    },

    /**
     * @param {index} x - Data x coordinate.
     * @return {Object} The properties for a specific column.
     * @memberOf Hypergrid.prototype
     */
    getColumnProperties: function(x) {
        return this.behavior.getColumnProperties(x);
    },

    /**
     * @param {index} x - Data x coordinate.
     * @return {Object} The properties for a specific column.
     * @memberOf Hypergrid.prototype
     */
    setColumnProperties: function(x, properties) {
        this.behavior.setColumnProperties(x, properties);
    },

    moveSingleSelect: function(x, y) {
        this.behavior.moveSingleSelect(this, x, y);
    },

    selectCell: function(x, y, silent) {
        var dontClearRows = this.isCheckboxOnlyRowSelections();
        this.selectionModel.clear(dontClearRows);
        this.selectionModel.select(x, y, 0, 0, silent);
    },

    toggleSelectColumn: function(x, keys) {
        keys = keys || [];
        var model = this.selectionModel;
        var alreadySelected = model.isColumnSelected(x);
        var hasCTRL = keys.indexOf('CTRL') > -1;
        var hasSHIFT = keys.indexOf('SHIFT') > -1;
        if (!hasCTRL && !hasSHIFT) {
            model.clear();
            if (!alreadySelected) {
                model.selectColumn(x);
            }
        } else {
            if (hasCTRL) {
                if (alreadySelected) {
                    model.deselectColumn(x);
                } else {
                    model.selectColumn(x);
                }
            }
            if (hasSHIFT) {
                model.clear();
                model.selectColumn(this.lastEdgeSelection[0], x);
            }
        }
        if (!alreadySelected && !hasSHIFT) {
            this.lastEdgeSelection[0] = x;
        }
        this.repaint();
        this.fireSyntheticColumnSelectionChangedEvent();
    },

    toggleSelectRow: function(y, keys) {
        //we can select the totals rows if they exist, but not rows above that
        keys = keys || [];

        var sm = this.selectionModel;
        var alreadySelected = sm.isRowSelected(y);
        var hasSHIFT = keys.indexOf('SHIFT') >= 0;

        if (alreadySelected) {
            sm.deselectRow(y);
        } else {
            this.singleSelect();
            sm.selectRow(y);
        }

        if (hasSHIFT) {
            sm.clear();
            sm.selectRow(this.lastEdgeSelection[1], y);
        }

        if (!alreadySelected && !hasSHIFT) {
            this.lastEdgeSelection[1] = y;
        }

        this.repaint();
    },

    singleSelect: function() {
        var isCheckboxOnlyRowSelections = this.isCheckboxOnlyRowSelections(),
            isSingleRowSelectionMode = this.isSingleRowSelectionMode(),
            hasCTRL = false,
            result;

        if (this.mouseDownState){
            //triggered programmatically
            hasCTRL = this.mouseDownState.primitiveEvent.detail.primitiveEvent.ctrlKey;
        }

        result = (
            isCheckboxOnlyRowSelections && isSingleRowSelectionMode ||
            !isCheckboxOnlyRowSelections && (!hasCTRL || isSingleRowSelectionMode)
        );

        if (result) {
            this.selectionModel.clearRowSelection();
        }

        return result;
    },

    selectViewportCell: function(x, y) {
        var headerRowCount = this.getHeaderRowCount(),
            realX = this.renderer.visibleColumns[x].ColumnIndex, // todo refac
            realY = this.renderer.visibleRows[y].rowIndex; // todo refac
        this.clearSelections();
        this.select(realX, realY + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(realX, realY + headerRowCount)); // todo refac
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToViewportCell: function(x, y) {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var headerRowCount = this.getHeaderRowCount(),
                realX = this.renderer.visibleColumns[x].columnIndex, // todo refac
                realY = this.renderer.visibleRows[y].rowIndex + headerRowCount, // todo refac
                selection = selections[0],
                origin = selection.origin;
            this.setDragExtent(this.newPoint(realX - origin.x, realY - origin.y));
            this.select(origin.x, origin.y, realX - origin.x, realY - origin.y);
            this.repaint();
        }
    },

    selectFinalCellOfCurrentRow: function() {
        var x = this.getColumnCount() - 1,
            y = this.getSelectedRows()[0],
            headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.scrollBy(this.getColumnCount(), 0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFinalCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0],
                origin = selection.origin,
                extent = selection.extent,
                columnCount = this.getColumnCount();
            this.scrollBy(columnCount, 0);

            this.clearSelections();
            this.select(origin.x, origin.y, columnCount - origin.x - 1, extent.y);

            this.repaint();
        }
    },

    selectFirstCellOfCurrentRow: function() {
        var x = 0,
            y = this.getSelectedRows()[0],
            headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.setHScrollValue(0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFirstCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0],
                origin = selection.origin,
                extent = selection.extent;
            this.clearSelections();
            this.select(origin.x, origin.y, -origin.x, extent.y);
            this.setHScrollValue(0);
            this.repaint();
        }
    },

    selectFinalCell: function() {
        this.selectCell(this.getColumnCount() - 1, this.getRowCount() - 1);
        this.scrollBy(this.getColumnCount(), this.getRowCount());
        this.repaint();
    },

    selectToFinalCell: function() {
        var selections = this.getSelections();
        if (selections && selections.length) {
            var selection = selections[0],
                origin = selection.origin,
                columnCount = this.getColumnCount(),
                rowCount = this.getRowCount();

            this.clearSelections();
            this.select(origin.x, origin.y, columnCount - origin.x - 1, rowCount - origin.y - 1);
            this.scrollBy(columnCount, rowCount);
            this.repaint();
        }
    },

    isShowRowNumbers: function() {
        return this.properties.showRowNumbers;
    },
    isEditable: function() {
        return this.properties.editable === true;
    },

    /**
     * @todo row refac: deprecate in favor of CellEvent.isGridRow
     * @param {integerRowIndex|sectionPoint} rn
     * @returns {boolean}
     */
    isGridRow: function(rn) {
        return rn >= 0 || rn.y >= 0;
    },

    isShowHeaderRow: function() {
        return this.properties.showHeaderRow;
    },
    getHeaderRowCount: function() {
        return this.behavior.getHeaderRowCount();
    },

    isShowFilterRow: function() {
        return this.properties.showFilterRow;
    },

    hasHierarchyColumn: function() {
        return this.behavior.hasHierarchyColumn();
    },
    isHierarchyColumn: function(x) {
        return this.hasHierarchyColumn() && x === 0;
    },
    checkScrollbarVisibility: function() {
        // var hoverClassOver = this.properties.scrollbarHoverOver;
        // var hoverClassOff = this.properties.scrollbarHoverOff;

        // if (hoverClassOff === 'visible') {
        //     this.sbHScroller.classList.remove(hoverClassOver);
        //     this.sbVScroller.classList.remove(hoverClassOff);
        //     this.sbHScroller.classList.add('visible');
        //     this.sbVScroller.classList.add('visible');
        // }
    },
    isColumnOrRowSelected: function() {
        return this.selectionModel.isColumnOrRowSelected();
    },
    selectColumn: function(x1, x2) {
        this.selectionModel.selectColumn(x1, x2);
    },
    selectRow: function(y1, y2) {
        var sm = this.selectionModel;

        if (this.singleSelect()) {
            y1 = y2;
        } else {
            // multiple row selection
            y2 = y2 || y1;
        }

        sm.selectRow(Math.min(y1, y2), Math.max(y1, y2));
    },
    isRowNumberAutosizing: function() {
        return this.properties.rowNumberAutosizing;
    },
    lookupFeature: function(key) {
        return this.behavior.lookupFeature(key);
    },
    getRow: function(y) {
        return this.behavior.getRow(y);
    },
    isCellSelection: function() {
        return this.properties.cellSelection === true;
    },
    isRowSelection: function() {
        return this.properties.rowSelection === true;
    },
    isColumnSelection: function() {
        return this.properties.columnSelection === true;
    },
    isColumnAutosizing: function() {
        return this.properties.columnAutosizing === true;
    },

    selectRowsFromCells: function() {
        if (!this.isCheckboxOnlyRowSelections()) {
            var last,
                hasCTRL = this.mouseDownState.primitiveEvent.detail.primitiveEvent.ctrlKey;

            if (hasCTRL && !this.isSingleRowSelectionMode()) {
                this.selectionModel.selectRowsFromCells(0, hasCTRL);
            } else if ((last = this.selectionModel.getLastSelection())) {
                this.selectRow(null, last.corner.y);
            } else {
                this.clearRowSelection();
            }
        }
    },
    selectColumnsFromCells: function() {
        this.selectionModel.selectColumnsFromCells();
    },
    getSelectedRows: function() {
        return this.behavior.getSelectedRows();
    },
    getSelectedColumns: function() {
        return this.behavior.getSelectedColumns();
    },
    getSelections: function() {
        return this.behavior.getSelections();
    },
    getLastSelectionType: function() {
        return this.selectionModel.getLastSelectionType();
    },
    isInCurrentSelectionRectangle: function(x, y) {
        return this.selectionModel.isInCurrentSelectionRectangle(x, y);
    },
    selectAllRows: function() {
        this.selectionModel.selectAllRows();
    },
    areAllRowsSelected: function() {
        return this.selectionModel.areAllRowsSelected();
    },
    toggleSelectAllRows: function() {
        if (this.areAllRowsSelected()) {
            this.selectionModel.clear();
        } else {
            this.selectAllRows();
        }
        this.repaint();
    },
    isSingleRowSelectionMode: function() {
        return this.properties.singleRowSelectionMode;
    },

    newPoint: function(x, y) {
        return new Point(x, y);
    },
    newRectangle: function(x, y, width, height) {
        return new Rectangle(x, y, width, height);
    },

    /**
     * @summary _Getter_
     * @method
     * @returns {sorterAPI} The grid's currently assigned sorter.
     * @memberOf dataModels.JSON.prototype
     */
    get sorter() {
        return this.behavior.sorter;
    },

    /**
     * @summary _Setter:_ Assign a sorter to the grid.
     * @method
     * @param {sorterAPI|undefined|null} sorter - One of:
     * * A sorter object, turning sorting *ON*.
     * * If `undefined` or `null`, the {@link dataModels.JSON~nullSorter|nullSorter} is reassigned to the grid, turning sorting *OFF.*
     * @memberOf Hypergrid.prototype
     */
    set sorter(sorter) {
        this.behavior.sorter = sorter;
        this.behaviorChanged();
    },

    /**
     * @summary _Getter_
     * @method
     * @returns {dataSourceHelperAPI} The grid's currently assigned filter.
     * @memberOf Hypergrid.prototype
     */
    get filter() {
        return this.behavior.filter;
    },

    /**
     * @summary _Setter:_ Set a grid instance's filter.
     * @desc Requires a filter data source be installed in the transformation pipeline.
     * @method
     * @param {dataSourceHelperAPI|undefined|null} filter - One of:
     * * A filter object, turning filter *ON*.
     * * If `undefined` or `null`, the null filter is reassigned to the grid, turning filtering *OFF.*
     * @memberOf Hypergrid.prototype
     */
    set filter(filter) {
        this.behavior.filter = filter;
        this.behaviorChanged();
    },

    /**
     * @summary Sticky hash of dialog options objects.
     * @desc Each key is a dialog name; the value is the options object for that dialog.
     * The default dialog options object has the key `'undefined'`, which is undefined by default; it is set by calling `setDialogOptions` with no `dialogName` parameter.
     * @private
     */
    dialogOptions: {},

    /**
     * @summary Set and/or return a specific dialog options object *or* a default dialog options object.
     *
     * @desc If `options` defined:
     * * If `dialogName` defined: Save the specific dialog's options object.
     * * If `dialogName` undefined: Save the default dialog options object.
     *
     * If `options` is _not_ defined, no new dialog options object will be saved; but a previously saved preset will be returned (after mixing in the default preset if there is one).
     *
     * The default dialog options object is used in two ways:
     * * when a dialog has no options object
     * * as a mix-in base when a dialog does have an options object
     *
     * @param {string} [dialogName] If undefined, `options` defines the default dialog options object.
     *
     * @param {object} [options] If defined, preset the named dialog options object or the default dialog options object if name is undefined.
     *
     * @returns {object} One of:
     * * When `options` undefined, first of:
     *   * previous preset
     *   * default preset
     *   * empty object
     * * When `options` defined, first of:
     *   * mix-in: default preset members + `options` members
     *   * `options` verbatim when default preset undefined
     */
    setDialogOptions: function(dialogName, options) {
        if (typeof dialogName === 'object') {
            options = dialogName;
            dialogName = undefined;
        }
        var defaultOptions = this.dialogOptions.undefined;
        options = options || dialogName && this.dialogOptions[dialogName];
        if (options) {
            this.dialogOptions[dialogName] = options;
            if (defaultOptions) {
                options = _({}).extend(defaultOptions, options); // make a mix-in
            }
        } else {
            options = defaultOptions || {};
        }
        return options;
    },

    /**
     * Options objects are remembered for subsequent use. Alternatively, they can be preset by calling {@link Hypergrid#setDialogOptions|setDialogOptions}.
     * @param {string} dialogName
     * @param {object} [options] - If omitted, use the options object previously given here (or to {@link Hypergrid#setDialogOptions|setDialogOptions}), if any. In any case, the resultant options object, if any, is mixed into the default options object, if there is one.
     */
    openDialog: function(dialogName, options) {
        if (!this.abortEditing()) { return; }
        options = this.setDialogOptions(dialogName, options);
        options.terminate = function() { // when about-to-be-opened dialog is eventually closed
            delete this.dialog;
        }.bind(this);
        this.dialog = this.behavior.openDialog(dialogName, options);
    },

    // although you can have multiple dialogs open at the same time, the following enforces one at a time (for now)
    toggleDialog: function(newDialogName, options) {
        var dialog = this.dialog,
            oldDialogName = dialog && dialog.$$CLASS_NAME;
        if (!dialog || !this.dialog.close() && oldDialogName !== newDialogName) {
            if (!dialog) {
                // open new dialog now
                this.openDialog(newDialogName, options);
            } else {
                // open new dialog when already-opened dialog finishes closing due to .closeDialog() above
                dialog.terminate = this.openDialog.bind(this, newDialogName, options);
            }
        }
    }
});

function findOrCreateContainer(boundingRect) {
    var div = document.getElementById('hypergrid'),
        used = div && !div.firstElementChild;

    if (!used) {
        div = document.createElement('div');

        if (boundingRect) {
            ['width', 'height', 'position', 'top', 'bottom', 'left', 'right'].forEach(function(style) {
                if (boundingRect[style]) {
                    div.style[style] = boundingRect[style];
                }
            });
        }

        document.body.appendChild(div);
    }

    return div;
}


/**
 * @summary Update deep properties with new values.
 * @desc This function is a recursive property setter which updates a deep property in a destination object with the value of a congruent property in a source object.
 *
 * > Terminology: A deep property is a "terminal node" (primitive value) nested at some depth (i.e., depth > 1) inside a complex object (an object containing nested objects). A congruent property is a property in another object with the same name and at the same level of nesting.
 *
 * This function is simple and elegant. I recommend you study the code, which nonetheless implies all of the following:
 *
 * * If the deep property is _not_ found in `destination`, it will be created.
 * * If the deep property is found in `destination` _and_ is a primitive type, it will be modified (overwritten with the value from `source`).
 * * If the deep property is found in `destination` _but_ is not a primitive type (i.e., is a nested object), it will _also_ be overwritten with the (primitive) value from `source`.
 * * If the nested object the deep property inhabits in `source` is not found in `destination`, it will be created.
 * * If the nested object the deep property inhabits in `source` is found in `destination` but is not in fact an object (i.e., it is a primitive value), it will be overwritten with a reference to that object.
 * * If the primitive value is `undefined`, the destination property is deleted.
 * * `source` may contain multiple properties to update.
 *
 * That one rule is simply this: If both the source _and_ the destination properties are objects, then recurse; else overwrite the destination property with the source property.
 *
 * > Caveat: This is _not_ equivalent to a deep extend function. While both a deep extend and this function will recurse over a complex object, they are fundamentally different: A deep extend clones the nested objects as it finds them; this function merely updates them (or creates them where they don't exist).
 *
 * @param {object} destination - An object to update with new or modified property values
 * @param {object} source - A congruent object continaly (only) the new or modified property values.
 * @returns {object} Always returns `destination`.
 */
function addDeepProperties(destination, source) {
    _(source).each(function(property, key) {
        if (typeof destination[key] === 'object' && typeof property === 'object') {
            addDeepProperties(destination[key], property);
        } else if (property === undefined) {
            delete destination[key];
        } else {
            destination[key] = property;
        }
    });
    return destination;
}

function normalizeRect(rect) {
    var o = rect.origin,
        c = rect.corner,

        ox = Math.min(o.x, c.x),
        oy = Math.min(o.y, c.y),

        cx = Math.max(o.x, c.x),
        cy = Math.max(o.y, c.y);

    return new Rectangle(ox, oy, cx - ox, cy - oy);
}

function buildTheme(theme) {
    clearObjectProperties(theme);
    var pb = document.createElement('paper-button'); // styles were based on old polymer theme

    pb.style.display = 'none';
    pb.setAttribute('disabled', true);
    document.body.appendChild(pb);
    var p = window.getComputedStyle(pb);

    var section = document.createElement('section');
    section.style.display = 'none';
    section.setAttribute('hero', true);
    document.body.appendChild(section);

    var h = window.getComputedStyle(document.querySelector('html'));
    var hb = window.getComputedStyle(document.querySelector('html, body'));
    var s = window.getComputedStyle(section);

    theme.columnHeaderBackgroundColor = p.color;
    theme.rowHeaderBackgroundColor = p.color;
    theme.topLeftBackgroundColor = p.color;
    theme.lineColor = p.backgroundColor;

    theme.backgroundColor2 = hb.backgroundColor;

    theme.color = h.color;
    theme.fontFamily = h.fontFamily;
    theme.backgroundColor = s.backgroundColor;

    pb.setAttribute('disabled', false);
    pb.setAttribute('secondary', true);
    pb.setAttribute('raised', true);
    p = window.getComputedStyle(pb);

    theme.columnHeaderColor = p.color;
    theme.rowHeaderColor = p.color;
    theme.topLeftColor = p.color;


    theme.backgroundSelectionColor = p.backgroundColor;
    theme.foregroundSelectionColor = p.color;

    pb.setAttribute('secondary', false);
    pb.setAttribute('warning', true);

    theme.columnHeaderForegroundSelectionColor = p.color;
    theme.columnHeaderBackgroundSelectionColor = p.backgroundColor;
    theme.rowHeaderForegroundSelectionColor = p.color;
    theme.fixedColumnBackgroundSelectionColor = p.backgroundColor;

    //check if there is actually a theme loaded if not, clear out all bogus values
    //from my cache
    if (theme.columnHeaderBackgroundSelectionColor === 'rgba(0, 0, 0, 0)' ||
        theme.lineColor === 'transparent') {
        clearObjectProperties(theme);
    }

    document.body.removeChild(pb);
    document.body.removeChild(section);

    return theme;
}

function clearObjectProperties(obj) {
    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            delete obj[prop];
        }
    }
}

/**
 * @this {dataRowObject}
 * @param column
 * @returns {string}
 */
function valOrFunc(column) {
    var result, calculator;
    if (this) {
        result = this[column.name];
        calculator = (typeof result)[0] === 'f' && result || column.calculator;
        if (calculator) {
            result = calculator.call(this, column.name);
        }
    }
    return result || result === 0 || result === false ? result : '';
}

/**
 * @summary Hash of references to shared plug-ins.
 * @desc Dictionary of shared (pre-installed) plug-ins. Used internally, primarily to avoid reinstallations. See examples for how to reference (albeit there is normally no need to reference plugins directly).
 *
 * For the dictionary of _instance_ plugins, see {@link Hypergrid#plugins|plugins} (defined in the {@link Hypergrid#intialize|Hypergrid constructor}).
 *
 * To force reinstallation of a shared plugin delete it first:
 * ```javascript
 * delete Hypergrid.plugins.mySharedPlugin;
 * ```
 * To force reinstallation of all shared plugins:
 * ```javascript
 * Hypergrid.plugins = {};
 * ```
 * @example
 * var allSharedPlugins = Hypergrid.plugins;
 * var mySharedPlugin = Hypergrid.plugins.mySharedPlugin;
 * @type {object}
 */
Hypergrid.plugins = {};

/**
 * @summary Shared localization defaults for all grid instances.
 * @desc These property values are overridden by those supplied in the `Hypergrid` constructor's `options.localization`.
 * @property {string|string[]} [locale] - The default locale to use when an explicit `locale` is omitted from localizer constructor calls. Passed to Intl.NumberFormat` and `Intl.DateFormat`. See {@ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation|Locale identification and negotiation} for more information. Omitting will use the runtime's local language and region.
 * @property {object} [numberOptions] - Options passed to `Intl.NumberFormat` for creating the basic "number" localizer.
 * @property {object} [dateOptions] - Options passed to `Intl.DateFormat` for creating the basic "date" localizer.
 * @type {object}
 */

Hypergrid.localization = {
    locale: 'en-US',
    numberOptions: { maximumFractionDigits: 0 }
};

module.exports = Hypergrid;

},{"./Base":49,"./behaviors/JSON":54,"./cellEditors":67,"./cellRenderers":77,"./defaults":86,"./lib/Localization":113,"./lib/Renderer":114,"./lib/SelectionModel":115,"./lib/polyfills":119,"./lib/stylesheet":120,"finbars":9,"fincanvas":10,"object-iterators":42,"rectangular":45}],51:[function(require,module,exports){
/* eslint-env browser */

'use strict';

// Only 1 choice from each block below should be exposed (uncommented):

module.exports = {

	analytics: require('hyper-analytics'), // npm
    // analytics: require('../../hyper-analytics'), // developer

};

},{"hyper-analytics":13}],52:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');
var Point = require('rectangular').Point;

var Base = require('../Base');
var Column = require('./Column');
var cellEventFactory = require('./../lib/cellEventFactory');
var HeaderSubgrid = require('../dataModels/HeaderSubgrid');
var FilterSubgrid = require('../dataModels/FilterSubgrid');
var SummarySubgrid = require('../dataModels/SummarySubgrid');
var dialogs = require('../dialogs');

var noExportProperties = [
    'columnHeader',
    'columnHeaderColumnSelection',
    'filterProperties',
    'rowHeader',
    'rowHeaderRowSelection',
    'rowNumbersProperties',
    'treeColumnProperties',
    'treeColumnPropertiesColumnSelection',
];

var warned = {};

/**
 * @constructor
 * @abstract
 * @desc A sort of "model++." It contains all code/data that's necessary for easily implementing a virtual data source and its manipulation/analytics.
 *
 */
var Behavior = Base.extend('Behavior', {

    /**
     * @desc this is the callback for the plugin pattern of nested tags
     * @param {Hypergrid} grid
     * @param {object} [options] - _(See {@link behaviors.JSON#setData} for additional options.)_
     * @param {DataModels[]} [options.subgrids]
     * @memberOf Behavior.prototype
     */
    initialize: function(grid, options) {
        /**
         * @type {Hypergrid}
         * @memberOf Behavior.prototype
         */
        this.grid = grid;

        this.initializeFeatureChain(grid);

        this.grid.behavior = this;
        this.reset(options);
    },

    /**
     * @desc create the feature chain - this is the [chain of responsibility](http://c2.com/cgi/wiki?ChainOfResponsibilityPattern) pattern.
     * @param {Hypergrid} grid
     * @memberOf Behavior.prototype
     */
    initializeFeatureChain: function(grid) {
        var self = this;

        /**
         * @summary Hash of feature class names.
         * @desc Built here but otherwise not in use.
         * @type {object}
         * @memberOf Behavior.prototype
         */
        this.featureMap = {};

        this.features.forEach(function(FeatureConstructor) {
            var newFeature = new FeatureConstructor;
            self.featureMap[newFeature.$$CLASS_NAME] = newFeature;
            if (self.featureChain) {
                self.featureChain.setNext(newFeature);
            } else {
                /**
                 * @summary Controller chain of command.
                 * @desc Each feature is linked to the next feature.
                 * @type {Feature}
                 * @memberOf Behavior.prototype
                 */
                self.featureChain = newFeature;
            }
        });
        if (this.featureChain) {
            this.featureChain.initializeOn(grid);
        }
    },

    features: [], // override in implementing class unless no features

    reset: function(options) {
        this.clearState();

        if (this.dataModel) {
            this.dataModel.reset();
        } else {
            /**
             * @type {DataModel}
             * @memberOf Behavior.prototype
             */
            this.dataModel = this.getNewDataModel(options);
        }

        // recreate `CellEvent` class so it can set up its internal `grid`, `behavior`, and `dataModel` convenience properties
        this.CellEvent = cellEventFactory(this.grid);

        this.dataUpdates = {}; //for overriding with edit values;
        this.scrollPositionX = this.scrollPositionY = 0;
        this.clearColumns();
        this.clearState();
        this.createColumns();

        this.subgrids = options.subgrids || [
            HeaderSubgrid,
            FilterSubgrid,
            [SummarySubgrid, { name: 'topTotals' }],
            this.dataModel,
            [SummarySubgrid, { name: 'bottomTotals' }]
        ];
    },

    get renderedColumnCount() {
        return this.grid.renderer.visibleColumns.length;
    },

    get renderedRowCount() {
        return this.grid.renderer.visibleRows.length;
    },

    clearColumns: function() {
        /**
         * @type {Column[]}
         * @memberOf Behavior.prototype
         */
        this.columns = [];

        /**
         * @type {Column[]}
         * @memberOf Behavior.prototype
         */
        this.allColumns = [];

        this.allColumns[-1] = this.columns[-1] = this.newColumn({ index: -1 });
        this.allColumns[-2] = this.columns[-2] = this.newColumn({ index: -2 });

        this.columnEnum = {};
    },

    getActiveColumn: function(x) {
        return this.columns[x];
    },

    /**
     * The "grid index" given a "data index" (or column object)
     * @param {Column|number} columnOrIndex
     * @returns {undefined|number} The grid index of the column or undefined if column not in grid.
     */
    getActiveColumnIndex: function(columnOrIndex) {
        var index = columnOrIndex instanceof Column ? columnOrIndex.index : columnOrIndex;
        for (var i = 0; i < this.columns.length; ++i) {
            if (this.columns[i].index === index) {
                return i;
            }
        }
    },

    getVisibleColumn: function() {
        return this.deprecated('getVisibleColumn(x)', 'getActiveColumn(x)', '1.0.6', arguments);
    },
    getVisibleColumnName: function() {
        return this.deprecated('getVisibleColumnName(x)', 'getActiveColumn(x).name', '1.0.6', arguments);
    },
    getColumnId: function() {
        return this.deprecated('getColumnId(x)', 'getActiveColumn(x).header', '1.0.6', arguments);
    },
    getHeader: function() {
        return this.deprecated('getHeader(x)', 'getActiveColumn(x).header', '1.0.6', arguments);
    },

    getColumn: function(x) {
        return this.allColumns[x];
    },

    newColumn: function(options) {
        return new Column(this, options);
    },

    addColumn: function(options) {
        var column = this.newColumn(options);
        this.columns.push(column);
        this.allColumns.push(column);
        return column;
    },

    createColumns: function() {
        //concrete implementation here
    },

    getColumnWidth: function(x) {
        var column = this.getActiveColumn(x);
        if (!column) {
            return this.grid.properties.defaultColumnWidth;
        }
        var width = column.getWidth();
        return width;
    },

    setColumnWidth: function(x, width) {
        this.getActiveColumn(x).setWidth(width);
        this.stateChanged();
    },

    getCellRenderer: function(config, cellEvent) {
        return cellEvent.column.getCellRenderer(config, cellEvent);
    },
    getCellProvider: function(name) {
        return this.deprecated('getCellProvider()', 'grid.cellRenderers', '1.0.6', arguments);
    },
    createCellProvider: function(name) {
        console.error('getCellProvider() is deprecated as of v1.0.6. No replacement; do not call. Previously called by `Behavior` constructor; `new CellRenderers()` is now called by `Hypergrid` constructor instead.', arguments);
    },

    /**
     * @deprecated
     * @memberOf Behavior.prototype
     */
    applyAnalytics: function() {
        this.dataModel.reindex();
        this.shapeChanged();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc utility function to empty an object of its members
     * @param {object} obj - the object to empty
     * @param {boolean} [exportProps]
     * * `undefined` (omitted) - delete *all* properties
     * * **falsy** - delete *only* the export properties
     * * **truthy** - delete all properties *except* the export properties
     */
    clearObjectProperties: function(obj, exportProps) {
        for (var key in obj) {
            if (
                obj.hasOwnProperty(key) && (
                    exportProps === undefined ||
                    !exportProps && noExportProperties.indexOf(key) >= 0 ||
                    exportProps && noExportProperties.indexOf(key) < 0
                )
            ) {
                delete obj[key];
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc getter for a [Memento](http://c2.com/cgi/wiki?MementoPattern) Object
     * @returns {object}
     */
    getPrivateState: function() {
        return this.deprecate('getPrivateState()', 'grid.properties', '1.2.0');
    },

    //this is effectively a clone, with certain things removed....
    getState: function() {
        var copy = JSON.parse(JSON.stringify(this.grid.properties));
        this.clearObjectProperties(copy.columnProperties, false);
        return copy;
    },
    /**
     * @memberOf Behavior.prototype
     * @desc clear all table state
     */
    clearState: function() {
        /**
         * memento for the user configured visual properties of the table
         * @type {object}
         * @memberOf Behavior.prototype
         */
        this.grid.properties = this.getDefaultState();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {object} Newly created default empty tablestate.
     */
    getDefaultState: function() {
        var tableProperties = this.grid._getProperties();
        var state = Object.create(tableProperties);

        _(state).extendOwn({
            columnProperties: []
        });

        return state;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Restore this table to a previous state.
     * See the [memento pattern](http://c2.com/cgi/wiki?MementoPattern).
     * @param {Object} memento - an encapsulated representation of table state
     */
    setState: function(memento) {

        if (memento.rowHeights) {
            if (!warned.rowHeights) {
                warned.rowHeights = true;
                console.warn('rowHeights, the hash of row heights you provided to setState method, is no longer supported as of v1.2.0 and will be ignored. Instead use individual calls to setRowHeight(y, height, dataModel) for each row height you wish to set, where y is local zero-based row index within dataModel. The dataModel arg is optional and defaults to this.dataModel; specify to set row heights in other data models, such as header row, filter cell row, individual summary rows, etc.');
            }
        }

        //we don't want to clobber the column properties completely
        if (!memento.columnIndexes) {
            var length = this.dataModel.schema.length;
            memento.columnIndexes = [];
            for (var i = 0; i < length; i++) {
                memento.columnIndexes[i] = i;
            }
        }
        var colProperties = memento.columnProperties;
        delete memento.columnProperties;
        this.clearState();
        var state = this.grid.properties;
        this.createColumns();
        this._setColumnOrder(memento.columnIndexes);
        _(state).extendOwn(memento);
        this.setAllColumnProperties(colProperties);
        memento.columnProperties = colProperties;

        //just to be close/ it's easier on the eyes
        this.setColumnWidth(-1, 24.193359375);
        this.dataModel.reindex();
    },

    setAllColumnProperties: function(properties) {
        properties = properties || [];
        for (var i = 0; i < properties.length; i++) {
            var current = this.grid.properties.columnProperties[i];
            this.clearObjectProperties(current, false);
            _(current).extendOwn(properties[i]);
        }
    },

    _setColumnOrder: function(columnIndexes) {
        if (Array.isArray(columnIndexes)){
            this.columns.length = columnIndexes.length;
            columnIndexes.forEach(function(index, i) {
                this.columns[i] = this.allColumns[index];
            }, this);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Rebuild the column order indexes
     * @param {Array} columnIndexes - list of column indexes
     * @param {Boolean} [silent=false] - whether to trigger column changed event
     */
    setColumnIndexes: function(columnIndexes, silent) {
        var tableState = this.grid.properties;
        this._setColumnOrder(columnIndexes);
        tableState.columnIndexes = columnIndexes;
        this.changed();
        if (!silent) {
            this.grid.fireSyntheticOnColumnsChangedEvent();
        }
    },

    /**
     * @summary Show inactive column(s) or move active column(s).
     *
     * @desc Adds one or several columns to the "active" column list.
     *
     * @param {boolean} [isActiveColumnIndexes=false] - Which list `columnIndexes` refers to:
     * * `true` - The active column list. This can only move columns around within the active column list; it cannot add inactive columns (because it can only refer to columns in the active column list).
     * * `false` - The full column list (as per column schema array). This inserts columns from the "inactive" column list, moving columns that are already active.
     *
     * @param {number|number[]} columnIndexes - Column index(es) into list as determined by `isActiveColumnIndexes`. One of:
     * * **Scalar column index** - Adds single column at insertion point.
     * * **Array of column indexes** - Adds multiple consecutive columns at insertion point.
     *
     * _This required parameter is promoted left one arg position when `isActiveColumnIndexes` omitted._
     *
     * @param {number} [referenceIndex=this.columns.length] - Insertion point, _i.e.,_ the element to insert before. A negative values skips the reinsert. Default is to insert new columns at end of active column list.
     *
     * _Promoted left one arg position when `isActiveColumnIndexes` omitted._
     *
     * @param {boolean} [allowDuplicateColumns=false] - Unless true, already visible columns are removed first.
     *
     * _Promoted left one arg position when `isActiveColumnIndexes` omitted + one position when `referenceIndex` omitted._
     *
     * @memberOf Behavior.prototype
     */
    showColumns: function(isActiveColumnIndexes, columnIndexes, referenceIndex, allowDuplicateColumns) {
        // Promote args when isActiveColumnIndexes omitted
        if (typeof isActiveColumnIndexes === 'number' || Array.isArray(isActiveColumnIndexes)) {
            allowDuplicateColumns = referenceIndex;
            referenceIndex = columnIndexes;
            columnIndexes = isActiveColumnIndexes;
            isActiveColumnIndexes = false;
        }

        var activeColumns = this.columns,
            sourceColumnList = isActiveColumnIndexes ? activeColumns : this.allColumns;

        // Nest scalar index
        if (typeof columnIndexes === 'number') {
            columnIndexes = [columnIndexes];
        }

        var newColumns = columnIndexes
            // Look up columns using provided indexes
            .map(function(index) { return sourceColumnList[index]; })
            // Remove any undefined columns
            .filter(function(column) { return column; });

        // Default insertion point is end (i.e., before (last+1)th element)
        if (typeof referenceIndex !== 'number') {
            allowDuplicateColumns = referenceIndex; // assume reference index was omitted when not a number
            referenceIndex = activeColumns.length;
        }

        // Remove already visible columns and adjust insertion point
        if (!allowDuplicateColumns) {
            newColumns.forEach(function(column) {
                var i = activeColumns.indexOf(column);
                if (i >= 0) {
                    activeColumns.splice(i, 1);
                    if (referenceIndex > i) {
                        --referenceIndex;
                    }
                }
            });
        }

        // Insert the new columns at the insertion point
        if (referenceIndex >= 0) {
            activeColumns.splice.apply(activeColumns, [referenceIndex, 0].concat(newColumns));
        }

        this.grid.properties.columnIndexes = activeColumns.map(function(column) { return column.index; });
    },

    /**
     * @summary Hide active column(s).
     * @desc Removes one or several columns from the "active" column list.
     * @param {boolean} [isActiveColumnIndexes=false] - Which list `columnIndexes` refers to:
     * * `true` - The active column list.
     * * `false` - The full column list (as per column schema array).
     * @param {number|number[]} columnIndexes - Column index(es) into list as determined by `isActiveColumnIndexes`. One of:
     * * **Scalar column index** - Adds single column at insertion point.
     * * **Array of column indexes** - Adds multiple consecutive columns at insertion point.
     *
     * _This required parameter is promoted left one arg position when `isActiveColumnIndexes` omitted._
     * @memberOf Behavior.prototype
     */
    hideColumns: function(isActiveColumnIndexes, columnIndexes) {
        var args = Array.prototype.slice.call(arguments); // Convert to array so we can add an argument (element)
        args.push(-1); // Remove only; do not reinsert.
        this.showColumns.apply(this, args);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc fetch the value for a property key
     * @returns {*} The value of the given property.
     * @param {string} key - a property name
     */
    resolveProperty: function(key) {
        // todo: remove when we remove the deprecated grid.resolveProperty
        return this.grid.resolveProperty(key);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc A specific cell was clicked; you've been notified.
     * @param {Object} event - all event information
     * @return {boolean} Clicked in a drill-down column.
     */
    cellClicked: function(event) {
        if (arguments.length === 2) {
            return this.deprecated('cellClicked(cell, event)', 'cellClicked(event)', '1.2.0', arguments);
        }
        return this.dataModel.cellClicked(event);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc A specific cell was le double-clicked; you've been notified.
     * @param {Point} cell - point of cell coordinates
     * @param {Object} event - all event information
     */
    cellDoubleClicked: function(cell, event) {

    },

    lookupFeature: function(key) {
        return this.featureMap[key];
    },

    /**
     * @param {CellEvent|number} xOrCellEvent - Grid column coordinate.
     * @param {number} [y] - Grid row coordinate. Omit if `xOrCellEvent` is a CellEvent.
     * @memberOf Behavior.prototype
     */
    getValue: function(xOrCellEvent, y) {
        switch (arguments.length) {
            case 1:
                return xOrCellEvent.value;
            case 2:
                return new this.CellEvent(xOrCellEvent, y).value;
        }
    },

    getUnfilteredValue: function(x, y) {
        var column = this.getActiveColumn(x);
        return column && column.getUnfilteredValue(y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @return The data.
     * @param {CellEvent|number} xOrCellEvent - Grid column coordinate.
     * @param {number} [y] - Grid row coordinate. Omit if `xOrCellEvent` is a CellEvent.
     * @param {Object} value - The value to use. _When `y` omitted, promoted to 2nd arg._
     * @return {boolean} Consumed.
     */
    setValue: function(xOrCellEvent, y, value) {
        switch (arguments.length) {
            case 3: xOrCellEvent = new this.CellEvent(xOrCellEvent, y); break;
            case 2: value = y; break;
        }

        xOrCellEvent.value = value;
    },

    getDataValue: function(x, y) {
        return this.deprecated('getDataValue(x, y, value)', 'dataModel.getValue(x, y, value)', '1.1.0', arguments);
    },

    setDataValue: function(x, y, value) {
        return this.deprecated('setDataValue(x, y, value)', 'dataModel.setValue(x, y, value)', '1.1.0', arguments);
    },

    /**
     * @summary Get the cell's own properties object.
     * @desc May be undefined because cells only have their own properties object when at lest one own property has been set.
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @returns {undefined|object} The "own" properties of the cell at x,y in the grid. If the cell does not own a properties object, returns `undefined`.
     * @memberOf Behavior.prototype
     */
    getCellOwnProperties: function(xOrCellEvent, y) {
        switch (arguments.length) {
            case 1:
                return xOrCellEvent.column // xOrCellEvent is cellEvent
                    .getCellOwnProperties(xOrCellEvent.dataCell.y, xOrCellEvent.visibleRow.subgrid);
            case 2:
                return this.getColumn(xOrCellEvent) // xOrCellEvent is x
                    .getCellOwnProperties(y);
        }
    },

    /**
     * @summary Get the properties object for cell.
     * @desc This is the cell's own properties object if found else the column object.
     *
     * If you are seeking a single specific property, consider calling {@link Behavior#getCellProperty} instead.
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @return {object} The properties of the cell at x,y in the grid.
     * @memberOf Behavior.prototype
     */
    getCellProperties: function(xOrCellEvent, y) {
        switch (arguments.length) {
            case 1:
                return xOrCellEvent.column // xOrCellEvent is cellEvent
                    .getCellProperties(xOrCellEvent.dataCell.y, xOrCellEvent.visibleRow.subgrid);
            case 2:
                return this.getColumn(xOrCellEvent) // xOrCellEvent is x
                    .getCellProperties(y);
        }
    },

    /**
     * @summary Return a specific cell property.
     * @desc If there is no cell properties object, defers to column properties object.
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate._ Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {string} key - Name of property to get. _When `y` omitted, this param promoted to 2nd arg._
     * @return {object} The specified property for the cell at x,y in the grid.
     * @memberOf Behavior.prototype
     */
    getCellProperty: function(xOrCellEvent, y, key) {
        switch (arguments.length) {
            case 2:
                return xOrCellEvent.column // xOrCellEvent is cellEvent
                    .getCellProperty(xOrCellEvent.dataCell.y, y, xOrCellEvent.visibleRow.subgrid); // y omitted so y here is actually key
            case 3:
                return this.getColumn(xOrCellEvent) // xOrCellEvent is x
                    .getCellProperty(y, key);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {Object} properties - Hash of cell properties. _When `y` omitted, this param promoted to 2nd arg._
     */
    setCellProperties: function(xOrCellEvent, y, properties) {
        if (typeof y === 'object') {
            xOrCellEvent.column // xOrCellEvent is cellEvent
                .setCellProperties(xOrCellEvent.dataCell.y, y, xOrCellEvent.visibleRow.subgrid); // y omitted so y here is actually properties
        } else {
            this.getColumn(xOrCellEvent) // xOrCellEvent is x
                .setCellProperties(y, properties);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {Object} properties - Hash of cell properties. _When `y` omitted, this param promoted to 2nd arg._
     */
    addCellProperties: function(xOrCellEvent, y, properties) {
        if (typeof y === 'object') {
            xOrCellEvent.column // xOrCellEvent is cellEvent
                .addCellProperties(xOrCellEvent.dataCell.y, y, xOrCellEvent.visibleRow.subgrid); // y omitted so y here is actually properties
        } else {
            this.getColumn(xOrCellEvent) // xOrCellEvent is x
                .addCellProperties(y, properties);
        }
    },

    /**
     * @summary Set a specific cell property.
     * @desc If there is no cell properties object, defers to column properties object.
     * @param {CellEvent|number} xOrCellEvent - Data x coordinate.
     * @param {number} [y] - Grid row coordinate. _Omit when `xOrCellEvent` is a `CellEvent`._
     * @param {string} key - Name of property to get. _When `y` omitted, this param promoted to 2nd arg._
     * @param value
     * @memberOf Behavior.prototype
     */
    setCellProperty: function(xOrCellEvent, y, key, value) {
        switch (arguments.length) {
            case 3:
                return xOrCellEvent.column // xOrCellEvent is cellEvent
                    .setCellProperty(xOrCellEvent.dataCell.y, y, key, xOrCellEvent.visibleRow.subgrid); // y omitted so y here is actually key and key is actually value
            case 4:
                return this.getColumn(xOrCellEvent) // xOrCellEvent is x
                    .setCellProperty(y, key, value);
        }
    },

    /**
     * @summary Gets the number of rows in the hypergrid.
     * @dsc Defined as the sum of all rows from all subgrids.
     * @memberOf Behavior.prototype
     */
    getRowCount: function() {
        return this.subgrids.reduce(function(sum, subgrid) {
            return sum + subgrid.getRowCount();
        }, 0);
    },

    getUnfilteredRowCount: function() {
        return this.deprecated('getUnfilteredRowCount()', null, '1.2.0', arguments, 'No longer supported');
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The height in pixels of the fixed rows area  of the hypergrid.
     */
    getFixedRowsHeight: function() {
        var count = this.getFixedRowCount();
        var total = 0;
        for (var i = 0; i < count; i++) {
            total += this.getRowHeight(i);
        }
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @param {number} rowIndex - Data row coordinate local to datsModel.
     * @param {DataModel} [dataModel=this.dataModel]
     */
    getRowHeight: function(rowIndex, dataModel) {
        var rowData = (dataModel || this.dataModel).getRow(rowIndex);
        return rowData && rowData.__ROW_HEIGHT || this.grid.properties.defaultRowHeight;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The value is lazily initialized and comes from the properties mechanism for '`defaultRowHeight`', which should be ~20px.
     * @returns {number} The row height in pixels.
     */
    getDefaultRowHeight: function() {
        return this.deprecated('getDefaultRowHeight', 'grid.properties.defaultRowHeight', '1.2.0');
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the pixel height of a specific row
     * @param {number} rowIndex - Data row coordinate local to datsModel.
     * @param {number} height - pixel height
     * @param {DataModel} [dataModel=this.dataModel]
     */
    setRowHeight: function(rowIndex, height, dataModel) {
        var rowData = (dataModel || this.dataModel).getRow(rowIndex);
        if (rowData) {
            rowData.__ROW_HEIGHT = Math.max(5, height);
            this.stateChanged();
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc This will allow 'floating' fixed rows.
     * @return {number} The maximum height of the fixed rows area in the hypergrid.
     */
    getFixedRowsMaxHeight: function() {
        return this.getFixedRowsHeight();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The width of the fixed column area in the hypergrid.
     */
    getFixedColumnsWidth: function() {
        var count = this.getFixedColumnCount();
        var total = 0;
        if (this.grid.isShowRowNumbers()) {
            total = this.getColumnWidth(-1);
        }
        for (var i = 0; i < count; i++) {
            total += this.getColumnWidth(i);
        }
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc This exists to support "floating" columns.
     * @return {number} The total width of the fixed columns area.
     */
    getFixedColumnsMaxWidth: function() {
        return this.getFixedColumnsWidth();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the scroll position in vertical dimension and notify listeners.
     * @param {number} y - the new y value
     */
    _setScrollPositionY: function(y) {
        this.setScrollPositionY(y);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the scroll position in horizontal dimension and notify listeners.
     * @param {number} x - the new x value
     */
    _setScrollPositionX: function(x) {
        this.setScrollPositionX(x);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The fixed row area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedRowClicked: function(grid, mouse) {
        var x = this.translateColumnIndex(this.getScrollPositionX() + mouse.gridCell.x - this.getFixedColumnCount());
        var translatedPoint = new Point(x, mouse.gridCell.y);
        mouse.gridCell = translatedPoint;
        this.fixedRowClicked(grid, mouse);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The fixed column area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedColumnClicked: function(grid, mouse) {
        var translatedPoint = new Point(mouse.gridCell.x, this.getScrollPositionY() + mouse.gridCell.y - this.getFixedRowCount());
        mouse.gridCell = translatedPoint;
        this.fixedColumnClicked(grid, mouse);
    },

    moveSingleSelect: function(grid, x, y) {
        if (this.featureChain) {
            this.featureChain.moveSingleSelect(grid, x, y);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate setting the cursor up the feature chain of responsibility
     * @param {Hypergrid} grid
     */
    setCursor: function(grid) {
        grid.updateCursor();
        this.featureChain.setCursor(grid);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse move to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseMove: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseMove(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onClick: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleClick(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onContextMenu: function(grid, event) {
        var proceed = grid.fireSyntheticContextMenuEvent(event);
        if (proceed && this.featureChain) {
            this.featureChain.handleContextMenu(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling wheel moved to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onWheelMoved: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleWheelMoved(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse drag to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseDrag: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDrag(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling key down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling key up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onDoubleClick: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleDoubleClick(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {string[]} [options] - Forwarded to dialog constructor.
     */
    openDialog: function(dialogName, options) {
        return new dialogs[dialogName](this.grid, options);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse exit to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseExit(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc I've been notified that the behavior has changed.
     */
    changed: function() { this.grid.behaviorChanged(); },

    /**
     * @memberOf Behavior.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    shapeChanged: function() { this.grid.behaviorShapeChanged(); },

    /**
     * @memberOf Behavior.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    stateChanged: function() { this.grid.behaviorStateChanged(); },

    /**
     * @memberOf Behavior.prototype
     * @return {boolean} Can re-order columns.
     */
    isColumnReorderable: function() {
        return this.grid.properties.columnsReorderable;
    },

    /**
     * @param {index} x - Data x coordinate.
     * @return {Object} The properties for a specific column.
     * @memberOf Behavior.prototype
     */
    getColumnProperties: function(x) {
        var column = this.getColumn(x);
        return column && column.properties;
    },

    /**
     * @param {index} x - Data x coordinate.
     * @return {Object} The properties for a specific column.
     * @memberOf Behavior.prototype
     */
    setColumnProperties: function(x, properties) {
        var column = this.getColumn(x);
        if (!column) {
            throw 'Expected column.';
        }
        var result = _(column.properties).extendOwn(properties);
        this.changed();
        return result;
    },

    /**
     * Clears all cell properties of given column or of all columns.
     * @param {number} [x] - Omit for all columns.
     */
    clearAllCellProperties: function(x) {
        if (x === undefined) {
            // todo: More efficient might be to undefine `dataModel.getData(*).__META`.
            for (var i = this.allColumns.length - 1; i >= 0; --i) {
                this.getColumn(i).clearAllCellProperties();
            }
        } else {
            var column = this.getColumn(i);
            if (column) {
                column.clearAllCellProperties();
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string[]} All the currently hidden column header labels.
     */
    getHiddenColumnDescriptors: function() {
        var tableState = this.grid.properties;
        var indexes = tableState.columnIndexes;
        var labels = [];
        var columnCount = this.getActiveColumnCount();
        for (var i = 0; i < columnCount; i++) {
            if (indexes.indexOf(i) === -1) {
                var column = this.getActiveColumn(i);
                labels.push({
                    id: i,
                    header: column.header,
                    field: column.name
                });
            }
        }
        return labels;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {integer} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.grid.properties.fixedColumnCount;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the number of fixed columns
     * @param {number} n - the integer count of how many columns to be fixed
     */
    setFixedColumnCount: function(n) {
        this.grid.properties.fixedColumnCount = n;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {integer} The number of fixed rows.
     */
    getFixedRowCount: function() {
        return (
            this.grid.getHeaderRowCount() +
            this.grid.properties.fixedRowCount
        );
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of fixed rows, which includes (top to bottom order):
     * 1. The header rows
     *    1. The header labels row (optional)
     *    2. The filter row (optional)
     *    3. The top total rows (0 or more)
     * 2. The non-scrolling rows (externally called "the fixed rows")
     *
     * @returns {number} Sum of the above or 0 if none of the above are in use.
     *
     * @param {number} The number of rows.
     */
    setFixedRowCount: function(n) {
        this.grid.properties.fixedRowCount = n;
    },

    /**
     * @summary Gets the number of "header rows".
     * @desc Defined as the sum of all rows of all subgrids before the (first) data subgrid.
     * @memberOf behaviors.JSON.prototype
     */
    getHeaderRowCount: function() {
        var result = 0;

        this.subgrids.find(function(subgrid) {
            if (!subgrid.type) {
                return true; // stop
            }
            result += subgrid.getRowCount();
        });

        return result;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc a dnd column has just been dropped, we've been notified
     */
    endDragColumnNotification: function() {},

    /**
     * @memberOf Behavior.prototype
     * @return {null} the cursor at a specific x,y coordinate
     * @param {number} x - the x coordinate
     * @param {number} y - the y coordinate
     */
    getCursorAt: function(x, y) {
        return null;
    },

    /**
     * Number of _visible_ columns.
     * @memberOf Behavior.prototype
     * @return {number} The total number of columns.
     */
    getActiveColumnCount: function() {
        return this.columns.length;
    },
    getColumnCount: function() {
        return this.deprecated('getColumnCount()', 'getActiveColumnCount()', '1.0.6', arguments);
    },

    /**
     * @summary Column alignment of given grid column.
     * @desc One of:
     * * `'left'`
     * * `'center'`
     * * `'right'`
     *
     * Cascades to grid.
     * @memberOf Behavior.prototype
     * @desc Quietly set the horizontal scroll position.
     * @param {number} x - The new position in pixels.
     */
    setScrollPositionX: function(x) {
        /**
         * @memberOf Behavior.prototype
         * @type {number}
         */
        this.scrollPositionX = x;
    },

    getScrollPositionX: function() {
        return this.scrollPositionX;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Quietly set the vertical scroll position.
     * @param {number} y - The new position in pixels.
     */
    setScrollPositionY: function(y) {
        /**
         * @memberOf Behavior.prototype
         * @type {number}
         */
        this.scrollPositionY = y;
    },

    getScrollPositionY: function() {
        return this.scrollPositionY;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {cellEditor} The cell editor for the cell at the given coordinates.
     * @param {CellEvent} editPoint - The grid cell coordinates.
     */
    getCellEditorAt: function(event) {
        return event.isGridColumn && (
            event.isFilterCell
                ? this.grid.cellEditors.create('filterbox', event)
                : event.column.getCellEditorAt(event)
        );
    },

    /**
     * @memberOf Behavior.prototype
     * @return {boolean} `true` if we should highlight on hover
     * @param {boolean} isColumnHovered - the column is hovered or not
     * @param {boolean} isRowHovered - the row is hovered or not
     */
    highlightCellOnHover: function(isColumnHovered, isRowHovered) {
        return isColumnHovered && isRowHovered;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellPropertiesPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a fixed row cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedRowPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a fixed column cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedColumnPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a top left cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellTopLeftPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function enhance the double click event just before it's broadcast to listeners
     * @param {Object} event - event to enhance
     */
    enhanceDoubleClickEvent: function(event) {},

    /**
     * @memberOf Behavior.prototype
     * @desc swap src and tar columns
     * @param {number} src - column index
     * @param {number} tar - column index
     */
    swapColumns: function(source, target) {
        var columns = this.columns;
        var tmp = columns[source];
        columns[source] = columns[target];
        columns[target] = tmp;
        this.changed();
    },

    getColumnEdge: function(c, renderer) {
        return this.dataModel.getColumnEdge(c, renderer);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {object} The object at y index.
     * @param {number} y - the row index of interest
     */
    getRow: function(y) {
        return this.dataModel.getRow(y);
    },

    convertViewPointToDataPoint: function(unscrolled) {
        return new Point(
            this.getActiveColumn(unscrolled.x).index,
            unscrolled.y
        );
    },

    hasHierarchyColumn: function() {
        return false;
    },

    getSelectionMatrixFunction: function(selectedRows) {
        return function() {
            return null;
        };
    },

    autosizeAllColumns: function() {
        this.checkColumnAutosizing(true);
        this.changed();
    },

    checkColumnAutosizing: function(force) {
        force = force === true;
        this.autoSizeRowNumberColumn();
        var autoSized = this.allColumns[-2].checkColumnAutosizing(force);
        this.allColumns.forEach(function(column) {
            autoSized = column.checkColumnAutosizing(force) || autoSized;
        });
        return autoSized;
    },

    autoSizeRowNumberColumn: function() {
        if (this.grid.isRowNumberAutosizing()) {
            this.allColumns[-1].checkColumnAutosizing(true);
        }
    },

    /**
     * @summary _Getter_
     * @method
     * @returns {dataSourceHelperAPI} The grid's currently assigned filter.
     * @memberOf Behavior.prototype
     */
    get filter() {
        return this.dataModel.filter;
    },

    /**
     * @summary _Setter:_ Assign a filter to the grid.
     * @method
     * @param {dataSourceHelperAPI|undefined|null} filter - One of:
     * * A filter object, turning filter *ON*.
     * * If `undefined` or `null`, the null filter is reassigned to the grid, turning filtering *OFF*.
     * @memberOf Behavior.prototype
     */
    set filter(filter) {
        this.dataModel.filter = filter;
    },

    /**
     * @summary _Getter_
     * @method
     * @returns {sorterAPI} The grid's currently assigned sorter.
     * @memberOf dataModels.JSON.prototype
     */
    get sorter() {
        return this.dataModel.sorter;
    },

    /**
     * @summary _Setter:_ Assign a sorter to the grid.
     * @method
     * @param {sorterAPI|undefined|null} sorter - One of:
     * * A sorter object, turning sorting *ON*.
     * * If `undefined` or `null`, the {@link dataModels.JSON~nullSorter|nullSorter} is reassigned to the grid, turning sorting *OFF.*
     * @memberOf Hypergrid.prototype
     */
    set sorter(sorter) {
        this.dataModel.sorter = sorter;
    },

    getSelectedRows: function() {
        return this.grid.selectionModel.getSelectedRows();
    },

    getSelectedColumns: function() {
        return this.grid.selectionModel.getSelectedColumns();
    },

    getSelections: function() {
        return this.grid.selectionModel.getSelections();
    },

    getData: function() {
        return this.dataModel.getData();
    },

    getFilteredData: function() {
        return this.deprecated('getIndexedData()', 'getIndexedData', '1.2.0', arguments);
    },
    getIndexedData: function() {
       this.dataModel.getIndexedData();
    },

    /**
     * An array where each element represents a subgrid to be rendered in the hypergrid.
     *
     * The list should always include at least one "data" subgrid, typically {@link Behavior#dataModel|dataModel}.
     * It may also include zero or more other types of subgrids such as header, filter, and summary subgrids.
     *
     * This object also serves as a dictionary of selected subgrids by name (i.e., for those subgrids that have a defined property `name`).
     *
     * The setter:
     * * "Enlivens" any constructors
     * * Reconstructs the dictionary
     * * Calls {@link Behavior#shapeChanged|shpaeChanged()}.
     *
     * @type {DataModel[]}
     * @memberOf Behavior.prototype
     */
    set subgrids(subgrids) {
        this._subgrids = subgrids = subgrids.map(enlivenSubgrids, this);

        subgrids.forEach(function(subgrid) {
            subgrids[subgrid.name || subgrid.type || 'data'] = subgrid;
        });

        this.shapeChanged();
    },
    get subgrids() {
        return this._subgrids;
    }
});

/**
 *
 * @param {DataModel|Array|function|undefined|null} [subgridSpec] - One of:
 * * `DataModel` - Mapped to self (passed through as is).
 * * `Array` - Mapped to newly instantiated data model: First element is assumed to be a `DataModel` constructor to be called with `new` keyword and `this.grid` as first arg and remaining elements as additional args.
 * * function - Mapped to newly instantiated data model: A `DataModel` constructor to be called with `new` keyword and `this.grid` as only arg.
 * * Falsy value - Mapped to the behavior's data model (`this.dataModel`).
 * @returns {DataModel}
 */
function enlivenSubgrids(dataModel) {
    if (!dataModel) {
        dataModel = this.dataModel;
    } else if (dataModel instanceof Array && dataModel.length) {
        var Constructor = dataModel[0],
            args = dataModel.slice(1);
        dataModel = new (Function.prototype.bind.apply(Constructor, [null, this.grid].concat(args)));
    } else if (typeof dataModel === 'function') {
        dataModel = new dataModel(this.grid); // eslint-disable-line new-cap
    }
    return dataModel;
}

/**
 * @memberOf Behavior.prototype
 */
Behavior.prototype.reindex = Behavior.prototype.applyAnalytics;

module.exports = Behavior;

},{"../Base":49,"../dataModels/FilterSubgrid":79,"../dataModels/HeaderSubgrid":80,"../dataModels/SummarySubgrid":82,"../dialogs":90,"./../lib/cellEventFactory":116,"./Column":53,"object-iterators":42,"rectangular":45}],53:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var overrider = require('overrider');

var deprecated = require('../lib/deprecated');
var HypergridError = require('../lib/error');

var warned = {};

/** @summary Create a new `Column` object.
 * @see {@link module:Cell} is mixed into Column.prototype.
 * @constructor
 * @param behavior
 * @param {number|string|object} indexOrOptions - One of:
 * * If a positive number, valid index into `fields` array.
 * * If a string, a name in the `fields` array.
 * * If an object, must contain either an `index` or a `name` property.
 *
 * Positive values of `index` are "real" fields; see also {@link Column#setProperties|setProperties} which is called to set the remaining properties specified in `options`.
 *
 * Negative values of `index` are special cases:
 * `index` | Meaning
 * :-----: | --------
 *    -1   | Row header column
 *    -2   | Tree (drill-down) column
 */
function Column(behavior, options) {
    var index, schema;

    this.behavior = behavior;
    this.dataModel = behavior.dataModel;

    schema = this.behavior.dataModel.schema;

    switch (typeof options) {
        case 'number':
            index = options;
            options = {};
            break;
        case 'string':
            index = getIndexFromName(options);
            options = {};
            break;
        case 'object':
            index = options.index !== undefined
                ? options.index
                : getIndexFromName(options.name);
    }

    function getIndexFromName(name) {
        return schema.findIndex(function(columnSchema, i) {
            return columnSchema.name === name;
        });
    }

    if (index === undefined) {
        throw 'Column not found in data.';
    }

    this._index = index;

    this.clearAllCellProperties();

    switch (index) {
        case -1:
        case -2:
            break;
        default:
            if (index < 0) {
                throw '`index` out of range';
            } else {
                this.properties = options;
            }
    }
}

Column.prototype = {
    constructor: Column.prototype.constructor,

    HypergridError: HypergridError,

    mixIn: overrider.mixIn,

    deprecated: deprecated,
    set: function(options) {
        return this.deprecated('set(options)', 'setProperties(options)', '1.2.0', arguments);
    },

    /**
     * @summary Index of this column in the `fields` array.
     * @returns {number}
     */
    get index() { // read-only (no setter)
        return this._index;
    },

    /**
     * @summary Name of this column from the `fields` array.
     * @returns {string}
     */
    get name() { // read-only (no setter)
        return this.dataModel.schema[this._index].name;
    },

    /**
     * @summary Get or set the text of the column's header.
     * @desc The _header_ is the label at the top of the column.
     *
     * Setting the header updates both:
     * * the `fields` (aka, header) array in the underlying data source; and
     * * the filter.
     * @type {string}
     */
    set header(headerText) {
        this.dataModel.schema[this.index].header = headerText;
        this.behavior.filter.prop(this.index, 'header', headerText);
        this.behavior.grid.repaint();
    },
    get header() {
        return this.dataModel.schema[this.index].header;
    },

    /**
     * @summary Get or set the computed column's calculator function.
     * @desc Setting the value here updates the calculator in both:
     * * the `calculator` array in the underlying data source; and
     * * the filter.
     *
     * The results of the new calculations will appear in the column cells on the next repaint.
     * @type {string}
     */
    set calculator(calculator) {
        var schema = this.dataModel.schema;
        if (calculator === undefined) {
            delete schema[this.index].calculator;
        } else {
            schema[this.index].calculator = calculator;
        }
        this.behavior.filter.prop(this.index, 'calculator', calculator);
        this.behavior.applyAnalytics();
    },
    get calculator() {
        return this.dataModel.schema[this.index].calculator;
    },

    /**
     * @summary Get or set the type of the column's header.
     * @desc Setting the type updates the filter which typically uses this information for proper collation.
     *
     * @todo: Instead of using `this._type`, put on data source like the other essential properties. In this case, sorter could use the info to choose a comparator more intelligently and efficiently.
     * @type {string}
     */
    set type(type) {
        this._type = type;
        //TODO: This is calling reindex for every column during grid init. Maybe defer all reindex calls until after an grid 'ready' event
        this.behavior.filter.prop(this.index, 'type', type);
        this.behavior.sorter.prop(this.index, 'type', type);
        this.behavior.reindex();
    },
    get type() {
        return this._type;
    },

    getUnfilteredValue: function(y) {
        return this.deprecated('getUnfilteredValue(y)', null, '1.2.0', arguments, 'No longer supported');
    },

    getValue: function(y) {
        return this.dataModel.getValue(this.index, y);
    },

    setValue: function(y, value) {
        return this.dataModel.setValue(this.index, y, value);
    },

    getWidth: function() {
        return this.properties && this.properties.width || this.behavior.grid.properties.defaultColumnWidth;
    },

    setWidth: function(width) {
        this.properties.width = Math.max(5, width);
    },

    getCellRenderer: function(config, cellEvent) {
        config.untranslatedX = cellEvent.gridCell.x;
        config.y = cellEvent.gridCell.y;

        config.x = this.index;
        config.normalizedY = cellEvent.dataCell.y;

        return this.dataModel.getCell(config, cellEvent.getCellProperty('renderer'));
    },

    checkColumnAutosizing: function(force) {
        var properties = this.properties;
        var a, b, d, autoSized;
        if (properties) {
            a = properties.width;
            b = properties.preferredWidth || a;
            d = properties.columnAutosized && !force;
            if (a !== b || !d) {
                properties.width = !d ? b : Math.max(a, b);
                properties.columnAutosized = !isNaN(properties.width);
                autoSized = properties.width !== a;
            }
        }
        return autoSized;
    },

    getCellType: function(y) {
        var value = this.getValue(y);
        return this.typeOf(value);
    },

    getType: function() {
        var props = this.properties;
        var type = props.type;
        if (!type) {
            type = this.computeColumnType();
            if (type !== 'unknown') {
                props.type = type;
            }
        }
        return type;
    },

    computeColumnType: function() {
        var headerRowCount = this.behavior.getHeaderRowCount();
        var height = this.behavior.getRowCount();
        var value = this.getValue(headerRowCount);
        var eachType = this.typeOf(value);
        if (!eachType) {
            return 'unknown';
        }
        var type = this.typeOf(value);
        //var isNumber = ((typeof value) === 'number');
        for (var y = headerRowCount; y < height; y++) {
            value = this.getValue(y);
            eachType = this.typeOf(value);
            // if (type !== eachType) {
            //     if (isNumber && (typeof value === 'number')) {
            //         type = 'float';
            //     } else {
            //         return 'mixed';
            //     }
            // }
        }
        return type;
    },

    typeOf: function(something) {
        if (something == null) {
            return null;
        }
        var typeOf = typeof something;
        switch (typeOf) {
            case 'object':
                return something.constructor.name.toLowerCase();
            case 'number':
                return parseInt(something) === something ? 'int' : 'float';
            default:
                return typeOf;
        }
    },

    get properties() {
        var tableState = this.behavior.grid.properties,
            result = tableState.columnProperties[this.index];

        if (!result) {
            result = tableState.columnProperties[this.index] = this.createColumnProperties();
        }

        return result;
    },
    set properties(properties) {
        var key, descriptor, obj = this.properties;

        for (key in obj) {
            descriptor = Object.getOwnPropertyDescriptor(obj, key);
            if (!descriptor || descriptor.configurable) {
                delete obj[key];
            }
        }

        this.addProperties(properties);
    },

    getProperties: function() {
        return this.deprecated('getProperties()', 'properties', '1.2.0');
    },

    /**
     * @param {object} properties
     * @param {boolean} [preserve=false]
     */
    setProperties: function(properties, preserve) {
        if (!preserve) {
            if (!warned.setProperties) {
                warned.setProperties = true;
                console.warn('setProperties(properties) has been deprecated in favor of properties (setter) as of v1.2.0 and will be removed in a future version. This advice only pertains to usages of setProperties when called with a single parameter. When called with a truthy second parameter, use the new addProperties(properties) call instead.');
            }
            this.properties = properties;
        } else {
            this.deprecated('setProperties(properties, preserve)', 'addProperties(properties)', '1.2.0', arguments, 'This warning pertains to setProperties only when preserve is truthy. When preserve is faulty, use the new properties setter.');
        }
    },

    addProperties: function(properties) {
        var key, descriptor, obj = this.properties;

        for (key in properties) {
            descriptor = Object.getOwnPropertyDescriptor(obj, key);
            if (!descriptor || descriptor.writable || descriptor.set) {
                obj[key] = properties[key];
            }
        }
    },

    /**
     * This method determines the proposed cell editor name from the render properties. The algorithm is:
     * 1. `editor` render property (cell editor name)
     * 2. `format` render property (localizer name)
     *
     * Note that "render property" means in each case the first defined property found on the cell, column, or grid.
     *
     * @param {number} y - The grid row index.
     * @param {object} options - Will be decorated with `format` and `column`.
     * @param {CellEvent} options.editPoint
     * @returns {undefined|CellEditor} Falsy value means either no declared cell editor _or_ instantiation aborted by falsy return return from fireRequestCellEdit.
     */
    getCellEditorAt: function(event) {
        var columnIndex = this.index,
            rowIndex = event.gridCell.y,
            editorName = event.getCellProperty('editor'),
            options = Object.defineProperties(event, {
                format: {
                    // `options.fomrat` is a copy of the cell's `format` property which is:
                    // 1. Subject to adjustment by the `getCellEditorAt` override.
                    // 2. Then used by the cell editor to reference the predefined localizer.
                    writable: true,
                    value: event.getCellProperty('format')
                },
                editPoint: {
                    get: function() {
                        if (!warned.editPoint) {
                            warned.editPoint = true;
                            console.warn('The .editPoint property has been deprecated as of v1.2.0 in favor of .gridCell. It may be removed in a future release.');
                        }
                        return this.gridCell;
                    }
                }
            }),
            cellEditor = this.dataModel.getCellEditorAt(columnIndex, rowIndex, editorName, options);

        if (cellEditor && !cellEditor.grid) {
            // cell editor returned but not fully instantiated (aborted by falsy return from fireRequestCellEdit)
            cellEditor = undefined;
        }

        return cellEditor;
    },

    getFormatter: function() {
        var localizerName = this.properties.format;
        return this.behavior.grid.localization.get(localizerName).format;
    }
};

Column.prototype.mixIn(require('./cellProperties'));
Column.prototype.mixIn(require('./columnProperties'));

module.exports = Column;

},{"../lib/deprecated":117,"../lib/error":118,"./cellProperties":55,"./columnProperties":56,"overrider":43}],54:[function(require,module,exports){
'use strict';

var Behavior = require('./Behavior');
var DataModelJSON = require('../dataModels/JSON');
var features = require('../features');

var REGEX_CAMEL_CASE = /([^_A-Z])([A-Z]+)/g; // all instances of xX or _X within a "word"

/**
 * @name behaviors.JSON
 * @desc > Same parameters as {@link behaviors.Behavior#initialize|initialize}, which is called by this constructor.
 * @constructor
 * @extends Behavior
 */
var JSON = Behavior.extend('behaviors.JSON', {

    /**
     * @summary Constructor logic, called _after_{@link Behavior#initialize|Behavior.initialize()}.
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     *
     * @memberOf behaviors.JSON.prototype
     */
    initialize: function(grid, options) {
        this.setData(options);
        if (options.pipeline) {
            this.setPipeline(options.pipeline);
        }
    },

    features: [
        features.CellSelection,
        features.KeyPaging,
        features.ColumnPicker,
        features.ColumnResizing,
        features.RowResizing,
        features.Filters,
        features.RowSelection,
        features.ColumnSelection,
        features.ColumnMoving,
        features.ColumnSorting,
        features.CellClick,
        features.CellEditing,
        features.OnHover
    ],

    createColumns: function() {
        var schema = this.dataModel.schema;

        this.clearColumns();

        schema.forEach(function(columnSchema, index) {
            this.addColumn({
                index: index,
                header: columnSchema.header,
                calculator: columnSchema.calculator
            });

            this.columnEnum[this.columnEnumKey(columnSchema.name)] = index; // todo: move columnEnum code from core to demo
        }, this);
    },

    /**
     * @summary Style enum keys.
     * @desc Override this method to style your keys to your liking.
     * @param key
     * @todo move columnEnum code from core to demo
     * @returns {string}
     */
    columnEnumKey: function(key) {
        return key.replace(REGEX_CAMEL_CASE, '$1_$2').toUpperCase();
    },

    getNewDataModel: function(options) {
        return new DataModelJSON(this.grid, options);
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the header labels.
     * @param {string[]|object} headers - The header labels. One of:
     * * _If an array:_ Must contain all headers in column order.
     * * _If a hash:_ May contain any headers, keyed by field name, in any order.
     */
    setHeaders: function(headers) {
        if (headers instanceof Array) {
            // Reset all headers
            var allColumns = this.allColumns;
            headers.forEach(function(header, index) {
                allColumns[index].header = header; // setter updates header in both column and data source objects
            });
        } else if (typeof headers === 'object') {
            // Adjust just the headers in the hash
            this.allColumns.forEach(function(column) {
                if (headers[column.name]) {
                    column.header = headers[column.name];
                }
            });
        }
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the fields array.
     * @param {string[]} fieldNames - The field names.
     */
    setFields: function(fieldNames) {
        //were defining the columns based on field names....
        //we must rebuild the column definitions
        this.dataModel.setFields(fieldNames);
        this.createColumns();
    },

    /**
     * @see {@link dataModels.JSON#setPipeline}
     * @param {object} [DataSources] - New pipeline description. _(See {@link dataModels.JSON#setPipeline}.)_
     * @param {object} [options] - Takes first argument position when `DataSources` omitted. _(See {@link dataModels.JSON#setPipeline}.)_
     * @param {boolean} [options.apply=true] Apply data transformations to the new data.
     * @memberOf behaviors.JSON.prototype
     */
    setPipeline: function(DataSources, options) {
        if (!Array.isArray(DataSources)) {
            options = DataSources;
            DataSources = undefined;
        }

        this.dataModel.setPipeline(DataSources, options);

        if (!options || options.apply === undefined || options.apply) {
            this.reindex();
        }
    },

    /**
     * Pop pipeline stack.
     * @see {@link dataModels.JSON#unstashPipeline}
     * @param {string} [whichStash]
     * @param {object} [options] - Takes first argument position when `DataSources` omitted.
     * @param {boolean} [options.apply=true] Apply data transformations to the new data.
     */
    unstashPipeline: function(stash, options) {
        if (typeof stash === 'object') {
            options = stash;
            stash = undefined;
        }

        this.dataModel.unstashPipeline(stash);

        if (!options || options.apply === undefined || options.apply) {
            this.reindex();
        }
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the data field.
     * @param {function|object[]} [dataRows=options.data] - Array of uniform data row objects or function returning same.
     * @param {object} [options] - Takes first argument position when `dataRows` omitted.
     * @param {function|object} [options.data] - Array of uniform data row objects or function returning same.
     * Passed as 1st param to {@link dataModel.JSON#setData}. If falsy, method aborted.
     * @param {function|object} [options.fields] - Array of field names or function returning same.
     * Passed as 2nd param to {@link dataModel.JSON#setData}.
     * @param {function|object} [options.calculators] - Array of calculators or function returning same.
     * Passed as 3rd param to {@link dataModel.JSON#setData}.
     * @param {boolean} [options.apply=true] Apply data transformations to the new data.
     */
    setData: function(dataRows, options) {
        if (!(Array.isArray(dataRows) || typeof dataRows === 'function')) {
            options = dataRows;
            dataRows = options && options.data;
        }

        dataRows = this.unwrap(dataRows);

        if (dataRows === undefined) {
            return;
        }

        if (!Array.isArray(dataRows)) {
            throw 'Data is not an array';
        }

        options = options || {};
        var grid = this.grid;

        this.dataModel.setData(
            dataRows,
            this.unwrap(options.schema) || [] // *always* define a new schema on reset
        );

        if (grid.cellEditor) {
            grid.cellEditor.cancelEditing();
        }

        if (options.apply === undefined || options.apply) {
            this.reindex();
        }

        var self = this;
        this.createColumns();
        if (self.grid.isColumnAutosizing()) {
            setTimeout(function() {
                self.autosizeAllColumns();
            }, 100);
            self.grid.allowEvents(self.dataModel.getRowCount() > 0);
        } else {
            setTimeout(function() {
                self.getColumn(-1).checkColumnAutosizing(true);
                self.grid.allowEvents(self.dataModel.getRowCount() > 0);
            });
        }
    },
    /**
     * @summary Rebinds the data without reshaping it.
     * @param dataRows
     * @param options
     * @memberOf behaviors.JSON.prototype
     */
    updateData: function(dataRows, options){
        options = options || {};
        if (!(Array.isArray(dataRows) || typeof dataRows === 'function')) {
            options = dataRows;
            dataRows = options && options.data;
        }
        dataRows = this.unwrap(dataRows);
        this.dataModel.setData(
            dataRows,
            this.unwrap(options.schema) // undefined will be ignored
        );

        this.reindex();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Build the fields and headers from the supplied column definitions.
     * ```javascript
     * myJsonBehavior.setColumns([
     *     { header: 'Stock Name', name: 'short_description' },
     *     { header: 'Status', name: 'trading_phase' },
     *     { header: 'Reference Price', name: 'reference_price' }
     * ]);
     * ```
     * @param {Array} columnDefinitions - an array of objects with fields 'title', and 'field'
     */
    setColumns: function(columnDefinitions) {
        console.warn('This function does not do anything');
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Enhance the double-click event just before it's broadcast to listeners.
     * @param {Point} event
     */
    enhanceDoubleClickEvent: function(event) {
        event.row = this.getRow(event.gridCell.y);
    },

    //Not being used. Should be repurposed??
    setDataProvider: function(dataProvider) {
        this.dataModel.setDataProvider(dataProvider);
    },

    hasHierarchyColumn: function() {
        return this.dataModel.hasHierarchyColumn();
    },

    getHiddenColumns: function() {
        return this.dataModel.getHiddenColumns();
    },

    getActiveColumns: function() {
        return this.dataModel.getActiveColumns();
    },
    getVisibleColumns: function() {
        return this.deprecated('getVisibleColumns()', 'getActiveColumns()', '1.0.6', arguments);
    },

    getSelectedColumns: function() {
        return this.grid.selectionModel.getSelectedColumns();
    },

    getSelections: function() {
        return this.grid.selectionModel.getSelections();
    },

    getSortedColumnIndexes: function(){
      return this.dataModel.getSortedColumnIndexes();
    }
});

module.exports = JSON;

},{"../dataModels/JSON":81,"../features":108,"./Behavior":52}],55:[function(require,module,exports){
/* eslint-env bro wser */

'use strict';

var _ = require('object-iterators');

/**
 * Column.js mixes this module into its prototype.
 * @module
 */
var cell = {

    /**
     * @summary Get the properties object for cell.
     * @desc This is the cell's own properties object if found; else the column object.
     *
     * If you are seeking a single specific property, consider calling {@link Column#getCellProperty} instead (which calls this method).
     * @param {number} rowIndex - Data row coordinate.
     * @return {object} The properties of the cell at x,y in the grid.
     * @memberOf Column#
     */
    getCellProperties: function(rowIndex, dataModel) {
        return this.getCellOwnProperties(rowIndex, dataModel) || this.properties;
    },

    /**
     * @param {number} rowIndex - Data row coordinate.
     * @param {Object} properties - Hash of cell properties.
     * @returns {*}
     * @memberOf Column#
     */
    setCellProperties: function(rowIndex, properties, dataModel) {
        return _(newCellPropertiesObject.call(this, rowIndex, dataModel)).extendOwn(properties);
    },

    /**
     * @param {number} rowIndex - Data row coordinate.
     * @param {Object} properties - Hash of cell properties.
     * @param {boolean} [preserve=false] - Falsy creates new object; truthy copies `properties` members into existing object.
     * @returns {*}
     * @memberOf Column#
     */
    addCellProperties: function(rowIndex, properties, dataModel) {
        return _(getCellPropertiesObject.call(this, rowIndex, dataModel)).extendOwn(properties);
    },

    /**
     * @summary Get the cell's own properties object.
     * @desc Due to memory constraints, we don't create a cell options properties object for every cell.
     *
     * If the cell has its own properties object, it:
     * * was created by a previous call to `setCellProperties` or `setCellProperty`
     * * has the column properties object as its prototype
     * * is returned
     *
     * If the cell does not have its own properties object, this method simply returns `undefined`.
     *
     * Call this method only when you need to know if the the cell has its own properties object; otherwise call {@link Column#getCellProperties|getCellProperties}.
     * @param {number} rowIndex - Data row coordinate.
     * @returns {undefined|object} The "own" properties of the cell at x,y in the grid. If the cell does not own a properties object, returns `undefined`.
     * @memberOf Column#
     */
    getCellOwnProperties: function(rowIndex, dataModel) {
        var rowData;
        return (
            this.index >= 0 && // no cell props on row handle cells
            (rowData = (dataModel || this.dataModel).getRow(rowIndex)) && // no cell props on non-existant rows
            rowData.__META && rowData.__META[this.name] // undefined if not previously created
        );
    },

    /**
     * @summary Return a specific cell property.
     * @desc If there is no cell properties object, defers to column properties object.
     * @param {number} rowIndex - Data row coordinate.
     * @param {string} key
     * @return {object} The specified property for the cell at x,y in the grid.
     * @memberOf Column#
     */
    getCellProperty: function(rowIndex, key, dataModel) {
        return this.getCellProperties(rowIndex, dataModel)[key];
    },

    /**
     * @param {number} rowIndex - Data row coordinate.
     * @param {string} key
     * @param value
     * @returns {object}
     * @memberOf Column#
     */
    setCellProperty: function(rowIndex, key, value, dataModel) {
        var propertiesObject = getCellPropertiesObject.call(this, rowIndex, dataModel);
        propertiesObject[key] = value;
        return propertiesObject;
    },

    clearAllCellProperties: function() {
        // Unimplemented!
        // Need to undefine all `dataModel.getData(*).__META[this.name]`.
    }
};

/**
 * @this {Column}
 * @param {number} rowIndex - Data row coordinate.
 * @returns {object}
 * @private
 */
function getCellPropertiesObject(rowIndex, dataModel) {
    return this.getCellOwnProperties(rowIndex, dataModel) || newCellPropertiesObject.call(this, rowIndex, dataModel);
}

/**
 * @todo: For v8 optimization, consider setting the new `__META` object to a "regularly shaped object" (i.e., with all the columns) instead of simply to `{}`. Considerations include how many of these objects are there, how often are they referenced, etc.
 * @this {Column}
 * @param {number} rowIndex - Data row coordinate.
 * @returns {object}
 * @private
 */
function newCellPropertiesObject(rowIndex, dataModel) {
    var rowData = (dataModel || this.dataModel).getRow(rowIndex),
        metaData = rowData.__META = rowData.__META || {};
    return (metaData[this.name] = Object.create(this.properties));
}

module.exports = cell;

},{"object-iterators":42}],56:[function(require,module,exports){
'use strict';

/**
 * @param {function|string} string
 * @returns {function}
 * @private
 */
function toFunction(string) {
    switch (typeof string) {
        case 'undefined':
        case 'function':
            return string;
        case 'string':
            break;
        default:
            throw 'Expected string, function, or undefined.';
    }

    var args = string.match(/function\s*\(([^]*?)\)/);
    if (!args) {
        throw 'Expected function keyword with formal parameter list.';
    }
    args = args[1].split(',').map(function(s, i) {
        s = s.match(/\s*(\w*)\s*/); // trim each argument
        if (!s && i) {
            throw 'Expected formal parameter.';
        }
        return s[1];
    });

    var body = string.match(/{\s*([^]*?)\s*}/);
    if (!body) {
        throw 'Expected function body.';
    }
    body = body[1];

    if (args.length === 1 && !args[0]) {
        args[0] = body;
    } else {
        args = args.concat(body);
    }

    return Function.apply(null, args);
}

var FIELD = 'columnProperties.field is deprecated as of v1.1.0 in favor of columnProperties.name. (Will be removed in a future release.)',
    COLUMN_NAME = 'columnProperties.columnName is deprecated as of v1.1.0 in favor of columnProperties.name. (Will be removed in a future release.)';

/**
 * @this {Column}
 * @returns {object}
 */
function createColumnProperties() {
    var column = this,
        tableState = column.behavior.grid.properties,
        properties;

    properties = Object.create(tableState, {

        index: { // read-only (no setter)
            get: function() {
                return column.index;
            }
        },

        name: { // read-only (no setter)
            get: function() {
                return column.name;
            }
        },

        field: { // read-only (no setter)
            get: function() {
                if (FIELD) { console.warn(FIELD); FIELD = undefined; }
                return column.name;
            }
        },

        columnName: { // read-only (no setter)
            get: function() {
                if (COLUMN_NAME) { console.warn(COLUMN_NAME); COLUMN_NAME = undefined; }
                return column.name;
            }
        },

        header: {
            get: function() {
                return column.header;
            },
            set: function(header) {
                column.header = header;
            }
        },

        type: {
            get: function() {
                return column.type;
            },
            set: function(type) {
                column.type = type;
            }
        },

        calculator: {
            get: function() {
                return column.calculator;
            },
            set: function(calculator) {
                column.calculator = toFunction(calculator);
            }
        }

    });


    Object.defineProperty(properties, 'rowNumbersProperties', { value: Object.create(properties, {
        foregroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.columnHeaderForegroundSelectionColor;
            },
            set: function(value) {
                this.columnHeaderForegroundSelectionColor = value;
            }
        },
        backgroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.columnHeaderBackgroundSelectionColor;
            },
            set: function(value) {
                this.columnHeaderBackgroundSelectionColor = value;
            }
        }
    })});

    Object.defineProperty(properties, 'rowHeader', { value: Object.create(properties, {
        font: {
            configurable: true,
            get: function() {
                return this.rowHeaderFont;
            },
            set: function(value) {
                this.rowHeaderFont = value;
            }
        },
        color: {
            configurable: true,
            get: function() {
                return this.rowHeaderColor;
            },
            set: function(value) {
                this.rowHeaderColor = value;
            }
        },
        backgroundColor: {
            configurable: true,
            get: function() {
                return this.rowHeaderBackgroundColor;
            },
            set: function(value) {
                this.rowHeaderBackgroundColor = value;
            }
        },
        foregroundSelectionFont: {
            configurable: true,
            get: function() {
                return this.rowHeaderForegroundSelectionFont;
            },
            set: function(value) {
                this.rowHeaderForegroundSelectionFont = value;
            }
        },
        foregroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.rowHeaderForegroundSelectionColor;
            },
            set: function(value) {
                this.rowHeaderForegroundSelectionColor = value;
            }
        },
        backgroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.rowHeaderBackgroundSelectionColor;
            },
            set: function(value) {
                this.rowHeaderBackgroundSelectionColor = value;
            }
        }
    })});

    Object.defineProperty(properties, 'columnHeader', { value: Object.create(properties, {
        font: {
            configurable: true,
            get: function() {
                return this.columnHeaderFont;
            },
            set: function(value) {
                this.columnHeaderFont = value;
            }
        },
        color: {
            configurable: true,
            get: function() {
                return this.columnHeaderColor;
            },
            set: function(value) {
                this.columnHeaderColor = value;
            }
        },
        backgroundColor: {
            configurable: true,
            get: function() {
                return this.columnHeaderBackgroundColor;
            },
            set: function(value) {
                this.columnHeaderBackgroundColor = value;
            }
        },
        foregroundSelectionFont: {
            configurable: true,
            get: function() {
                return this.columnHeaderForegroundSelectionFont;
            },
            set: function(value) {
                this.columnHeaderForegroundSelectionFont = value;
            }
        },
        foregroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.columnHeaderForegroundSelectionColor;
            },
            set: function(value) {
                this.columnHeaderForegroundSelectionColor = value;
            }
        },
        backgroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.columnHeaderBackgroundSelectionColor;
            },
            set: function(value) {
                this.columnHeaderBackgroundSelectionColor = value;
            }
        },
        halign: {
            configurable: true,
            get: function() {
                return this.columnHeaderHalign;
            },
            set: function(value) {
                this.columnHeaderHalign = value;
            }
        }
    })});

    Object.defineProperty(properties, 'columnHeaderColumnSelection', { value: Object.create(properties.columnHeader, {
        foregroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.columnHeaderForegroundColumnSelectionColor;
            },
            set: function(value) {
                this.columnHeaderForegroundColumnSelectionColor = value;
            }
        },
        backgroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.columnHeaderBackgroundColumnSelectionColor;
            },
            set: function(value) {
                this.columnHeaderBackgroundColumnSelectionColor = value;
            }
        }
    })});

    Object.defineProperty(properties, 'rowHeaderRowSelection', { value: Object.create(properties.rowHeader, {
        foregroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.rowHeaderForegroundRowSelectionColor;
            },
            set: function(value) {
                this.rowHeaderForegroundRowSelectionColor = value;
            }
        },
        backgroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.rowHeaderBackgroundRowSelectionColor;
            },
            set: function(value) {
                this.rowHeaderBackgroundRowSelectionColor = value;
            }
        }
    })});

    Object.defineProperty(properties, 'filterProperties', { value: Object.create(properties, {
        font: {
            configurable: true,
            get: function() {
                return this.filterFont;
            },
            set: function(value) {
                this.filterFont = value;
            }
        },
        color: {
            configurable: true,
            get: function() {
                return this.filterColor;
            },
            set: function(value) {
                this.filterColor = value;
            }
        },
        backgroundColor: {
            configurable: true,
            get: function() {
                return this.filterBackgroundColor;
            },
            set: function(value) {
                this.filterBackgroundColor = value;
            }
        },
        foregroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.filterForegroundSelectionColor;
            },
            set: function(value) {
                this.filterForegroundSelectionColor = value;
            }
        },
        backgroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.filterBackgroundSelectionColor;
            },
            set: function(value) {
                this.filterBackgroundSelectionColor = value;
            }
        },
        halign: {
            configurable: true,
            get: function() {
                return this.filterHalign;
            },
            set: function(value) {
                this.filterHalign = value;
            }
        }
    })});

    Object.defineProperty(properties, 'treeColumnProperties', { value: Object.create(properties, {
        font: {
            configurable: true,
            get: function() {
                return this.treeColumnFont;
            },
            set: function(value) {
                this.treeColumnFont = value;
            }
        },
        color: {
            configurable: true,
            get: function() {
                return this.treeColumnColor;
            },
            set: function(value) {
                this.treeColumnColor = value;
            }
        },
        backgroundColor: {
            configurable: true,
            get: function() {
                return this.treeColumnBackgroundColor;
            },
            set: function(value) {
                this.treeColumnBackgroundColor = value;
            }
        },
        foregroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.treeColumnForegroundSelectionColor;
            },
            set: function(value) {
                this.treeColumnForegroundSelectionColor = value;
            }
        },
        backgroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.treeColumnBackgroundSelectionColor;
            },
            set: function(value) {
                this.treeColumnBackgroundSelectionColor = value;
            }
        }
    })});

    Object.defineProperty(properties, 'treeColumnPropertiesColumnSelection', { value: Object.create(properties.treeColumnProperties, {
        foregroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.treeColumnForegroundColumnSelectionColor;
            },
            set: function(value) {
                this.treeColumnForegroundColumnSelectionColor = value;
            }
        },
        backgroundSelectionColor: {
            configurable: true,
            get: function() {
                return this.treeColumnBackgroundColumnSelectionColor;
            },
            set: function(value) {
                this.treeColumnBackgroundColumnSelectionColor = value;
            }
        }
    })});

    return properties;
}

module.exports.createColumnProperties = createColumnProperties;

},{}],57:[function(require,module,exports){
'use strict';

module.exports = {
    Behavior: require('./Behavior'), // abstract base class
    JSON: require('./JSON'),
    Column: require('./Column')
};

},{"./Behavior":52,"./Column":53,"./JSON":54}],58:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var mustache = require('mustache');
var _ = require('object-iterators');

var Base = require('../Base');
var effects = require('../lib/DOM/effects');
var Localization = require('../lib/Localization');

/**
 * @constructor
 */
var CellEditor = Base.extend('CellEditor', {

    /**
     * @param grid
     * @param {CellEvent} options - Properties listed below + arbitrary mustache "variables" for merging into template.
     * @param {Point} options.editPoint - Deprecated; use `options.gridCell`.
     * @param {string} [options.format] - Name of a localizer with which to override prototype's `localizer` property.
     */
    initialize: function(grid, options) {
        // Mix in all enumerable properties for mustache use.
        for (var key in options) {
            if (options.hasOwnProperty(key) && this[key] !== null) {
                this[key] = options[key];
            }
        }

        this.event = options;

        var value = grid.behavior.getValue(this.event);
        if (value instanceof Array) {
            value = value[1]; //it's a nested object
        }

        /**
         * my instance of hypergrid
         * @type {Hypergrid}
         * @memberOf CellEditor.prototype
         */
        this.grid = grid;

        this.grid.cellEditor = this;

        this.locale = grid.localization.locale; // for template's `lang` attribute

        // override native localizer with localizer named in format if defined (from instantiation options)
        if (options.format) {
            this.localizer = this.grid.localization.get(options.format);
        }

        this.initialValue = value;

        var container = document.createElement('DIV');
        container.innerHTML = mustache.render(this.template, this);

        /**
         * This object's input control, one of:
         * * *input element* - an `HTMLElement` that has a `value` attribute, such as `HTMLInputElement`, `HTMLButtonElement`, etc.
         * * *container element* - an `HTMLElement` containing one or more input elements, only one of which contains the editor value.
         *
         * For access to the input control itself (which may or may not be the same as `this.el`), see `this.input`.
         *
         * @type {HTMLElement}
         * @default null
         * @memberOf CellEditor.prototype
         */
        this.el = container.firstChild;

        this.input = this.el;

        this.errors = 0;

        var self = this;
        this.el.addEventListener('keyup', this.keyup.bind(this));
        this.el.addEventListener('keydown', function(e) {
            grid.fireSyntheticEditorKeyDownEvent(self, e);
        });
        this.el.addEventListener('keypress', function(e) {
            grid.fireSyntheticEditorKeyPressEvent(self, e);
        });
        this.el.addEventListener('mousedown', function(e) {
            self.onmousedown(e);
        });
    },

    // If you override this method, be sure to call it as a final step (or call stopPropagation yourself).
    onmousedown: function(event) {
        event.stopPropagation(); // Catch mouseodwn here before it gets to the document listener defined in Hypergrid().
    },

    localizer: Localization.prototype.null,

    specialKeyups: {
        //0x08: 'clearStopEditing', // backspace
        0x09: 'stopEditing', // tab
        0x0d: 'stopEditing', // return/enter
        0x1b: 'cancelEditing' // escape
    },

    keyup: function(e) {
        if (e) {
            var specialKeyup = this.specialKeyups[e.keyCode];

            if (specialKeyup) {
                e.preventDefault();
                if (this[specialKeyup](3)) {
                    this.grid.repaint();
                    this.grid.takeFocus();
                }
            }

            this.grid.fireSyntheticEditorKeyUpEvent(this, e);
        }
    },

    /**
     * if true, check that the editor is in the right location
     * @type {boolean}
     * @default false
     * @memberOf CellEditor.prototype
     */
    checkEditorPositionFlag: false,

    /**
     * @memberOf CellEditor.prototype
     * @desc This function is a callback from the fin-hypergrid.   It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        this.checkEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc scroll values have changed, we've been notified
     */
    scrollValueChangedNotification: function() {
        this.checkEditorPositionFlag = true;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc move the editor to the current editor point
     */
    moveEditor: function() {
        var cellBounds = this.event.bounds;

        //hack to accommodate bootstrap margin issues...
        var xOffset =
            this.grid.div.getBoundingClientRect().left -
            this.grid.divCanvas.getBoundingClientRect().left;

        cellBounds.x -= xOffset;

        this.setBounds(cellBounds);
    },

    beginEditing: function() {
        if (this.grid.fireRequestCellEdit(this.event.gridCell, this.initialValue)) {
            this.checkEditorPositionFlag = true;
            this.checkEditor();
        }
    },
    beginEditAt: function(Constructor, name) {
        return this.deprecated('beginEditAt(point)', 'beginEditing()', '1.0.6');
    },

    /**
     * @summary Put the value into our editor.
     * @desc Formats the value and displays it.
     * The localizer's {@link localizerInterface#format|format} method will be called.
     *
     * Override this method if your editor has additional or alternative GUI elements.
     *
     * @param {object} value - The raw unformatted value from the data source that we want to edit.
     * @memberOf CellEditor.prototype
     */
    setEditorValue: function(value) {
        this.input.value = this.localizer.format(value);
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc display the editor
     */
    showEditor: function() {
        this.el.style.display = 'inline';
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc hide the editor
     */
    hideEditor: function() {
        this.el.style.display = 'none';
    },

    /** @summary Stops editing.
     * @desc Before saving, validates the edited value in two phases as follows:
     * 1. Call `validateEditorValue`. (Calls the localizer's `invalid()` function, if available.)
     * 2. Catch any errors thrown by the {@link CellEditor#getEditorValue|getEditorValue} method.
     *
     * **If the edited value passes both phases of the validation:**
     * Saves the edited value by calling the {@link CellEditor#saveEditorValue|saveEditorValue} method.
     *
     * **On validation failure:**
     * 1. If `feedback` was omitted, cancels editing, discarding the edited value.
     * 2. If `feedback` was provided, gives the user some feedback (see `feedback`, below).
     *
     * @param {number} [feedback] What to do on validation failure:
     * * If omitted, simply cancels editing without saving edited value.
     * * If 0, shows the error feedback effect (see the {@link CellEditor#errorEffect|errorEffect} property).
     * * If > 0, shows the error feedback effect _and_ calls the {@link CellEditor#errorEffectEnd|errorEffectEnd} method) every `feedback` call(s) to `stopEditing`.
     * @returns {boolean} Truthy means successful stop. Falsy means syntax error prevented stop. Note that editing is canceled when no feedback requested and successful stop includes (successful) cancel.
     * @memberOf CellEditor.prototype
     */
    stopEditing: function(feedback) {
        /**
         * @type {boolean|string|Error}
         */
        var error = this.validateEditorValue();

        if (!error) {
            try {
                var value = this.getEditorValue();
            } catch (err) {
                error = err;
            }
        }

        if (!error && this.grid.fireSyntheticEditorDataChangeEvent(this, this.initialValue, value)) {
            try {
                this.saveEditorValue(value);
            } catch (err) {
                error = err;
            }
        }

        if (!error) {
            this.hideEditor();
            this.grid.cellEditor = null;
            this.el.remove();
        } else if (feedback >= 0) { // never true when `feedback` undefined
            var point = this.event.gridCell;
            this.grid.selectViewportCell(point.x, point.y - this.grid.getHeaderRowCount());
            this.errorEffectBegin(++this.errors % feedback === 0 && error);
        } else { // invalid but no feedback
            this.cancelEditing();
        }

        return !error;
    },

    /** @summary Cancels editing.
     * @returns {boolean} Successful. (Cancel is always successful.)
     */
    cancelEditing: function() {
        this.setEditorValue(this.initialValue);
        this.hideEditor();
        this.grid.cellEditor = null;
        this.el.remove();

        return true;
    },

    /**
     * Calls the effect function indicated in the {@link CellEditor#errorEffect|errorEffect} property which triggers a series of CSS transitions.
     * @param {boolean|string|Error} [error] - If defined, call the {@link CellEditor#errorEffectEnd|errorEffectEnd} method at the end of the last effect transition with this error.
     * @memberOf CellEditor.prototype
     */
    errorEffectBegin: function(error) {
        var options = { callback: error && this.errorEffectEnd.bind(this, error) },
            effect = this.errorEffect;

        if (typeof effect === 'string') {
            effect = this.errorEffects[effect];
        }

        if (typeof effect === 'object') {
            _(options).extendOwn(effect.options);
            effect = effect.effector;
        }

        if (typeof effect === 'function') {
            effect.call(this, options);
        } else {
            throw 'Expected `this.errorEffect` to resolve to an error effect function.';
        }
    },

    /**
     * This function expects to be passed an error. There is no point in calling this function if there is no error. Nevertheless, if called with a falsy `error`, returns without doing anything.
     * @this {CellEditor}
     * @param {boolean|string|Error} [error]
     */
    errorEffectEnd: function(error) {
        if (error) {
            var msg =
                'Invalid value. To resolve, do one of the following:\n\n' +
                '   * Correct the error and try again.\n' +
                '         - or -\n' +
                '   * Cancel editing by pressing the "esc" (escape) key.';

            error = error.message || error;

            if (typeof error !== 'string') {
                error = '';
            }

            if (this.localizer.expectation) {
                error = error ? error + '\n' + this.localizer.expectation : this.localizer.expectation;
            }

            if (error) {
                if (/[\n\r]/.test(error)) {
                    error = '\n' + error;
                    error = error.replace(/[\n\r]+/g, '\n\n   * ');
                }
                msg += '\n\nAdditional information about this error: ' + error;
            }

            alert(msg); // eslint-disable-line no-alert
        }
    },

    /** @typedef effectObject
     * @property {effectFunction} effector
     * @property {object} [options] - An options object with which to call the function.
     */
    /**
     * May be one of:
     * * **string** - Name of registered error effect.
     * * **effectFunction** - Reference to an effect function.
     * * **effectObject** - Reference to an effectObject containing an {@link effectFunction} and an `options` object with which to call the function.
     * @type {string|effectFunction|effectObject}
     * @memberOf CellEditor.prototype
     */
    errorEffect: 'shaker',

    /**
     * Hash of registered {@link effectFunction}s or {@link effectObject}s.
     * @memberOf CellEditor.prototype
     */
    errorEffects: {
        shaker: effects.shaker,
        glower: effects.glower
    },

    /**
     * @desc save the new value into the behavior (model)
     * @returns {boolean} Data changed and pre-cell-edit event was not canceled.
     * @memberOf CellEditor.prototype
     */
    saveEditorValue: function(value) {
        var save =
            !(value && value === this.initialValue) && // data changed
            this.grid.fireBeforeCellEdit(this.event.gridCell, this.initialValue, value, this); // proceed

        if (save) {
            this.grid.behavior.setValue(this.event, value);
            this.grid.fireAfterCellEdit(this.event.gridCell, this.initialValue, value, this);
        }

        return save;
    },

    /**
     * @summary Extract the edited value from the editor.
     * @desc De-format the edited string back into a primitive value.
     *
     * The localizer's {@link localizerInterface#parse|parse} method will be called on the text box contents.
     *
     * Override this method if your editor has additional or alternative GUI elements. The GUI elements will influence the primitive value, either by altering the edited string before it is parsed, or by transforming the parsed value before returning it.
     * @returns {object} the current editor's value
     * @memberOf CellEditor.prototype
     */
    getEditorValue: function() {
        return this.localizer.parse(this.input.value);
    },

    /**
     * If there is no validator on the localizer, returns falsy (not invalid; possibly valid).
     * @returns {boolean|string} Truthy value means invalid. If a string, this will be an error message. If not a string, it merely indicates a generic invalid result.
     */
    validateEditorValue: function() {
        return this.localizer.invalid && this.localizer.invalid(this.input.value);
    },

    /**
     * @summary Request focus for my input control.
     * @desc See GRID-95 "Scrollbar moves inward" for issue and work-around explanation.
     * @memberOf CellEditor.prototype
     */
    takeFocus: function() {
        var el = this.el,
            leftWas = el.style.left,
            topWas = el.style.top;

        el.style.left = el.style.top = 0; // work-around: move to upper left

        var x = window.scrollX, y = window.scrollY;
        this.input.focus();
        window.scrollTo(x, y);
        this.selectAll();

        el.style.left = leftWas;
        el.style.top = topWas;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc select everything
     */
    selectAll: nullPattern,

    /**
     * @memberOf CellEditor.prototype
     * @desc set the bounds of my input control
     * @param {rectangle} rectangle - the bounds to move to
     */
    setBounds: function(cellBounds) {
        var style = this.el.style;

        style.left = px(cellBounds.x);
        style.top = px(cellBounds.y);
        style.width = px(cellBounds.width);
        style.height = px(cellBounds.height);
    },

    /**
     * @desc check that the editor is in the correct location, and is showing/hidden appropriately
     * @memberOf CellEditor.prototype
     */
    checkEditor: function() {
        if (this.checkEditorPositionFlag) {
            this.checkEditorPositionFlag = false;
            if (this.event.isCellVisible) {
                this.setEditorValue(this.initialValue);
                this.attachEditor();
                this.moveEditor();
                this.showEditor();
                this.takeFocus();
            } else {
                this.hideEditor();
            }
        }
    },

    attachEditor: function() {
        this.grid.div.appendChild(this.el);
    },

    template: ''

});

function nullPattern() {}
function px(n) { return n + 'px'; }


CellEditor.abstract = true; // don't instantiate directly


module.exports = CellEditor;

},{"../Base":49,"../lib/DOM/effects":110,"../lib/Localization":113,"mustache":41,"object-iterators":42}],59:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * As of spring 2016:
 * Functions well in Chrome and Firefox; unimplemented in Safari.
 * @constructor
 * @extends CellEditor
 */
var Color = CellEditor.extend('Color', {

    template: '<input type="color" lang="{{locale}}" style="{{style}}">'

});

module.exports = Color;

},{"./CellEditor":58}],60:[function(require,module,exports){
// ComboBox.js - A combo-box is a combination of a text-box and a drop-down.
// User may type into it and/or select an item from the drop-down (by clicking on the triangle at the right).
// The drop-down has sections which are toggled from a control area between the text-box and the drop-down.

/* eslint-env browser */

'use strict';

var Textfield = require('./Textfield');
var prototype = require('./CellEditor').prototype;
var Queueless = require('../lib/DOM/queueless');
var elfor = require('../lib/DOM/elfor');

/*********************************/
/* eslint-disable no-unused-vars */
/*********************************/

var TOGGLE_MODE_PREFIX = 'toggle-mode-';

var stateToActionMap = {
    hidden: slideDown,
    visible: slideUp
};

/**
 * A combo box is a text box that also has a drop-down containing options. The drop-down consists of an actual drop-down list (a `<select>` list) plus a _control area_ above it containing toggles. The toggles control the visibility of the various "mode lists."
 *
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 * @extends Textfield
 */
var ComboBox = Textfield.extend('ComboBox', {

    initialize: function() {
        var el = this.el;

        this.input = el.querySelector('input');
        this.dropper = el.querySelector('span');
        this.options = el.querySelector('div');
        this.controls = this.options.querySelector('div');
        this.dropdown = this.options.querySelector('select');

        this.controllable = this.modes.length > 1;

        // set up a transition end controller
        this.optionsTransition = new Queueless(this.options, this);

        this.menuModesSource = this.column.menuModes || { distinctValues: true };

        // wire-ups
        this.dropper.addEventListener('mousedown', this.toggleDropDown.bind(this));
        this.dropdown.addEventListener('mousewheel', function(e) { e.stopPropagation(); });
        this.dropdown.addEventListener('change', this.insertText.bind(this));
    },

    template: [
'<div class="hypergrid-combobox" title="">',
'    <input type="text" lang="{{locale}}" style="{{style}}">',
'    <span title="Click for options"></span>',
'    <div>',
'        <div></div>',
'        <select size="15" lang="{{locale}}"></select>',
'    </div>',
'</div>'
    ].join('\n'),

    modes: [
        {
            name: 'distinctValues',
            appendOptions: function(optgroup) {
                // get the distinct column values and sort them
                var distinct = {},
                    d = [],
                    columnName = this.column.name,
                    formatter = this.column.getFormatter();

                this.grid.behavior.getData().forEach(function(dataRow) {
                    var val = formatter(dataRow[columnName]);
                    distinct[val] = (distinct[val] || 0) + 1;
                });

                for (var key in distinct) {
                    d.push(key);
                }

                while (optgroup.firstElementChild) {
                    optgroup.firstElementChild.remove();
                }

                d.sort().forEach(function(val) {
                    var option = new Option(val + ' (' + distinct[val] + ')', val);
                    optgroup.appendChild(option);
                });

                return d.length;
            }
        }
    ],

    showEditor: function() {
        var menuModesSource = this.menuModesSource,
            menuModes = this.menuModes = {};

        // build the proxy
        this.modes.forEach(function(mode) {
            var modeName = mode.name;
            if (modeName in menuModesSource) {
                menuModes[modeName] = menuModesSource[modeName];
            }
        });

        // wire-ups
        if (this.controllable) {
            this.controls.addEventListener('click', onModeIconClick.bind(this));
        }

        // set the initial state of the mode toggles
        this.modes.forEach(function(mode) {
            // create a toggle
            var toggle = document.createElement('span');
            if (this.controllable) {
                toggle.className = TOGGLE_MODE_PREFIX + mode.name;
                toggle.title = 'Toggle ' + (mode.label || mode.name).toLowerCase();
                toggle.textContent = mode.symbol;
            }
            this.controls.appendChild(toggle);

            // create and label a new optgroup
            if (mode.selector) {
                var optgroup = document.createElement('optgroup');
                optgroup.label = mode.label;
                optgroup.className = 'submenu-' + mode.name;
                optgroup.style.backgroundColor = mode.backgroundColor;
                this.dropdown.add(optgroup);
            }

            setModeIconAndOptgroup.call(this, toggle, mode.name, menuModes[mode.name]);
        }.bind(this));

        prototype.showEditor.call(this);
    },

    hideEditor: function() {
        // this is where you would persist this.menuModes
        prototype.hideEditor.call(this);
    },

    toggleDropDown: function() {
        if (!this.optionsTransition.transitioning) {
            var state = window.getComputedStyle(this.dropdown).visibility;
            stateToActionMap[state].call(this);
        }
    },

    insertText: function(e) {
        // replace the input text with the drop-down text
        this.input.focus();
        this.input.value = this.dropdown.value;
        this.input.setSelectionRange(0, this.input.value.length);

        // close the drop-down
        this.toggleDropDown();
    }
});

function onModeIconClick(e) {
    var ctrl = e.target;

    if (ctrl.tagName === 'SPAN') {
        // extra ct the mode name from the toggle control's class name
        var modeClassName = Array.prototype.find.call(ctrl.classList, function(className) {
                return className.indexOf(TOGGLE_MODE_PREFIX) === 0;
            }),
            modeName = modeClassName.substr(TOGGLE_MODE_PREFIX.length);

        // toggle mode in the filter
        var modeState = this.menuModes[modeName] ^= 1;

        setModeIconAndOptgroup.call(this, ctrl, modeName, modeState);
    }
}

function setModeIconAndOptgroup(ctrl, name, state) {
    var style, optgroup, sum, display,
        dropdown = this.dropdown,
        mode = this.modes.find(function(mode) { return mode.name === name; }); // eslint-disable-line no-shadow

    // set icon state (color)
    ctrl.classList.toggle('active', !!state);

    // empty the optgroup if hiding; rebuild it if showing
    if (state) { // rebuild it
        // show progress cursor for (at least) 1/3 second
        style = this.el.style;
        style.cursor = 'progress';
        setTimeout(function() { style.cursor = null; }, 333);

        if (mode.selector) {
            optgroup = dropdown.querySelector(mode.selector);
            sum = mode.appendOptions.call(this, optgroup);

            // update sum
            optgroup.label = optgroup.label.replace(/ \(\d+\)$/, ''); // remove old sum
            optgroup.label += ' (' + sum + ')';
        } else {
            sum = mode.appendOptions.call(this, dropdown);
            if (!this.controllable) {
                ctrl.textContent = sum + ' values';
            }
        }

        display = null;
    } else {
        display = 'none';
    }

    // hide/show the group
    var selector = mode.selector;
    if (!selector) {
        selector = 'option,optgroup:not([class])';
        var mustBeChildren = true; // work-around for ':scope>option,...' not avail in IE11
    }
    elfor.each(selector, iteratee, dropdown);

    function iteratee(el) {
        if (!mustBeChildren || el.parentElement === dropdown) {
            el.style.display = display;
        }
    }

    // TODO: Reset the width of this.options to the natural width of this.dropdown. To do this, we need to remove the latter's "width: 100%" from the CSS and then set an explicit this.options.style.width based on the computed width of this.dropdown. This is complicated by the fact that it cannot be done before it is in the DOM.
}

function slideDown() {
    // preserve the text box's current text selection, which is about to be lost
    this.selectionStart = this.input.selectionStart;
    this.selectionEnd = this.input.selectionEnd;

    // clean up the select list from last usage
    this.dropdown.selectedIndex = -1; // be kind (remove previous selection)
    this.dropdown.style.scrollTop = 0; // rewind

    // show the drop-down slide down effect
    this.options.style.visibility = 'visible';
    var dropDownTopMargin = getFloat(this.dropdown, 'marginTop'),
        dropDownRows = this.dropdown.size,
        optionHeight = Math.ceil((this.dropdown.length ? getFloat(this.dropdown[0], 'height') : 13.1875) * 2) / 2 + 1;
    this.options.style.height = dropDownTopMargin + optionHeight * dropDownRows + 'px'; // starts the slide down effect

    // while in drop-down, listen for clicks in text box which means abprt
    this.input.addEventListener('mousedown', this.slideUpBound = slideUp.bind(this));

    // wait for transition to end
    this.optionsTransition.begin();
}

function slideUp() {
    // stop listening to input clicks
    this.input.removeEventListener('mousedown', this.slideUpBound);

    // start the slide up effect
    this.options.style.height = 0;

    // schedule the hide to occur after the slide up effect
    this.optionsTransition.begin(function(event) {
        this.style.visibility = 'hidden';
    });
}

function getFloat(el, style) {
    return parseFloat(window.getComputedStyle(el)[style]);
}


module.exports = ComboBox;

},{"../lib/DOM/elfor":111,"../lib/DOM/queueless":112,"./CellEditor":58,"./Textfield":66}],61:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var CellEditor = require('./CellEditor');

var isChromium = window.chrome,
    winNav = window.navigator,
    vendorName = winNav.vendor,
    isOpera = winNav.userAgent.indexOf('OPR') > -1,
    isIEedge = winNav.userAgent.indexOf('Edge') > -1,
    isIOSChrome = winNav.userAgent.match('CriOS'),
    isChrome = !isIOSChrome &&
        isChromium !== null &&
        isChromium !== undefined &&
        vendorName === 'Google Inc.' &&
        isOpera == false && isIEedge == false; // eslint-disable-line eqeqeq

/**
 * As of spring 2016:
 * Functions well in Chrome except no localization (day, month names; date format).
 * Unimplemented in Safari, Firefox, Internet Explorer.
 * This is a "snmart" control. It detects Chrome:
 * * If Chrome, uses chromeDate overrides format to that required by the value attribute, yyyy-mm-dd. (Note that this is not the format displayed in the control, which is always mm/dd/yyyy.)
 * * Otherwise uses localized date format _but_ falls back to a regular text box.
 * @constructor
 * @extends CellEditor
 */
var Date = CellEditor.extend('Date', {

    initialize: function(grid) {

        var localizerName,
            usesDateInputControl = isChrome;

        if (usesDateInputControl) {
            localizerName = 'chromeDate';
            this.template = '<input type="date">';
        } else {
            localizerName = 'date';
            this.template = '<input type="text" lang="{{locale}}">';

            this.selectAll = function() {
                var lastCharPlusOne = this.getEditorValue().length;
                this.input.setSelectionRange(0, lastCharPlusOne);
            };
        }

        this.localizer = grid.localization.get(localizerName);
    }
});


module.exports = Date;

},{"./CellEditor":58}],62:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var popMenu = require('pop-menu');

var ComboBox = require('./ComboBox');
var prototype = require('./CellEditor').prototype;


/**
 * The select list consists of the following sets of drop-down items:
 * * `operators` (icon *&lt;*) The particular selection of operators for this column. Comes from the filter tree.
 * * `distinctValues` (icon *#*) List of distinct column values. Calculated from inspection of column values on _and_ on icon click.
 * * `columnNames` (icon *T*) List other column names. Calculated from inspection of column values on _and_ on icon click.
 *
 * The control area reflects the `this.modes` array (above). It is modeled by a 'menuModes` object, a hash with boolean properties representing the state of each of the sets of menu items outlined above. Missing properties are falsy by implication. The state semantics are:
 *   * `1` or `true` means adds CSS class `active` to icon _and_ shows set's items in drop-down.
 *   * `0` or `false` means removes (CSS class `active` from icon _and_ hides set's items in drop-down.
 *
 * *Persisting changes:* The only change this UI supports (besides the filter text itself) is the menu mode states, which are expected to be "sticky." That is, they are "persisted" (written back) to the filter. However, there is a problem: When the column filter is blank it doesn't actually exist yet in the filter, so there is nowhere to save it. The solution is to read the `menuModes` hash _from_ the filter tree but don't modify it until end of editing. Reading it from the filter tree picks up previous setting if there was an extant column filter or the default if there was not. But then, rather than modifying this structure (because it might be the default and we don't want to overwrite that), we hang a proxy copy off the behavior's column object for this column. This will persist it for the duration of the app session. At end of editing, if and only if there is now a column filter (text is not blank), we copy it to the column filter's subtree node in the filter tree.
 *
 * @constructor
 * @extends ComboBox
 */
var FilterBox = ComboBox.extend('FilterBox', {

    initialize: function() {

        // look in the filter, under column filters, for a column filter for this column
        var root = this.grid.behavior.filter,
            columnFilters = root && root.columnFilters;

        if (!columnFilters) {
            throw 'Column filters not available.';
        }

        var columnName = this.column.name,
            columnFilterSubtree = root.getColumnFilter(columnName) || {},
            columnSchema = root.schema.lookup(columnName) || {};


        // get the operator list from the node, schema, typeOpMap, or root:
        // (This mimics the code in FilterLeaf.js's `getOpMenu` function because the node may not exist yet.)
        this.opMenu =

            // pull operator list from column schema if available
            columnSchema.opMenu ||

            // operator list for the column's type if available
            root.typeOpMap && root.typeOpMap[columnSchema.type || columnFilterSubtree.type] ||

            // default operator list (which itself defaults to `Conditionals.defaultOpMenu`)
            root.opMenu;


        // get the column filter's `menuModes` object -- contains the states of the drop-down option icons:
        this.menuModesSource =

            // first try proxy from last time (because editing may have ended without a column filter to put in the filter tree)
            this.column.menuModes ||

            // ELSE try column filter's `menuModes` WHEN available
            columnFilterSubtree.menuModes ||

            // try use column schema's `menuModes` when defined
            columnSchema.menuModes ||

            // ELSE try the filter default (which itself defaults to operators ON, others OFF; see definition at top of DefaultFilter.js)
            columnFilters.menuModes;

    },

    abortEditing: prototype.cancelEditing,

    /**
     * When there's only one mode defined here, the control area portion of the UI is hidden.
     */
    modes: [
        {
            name: 'operators',
            symbol: '<',
            appendOptions: function(dropdown) {
                if (!dropdown.length) {
                    // Various  operator options and/or optgroups vary per column based on `opMenu`.
                    var opMenuGroups = this.grid.behavior.filter.opMenuGroups;
                    popMenu.build(dropdown, this.opMenu, {
                        group: function(groupName) {
                            return opMenuGroups[groupName];
                        },
                        prompt: null
                    });
                    // This list of conjunctions is an extra and is for all columns. All operator optgroups are classless.
                    var optgroup = document.createElement('optgroup');
                    optgroup.label = 'Conjunctions';
                    optgroup.appendChild(new Option('and', ' and '));
                    optgroup.appendChild(new Option('or', ' or '));
                    optgroup.appendChild(new Option('nor', ' nor '));
                }
            }
        }, {
            name: 'columnNames',
            label: 'Column Names',
            selector: 'optgroup.submenu-columnNames',
            symbol: 'A',
            backgroundColor: '#eff',
            appendOptions: function(optgroup) {
                var columns = this.grid.behavior.columns,
                    x = this.event.gridCell.x;

                while (optgroup.firstElementChild) {
                    optgroup.firstElementChild.remove();
                }

                columns.forEach(function(column, index) {
                    if (index !== x) {
                        var name = column.name,
                            option = new Option(name);
                        option.title = '[' + name + ']\r"' + column.header + '"';
                        optgroup.appendChild(option);
                    }
                });
                return columns.length;
            }
        }, {
            name: 'distinctValues',
            label: 'Distinct Values',
            selector: 'optgroup.submenu-distinctValues',
            symbol: '#',
            backgroundColor: '#fef',
            appendOptions: ComboBox.prototype.modes[0].appendOptions
        }
    ],

    /**
     * Write the `menuModes` proxy to the filter tree's column filter subtree node.
     * We look up the node again here because it might be new; or may have been deleted & recreated during editing.
     */
    hideEditor: function() {
        // look in the filter, under column filters, for a column filter for this column
        var filter = this.grid.behavior.filter,
            columnName = this.column.name,
            columnFilterSubtree = filter.getColumnFilter(columnName);

        if (columnFilterSubtree) {
            // write back to filter-tree node for persisting with getState
            columnFilterSubtree.menuModes = this.menuModes;
        }

        this.column.menuModes = this.menuModes;

        ComboBox.prototype.hideEditor.call(this);
    },

    keyup: function(e) {
        if (e) {
            prototype.keyup.call(this, e);

            if (this.grid.properties.filteringMode === 'immediate') {
                this.saveEditorValue(this.getEditorValue());
                this.moveEditor();
            }
        }
    },

    insertText: function(e) {
        var start = this.selectionStart,
            end = this.selectionEnd,
            dropdown = this.dropdown,
            operator = dropdown.value,
            option = dropdown.options[dropdown.selectedIndex],
            optgroup = option.parentElement,
            isOperator = !(optgroup.tagName === 'OPTGROUP' && optgroup.className);

        this.input.focus();

        if (start === end && isOperator) {
            var parser = this.grid.behavior.filter.parserCQL,
                cql = this.input.value,
                position = parser.getOperatorPosition(cql, this.selectionStart, operator);

            start = position.start;
            end = position.end;

            // prepend space to operator as needed
            if (
                start > 0 && // not at very beginning? and...
                !/\s/.test(cql[start - 1]) // no white space before operator?
            ) {
                operator = ' ' + operator;
            }

            // append space to operator as needed
            if (
                end === cql.length || // at very end? or...
                !/\s/.test(cql[end]) // no white space after operator?
            ) {
                operator += ' ';
            }
        }

        // insert the drop-down text at the insertion point or over the selected text
        this.input.setRangeText(operator, start, end, 'end');

        // close the drop-down
        this.toggleDropDown();
    },

    saveEditorValue: function(value) {
        prototype.saveEditorValue.call(this, value);
        this.grid.behavior.applyAnalytics();
    }

});


module.exports = FilterBox;

},{"./CellEditor":58,"./ComboBox":60,"pop-menu":44}],63:[function(require,module,exports){
'use strict';

var Textfield = require('./Textfield');

/**
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 * @extends Textfield
 */
var Number = Textfield.extend('Number', {

    initialize: function(grid) {
        this.localizer = grid.localization.get('number');
    }

});

module.exports = Number;

},{"./Textfield":66}],64:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * @constructor
 * @extends CellEditor
 */
var Slider = CellEditor.extend('Slider', {

    template: '<input type="range" lang="{{locale}}" style="{{style}}">'

});

module.exports = Slider;

},{"./CellEditor":58}],65:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');

/**
 * @constructor
 * @extends CellEditor
 */
var Spinner = CellEditor.extend('Spinner', {

    template: '<input type="number" lang="{{locale}}" style="{{style}}">'

});

module.exports = Spinner;

},{"./CellEditor":58}],66:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor');
var Localization = require('../lib/Localization');


/**
 * As of spring 2016:
 * Functions well in Chrome, Safari, Firefox, and Internet Explorer.
 * @constructor
 * @extends CellEditor
 */
var Textfield = CellEditor.extend('Textfield', {

    template: '<input type="text" lang="{{locale}}" class="hypergrid-textfield" style="{{style}}">',

    initialize: function() {
        this.input.style.textAlign = this.event.getCellProperty('halign');
    },

    localizer: Localization.prototype.string,

    selectAll: function() {
        this.input.setSelectionRange(0, this.input.value.length);
    }
});

module.exports = Textfield;

},{"../lib/Localization":113,"./CellEditor":58}],67:[function(require,module,exports){
/**
 * @module cellEditors
 */

'use strict';

/**
 *
 * @param {Hypergrid} grid
 * @param {boolean} [privateRegistry=false] - This instance will use a private registry.
 * @constructor
 */
function CellEditors(grid, privateRegistry) {
    this.grid = grid;

    if (privateRegistry) {
        this.editors = {};
    }

    // preregister the standard cell editors
    if (privateRegistry || !this.get('celleditor')) {
        this.add(require('./CellEditor'));
        this.add(require('./ComboBox'));
        this.add(require('./Color'));
        this.add(require('./Date'));
        this.add(require('./FilterBox'));
        this.add(require('./Number'));
        this.add(require('./Slider'));
        this.add(require('./Spinner'));
        this.add(require('./Textfield'));
    }
}

CellEditors.prototype = {
    constructor: CellEditors.prototype.constructor, // preserve constructor

    /**
     * @summary Register a cell editor constructor.
     * @desc Adds a custom cell editor constructor to the `editors` hash using the provided name (or the class name), converted to all lower case.
     *
     * > All native cell editors are "preregistered" in `editors`..
     *
     * @param {string} [name] - Case-insensitive editor key. If not given, `YourCellEditor.prototype.$$CLASS_NAME` is used.
     *
     * @param {YourCellEditor.prototype.constructor} Constructor - A constructor, typically extended from `CellEditor` (or a descendant therefrom).
     *
     * > Note: `$$CLASS_NAME` can be easily set up by providing a string as the (optional) first parameter (`alias`) in your {@link https://www.npmjs.com/package/extend-me|CellEditor.extend} call.
     *
     * @returns {CellEditor} A newly registered constructor extended from {@link CellEditor}.
     *
     * @memberOf module:cellEditors
     */
    add: function(name, Constructor) {
        if (typeof name === 'function') {
            Constructor = name;
            name = undefined;
        }

        name = name || Constructor.prototype.$$CLASS_NAME;
        name = name && name.toLowerCase();
        this.editors[name] = Constructor;
        return Constructor;
    },

    /**
     * @summary Register a synonym for an existing cell editor constructor.
     * @param {string} synonymName
     * @param {string} existingName
     * @returns {CellEditor} The previously registered constructor this new synonym points to.
     * @memberOf CellEditors.prototype
     */
    addSynonym: function(synonymName, existingName) {
        var cellEditor = this.get(existingName);
        return (this.editors[synonymName] = cellEditor);
    },

    /**
     * @param {string} name - Name of a registered editor.
     * @returns {CellEditor} A registered constructor extended from {@link CellEditor}.
     * @memberOf CellEditors.prototype
     */
    get: function(name) {
        return this.editors[name && name.toLowerCase()];
    },

    /**
     * @summary Lookup registered cell editor and return a new instance thereof.
     * @desc Note: Must be called with the Hypergrid object as context!
     * @returns {CellEditor} New instance of the named cell editor.
     * @param {string} name - Name of a registered editor.
     * @param {string} [options] - Properties to add to the instantiated editor primarily for mustache's use.
     * @memberOf CellEditors.prototype
     */
    create: function(name, options) {
        var cellEditor,
            Constructor = this.get(name);

        if (Constructor) {
            if (Constructor.abstract) {
                throw 'Attempt to instantiate an "abstract" cell editor class.';
            }
            cellEditor = new Constructor(this.grid, options);
        }

        return cellEditor;
    },

    /**
     * The cell editor registry containing all the "preregistered" cell editor constructors.
     * @private
     * @memberOf CellEditors.prototype
     */
    editors: {}
};

module.exports = CellEditors;

},{"./CellEditor":58,"./Color":59,"./ComboBox":60,"./Date":61,"./FilterBox":62,"./Number":63,"./Slider":64,"./Spinner":65,"./Textfield":66}],68:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var Button = CellRenderer.extend('Button', {

    /**
     * @summary The default cell rendering function for a button cell.
     * @implements paintFunction
     * @memberOf Button.prototype
     */
    paint: function(gc, config) {
        var val = config.value,
            c = config.x,
            r = config.y,
            bounds = config.bounds,
            x = bounds.x + 1,
            y = bounds.y + 1,
            width = bounds.width - 1 - config.lineWidth,
            height = bounds.height - 1 - config.lineWidth,
            radius = height / 2,
            arcGradient = gc.createLinearGradient(x, y, x, y + height);

        if (config.mouseDown) {
            arcGradient.addColorStop(0, '#B5CBED');
            arcGradient.addColorStop(1, '#4d74ea');
        } else {
            arcGradient.addColorStop(0, '#ffffff');
            arcGradient.addColorStop(1, '#aaaaaa');
        }

        // draw the background
        gc.fillStyle = config.backgroundColor;
        gc.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

        // draw the capsule
        gc.fillStyle = arcGradient;
        gc.strokeStyle = '#000000';
        this.roundRect(gc, x, y, width, height, radius, arcGradient, true);

        var ox = (width - config.getTextWidth(gc, val)) / 2;
        var oy = (height - config.getTextHeight(gc.font).descent) / 2;

        // draw the text
        gc.textBaseline = 'middle';
        gc.fillStyle = '#333333';
        gc.font = height - 2 + 'px sans-serif';
        config.backgroundColor = 'rgba(0,0,0,0)';
        gc.fillText(val, x + ox, y + oy);

        //identify that we are a button
        config.buttonCells[c + ',' + r] = true;
    }
});

module.exports = Button;



},{"./CellRenderer":69}],69:[function(require,module,exports){
'use strict';

var Base = require('../Base');

/** @typedef paintFunction
 * @type {function}
 * @this {CellEditor}
 * @param {CanvasGraphicsContext} gc
 * @param {object} config
 * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
 * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
 * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
 * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
 * @param {number} config.y - the vertical grid coordinate measured from top header row
 */

/** @constructor
 * @desc Instances of `CellRenderer` are used to render the 2D graphics context within the bound of a cell. Extend this base class to implement your own cell renderer
 *
 *
 * See also {@tutorial cell-renderer}.
 */
var CellRenderer = Base.extend('CellRenderer', {
    /**
     * @desc An empty implementation of a cell renderer, see [the null object pattern](http://c2.com/cgi/wiki?NullObject).
     * @implements paintFunction
     * @memberOf CellRenderer.prototype
     */
    paint: function(gc, config) {},

    /**
     * @desc A simple implementation of rounding a cell.
     * @param {CanvasGraphicsContext} gc
     * @param {number} x - the x grid coordinate of my origin
     * @param {number} y - the y grid coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {number} radius
     * @param {number} fill
     * @param {number} stroke
     * @memberOf CellRenderer.prototype
     */
    roundRect: function(gc, x, y, width, height, radius, fill, stroke) {

        if (!stroke) {
            stroke = true;
        }
        if (!radius) {
            radius = 5;
        }
        gc.beginPath();
        gc.moveTo(x + radius, y);
        gc.lineTo(x + width - radius, y);
        gc.quadraticCurveTo(x + width, y, x + width, y + radius);
        gc.lineTo(x + width, y + height - radius);
        gc.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        gc.lineTo(x + radius, y + height);
        gc.quadraticCurveTo(x, y + height, x, y + height - radius);
        gc.lineTo(x, y + radius);
        gc.quadraticCurveTo(x, y, x + radius, y);
        gc.closePath();
        if (stroke) {
            gc.stroke();
        }
        if (fill) {
            gc.fill();
        }
        gc.closePath();
    }
});

CellRenderer.abstract = true; // don't instantiate directly

module.exports = CellRenderer;

},{"../Base":49}],70:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var ErrorCell = CellRenderer.extend('ErrorCell', {

    /**
     * @summary Writes error message into cell.
     *
     * @desc This function is guaranteed to be called as follows:
     *
     * ```javascript
     * gc.save();
     * gc.beginPath();
     * gc.rect(x, y, width, height);
     * gc.clip();
     * behavior.getCellProvider().renderCellError(gc, message, x, y, width, height);
     * gc.restore();
     * ```
     *
     * Before doing anything else, this function should clear the cell by setting `gc.fillStyle` and calling `gc.fill()`.
     *
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {number} config.x - the "translated" index into the `behavior.allColumns` array
     * @param {number} config.normalizedY - the vertical grid coordinate normalized to first data row
     * @param {number} config.untranslatedX - the horizontal grid coordinate measured from first data column
     * @param {number} config.y - the vertical grid coordinate measured from top header row
     * @memberOf ErrorCell.prototype
     */
    paint: function(gc, config, message) {
        //var images = require('../../images/index');
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        // clear the cell
        // (this makes use of the rect path defined by the caller)
        gc.fillStyle = '#FFD500';
        gc.fill();
        // render cell border
        //gc.strokeStyle = gc.createPattern(images.caution, 'repeat'); // Causes Error
        gc.lineWidth = 5;
        gc.beginPath();
        gc.moveTo(x, y); // caution: do not use rect() here because Chrome does not clip its stroke properly
        gc.lineTo(x + width, y);
        gc.lineTo(x + width, y + height);
        gc.lineTo(x, y + height);
        gc.lineTo(x, y);
        gc.stroke();
        // adjust clip region to prevent text from rendering over right border should it overflow
        gc.beginPath();
        gc.rect(x, y, width - 2, height);
        gc.clip();
        // render message text
        gc.fillStyle = '#A00';
        gc.textAlign = 'start';
        gc.textBaseline = 'middle';
        gc.font = 'bold 6pt "arial narrow", verdana, geneva';
        gc.fillText(message, x + 4, y + height / 2 + 0.5);
    }
});

module.exports = ErrorCell;

},{"./CellRenderer":69}],71:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var LastSelection = CellRenderer.extend('LastSelection', {

    /**
     * @desc A rendering of the last Selection Model
     * @implements paintFunction
     * @memberOf LastSelection.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        // var focusLineStep =  [
        //     [5, 5],
        //     [0, 1, 5, 4],
        //     [0, 2, 5, 3],
        //     [0, 3, 5, 2],
        //     [0, 4, 5, 1],
        //     [0, 5, 5, 0],
        //     [1, 5, 4, 0],
        //     [2, 5, 3, 0],
        //     [3, 5, 2, 0],
        //     [4, 5, 1, 0]
        // ];
        gc.rect(x + 1, y, width - 2, height - 2);
        gc.fillStyle = config.selectionRegionOverlayColor;
        gc.fill();
        gc.lineWidth = 1;
        gc.strokeStyle = config.selectionRegionOutlineColor;

        // animate the dashed line a bit here for fun

        gc.stroke();

        // gc.rect(x, y, width, height);
        //
        // gc.strokeStyle = 'white';
        //
        // //animate the dashed line a bit here for fun
        // gc.setLineDash(focusLineStep[Math.floor(10 * (Date.now() / 300 % 1)) % focusLineStep.length]);
        //
        // gc.stroke();
    }
});

module.exports = LastSelection;



},{"./CellRenderer":69}],72:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var SimpleCell = CellRenderer.extend('SimpleCell', {

    /**
     * @summary The default cell rendering function for rendering a vanilla cell.
     * @desc Great care has been taken in crafting this function as it needs to perform extremely fast. Reads on the gc object are expensive but not quite as expensive as writes to it. We do our best to avoid writes, then avoid reads. Clipping bounds are not set here as this is also an expensive operation. Instead, we truncate overflowing text and content by filling a rectangle with background color column by column instead of cell by cell.  This column by column fill happens higher up on the stack in a calling function from fin-hypergrid-renderer.  Take note we do not do cell by cell border renderering as that is expensive.  Instead we render many fewer gridlines after all cells are rendered.
     * @implements paintFunction
     * @memberOf SimpleCell.prototype
     */
    paint: function(gc, config) {
        var val = config.value,
            bounds = config.bounds,
            x = bounds.x,
            y = bounds.y,
            width = bounds.width,
            height = bounds.height,
            leftPadding = 2; //TODO: fix this

        var leftIcon, rightIcon, centerIcon, ixoffset, iyoffset, font;

        // setting gc properties are expensive, let's not do it needlessly

        if (val && val.constructor === Array) {
            leftIcon = val[0];
            rightIcon = val[2];
            val = val[1];
            if (val && typeof val === 'object') {
                if (val.constructor.name === 'HTMLImageElement') { // must be an image
                    centerIcon = val;
                    val = null;
                }
            }
            if (leftIcon && leftIcon.nodeName !== 'IMG') {
                leftIcon = null;
            }
            if (rightIcon && rightIcon.nodeName !== 'IMG') {
                rightIcon = null;
            }
            if (centerIcon && centerIcon.nodeName !== 'IMG') {
                centerIcon = null;
            }
        }

        if (config.isUserDataArea) {
            val = valOrFunc(val, config, config.calculator);
        }

        val = config.formatValue(val);

        font = config.isSelected ? config.foregroundSelectionFont : config.font;

        if (gc.font !== font) {
            gc.font = font;
        }

        if (gc.textAlign !== 'left') {
            gc.textAlign = 'left';
        }
        if (gc.textBaseline !== 'middle') {
            gc.textBaseline = 'middle';
        }

        // fill background only if our bgColor is populated or we are a selected cell
        var backgroundColor, hover, hoverColor, selectColor,
            colors = [];

        if (config.isCellHovered && config.hoverCellHighlight.enabled) {
            hoverColor = config.hoverCellHighlight.backgroundColor;
        } else if (config.isRowHovered && (hover = config.hoverRowHighlight).enabled) {
            hoverColor = config.isGridColumn || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
        } else if (config.isColumnHovered && (hover = config.hoverColumnHighlight).enabled) {
            hoverColor = config.isGridRow || !hover.header || hover.header.backgroundColor === undefined ? hover.backgroundColor : hover.header.backgroundColor;
        }
        if (alpha(hoverColor) < 1) {
            if (config.isSelected) {
                selectColor = valOrFunc(config.backgroundSelectionColor, config);
            }
            if (alpha(selectColor) < 1) {
                backgroundColor = valOrFunc(config.backgroundColor, config);
                if (alpha(backgroundColor) > 0) {
                    colors.push(backgroundColor);
                }
            }
            if (selectColor !== undefined) {
                colors.push(selectColor);
            }
        }
        if (hoverColor !== undefined) {
            colors.push(hoverColor);
        }
        layerColors(gc, colors, x, y, width, height);

        // draw text
        var theColor = valOrFunc(config.isSelected ? config.foregroundSelectionColor : config.color, config);
        if (gc.fillStyle !== theColor) {
            gc.fillStyle = theColor;
            gc.strokeStyle = theColor;
        }

        if (config.isHeaderRow && config.headerTextWrapping) {
            this.renderMultiLineText(gc, config, val);
        } else {
            this.renderSingleLineText(gc, config, val);
        }

        var iconWidth = 0;
        if (leftIcon) {
            iyoffset = Math.round((height - leftIcon.height) / 2);
            gc.drawImage(leftIcon, x + leftPadding, y + iyoffset);
            iconWidth = Math.max(leftIcon.width + 2);
        }
        if (rightIcon && width > 1.75 * height) {
            iyoffset = Math.round((height - rightIcon.height) / 2);
            var rightX = x + width - rightIcon.width;
            if (backgroundColor !== undefined) {
                layerColors(gc, colors, rightX, y, rightIcon.width, height);
            } else {
                gc.clearRect(rightX, y, rightIcon.width, height);
            }
            gc.drawImage(rightIcon, rightX, y + iyoffset);
            iconWidth = Math.max(rightIcon.width + 2);
        }
        if (centerIcon) {
            iyoffset = Math.round((height - centerIcon.height) / 2);
            ixoffset = Math.round((width - centerIcon.width) / 2);
            gc.drawImage(centerIcon, x + width - ixoffset - centerIcon.width, y + iyoffset);
            iconWidth = Math.max(centerIcon.width + 2);
        }
        if (config.cellBorderThickness) {
            gc.beginPath();
            gc.rect(x, y, width, height);
            gc.lineWidth = config.cellBorderThickness;
            gc.strokeStyle = config.cellBorderStyle;

            // animate the dashed line a bit here for fun

            gc.stroke();
            gc.closePath();
        }
        config.minWidth = config.minWidth + 2 * (iconWidth);
    },

    /**
     * @summary Renders single line text.
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {*} val - The text to render in the cell.
     * @memberOf SimpleCell.prototype
     */
    renderMultiLineText: function(gc, config, val) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;
        var lines = fitText(gc, config, val, width);
        if (lines.length === 1) {
            return this.renderSingleLineText(gc, config, squeeze(val));
        }

        var colHEdgeOffset = config.cellPadding,
            halignOffset = 0,
            valignOffset = config.voffset,
            halign = config.halign,
            textHeight = config.getTextHeight(config.font).height;

        switch (halign) {
            case 'right':
                halignOffset = width - colHEdgeOffset;
                break;
            case 'center':
                halignOffset = width / 2;
                break;
            case 'left':
                halignOffset = colHEdgeOffset;
                break;
        }

        var hMin = 0, vMin = Math.ceil(textHeight / 2);

        valignOffset += Math.ceil((height - (lines.length - 1) * textHeight) / 2);

        halignOffset = Math.max(hMin, halignOffset);
        valignOffset = Math.max(vMin, valignOffset);

        gc.save(); // define a clipping region for cell
        gc.beginPath();
        gc.rect(x, y, width, height);
        gc.clip();

        gc.textAlign = halign;

        for (var i = 0; i < lines.length; i++) {
            gc.fillText(lines[i], x + halignOffset, y + valignOffset + (i * textHeight));
        }

        gc.restore(); // discard clipping region
    },

    /**
     * @summary Renders single line text.
     * @param {CanvasGraphicsContext} gc
     * @param {object} config
     * @param {Rectangle} config.bounds - The clipping rect of the cell to be rendered.
     * @param {*} val - The text to render in the cell.
     * @memberOf SimpleCell.prototype
     */
    renderSingleLineText: function(gc, config, val) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;
        var colHEdgeOffset = config.cellPadding,
            halignOffset = 0,
            valignOffset = config.voffset,
            halign = config.halign,
            isCellHovered = config.isCellHovered,
            isLink = config.link;

        var fontMetrics = config.getTextHeight(config.font);
        var textWidth = config.getTextWidth(gc, val);

        //we must set this in order to compute the minimum width
        //for column autosizing purposes
        config.minWidth = textWidth + (2 * colHEdgeOffset);

        switch (halign) {
            case 'right':
                //textWidth = config.getTextWidth(gc, config.value);
                halignOffset = width - colHEdgeOffset - textWidth;
                break;
            case 'center':
                //textWidth = config.getTextWidth(gc, config.value);
                halignOffset = (width - textWidth) / 2;
                break;
            case 'left':
                halignOffset = colHEdgeOffset;
                break;
        }

        halignOffset = Math.max(0, halignOffset);
        valignOffset += Math.ceil(height / 2);

        if (val !== null) {
            gc.fillText(val, x + halignOffset, y + valignOffset);
        }

        if (isCellHovered) {
            gc.beginPath();
            if (isLink) {
                underline(config, gc, val, x + halignOffset, y + valignOffset + Math.floor(fontMetrics.height / 2), 1);
                gc.stroke();
            }
            gc.closePath();
        }
        if (config.strikeThrough === true) {
            gc.beginPath();
            strikeThrough(config, gc, val, x + halignOffset, y + valignOffset + Math.floor(fontMetrics.height / 2), 1);
            gc.stroke();
            gc.closePath();
        }
    }
});


function fitText(gc, config, string, width) {
    return findLines(gc, config, squeeze(string).split(' '), width);
}

function findLines(gc, config, words, width) {

    if (words.length === 1) {
        return words;
    }

    // starting with just the first word
    var stillFits, line = [words.shift()];
    while (
        // so lone as line still fits within current column
    (stillFits = config.getTextWidth(gc, line.join(' ')) < width)
    // AND there are more words available
    && words.length
        ) {
        // add another word to end of line and retest
        line.push(words.shift());
    }

    if (
        !stillFits // if line is now too long
        && line.length > 1 // AND is multiple words
    ) {
        words.unshift(line.pop()); // back off by (i.e., remove) one word
    }

    line = [line.join(' ')];

    if (words.length) { // if there's anything left
        line = line.concat(findLines(gc, config, words, width)); // break it up as well
    }

    return line;
}

// trim string; then reduce all runs of multiple spaces to a single space
function squeeze(string) {
    return (string + '').trim().replace(/\s\s+/g, ' ');
}

function strikeThrough(config, gc, text, x, y, thickness) {
    var fontMetrics = config.getTextHeight(config.font);
    var width = config.getTextWidth(gc, text);
    y -= fontMetrics.height * 0.4;

    switch (gc.textAlign) {
        case 'center':
            x -= width / 2;
            break;
        case 'right':
            x -= width;
            break;
    }

    //gc.beginPath();
    gc.lineWidth = thickness;
    gc.moveTo(x + 0.5, y + 0.5);
    gc.lineTo(x + width + 0.5, y + 0.5);
}

function underline(config, gc, text, x, y, thickness) {
    var width = config.getTextWidth(gc, text);

    switch (gc.textAlign) {
        case 'center':
            x -= width / 2;
            break;
        case 'right':
            x -= width;
            break;
    }

    //gc.beginPath();
    gc.lineWidth = thickness;
    gc.moveTo(x + 0.5, y + 0.5);
    gc.lineTo(x + width + 0.5, y + 0.5);
}

function layerColors(gc, colors, x, y, width, height) {
    colors.forEach(function(color) {
        gc.fillStyle = color;
        gc.fillRect(x, y, width, height);
    });
}

function valOrFunc(vf, config, calculator) {
    var result = vf;
    if (config.isGridColumn && config.isGridRow && config.dataRow) {
        calculator = (typeof vf)[0] === 'f' && vf || calculator;
        if (calculator) {
            result = calculator(config.dataRow, config.name);
        }
    }
    return result || result === 0 || result === false ? result : '';
}

function alpha(cssColorSpec) {
    if (cssColorSpec === undefined) {
        // undefined so not visible; treat as transparent
        return 0;
    }

    var matches = cssColorSpec.match(alpha.regex);

    if (matches === null) {
        // an opaque color (a color spec with no alpha channel)
        return 1;
    }

    var A = matches[4];

    if (A === undefined) {
        // cssColorSpec must have been 'transparent'
        return 0;
    }

    return Number(A);
}

alpha.regex = /^(transparent|((RGB|HSL)A\(.*,\s*([\d\.]+)\)))$/i;

module.exports = SimpleCell;

},{"./CellRenderer":69}],73:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var Slider = CellRenderer.extend('Slider', {

    /**
     * @desc Emerson's paint function for a slider button. currently the user cannot interact with it
     * @implements paintFunction
     * @memberOf Slider.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;
        gc.strokeStyle = 'white';
        var val = config.value;
        var radius = height / 2;
        var offset = width * val;
        var bgColor = config.isSelected ? config.backgroundColor : '#333333';
        var btnGradient = gc.createLinearGradient(x, y, x, y + height);
        btnGradient.addColorStop(0, bgColor);
        btnGradient.addColorStop(1, '#666666');
        var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        arcGradient.addColorStop(0, '#aaaaaa');
        arcGradient.addColorStop(1, '#777777');
        gc.fillStyle = btnGradient;
        this.roundRect(gc, x, y, width, height, radius, btnGradient);
        if (val < 1.0) {
            gc.fillStyle = arcGradient;
        } else {
            gc.fillStyle = '#eeeeee';
        }
        gc.beginPath();
        gc.arc(x + Math.max(offset - radius, radius), y + radius, radius, 0, 2 * Math.PI);
        gc.fill();
        gc.closePath();
        config.minWidth = 100;
    }
});

module.exports = Slider;

},{"./CellRenderer":69}],74:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var SparkBar = CellRenderer.extend('SparkBar', {

    /**
     * @desc A simple implementation of a sparkline, because it's a barchart we've changed the name ;).
     * @implements paintFunction
     * @memberOf SparkBar.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        gc.beginPath();
        var val = config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;
        var fgColor = config.isSelected ? config.foregroundSelectionColor : config.color;
        if (config.backgroundColor || config.isSelected) {
            gc.fillStyle = config.isSelected ? 'blue' : config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }
        gc.fillStyle = fgColor;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            gc.fillRect(x + 5, y + height - barheight, eWidth * 0.6666, barheight);
            x += eWidth;
        }
        gc.closePath();
        config.minWidth = count * 10;
    }
});

module.exports = SparkBar;

},{"./CellRenderer":69}],75:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var SparkLine = CellRenderer.extend('SparkLine', {

    /**
     * @desc A simple implementation of a sparkline.  see [Edward Tufte sparkline](http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR)
     * @implements paintFunction
     * @memberOf SparkLine.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        gc.beginPath();
        var val = config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;

        var fgColor = config.isSelected ? config.foregroundSelectionColor : config.color;
        if (config.backgroundColor || config.isSelected) {
            gc.fillStyle = config.isSelected ? config.backgroundSelectionColor : config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }
        gc.strokeStyle = fgColor;
        gc.fillStyle = fgColor;
        gc.beginPath();
        var prev;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            if (!prev) {
                prev = barheight;
            }
            gc.lineTo(x + 5, y + height - barheight);
            gc.arc(x + 5, y + height - barheight, 1, 0, 2 * Math.PI, false);
            x += eWidth;
        }
        config.minWidth = count * 10;
        gc.stroke();
        gc.closePath();
    }
});

module.exports = SparkLine;

},{"./CellRenderer":69}],76:[function(require,module,exports){
'use strict';

var CellRenderer = require('./CellRenderer');

/**
 * @constructor
 * @extends CellRenderer
 */
var TreeCell = CellRenderer.extend('TreeCell', {

    /**
     * @desc A simple implementation of a tree cell renderer for use mainly with the qtree.
     * @implements paintFunction
     * @memberOf TreeCell.prototype
     */
    paint: function(gc, config) {
        var x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height;

        var val = config.value.data;
        var indent = config.value.indent;
        var icon = config.value.icon;

        //fill background only if our bgColor is populated or we are a selected cell
        if (config.backgroundColor || config.isSelected) {
            gc.fillStyle = config.isSelected ? config.backgroundColor : config.backgroundColor;
            gc.fillRect(x, y, width, height);
        }

        if (!val || !val.length) {
            return;
        }
        var valignOffset = Math.ceil(height / 2);

        gc.fillStyle = config.isSelected ? config.backgroundColor : config.backgroundColor;
        gc.fillText(icon + val, x + indent, y + valignOffset);

        var textWidth = config.getTextWidth(gc, icon + val);
        var minWidth = x + indent + textWidth + 10;
        config.minWidth = minWidth;
    }
});

module.exports = TreeCell;

},{"./CellRenderer":69}],77:[function(require,module,exports){
/**
 * @summary API of cell renderer object constructors, plus some access methods.
 * @module cellRenderers
 */

'use strict';

/**
 * @param {boolean} [privateRegistry=false] - This instance will use a private registry.
 * @constructor
 */
function CellRenderers(privateRegistry) {
    if (privateRegistry) {
        this.singletons = {};
    }

    // preregister the standard cell renderers
    if (privateRegistry || !this.get('emptycell')) {
        this.add('EmptyCell', require('./CellRenderer'));
        this.add(require('./Button'));
        this.add(require('./SimpleCell'));
        this.add(require('./SliderCell'));
        this.add(require('./SparkBar'));
        this.add(require('./LastSelection'));
        this.add(require('./SparkLine'));
        this.add(require('./ErrorCell'));
        this.add(require('./TreeCell'));
    }
}

CellRenderers.prototype = {
    constructor: CellRenderers.prototype.constructor, // preserve constructor

    /**
     * @summary Register and instantiate a cell renderer singleton.
     * @desc Adds a custom cell renderer to the `singletons` hash using the provided name (or the class name), converted to all lower case.
     *
     * > All native cell renderers are "preregistered" in `singletons`. Add more by calling `get`.
     *
     * @param {string} [name] - Case-insensitive renderer key. If not given, `YourCellRenderer.prototype.$$CLASS_NAME` is used.
     *
     * @param {CellRenderer} Constructor - A constructor, typically extended from `CellRenderer` (or a descendant therefrom).
     *
     * > Note: `$$CLASS_NAME` can be easily set up by providing a string as the (optional) first parameter (`alias`) in your {@link https://www.npmjs.com/package/extend-me|CellEditor.extend} call.
     *
     * @returns {CellRenderers} A newly registered constructor extended from {@link CellRenderers}.
     *
     * @memberOf CellRenderers.prototype
     */
    add: function(name, Constructor) {
        if (typeof name === 'function') {
            Constructor = name;
            name = undefined;
        }

        name = name || Constructor.prototype.$$CLASS_NAME;
        name = name && name.toLowerCase();
        return (this.singletons[name] = new Constructor);
    },

    /**
     * @summary Register a synonym for an existing cell renderer singleton.
     * @param {string} synonymName
     * @param {string} existingName
     * @returns {CellRenderers} The previously registered constructor this new synonym points to.
     * @memberOf CellRenderers.prototype
     */
    addSynonym: function(synonymName, existingName) {
        var cellRenderer = this.get(existingName);
        return (this.singletons[synonymName] = cellRenderer);
    },

    /**
     * Fetch a registered cell renderer singleton.
     * @param {string} name
     * @returns {CellRenderers} A registered constructor extended from {@link CellRenderers}.
     * @memberOf CellRenderers.prototype
     */
    get: function(name) {
        return this.singletons[name && name.toLowerCase()];
    },

    /**
     * The cell editor registry containing all the "preregistered" cell renderer singletons.
     * @private
     * @memberOf CellRenderers.prototype
     */
    singletons: {}
};


module.exports = CellRenderers;

},{"./Button":68,"./CellRenderer":69,"./ErrorCell":70,"./LastSelection":71,"./SimpleCell":72,"./SliderCell":73,"./SparkBar":74,"./SparkLine":75,"./TreeCell":76}],78:[function(require,module,exports){
'use strict';

var Base = require('../Base');

/**
 * @constructor
 */
var DataModel = Base.extend('DataModel', {
    grid: null,
    initialize: function(grid, options) {
        this.grid = grid;
    },

    changed: function() {
        this.deprecated('changed()', 'grid.behavior.changed()', '1.1.0');
    },

    getPrivateState: function() {
        return this.deprecated('getPrivateState()', 'grid.properties', '1.2.0');
    },

    /**
     * @param {object} config
     * @param {string} declaredRendererName - The proposed cell renderer name (form the render properties).
     * @returns {CellRenderer}
     * @memberOf DataModel.prototype
     */
    getCell: function(config, declaredRendererName) {
        return this.grid.cellRenderers.get(declaredRendererName);
    },

    /**
     * @summary Instantiate a new cell editor.
     * @desc The application developer may override this method to:
     * * Instantiate and return an arbitrary cell editor. The generic implementation here simply returns the declared cell editor. This is `undefined` when there was no such declaration, or if the named cell editor was not registered.
     * * Return `undefined` for no cell editor at all. The cell will not be editable.
     * * Set properties on the instance by passing them in the `options` object. These are applied to the new cell editor object after instantiation but before rendering.
     * * Manipulate the cell editor object (including its DOM elements) after rendering but before DOM insertion.
     *
     * Overriding this method with a null function (that always returns `undefined`) will have the effect of making all cells uneditable.
     *
     * @param {number} columnIndex - Absolute column index. I.e., the position of the column in the data source's original `fields` array, as echoed in `behavior.allColumns[]`.
     * @param {number} rowIndex - Row index of the data row in the currently filtered and sorted list of rows, regardless of vertical scroll position, offset by the number of header rows (all the rows above the first data row including the filter row). I.e., after subtracting out the number of header rows, this is the position of the data row in the `index` array of the data source (i.e., the last data source pipeline).
     * @param {string} declaredEditorName - The proposed cell editor name (from the render properties).
     * @param {object} options - Properties to copy to the new cell editor primarily for mustache's use. Additionally, always includes the following:
     * @param {string} options.format - The value of the `format` render prop. May be `undefined`.
     * @param {object} options.column - For convenience, the column object in `behavior.allColumns[]` to which `columnIndex` refers.
     * @param {Point} options.editPoint - Deprecated; use `options.gridCell`.
     * @param {Point} options.gridCell - The grid coordinates of the cell to edit.
     * @param {number} options.gridCell.x - The horizontal model coordinate of the cell to edit. This is the grid coordinate regardless of horizontal scroll position. I.e., the position of the column in the ordered list of selected columns (`behavior.columns[]`). (This is the coordinate required by {@link Hypergrid#editAt|editAt}.)
     * @param {number} options.gridCell.y - Same as `rowIndex`.
     *
     * @returns {undefined|CellEditor} An object instantiated from the registered cell editor constructor named in `declaredEditorName`. A falsy return means the cell is not editable because the `declaredEditorName` was not registered.
     *
     * @memberOf DataModel.prototype
     */
    getCellEditorAt: function(columnIndex, rowIndex, declaredEditorName, options) {
        return this.grid.cellEditors.create(declaredEditorName, options);
    }

});

module.exports = DataModel;

},{"../Base":49}],79:[function(require,module,exports){
'use strict';

var images = require('../../images');

function FilterRow(grid) {
    this.grid = grid;
    this.behavior = grid.behavior;
    this.dataRow = {}; // for meta data (__HEIGHT)
}

FilterRow.prototype = {
    constructor: FilterRow.prototype.constructor,

    type: 'filter',

    getRowCount: function() {
        return this.grid.isShowFilterRow() ? 1 : 0;
    },

    getValue: function(x, y) {
        checkForColumnFilters.call(this);

        var column = this.behavior.getColumn(x),
            result = this.behavior.filter.getColumnFilterState(column.name) || '';

        result = [null, result, images.filter(result.length)];

        return result;
    },

    setValue: function(x, y, value) {
        checkForColumnFilters.call(this);

        var column = this.behavior.getColumn(x);
        this.behavior.filter.setColumnFilterState(column.name, value);
    },

    getRow: function(y) {
        return this.dataRow;
    }
};

function checkForColumnFilters() {
    if (!this.behavior.filter.getColumnFilterState) {
        throw new this.behavior.HypergridError('Column filters not available.');
    }
}

module.exports = FilterRow;

},{"../../images":4}],80:[function(require,module,exports){
'use strict';

function HeaderRow(grid) {
    this.grid = grid;
    this.behavior = grid.behavior;
    this.dataRow = {}; // for meta data (__HEIGHT)
}

HeaderRow.prototype = {
    constructor: HeaderRow.prototype.constructor,

    type: 'header',

    getRowCount: function() {
        return this.grid.isShowHeaderRow() ? 1 : 0;
    },

    getValue: function(x, y) {
        var column = this.behavior.getColumn(x),
            result = column.header || column.name, // uses field name when header undefined
            sortString = this.behavior.dataModel.getSortImageForColumn(x),
            groups;

        if (sortString) {
            // if grouped header, prepend group headers to sort direction indicator
            if ((groups = result.lastIndexOf(this.behavior.groupHeaderDelimiter) + 1)) {
                sortString = result.substr(0, groups) + sortString;
                result = result.substr(groups);
            }

            // prepend sort direction indicator to column header
            result = sortString + result;
        }

        return result;
    },

    setValue: function(x, y, value) {
        this.behavior.getColumn(x).header = value;
    },

    getRow: function(y) {
        return this.dataRow;
    }
};

module.exports = HeaderRow;

},{}],81:[function(require,module,exports){
'use strict';

var DataModel = require('./DataModel');
var DataSourceOrigin = require('../dataSources/DataSourceOrigin');

/** @typedef {object} dataSourcePipelineObject
 * @property {string} type - A "DataSourceOrigin" style constructor name.
 * @property {*} [options] - When defined, passed as 2nd argument to constructor.
 * @property {string} [parent] - Defines a branch off the main sequence.
 */

/**
 * @implements dataSourceHelperAPI
 * @desc This is a simple "null" helper API implementation with only a null `properties` method is defined.
 * @see {@link http://c2.com/cgi/wiki?NullObject}
 * @memberOf dataModels.JSON
 * @inner
 */
var nullDataSourceHelperAPI = {
    properties: function(properties) {
        var result,
            isGetter = 'getPropName' in properties;

        if (isGetter) {
            // All props are undefined in this null API regardless of their name; and
            // undefined props return `null` as per interface definition.
            result = null;
        }

        return result;
    }
};

/**
 * @name dataModels.JSON
 * @constructor
 * @extends DataModel
 */
var JSON = DataModel.extend('dataModels.JSON', {

    initialize: function(grid, options) {
        this.reset(options);
    },

    /**
     * Override to use a different origin.
     * @type(DataSourceBase}
     */
    DataSourceOrigin: DataSourceOrigin,

    /**
     * @type {dataSourcePipelineObject[][]}
     * @summary Pipeline stash push-down list.
     * @desc The pipeline stash may be shared or instanced. This is the shared stash. An instance may override this with an instance stash variable (of the same name). See {@link dataModels.JSON.prototype#getPipelineSchemaStash}.
     * @memberOf dataModels.JSON.prototype
     */
    pipelineSchemaStash: [],

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {object} [options]
     */
    reset: function(options) {
        this.selectedData = [];

        /**
         * @summary Hash of data source helper APIs.
         * @desc Keyed by data source type. An API is required by data sources with an `api` property.
         * @see {@link dataModels.JSON/updateDataSources}
         * @type {object}
         */
        this.api = {};

        delete this.pipelineSchemaStash; // remove existing "own" version if any

        this.source = new this.DataSourceOrigin(options.data, options.schema);

        this.setPipeline();
        //Register Defaults
        this.registerHelperAPI('filter');
        this.registerHelperAPI('sorter');
    },

    /**
     * @summary The default data sources for a new pipeline when none are give.
     * @desc For now Filtering is hardcoded in the grid.
     * In the future, this will likely be empty (unless overridden by application developer for his own purposes).
     * @type {pipelineSchema}
     * @memberOf dataModels.JSON.prototype
     */
    defaultPipelineSchema: [],

    clearSelectedData: function() {
        this.selectedData.length = 0;
    },

    /**
     * @deprecated As of v1.0.7, reference the `dataSource` property instead.
     * @returns {*}
     */
    getDataSource: function() {
        return this.deprecated('getDataSource()', 'dataSource', '1.0.7');
    },

    getData: function() {
        return this.source.data;
    },

    /**
     * @deprecated As of v1.1.0, use getIndexedData
     */
    getFilteredData: function() {
        return this.deprecated('getFilteredData()', 'getIndexedData()', '1.2.0', arguments);
    },

    getIndexedData: function() {
        var ds = this.dataSource;
        var count = ds.getRowCount();
        var result = new Array(count);
        for (var y = 0; y < count; y++) {
            result[y] = ds.getRow(y);
        }
        return result;
    },

    /**
     * @param {number} x - Data column coordinate.
     * @param {number} y - Data row coordinate.
     * @memberOf dataModels.JSON.prototype
     */
    getValue: function(x, y) {
        if (this.hasHierarchyColumn()) {
            if (x === -2) {
                x = 0;
            }
        } else if (this.isDrillDown()) {
            x += 1;
        }
        return this.dataSource.getValue(x, y);
    },

    /**
     * @param {number} y - Data row coordinate.
     * @returns {*}
     */
    getDataIndex: function(y) {
        return this.dataSource.getDataIndex(y);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x - Data column coordinate.
     * @param {number} r - Grid row coordinate.
     * @param value
     */
    setValue: function(x, r, value) {
        if (this.hasHierarchyColumn()) {
            if (x === -2) {
                x = 0;
            }
        } else if (this.isDrillDown()) {
            x += 1;
        }
        this.dataSource.setValue(x, r, value);
    },

    /**
     * @deprecated As of v1.1.0, use `this.grid.behavior.getColumnProperties(x)` instead.
     * @memberOf dataModels.JSON.prototype
     * @param {number} x - Data column coordinate.
     * @returns {*}
     */
    getColumnProperties: function(x) {
        //access directly because we want it ordered
        return this.deprecated('getColumnProperties(x)', 'grid.behavior.getColumnProperties(x)', '1.2.0', arguments);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getColumnCount: function() {
        var showTree = this.grid.properties.showTreeColumn === true;
        var offset = (this.isDrillDown() && !showTree) ? -1 : 0;
        return this.dataSource.getColumnCount() + offset;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getRowCount: function() {
        return this.dataSource.getRowCount();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getHeaders: function() {
        return getSchemaPropArr.call(this, 'header', 'getHeaders');
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} headers
     */
    setHeaders: function(headers) {
        this.dataSource.setHeaders(headers);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} fields
     */
    setFields: function(fields) {
        this.dataSource.setFields(fields);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getFields: function() {
        return getSchemaPropArr.call(this, 'name', 'getFields');
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getCalculators: function() {
        return getSchemaPropArr.call(this, 'calculator', 'getCalculators');
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    reindex: function(options) {
        selectedDataRowsBackingSelectedGridRows.call(this);

        this.pipeline.forEach(function(dataSource) {
            if (dataSource) {
                if (dataSource.apply) {
                    dataSource.apply(options);
                }
            }
        });

        reselectGridRowsBackedBySelectedDataRows.call(this);
    },

    /**
     * @summary Set or reset grid data.
     * See {@link DataSourceOrigin#setData} for details.
     * @memberOf dataModels.JSON.prototype
     */
    setData: function(dataSource, schema) {
        this.source.setData(dataSource, schema);
    },

    /** @typedef pipelineSchema
     * @type {DataSourceBase[]}
     * @summary Describes a new pipeline.
     * @desc Consists of an ordered list of data source constructors, descendants of `DataSourceBase`.
     * May contain `undefined` elements, which are ignored.
     */

    /**
     * @summary Instantiates the data source pipeline.
     * @desc Each new pipe is created from the list of supplied constructors, each taking a reference to the previous data source in the pipeline.
     *
     * A reference to each new pipe is added to `this.sources` dataModel using the pipe's derived name.
     *
     * Will clear out any filtering and sorting state.
     *
     * The last pipe is assigned the synonym `this.dataSource`.
     * @param {pipelineSchema} [DataSources] - New pipeline description. If not given, uses the default {@link dataModels.JSON#DataSources|this.defaultPipelineSchema}.
     * @param {object} [options] - Takes first argument position when `DataSources` omitted.
     * @param {string} [options.stash] - See {@link dataModels.JSON.prototype#getPipelineSchemaStash}. If given, saves the currently defined pipeline onto the indicated stash stack and then resets it with the given `DataSources`.
     * @memberOf dataModels.JSON.prototype
     */
    setPipeline: function(DataSources, options) {
        if (!Array.isArray(DataSources)) {
            options = DataSources;
            DataSources = undefined;
        }

        if (options && options.stash) {
            this.getPipelineSchemaStash(options.stash).push(this.DataSources);
        }

        var dataSource = this.source;

        /**
         * @summary Currently defined pipeline.
         * @desc Each instance has its own pipeline.
         * (Pipelines cannot be shared because they contain indexes specific to the data in the grid.)
         * @name pipeline
         * @type {dataSourcePipelineObject[]}
         * @memberOf dataModels.JSON.prototype
         */
        this.pipeline = [];

        DataSources = DataSources || this.defaultPipelineSchema;

        DataSources.forEach(function(DataSource) {
            if (DataSource) {
                dataSource = new DataSource(dataSource);
                this.pipeline.push(dataSource);

                // Ensure a null helper API defined for all data sources that require one
                if (dataSource.type && dataSource.set && !this.api[dataSource.type]) {
                    this.registerHelperAPI(dataSource.type);
                }
            }
        }, this);

        this.updateDataSources();

        this.dataSource = dataSource;

        this.DataSources = DataSources;
    },

    /**
     * Find the last data source in the pipeline of specified type.
     * @param {string} type
     * @returns {DataSourceBase}
     */
    findDataSourceByType: function(type) {
        var dataSource;
        for (var i = this.pipeline.length - 1; i >= 0; i--) {
            dataSource = this.pipeline[i];
            if (dataSource.type === type) {
                return dataSource;
            }
        }
    },

    /**
     * @summary Update data sources with APIs of matching types.
     * @desc Only updates _qualified_ data sources, which include:
     * * those for which an API of the data source's type is defined in `this.api`; and
     * * those that can accept an API (have an `api` property to set).
     * @param {string} [type] - Type of data source to update. If omitted, updates all data sources.
     * @returns {number|object} One of:
     * `type` specified - The number of updated data sources of the specified type.
     * `type` omitted - Hash containing the number of updated data sources by type.
     */
    updateDataSources: function(type) {
        var results = {},
            api = this.api;

        this.pipeline.forEach(function(dataSource) {
            if (
                (!type || dataSource.type === type) &&
                api[dataSource.type]
            ) {
                dataSource.set(api[dataSource.type]);
                results[dataSource.type] = (results[dataSource.type] || 0) + 1;
            }
        });

        return type ? results[type] : results;
    },

    /**
     * @summary The pipeline stash currently in use (either shared or instance).
     * @desc Instance stash is created here when requested and instance doesn't yet have its "own" version.
     * @param {string} [whichStash] - One of:
     * * `'shared'` - Use shared stash.
     * * `'own'' or `'instance'` - Use instance stash, creating it if it does not exist.
     * * `'default'` or `undefined` - Use instance stash if previously created; otherwise use shared stash.
     * @returns The pipeline stash push-down list.
     * @memberOf dataModels.JSON.prototype
     */
    getPipelineSchemaStash: function(whichStash) {
        var stash;
        switch (whichStash) {

            case 'shared':
                stash = DataModel.prototype.stash;
                break;

            case 'own':
            case 'instance':
                if (!this.hasOwnProperty('pipelineSchemaStash')) {
                    this.pipelineSchemaStash = [];
                }
            // disable eslint no-fallthrough
            case 'default':
            case undefined:
                stash = this.pipelineSchemaStash;
                break;

        }
        return stash;
    },

    /**
     * Pops the last stashed pipeline off the stash stack, making it the currently defined pipeline.
     * @param {string} [whichStash] - See {@link dataModels.JSON.prototype#getPipelineSchemaStash}.
     * @memberOf dataModels.JSON.prototype
     */
    unstashPipeline: function(whichStash) {
        var pipelineSchemaStash = this.getPipelineSchemaStash(whichStash);
        if (pipelineSchemaStash.length) {
            this.setPipeline(pipelineSchemaStash.pop());
        }
    },

    /**
     * @deprecated
     * @param {number} [newLength=0]
     * @memberOf dataModels.JSON.prototype
     */
    truncatePipeline: function(newLength) {
        return this.deprecated('truncatePipeline(newLength)', 'setPipeline()', '1.2.0', arguments, 'Build a local pipeline (array of data source constructors) and pass it to setPipeline.');
    },

    isDrillDown: function(event) {
        var colIndex = event && event.gridCell && event.gridCell.x;
        return this.dataSource.isDrillDown(colIndex);
    },

    /**
     * @deprecated
     * @summary Set the top total row(s).
     * @param {dataRowObject[]} totalRows - Array of 0 or more rows containing summary data. Omit to set to empty array.
     * @memberOf dataModels.JSON.prototype
     */
    setTopTotals: function(totalRows) {
        return this.deprecate('setTopTotals(rows)', 'grid.behavior.setTopTotals(rows)', '1.1.0', arguments);
    },

    /**
     * @deprecated
     * @summary Get the top total row(s).
     * @returns {dataRowObject[]}
     * @memberOf dataModels.JSON.prototype
     */
    getTopTotals: function() {
        return this.deprecate('getTopTotals(rows)', 'grid.behavior.getTopTotals(rows)', '1.1.0', arguments);
    },

    /**
     * @deprecated
     * @summary Set the bottom total row(s).
     * @param {dataRowObject[]} totalRows - Array of 0 or more rows containing summary data. Omit to set to empty array.
     * @memberOf dataModels.JSON.prototype
     */
    setBottomTotals: function(totalRows) {
        return this.deprecate('setBottomTotals(rows)', 'grid.behavior.setBottomTotals(rows)', '1.1.0', arguments);
    },

    /**
     * @deprecated
     * @summary Get the bottom total row(s).
     * @returns {dataRowObject[]}
     * @memberOf dataModels.JSON.prototype
     */
    getBottomTotals: function() {
        return this.deprecate('getBottomTotals(rows)', 'grid.behavior.getBottomTotals(rows)', '1.1.0', arguments);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getActiveColumns: function() {
        return this.grid.behavior.columns.filter(function(column) {
            return column.name !== 'tree';
        });
    },

    /**
     * @deprecated As of v1.0.6, use `this.getActiveColumns` instead.
     * @returns {*}
     */
    getVisibleColumns: function() {
        return this.deprecated('getVisibleColumns()', 'getActiveColumns()', '1.0.6', arguments);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getHiddenColumns: function() {
        var visible = this.grid.behavior.columns;
        var all = this.grid.behavior.allColumns;
        var hidden = [];
        for (var i = 0; i < all.length; i++) {
            if (visible.indexOf(all[i]) === -1) {
                hidden.push(all[i]);
            }
        }
        hidden.sort(function(a, b) {
            return a.header < b.header;
        });
        return hidden;
    },
    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasHierarchyColumn: function() {
        var showTree = this.grid.properties.showTreeColumn === true;
        return this.isDrillDown() && showTree;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param index
     * @param returnAsString
     * @desc Provides the unicode character used to denote visually if a column is a sorted state
     * @returns {*}
     */
    getSortImageForColumn: function(columnIndex) {
        //Not implemented
    },

    /**
     * @param cell
     * @param event
     * @return {boolean} Clicked in a drill-down column.
     * @memberOf dataModels.JSON.prototype
     */
    cellClicked: function(event) {
        if (arguments.length === 2) {
            return this.deprecated('cellClicked(cell, event)', 'cellClicked(event)', '1.2.0', arguments);
        }
        return this.toggleRow(event.dataCell.y);
    },

    /**
     * @summary Toggle the drill-down control of a the specified row.
     * @desc Operates only on the following rows:
     * * Expandable rows - Rows with a drill-down control.
     * * Revealed rows - Rows not hidden inside of collapsed drill-downs.
     * @param y - Revealed row number. (This is not the row ID.)
     * @param {boolean} [expand] - One of:
     * * `true` - Expand row.
     * * `false` - Collapse row.
     * * `undefined` (or omitted) - Toggle state of row.
     * @returns {boolean|undefined} Changed. Specifically, one of:
     * * `undefined` row had no drill-down control
     * * `true` drill-down changed
     * * `false` drill-down unchanged (was already in requested state)
     * @memberOf dataModels.JSON.prototype
     */
    toggleRow: function(y, expand) {
        //TODO: fire a row toggle event
        var changed;
        if (this.isDrillDown()) {
            changed = this.dataSource.click(y, expand);
            if (changed) {
                this.reindex({rowClick: true});
                this.grid.behavior.changed();
            }
        }
        return changed;
    },

    /**
     * @param {number} r - Data row coordinate.
     * @returns {object|undefined} Returns data row object or `undefined` if a header row.
     * @memberOf dataModels.JSON.prototype
     */
    getRow: function(r) {
        return this.dataSource.getRow(r);
    },

    /**
     * @summary _Getter:_ Return the filter from the data model.
     * @method
     * @returns {dataSourceHelperAPI} The grid's currently assigned filter.
     * @memberOf dataModels.JSON.prototype
     */
    get filter() {
        return this.api.filter;
    },

    /**
     * @summary _Setter:_ Assign a filter to the data model.
     * @method
     * @param {dataSourceHelperAPI|undefined|null} filter - One of:
     * * A filter object - Turns the filter *ON*.
     * * `undefined` or `null` - Turns the filter *OFF.*
     * @memberOf dataModels.JSON.prototype
     */
    set filter(filter) {
        this.registerHelperAPI('filter', filter);
    },
    /**
     * @summary _Getter_
     * @method
     * @returns {sorterAPI} The grid's currently assigned sorter.
     * @memberOf dataModels.JSON.prototype
     */
    get sorter() {
        return this.api.sorter;
    },

    /**
     * @summary _Setter:_ Assign a sorter to the grid.
     * @method
     * @param {sorterAPI|undefined|null} sorter - One of:
     * * A sorter object, turning sorting *ON*.
     * * If `undefined` or `null`, the {@link dataModels.JSON~nullSorter|nullSorter} is reassigned to the grid, turning sorting *OFF.*
     * @memberOf dataModels.JSON.prototype
     */
    set sorter(sorter) {
        this.registerHelperAPI('sorter', sorter);
    },

    /**
     * @summary Register the data source helper API.
     * @desc The API is immediately applied to all data sources in the pipeline of the given type; and reassigned later whenever the pipeline is reset.
     * @param {string} dataSourceType
     * @param {dataSourceHelperAPI|undefined|null} helper - One of:
     * * A filter object - Turns the data source *ON*.
     * * `undefined` or `null` - Turns the data source *OFF.*
     * * A helper API. Turns the data source *ON*.
     */
    registerHelperAPI: function(dataSourceType, helper) {
        this.api[dataSourceType] = helper = helper || nullDataSourceHelperAPI;

        if (typeof helper.properties === 'function' && helper.properties.length === 1) {
            helper.prop = propPrep.bind(helper, this);
        }

        if (this.updateDataSources(dataSourceType)) {
            this.reindex();
        }
    },

    /**
     * @deprecated As of v1.1.0, use `this.reindex` instead.
     * @memberOf dataModels.JSON.prototype
     */
    applyState: function() {
        return this.deprecated('applyState()', 'reindex()', '1.2.0', arguments);
    },

    getUnfilteredValue: function(x, y) {
        return this.deprecated('getUnfilteredValue(x, y)', null, '1.2.0', arguments, 'No longer supported');
    },

    getUnfilteredRowCount: function() {
        return this.deprecated('getUnfilteredValue(x, y)', null, '1.2.0', arguments, 'No longer supported');
    },

    /**
     * @summary Add a new data row to the grid.
     * @desc If data source pipeline in use, to see the new row in the grid, you must eventually call:
     * ```javascript
     * this.grid.behavior.reindex();
     * this.grid.behaviorChanged();
     * ```
     * @param {object} newDataRow
     * @returns {object} The new row object.
     * @memberOf dataModels.JSON.prototype
     */
    addRow: function(newDataRow) {
        this.getData().push(newDataRow);
        return newDataRow;
    },

    get schema() { return this.source.schema; },

    set schema(schema) {
        this.source.setSchema(schema);
    }
});

// LOCAL METHODS -- to be called with `.call(this`

/**
 * Accumulate actual data row objects backing current grid row selections.
 * This call should be paired with a subsequent call to `reselectGridRowsBackedBySelectedDataRows`.
 * @private
 * @this {dataModels.JSON}
 * @memberOf dataModels.JSON.prototype
 */
function selectedDataRowsBackingSelectedGridRows() {
    var selectedData = this.selectedData,
        hasRowSelections = this.grid.selectionModel.hasRowSelections(),
        needIndexedDataList = selectedData.length || hasRowSelections;

    if (needIndexedDataList) {
        var indexedData = this.getIndexedData();
    }

    // STEP 1: Remove any filtered data rows from the recently selected list.
    selectedData.forEach(function(dataRow, index) {
        if (indexedData.indexOf(dataRow) >= 0) {
            delete selectedData[index];
        }
    });

    // STEP 2: Accumulate the data rows backing any currently selected grid rows in `this.selectedData`.
    if (hasRowSelections) { // any current grid row selections?
        this.grid.getSelectedRows().forEach(function(selectedRowIndex) {
            var dataRow = indexedData[selectedRowIndex];
            if (selectedData.indexOf(dataRow) < 0) {
                selectedData.push(dataRow);
            }
        });
    }
}

/**
 * Re-establish grid row selections based on actual data row objects accumulated by `selectedDataRowsBackingSelectedGridRows` which should be called first.
 * @private
 * @this {dataModels.JSON}
 * @memberOf dataModels.JSON.prototype
 */
function reselectGridRowsBackedBySelectedDataRows() {
    if (this.selectedData.length) { // any data row objects added from previous grid row selections?
        var selectionModel = this.grid.selectionModel,
            offset = this.grid.getHeaderRowCount(),
            filteredData = this.getIndexedData();

        selectionModel.clearRowSelection();

        this.selectedData.forEach(function(dataRow) {
            var index = filteredData.indexOf(dataRow);
            if (index >= 0) {
                selectionModel.selectRow(offset + index);
            }
        });
    }
}

/**
 * @inner
 * @summary Digests `(columnIndex, propName, value)` and calls `properties`.
 * @desc Digests the three parameters `(columnIndex, propName, value)` detailed below, creating a single object with which it then calls the helper API `properties` method.
 *
 * A helper API `properties` method:
 * * Supports two types of actions:
 *   * **Getter** call where you supply just the property name. The method gets the property value from the API and returns it.
 *   * **Setter** call where you supply a value along with the property name; or you supply a hash of property name/value pairs. The method sets the property on the API and returns nothing. All values are valid with the exception of `undefined` which deletes the property of the given name rather than setting it to `undefined`.
 * * Supports two types of properties:
 *   * **Global properties** affect the API globally.
 *   * **Column properties** pertain to specific columns.
 *
 * This method is overloaded. The way it is called as explained in the Parameters section below determines both the type of action (getter, setter) and the kind of property (global, column).
 *
 * Note: Not all API properties are dynamic; some are static and updating them later will have no effect.
 *
 * @this {dataSourceHelperAPI}
 *
 * @param {DataSourceBase} dataModel - The data model. This parameter is bound to the call by {@link dataModels.JSON#setHelperAPI|setHelperAPI}.
 *
 * @param {number} [columnIndex] - If given, this is a property on a specific column. If omitted, this is a property on the whole API properties object.
 *
 * @param {string|object} property - _If `columnIndex` is omitted, this arg takes its place._
 *
 * One of these types:
 * * **string** - Property name. The name of the explicit property to either get or (if `value` also given) set on the properties object.
 * * **object** - Hash of properties to set on the properties object.
 *
 * @param [value] - _If `columnIndex` is omitted, this arg takes its place._
 *
 * One of:
 * * Omitted (when `property` is a string), this is the "getter" action: Return the value from the properties object of the key in `property`.
 * * When `property` is a string and `value` is given, this is the "setter" action: Copy this value to properties object using the key in `property`.
 * * When `property` is a hash and `value` is given: Unexpected; throws an error.
 *
 * @returns {propObject}
 */
function propPrep(dataModel, columnIndex, propName, value) {
    var invalid,
        properties = {},
        argCount = arguments.length;

    if (typeof columnIndex === 'number') {
        argCount--;
    } else {
        value = propName;
        propName = columnIndex;
        columnIndex = undefined;
    }

    switch (argCount) {

        case 2: // getter propName name or setter hash
            if (typeof propName === 'object') {
                properties = propName;
            } else {
                properties.getPropName = propName;
            }
            break;

        case 3: // setter for value
            if (typeof propName !== 'string') {
                invalid = true;
            } else {
                properties[propName] = value;
            }
            break;

        default: // too few or too many args
            invalid = true;

    }

    if (invalid) {
        throw 'Invalid overload.';
    }

    if (columnIndex !== undefined) {
        // non-enumerable propName:
        Object.defineProperty(properties, 'column', {
            value: {
                index: columnIndex,
                name: dataModel.source.schema[columnIndex].name
            }
        });
    }

    return this.properties(properties);
}

var warned = {};
/**
 * @private
 * @param {string} propName
 * @this DataSourceOrigin#
 * @returns {*[]}
 */
function getSchemaPropArr(propName, deprecatedMethodName) {
    if (!warned[deprecatedMethodName]) {
        console.warn(deprecatedMethodName + '() has been deprecated as of v1.2.0 and will be removed in a future release. Constructs like ' + deprecatedMethodName + '()[i] should be changed to schema[i]. (This deprecated method now returns a new array derived from schema.)');
        warned[deprecatedMethodName] = true;
    }
    return this.schema.map(function(columnSchema) {
        return columnSchema[propName];
    }, this);
}

/**
 * @deprecated
 * @memberOf dataModels.JSON.prototype
 */
JSON.prototype.applyAnalytics = JSON.prototype.reindex; // eslint-disable-line no-extend-native

module.exports = JSON;

},{"../dataSources/DataSourceOrigin":84,"./DataModel":78}],82:[function(require,module,exports){
'use strict';

function SummaryRow(grid, options) {
    this.behavior = grid.behavior;

    /**
     * @type {dataRowObject[]}
     */
    this.data = [];

    if (options && options.name) {
        this.name = options.name;
    }
}

SummaryRow.prototype = {
    constructor: SummaryRow.prototype.constructor,

    type: 'summary',

    getRowCount: function() {
        return this.getData().length;
    },

    getData: function() {
        return this.behavior.dataModel.dataSource.getGrandTotals() || this.data;
    },

    setData: function(data) {
        this.data = data || [];
    },

    getValue: function(x, y) {
        return this.data[y][x];
    },

    setValue: function(x, y, value) {
        this.data[x] = value;
    },

    getRow: function(y) {
        return this.data[y];
    }
};

module.exports = SummaryRow;

},{}],83:[function(require,module,exports){
'use strict';

module.exports = {
    DataModel: require('./DataModel'), // abstract base class
    JSON: require('./JSON'),
    HeaderSubgrid: require('./HeaderSubgrid'),
    FilterSubgrid: require('./FilterSubgrid'),
    SummarySubgrid: require('./SummarySubgrid')
};

},{"./DataModel":78,"./FilterSubgrid":79,"./HeaderSubgrid":80,"./JSON":81,"./SummarySubgrid":82}],84:[function(require,module,exports){
'use strict';

var DataSourceBase = require('fin-hypergrid-data-source-base');

/**
 * See {@link DataSourceOrigin#initialize} for constructor parameters.
 * @constructor
 */
var DataSourceOrigin = DataSourceBase.extend('DataSourceOrigin',  {

    /**
     * Currently a synonym for {@link DataSourceOrigin#setData} (see).
     */
    initialize: function(data, schema) {
        delete this.dataSource; // added by DataSourceBase#initialize but we don't want here
        this.setData.call(this, data, schema || []);
    },

    /**
     * @memberOf DataSourceOrigin#
     */
    setData: setData,

    get schema() { return this._schema; },
    set schema(schema) { this._schema = schema; },

    /**
     * @memberOf DataSourceOrigin#
     * @returns {columnSchemaObject[]}
     */
    getSchema:  function(){
        return this._schema;
    },
    /**
     * @memberOf DataSourceOrigin#
     * Caveat: Do not call on a data update when you expect to reuse the existing schema.
     * @param schema
     */
    setSchema: function(schema){
        if (!schema.length) {
            var fields = computeFieldNames(this.data[0]);

            schema = Array(fields.length);

            for (var i = 0; i < fields.length; i++) {
                schema[i] = { name: fields[i] };
            }
        }

        /**
         * @summary The array of column schema objects.
         * @name schema
         * @type {columnSchemaObject[]}
         * @memberOf DataSourceOrigin#
         */
        this._schema = schema;
    },

    isNullObject: false,

    getDataIndex: function(y) {
        return y;
    },

    /**
     * @memberOf DataSourceOrigin#
     * @param y
     * @returns {dataRowObject}
     */
    getRow: function(y) {
        return this.data[y];
    },

    /**
     * @summary Find, replace, or update a row by it's primary key column.
     * @param {string|object} columnName - One of:
     * * _string_ - Column name. See `value`.
     * * _object_ - Hash of 0 or more key-value pairs to search for.
     * @param {string[]|*} [value] - One of:
     * _omitted_ - When `columnName` is a hash and you want to search all its keys.
     * _string[]_ - When `columnName` is a hash but you only want to search certain keys.
     * _otherwise_ - When `columnName` is a string. Value to search for.
     * Note that `null` is a valid search value.
     * @param {object|null|undefined} [replacement] - One of:
     * * _omitted_ - Ignored.
     * * _object_ - Replacement for the data row if found.
     * * `null` - Flag to delete the data row if found. The found data row is nonetheless returned.
     * * `undefined` - Flag to return index of found row instead of row object itself.
     * @returns {object|number|undefined} One of:
     * * `undefined` - data row not found
     * * _object_ - found data row object (will have been deleted if `replacement` was `null`)
     * * _number_ - index of found data row object in `this.data` (if `replacement` was `undefined`)
     * @todo Use a binary search (rather than `Array..find`) when column is known to be indexed (sorted).
     * @memberOf DataSourceOrigin#
     */
    findRow: function findRow(columnName, value, replacement) {
        var result, index, keys, hash, args;

        if (typeof columnName === 'object') {
            hash = columnName;

            if (value instanceof Array) {
                args = 2;
                keys = value;
                if (keys.reduce(function(sum, key) {
                        if (key in hash) {
                            sum++;
                        }
                        return sum;
                    }, 0) !== keys.length) {
                    throw 'Expected all keys given in 2nd arg to be found in hash given in 1st arg.';
                }
            } else {
                args = 1;
                keys = Object.keys(hash);
                replacement = value; // promote
            }

            if (keys.length === 1) {
                columnName = keys[0];
                value = hash[columnName];
                hash = undefined;
            } else if (keys.length) {
                result = this.data.find(function(row, idx) {
                    if (!row) {
                        return;
                    }
                    index = idx;
                    for (var key in keys) {
                        columnName = keys[key];
                        if (row[columnName] !== hash[columnName]) {
                            return; // bail
                        }
                    }
                    return true; // found!
                });
            }
        } else {
            if (arguments.length < 2) {
                throw 'Expected at least 2 arguments when first argument not object but found ' + arguments.length + '.';
            }
            args = 2;
        }

        if (!hash) {
            result = this.data.find(function(row, idx) {
                if (!row) { return; }
                index = idx;
                return row[columnName] === value;
            });
        }

        if (result) {
            this.foundRowIndex = index;
            if (replacement === null) {
                this.data.splice(index, 1);
            } else if (typeof replacement === 'object') {
                this.data[index] = replacement;
            } else if (replacement === undefined) {
                if (arguments.length > args) {
                    delete this.data[index];
                }
            } else {
                throw 'Expected null, undefined, or object but found ' + typeof replacement + '.';
            }
        } else {
            this.foundRowIndex = undefined;
        }

        return result;
    },

    /**
     * @summary Find, replace, or update a row by it's index.
     * @param {number} index - Row index that is being accessed
     * @param {object|null|undefined} [replacement] - One of:
     * * _omitted_ - Ignored.
     * * _object_ - Replacement for the data row if found.
     * * `null` - Flag to delete the data row if found. The found data row is nonetheless returned.
     * * `undefined` - Flag to delete the row at that index.
     * @returns {object|number|undefined} One of:
     * * `undefined` - data row not found
     * * _object_ - found data row object (will have been deleted if `replacement` was `null`)
     * @todo Use a binary search (rather than `Array..find`) when column is known to be indexed (sorted).
     * @memberOf DataSourceOrigin#
     */
    findRowByIndex: function findRow(index, replacement) {
        var result;

        if (arguments.length < 1) {
            throw 'Expected at least 1 argument but found ' + arguments.length + '.';
        }

        if (typeof index !== 'number') {
            throw 'Expected at index to be a number but got ' + index + '.';
        }

        result = this.data[index];

        if (result) {
            if (replacement === null) {
                this.data.splice(index, 1);
            } else if (typeof replacement === 'object') {
                this.data[index] = replacement;
            } else if (replacement === undefined && arguments.length >= 2) {
                delete this.data[index];
            } else if (replacement !== undefined) {
                throw 'Expected null, undefined, or object but found ' + typeof replacement + '.';
            }
        }

        return result;
    },


    /**
     * @memberOf DataSourceOrigin#
     * @param x
     * @param y
     * @returns {*}
     */
    getValue: function(x, y) {
        var row = this.getRow(y);
        if (!row) {
            return null;
        }
        return row[this.schema[x].name];
    },

    /**
     * @memberOf DataSourceOrigin#
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        this.getRow(y)[this.schema[x].name] = value;
    },

    /**
     * @memberOf DataSourceOrigin#
     * @returns {number}
     */
    getRowCount: function() {
        return this.data.length;
    },

    /**
     * @memberOf DataSourceOrigin#
     * @returns {number}
     */
    getColumnCount: function() {
        return this.schema.length;
    },

    /**
     * @memberOf DataSourceOrigin#
     * @returns {number[]}
     */
    getFields: function() {
        return this.schema.map(function(columnSchema) { return columnSchema.name; });
    },

    /**
     * @memberOf DataSourceOrigin#
     * @returns {string[]}
     */
    getHeaders: function() {
        return this.schema.map(function(columnSchema) { return columnSchema.header; });
    },

    /**
     * @memberOf DataSourceOrigin#
     * @param {string[]} fields
     */
    setFields: function(fields) {
        if (!(Array.isArray(fields) && fields.length === this.schema.length)) {
            throw new this.DataSourceError('Expected argument to be an array with correct length.');
        }
        fields.forEach(function(field, i) {
            this.schema[i].field = field;
        }, this);
    },

    /**
     * @memberOf DataSourceOrigin#
     * @param {string[]} [headers] - If omitted, headers will be reset to their derived defaults on next call to `getHeaders`.
     */
    setHeaders: function(headers) {
        if (!(Array.isArray(headers) && headers.length === this.schema.length)) {
            throw new this.DataSourceError('Expected argument to be an array with correct length.');
        }
        headers.forEach(function(header, i) {
            this.schema[i].header = header;
        }, this);
    }
});

/** @typedef {object} columnSchemaObject
 * @property {string} name - The required column name.
 * @property {string} [header] - An override for derived header
 * @property {function} [calculator] - A function for a computed column. Undefined for normal data columns.
 * @property {string} [type] - Used for sorting when and only when comparator not given.
 * @property {object} [comparator] - For sorting, both of following required:
 * @property {function} comparator.asc - ascending comparator
 * @property {function} comparator.desc - descending comparator
 */

/**
 * @param {object[]} [data=[]] - Array of uniform objects containing the grid data.
 * @param {columnSchemaObject[]} [schema=[]]
 * @memberOf DataSourceOrigin#
 */
function setData(data, schema) {
    /**
     * @summary The array of uniform data objects.
     * @name schema
     * @type {columnSchemaObject[]}
     * @memberOf DataSourceOrigin#
     */
    this.data = data || [];

    if (schema) {
        this.setSchema(schema);
    }
}

/**
 * @private
 * @param {object} object
 * @returns {string[]}
 */
function computeFieldNames(object) {
    if (!object) {
        return [];
    }
    return Object.getOwnPropertyNames(object || []).filter(function(e) {
        return e.substr(0, 2) !== '__';
    });
}

module.exports = DataSourceOrigin;

},{"fin-hypergrid-data-source-base":8}],85:[function(require,module,exports){
'use strict';

module.exports = {
    dataSourceOrigin: require('./DataSourceOrigin'),
    DataSourceBase: require('fin-hypergrid-data-source-base')
};

},{"./DataSourceOrigin":84,"fin-hypergrid-data-source-base":8}],86:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var LRUCache = require('lru-cache');


/**
 * This module lists the properties that can be set on a {@link Hypergrid} along with their default values.
 * Edit this file to override the defaults.
 * @module defaults
 */

module.exports = {

    /**
     * The font for data cells.
     * @default
     * @type {string}
     * @instance
     */
    noDataMessage: '',


    /**
     * The font for data cells.
     * @default
     * @type {cssFont}
     * @instance
     */
    font: '13px Tahoma, Geneva, sans-serif',

    /**
     * Font color for data cells.
     * @default
     * @type {string}
     * @instance
     */
    color: 'rgb(25, 25, 25)',

    /**
     * Background color for data cells.
     * @default
     * @type {string}
     * @instance
     */
    backgroundColor: 'rgb(241, 241, 241)',

    /**
     * Font style for selected cell(s).
     * @default
     * @type {string}
     * @instance
     */
    foregroundSelectionFont: 'bold 13px Tahoma, Geneva, sans-serif',

    /**
     * Font color for selected cell(s).
     * @default
     * @type {string}
     * @instance
     */
    foregroundSelectionColor: 'rgb(0, 0, 128)',
    /**
     * @default
     * @type {boolean}
     * @instance
     */
    sortOnHiddenColumns: true,
    /**
     * Background color for selected cell(s).
     * @default
     * @type {string}
     * @instance
     */
    backgroundSelectionColor: 'rgba(147, 185, 255, 0.625)',


    /********** SECTION: COLUMN HEADER COLORS **********/

    // IMPORTANT CAVEAT: The code is inconsistent regarding the terminology. Is the "column header" section _the row_ of cells at the top (that act as headers for each column) or is it _the column_ of cells (that act as headers for each row)? Oh my.

    /**
     * @default
     * @type {cssFont}
     * @instance
     */
    columnHeaderFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderColor: 'rgb(25, 25, 25)',

    /**
     * Font style for selected columns' headers.
     * @default
     * @type {string}
     * @instance
     */
    columnHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderForegroundColumnSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    columnHeaderBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',

    /**
     * @default
     * @type {string}
     * @instance
     */
    columnHeaderHalign: 'center',


    /********** SECTION: ROW HEADER COLORS **********/

    /**
     * @default
     * @type {cssFont}
     * @instance
     */
    rowHeaderFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderForegroundSelectionColor: 'rgb(80, 80, 80)',

    /**
     * Font style for selected rows' headers.
     * @default
     * @type {string}
     * @instance
     */
    rowHeaderForegroundSelectionFont: 'bold 12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderForegroundRowSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    rowHeaderBackgroundRowSelectionColor: 'rgb(255, 180, 0)',


    /********** SECTION: FILTER ROW COLORS **********/

    /**
     * @default
     * @type {cssFont}
     * @instance
     */
    filterFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterBackgroundColor: 'white',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterForegroundSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    filterBackgroundSelectionColor: 'rgb(255, 220, 97)',

    /**
     * @default
     * @type {string}
     * @instance
     */
    filterHalign: 'center',


    /********** SECTION: TREE COLUMN COLORS **********/
    // The "tree column" contains the hierarchical drill-down controls.

    /**
     * @default
     * @type {cssFont}
     * @instance
     */
    treeColumnFont: '12px Tahoma, Geneva, sans-serif',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnBackgroundColor: 'rgb(223, 227, 232)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnForegroundSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnBackgroundSelectionColor: 'rgba(255, 220, 97, 0.45)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnForegroundColumnSelectionColor: 'rgb(25, 25, 25)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    treeColumnBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    backgroundColor2: 'rgb(201, 201, 201)',

    /**
     * @default
     * @type {number}
     * @instance
     */
    voffset: 0,

    /**
     * @default
     * @type {string}
     * @instance
     */
    scrollbarHoverOver: 'visible',

    /**
     * @default
     * @type {string}
     * @instance
     */
    scrollbarHoverOff: 'hidden',

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    scrollingEnabled: true,

    /**
     * @default
     * @type {string}
     * @instance
     */
    vScrollbarClassPrefix: '',

    /**
     * @default
     * @type {string}
     * @instance
     */
    hScrollbarClassPrefix: '',

    //these used to be in the constants element

    /**
     * @default
     * @type {string}
     * @instance
     */
    fixedRowAlign: 'center',

    /**
     * @default
     * @type {string}
     * @instance
     */
    fixedColAlign: 'center',
    /**
     * @default
     * @type {string}
     * @instance
     */
    halign: 'center',

    /**
     * @default
     * @type {number}
     * @instance
     */
    cellPadding: 5,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    gridLinesH: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    gridLinesV: true,
    /**
     * @default
     * @type {boolean}
     * @instance
     */
    gridLinesVOverflow: false,

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    lineColor: 'rgb(199, 199, 199)',

    /**
     * @default
     * @type {number}
     * @instance
     */
    lineWidth: 1,


    /**
     * @default
     * @type {number}
     * @instance
     */
    defaultRowHeight: 15,

    /**
     * @default
     * @type {number}
     * @instance
     */
    defaultColumnWidth: 100,

    //for immediate painting, set these values to 0, true respectively

    /**
     * @default
     * @type {number}
     * @instance
     */
    repaintIntervalRate: 60,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    repaintImmediately: false,

    //enable or disable double buffering

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    useBitBlit: false,


    /**
     * @default
     * @type {boolean}
     * @instance
     */
    useHiDPI: true,

    /**
     * @default ['alt', 'esc']
     * @type {string}
     * @instance
     */
    editorActivationKeys: ['alt', 'esc'],

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    readOnly: false,

    // inherited by cell renderers

    /**
     * @default `getTextWidth`
     * @type {function}
     * @instance
     */
    getTextWidth: getTextWidth,

    /**
     * @default `getTextHeight`
     * @type {function}
     * @instance
     */
    getTextHeight: getTextHeight,


    /**
     * @default
     * @type {number}
     * @instance
     */
    fixedColumnCount: 0,

    /**
     * @default
     * @type {number}
     * @instance
     */
    fixedRowCount: 0,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    showRowNumbers: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    showTreeColumn: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    showHeaderRow: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    showFilterRow: false,


    /** Clicking in a cell "selects" it; it is added to the select region and repainted with "cell selection" colors.
     * @default
     * @type {boolean}
     * @instance
     */
    cellSelection: true,

    /** Clicking in a column header (top row) "selects" the column; the entire column is added to the select region and repainted with "column selection" colors.
     * @default
     * @type {boolean}
     * @instance
     */
    columnSelection: true,

    /** Clicking in a row header (leftmost column) "selects" the row; the entire row is added to the select region and repainted with "row selection" colors.
     * @default
     * @type {boolean}
     * @instance
     */
    rowSelection: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    singleRowSelectionMode: true,

    /**
     * @default
     * @type {cssColor}
     * @instance
     */
    selectionRegionOverlayColor: 'rgba(0, 0, 48, 0.2)',

    /**
     * @default
     * @type {string}
     * @instance
     */
    selectionRegionOutlineColor: 'rgb(69, 69, 69)',

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    columnAutosizing: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    rowNumberAutosizing: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    headerTextWrapping: false,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    rowResize: false,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    editable: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    filterable: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    editOnDoubleClick: true,

    /**
     * @default
     * @type {number}
     * @instance
     */
    doubleClickDelay: 325,

    /**
     * Grid-level property.
     * When user presses a printable character key _or_ BACKSPACE _or_ DELETE:
     * 1. Activate cell editor on current cell (i.e., origin of most recent selection).
     * 2. If cell editor is a text editor:
     *    1. Replace current value with the character the user typed; or
     *    2. Clear it on BACKSPACE, DELETE, or other invalid character (_e.g._ when user types a letter but the cell editor only accepts digits).
     *
     * > In invoked, user has the option to back out by pressing the ESCAPE key.
     *
     * @default
     * @type {boolean}
     * @instance
     */
    editOnKeydown: true,

    /**
     * @default
     * @type {boolean}
     * @instance
     */
    checkboxOnlyRowSelections: false,

    /** @summary Name of a formatter for cell text.
     * @desc The default (`undefined`) falls back to `column.type`.
     * The value `null` does no formatting.
     * @default undefined
     * @type {undefined|null|string}
     * @instance
     * @tutorial localization
     */
    format: undefined,

    /** @summary Name of a cell editor from the {@link module:cellEditors|cellEditors API}..
     * @desc Not editable if named editor is does not exist.
     * @default undefined
     * @type {undefined|null|string}
     * @instance
     * @tutorial cell-editors
     */
    editor: undefined,

    /**
     * Name of cell renderer from the {@link module:cellRenderers|cellRenderers API}.
     * @default
     * @type {string}
     * @instance
     */
    renderer: 'SimpleCell',

    /********** HOVER COLORS **********/

    /** @typedef hoverColors
     * @property {boolean} [enable=false] - `false` means not hilite on hover
     * @property {cssColor} backgroundColor - cell, row, or column background color. Alpha channel will be respected and if given will be painted over the cells predetermined color.
     * @property {cssColor} [header.backgroundColor=backgroundColor] - for columns and rows, this is the background color of the column or row "handle" (header rows or columns, respectively). (Not used for cells.)
     */

    /** On mouse hover, whether to repaint the cell background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(160, 160, 40, 0.30) }'
     * @instance
     */
    hoverCellHighlight: {
        enabled: true,
        backgroundColor: 'rgba(160, 160, 40, 0.45)'
    },

    /** On mouse hover, whether to repaint the row background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(100, 100, 25, 0.15) }'
     * @instance
     */
    hoverRowHighlight: {
        enabled: true,
        backgroundColor: 'rgba(100, 100, 25, 0.30)'

    },

    /** On mouse hover, whether to repaint the column background and how.
     * @type {hoverColors}
     * @default '{ enabled: true, background: rgba(60, 60, 15, 0.15) }'
     * @instance
     */
    hoverColumnHighlight: {
        enabled: true,
        backgroundColor: 'rgba(60, 60, 15, 0.15)'
    },


    /** Display cell font with under-score line drawn over it.
     * > Implementation of links right now is not automatic; you must attach a 'fin-click' listener to the hypergrid object, etc.
     * @type {boolean}
     * @default
     * @instance
     */
    link: false,

    /** Display cell font with strike-through line drawn over it.
     * @type {boolean}
     * @default
     * @instance
     */
    strikeThrough: false,

    /** Ignore sort interaction (double-click).
     * @type {boolean}
     * @default
     * @instance
     */
    unsortable: false,

    /** Allow multiple cell region selections.
     * @type {boolean}
     * @default
     * @instance
     */
    multipleSelections: false,

    /** @summary Re-render grid at maximum speed.
     * @desc In this mode:
     * * The "dirty" flag, set by calling `grid.repaint()`, is ignored.
     * * `grid.getCanvas().currentFPS` is a measure of the number times the grid is being re-rendered each second.
     * * The Hypergrid renderer gobbles up CPU time even when the grid appears idle (the very scenario `repaint()` is designed to avoid). For this reason, we emphatically advise against shipping applications using this mode.
     * @type {boolean}
     * @default
     * @instance
     */
    enableContinuousRepaint: false,

    /** @summary Allow user to move columns .
     * @desc Columns can be reordered through either of two interfaces:
     * * Column Dragging feature
     * * Column Picker dialog
     * @type {boolean}
     * @default
     * @instance
     */
    columnsReorderable: true,

    /** @summary Apply cell properties before `getCell`.
     * @type {boolean}
     * @default
     * @instance
     */
    applyCellProperties: true,

    /** @summary Reapply cell properties after `getCell`.
     * @type {boolean}
     * @default
     * @instance
     */
    reapplyCellProperties: false,

    /** @summary Column grab within this number of pixels from top of cell.
     * @type {number}
     * @default
     * @instance
     */
    columnGrabMargin: 5
};

/** @typedef {string} cssColor
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
 */
/** @typedef {string} cssFont
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/font
 */

var textWidthCache = new LRUCache(2000);

function getTextWidth(gc, string) {
    if (string === null || string === undefined) {
        return 0;
    }
    string += '';
    if (string.length === 0) {
        return 0;
    }
    var key = gc.font + string;
    var width = textWidthCache.get(key);
    if (!width) {
        width = gc.measureText(string).width;
        textWidthCache.set(key, width);
    }
    return width;
}

var fontData = {};

function getTextHeight(font) {
    var result = fontData[font];

    if (!result) {
        result = {};

        var text = document.createElement('span');
        text.textContent = 'Hg';
        text.style.font = font;

        var block = document.createElement('div');
        block.style.display = 'inline-block';
        block.style.width = '1px';
        block.style.height = '0px';

        var div = document.createElement('div');
        div.appendChild(text);
        div.appendChild(block);

        div.style.position = 'absolute';
        document.body.appendChild(div);

        try {

            block.style.verticalAlign = 'baseline';

            var blockRect = block.getBoundingClientRect();
            var textRect = text.getBoundingClientRect();

            result.ascent = blockRect.top - textRect.top;

            block.style.verticalAlign = 'bottom';
            result.height = blockRect.top - textRect.top;

            result.descent = result.height - result.ascent;

        } finally {
            document.body.removeChild(div);
        }
        if (result.height !== 0) {
            fontData[font] = result;
        }
    }

    return result;
}

},{"lru-cache":40}],87:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var ListDragon = require('list-dragon');

var Dialog = require('./Dialog');
var stylesheet = require('../lib/stylesheet');

/**
 * @constructor
 * @extends Dialog
 */
var ColumnPicker = Dialog.extend('ColumnPicker', {
    /**
     * @param {Hypergrid} grid
     * @param {object} [options] - May include `Dialog` options.
     */
    initialize: function(grid, options) {
        var behavior = grid.behavior;

        this.grid = grid;

        if (behavior.isColumnReorderable()) {
            // parse & add the drag-and-drop stylesheet addendum
            var stylesheetAddendum = stylesheet.inject('list-dragon-addendum');

            // grab the group lists from the behavior
            if (behavior.setGroups) {
                this.selectedGroups = {
                    title: 'Groups',
                    models: behavior.getGroups()
                };

                this.availableGroups = {
                    title: 'Available Groups',
                    models: behavior.getAvailableGroups()
                };

                var groupPicker = new ListDragon([
                    this.selectedGroups,
                    this.availableGroups
                ]);

                // add the drag-and-drop sets to the dialog
                this.append(groupPicker.modelLists[0].container);
                this.append(groupPicker.modelLists[1].container);
            }

            // grab the column lists from the behavior
            this.inactiveColumns = {
                title: 'Inactive Columns',
                models: behavior.getHiddenColumns().sort(compareByName)
            };

            this.activeColumns = {
                title: 'Active Columns',
                models: behavior.getActiveColumns()
            };

            this.sortOnHiddenColumns = this.wasSortOnHiddenColumns = grid.properties.sortOnHiddenColumns;

            var columnPicker = new ListDragon([
                this.inactiveColumns,
                this.activeColumns
            ], {
                // add the list-dragon-base stylesheet right before the addendum
                cssStylesheetReferenceElement: stylesheetAddendum,
                // these models have a header property as their labels
                label: '{header}'
            });

            // add the drag-and-drop sets to the dialog
            this.append(columnPicker.modelLists[0].container);
            this.append(columnPicker.modelLists[1].container);

            //Listen to the visible column changes
            columnPicker.modelLists[1].element.addEventListener('listchanged', function(e){
                grid.fireSyntheticOnColumnsChangedEvent();
            });

            this.sortOnHiddenColumns = this.grid.properties.sortOnHiddenColumns;
        } else {
            var div = document.createElement('div');
            div.style.textAlign = 'center';
            div.style.marginTop = '2em';
            div.innerHTML = 'The selection of visible columns in the grid may not be changed.';
            this.append(div);
        }

        // Add checkbox to control panel for sorting on hidden fields
        var label = document.createElement('label');
        label.innerHTML = '<input type="checkbox"> Allow sorting on hidden columns';
        label.style.fontWeight = 'normal';
        label.style.marginRight = '2em';

        var checkbox = label.querySelector('input');
        checkbox.checked = this.sortOnHiddenColumns;
        checkbox.addEventListener('click', function(e){
            self.sortOnHiddenColumns = checkbox.checked;
            e.stopPropagation();
        });

        var panel = this.el.querySelector('.hypergrid-dialog-control-panel');
        panel.insertBefore(label, panel.firstChild);

        // add the dialog to the DOM
        this.open(options.container);
    },

    onClosed: function() {
        var behavior = this.grid.behavior,
            columns = behavior.columns;

        if (this.activeColumns) {
            var tree = columns[0];

            // TODO: breaking encapsulation; should be using setters and getters on the behavior
            columns.length = 0;
            if (tree && tree.label === 'Tree') {
                columns.push(tree);
            }
            this.activeColumns.models.forEach(function(column) {
                columns.push(column);
            });

            if (this.sortOnHiddenColumns !== this.wasSortOnHiddenColumns) {
                this.grid.addProperties({ sortOnHiddenColumns: this.sortOnHiddenColumns });
                behavior.sortChanged(this.inactiveColumns.models);
            }

            behavior.changed();
        }

        if (this.selectedGroups){
            var groupBys = this.selectedGroups.models.map(function(e) {
                return e.id;
            });
            behavior.setGroups(groupBys);
        }
    }
});

function compareByName(a, b) {
    a = a.header.toString().toUpperCase();
    b = b.header.toString().toUpperCase();
    return a < b ? -1 : a > b ? +1 : 0;
}


module.exports = ColumnPicker;

},{"../lib/stylesheet":120,"./Dialog":88,"list-dragon":39}],88:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var automat = require('automat');

var Base = require('../Base');
var markup = require('../../html');
var images = require('../../images');
var elfor = require('../lib/DOM/elfor');

/**
 * Creates and services a DOM element used as a cntainer for a dialog. The standard `markup.dialog` is simply a div with a _control panel_ containing a close box and a settings gear icon.
 *
 * You can supply an alternative dialog template. The interface is:
 * * Class name `hypergrid-dialog`.
 * * At least one child element. Content will be inserted before this first child.
 * * Typically contains a close-box element with class name `hypergrid-dialog-close` and possibly other controls with class name `hypergrid-dialog-xxxx` (where _xxxx_ is a unique name for your control).
 *
 * @constructor
 */
var Dialog = Base.extend('Dialog', {

    /**
     * Creates a basic dialog box in `this.el`.
     * @param {Hypergrid} grid
     * @param {object} [options]
     * @param {string|function} [options.dialogTemplate] - An alternate dialog template. The last child element must be the "control panel."
     * @param {boolean} [options.settings=true] - Control box has settings icon. (Settings icon must be included in template. This option removes it. That is, if explicitly `false` _and_ there is a settings control, remove it.)
     * @param {string|boolean} [options.backgroundImage=images.dialog.src] - A URI for a background image. If explicitly `false`, background image is suppressed.
     * @param {function} [terminate]
     */
    initialize: function(grid, options) {
        options = options || {};

        this.grid = grid;

        // create the backdrop; it is absolute-positioned and stretched
        this.el = automat.firstChild(options.dialogTemplate || markup.dialog, options.dialogReplacements);

        this.originalFirstChild = this.el.firstElementChild;

        if (options.settings === false) {
            var settings = this.el.querySelector('.hypergrid-dialog-settings');
            if (settings) {
                settings.remove();
            }
        }

        // add background image
        if (options.backgroundImage !== false) {
            this.el.style.backgroundImage = 'url(\'' + (options.backgroundImage || images.dialog.src) + '\')';
        }

        // listen for clicks
        this.el.addEventListener('click', onClick.bind(this));

        if (options.terminate) {
            this.terminate = options.terminate;
        }
    },

    /**
     * @summary Adds DOM `Node`s to dialog.
     * @desc Input can be nodes or a template from which to create nodes. The nodes are inserted into the dialog's DOM (`this.el`), right before the "control panel."
     * @param {string|function|Node|Node[]} nodes - See `automat`.
     * @param {...*} [replacements] - See `automat`.
     */
    append: function(nodes, replacements/*...*/) {
        var el = this.el;

        if (typeof nodes === 'string' || typeof nodes === 'function') {
            var args = Array.prototype.slice.call(arguments);
            args.splice(1, 0, el, this.originalFirstChild);
            automat.append.apply(null, args);

        } else if ('length' in nodes) {
            for (var i = 0; i < nodes.length; ++i) {
                el.insertBefore(nodes[i], this.originalFirstChild);
            }

        } else {
            el.insertBefore(nodes, this.originalFirstChild);
        }
    },

    /**
     * Insert dialog into DOM.
     *
     * @param {HTMLElement} [container] - If undefined, dialog is appended to body.
     *
     * If defined, dialog is appended to container. When container is not body, it will be:
     * # made visible before append (it should initially be hidden)
     * # made hidden after remove
     */
    open: function(container) {
        var error;

        if (!(this.opened || this.opening || this.closed || this.closing)) {
            error = this.onOpen();

            if (!error) {
                var el = this.el;

                this.opening = true;

                container = container || document.querySelector('body');

                if (container.tagName !== 'BODY') {
                    container.style.visibility = 'visible';
                }

                // insert the new dialog markup into the DOM
                container.appendChild(el);

                // schedule it for a show transition
                setTimeout(function() { el.classList.add('hypergrid-dialog-visible'); }, 50);

                // at end of show transition, hide all the hypergrids behind it to prevent any key/mouse events from getting to them
                // todo: pause all hypergrids so they don't spin uselessly
                el.addEventListener('transitionend', this.hideAppBound = hideApp.bind(this));
            }
        }

        return error;
    },

    /**
     * Remove dialog from DOM.
     */
    close: function() {
        var error;

        if (this.opened && !(this.closed || this.closing)) {
            error = this.onClose();

            if (!error) {
                var el = this.el;

                this.closing = true;

                // unhide all the hypergrids behind the dialog
                this.appVisible('visible');

                // start a hide transition of dialog revealing grids behind it
                el.classList.remove('hypergrid-dialog-visible');

                // at end of hide transition, remove dialog from the DOM
                el.addEventListener('transitionend', this.removeDialogBound = removeDialog.bind(this));
            }
        }

        return error;
    },

    appSelector: 'canvas.hypergrid',
    appVisible: function(visibility) {
        elfor.each(this.appSelector, function(el) {
            el.style.visibility = visibility;
        });
    },

    onOpen: nullPattern,
    onOpened: nullPattern,
    onClose: nullPattern,
    onClosed: nullPattern,
    terminate: nullPattern
});

function nullPattern() {}

function removeDialog(evt) {
    if (evt.target === this.el && evt.propertyName === 'opacity') {
        if (this.el.parentElement.tagName !== 'BODY') {
            this.el.parentElement.style.visibility = 'hidden';
        }
        this.el.remove();
        delete this.el;

        this.onClosed();
        this.terminate();
        this.closing = false;
        this.closed = true;
    }
}

function hideApp(evt) {
    if (evt.target === this.el && evt.propertyName === 'opacity') {
        this.appVisible('hidden');
        this.el.removeEventListener('transitionend', this.hideAppBound);
        this.onOpened();
        this.opening = false;
        this.opened = true;
    }
}

function onClick(evt) {
    if (this) {
        if (evt.target.classList.contains('hypergrid-dialog-close')) {
            evt.preventDefault(); // ignore href
            this.close();

        } else if (evt.target.classList.contains('hypergrid-dialog-settings')) {
            evt.preventDefault(); // ignore href
            if (this.settings) { this.settings(); }

        } else if (this.onClick && !this.onClick.call(this, evt) && evt.target.tagName === 'A') {
            evt.preventDefault(); // ignore href of handled event
        }
    }

    evt.stopPropagation(); // the click stops here, handled or not
}

module.exports = Dialog;

},{"../../html":2,"../../images":4,"../Base":49,"../lib/DOM/elfor":111,"automat":5}],89:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var Tabz = require('tabz');
var popMenu = require('pop-menu');
var automat = require('automat');

var Dialog = require('./Dialog');
var markup = require('../../html');
var copyInput = require('../lib/DOM/copy-input');

var tabProperties = {
    tableQB: {
        isTableFilter: true
    },
    tableSQL: {
        isTableFilter: true,
        language: 'SQL'
    },
    columnsQB: {
        isColumnFilter: true
    },
    columnsSQL: {
        isColumnFilter: true,
        language: 'SQL'
    },
    columnsCQL: {
        isColumnFilter: true,
        language: 'CQL'
    }
};

/**
 * @constructor
 * @extends Dialog
 */
var ManageFilters = Dialog.extend('ManageFilters', {

    /**
     * @param {Hypergrid} grid
     * @param {object} [options] - May include `Dialog` options.
     * @param {HTMLElement} [options.container=document.body]
     */
    initialize: function(grid, options) {
        this.filter = grid.filter;

        this.append(markup.filterTrees);

        // initialize the folder tabs
        var tabz = this.tabz = new Tabz({
            root: this.el,
            onEnable: renderFolder.bind(this),
            onDisable: saveFolders.bind(this, null) // null options
        });

        // wire-up the New Column drop-down
        var newColumnDropDown = this.el.querySelector('#add-column-filter-subexpression');
        newColumnDropDown.onmousedown = onNewColumnMouseDown.bind(this);
        newColumnDropDown.onchange = onNewColumnChange.bind(this);

        // put the two subtrees in the two panels
        tabz.folder('#tableQB').appendChild(this.filter.tableFilter.el);
        tabz.folder('#columnsQB').appendChild(this.filter.columnFilters.el);

        // copy the SQL more-info block from the table to the columns tab
        var columnSqlEl = tabz.folder('#columnsSQL');
        var moreSqlInfo = tabz.folder('#tableSQL').firstElementChild.cloneNode(true);
        columnSqlEl.insertBefore(moreSqlInfo, columnSqlEl.firstChild);

        // add it to the DOM
        this.open(options.container);

        // following needed for unclear reasons to get drop-down to display correctly
        newColumnDropDown.selectedIndex = 0;
    },

    onClose: function() {
        return saveFolders.call(this);
    },

    onClosed: function() {
        var behavior = this.grid.behavior;
        behavior.reindex();
        behavior.changed();
    },

    /**
     * Custom click handlers; called by curtain.onclick in context
     * @param evt
     * @returns {boolean}
     */
    onClick: function(evt) { // to be called with filter object as syntax
        var ctrl = evt.target;

        if (ctrl.classList.contains('more-info')) {
            // find all more-info links and their adjacent blocks (blocks always follow links)
            var els = this.el.querySelectorAll('.more-info');

            // hide all more-info blocks except the one following this link (unless it's already visible in which case hide it too).
            for (var i = 0; i < els.length; ++i) {
                var el = els[i];
                if (el.tagName === 'A') {
                    var found = el === ctrl;
                    el.classList[found ? 'toggle' : 'remove']('hide-info');
                    el = els[i + 1];
                    el.style.display = found && el.style.display !== 'block' ? 'block' : 'none';
                }
            }

        } else if (ctrl.classList.contains('filter-copy')) {
            var isCopyAll = ctrl.childNodes.length; // contains "All"
            if (isCopyAll) {
                ctrl = this.tabz.folder(ctrl).querySelector(copyInput.selectorTextControls);
                copyInput(ctrl, this.filter.columnFilters.getState({ syntax: 'SQL' }));
            } else {
                copyInput(ctrl.parentElement.querySelector(copyInput.selectorTextControls));
            }

        } else {
            return true; // means unhandled
        }
    }
});

/**
 * @param options
 * @param tab
 * @param folder
 * @param [panel] Panel to save (from tab click). If omitted, save both panels (from onclose).
 * @returns {boolean|undefined|string}
 */
function saveFolders(options, tab, folder, panel) {
    return (
        (!panel || panel.id === 'tableFilterPanel') && saveFolder.call(this, this.filter.tableFilter, options) ||
        (!panel || panel.id === 'columnFiltersPanel') && saveFolder.call(this, this.filter.columnFilters, options)
    );
}

/**
 * @this Filter
 * @param {DefaultFilter} subtree
 * @param {object} [options={alert:true,focus:true}] - Side effects as per `FilterTree.prototype.invalid`'s `options`' parameter.
 * @returns {undefined|string} - Validation error text; falsy means valid (no error).
 */
function saveFolder(subtree, options) { // to be called with filter object as syntax
    var isColumnFilters = subtree === this.filter.columnFilters,
        tabQueryBuilder = this.tabz.tab(isColumnFilters ? '#columnsQB' : '#tableQB'),
        tab = this.tabz.enabledTab(tabQueryBuilder),
        folder = this.tabz.folder(tab),
        isQueryBuilder = tab === tabQueryBuilder,
        defaultedOptions = options || {
            alert: true,
            focus: true
        },
        enhancedOptions = {
            alert: defaultedOptions.alert,
            focus: defaultedOptions.focus && isQueryBuilder
        },
        error, ctrl;

    if (isColumnFilters || isQueryBuilder) {
        error = subtree.invalid(enhancedOptions);
    } else { // table filter SQL tab
        ctrl = folder.querySelector('textarea');
        error = this.filter.setTableFilterState(ctrl.value, options);
    }

    if (error && !isQueryBuilder) {
        // If there was a validation error, move the focus from the query builder control to the text box control.
        if (isColumnFilters) {
            // We're in SQL or CQL tab so find text box that goes with this subexpression and focus on it instead of QB control.
            var errantColumnName = error.node.el.parentElement.querySelector('input').value;
            ctrl = folder.querySelector('[name="' + errantColumnName + '"]');
        }
    }

    if (ctrl) {
        decorateFilterInput(ctrl, error);
    }

    return error;
}

function decorateFilterInput(ctrl, error) {
    ctrl.classList.toggle('filter-tree-error', !!error);

    ctrl.focus();

    // find the nearby warning element
    var warningEl;
    do {
        ctrl = ctrl.parentElement;
        warningEl = ctrl.querySelector('.filter-tree-warn');
    } while (!warningEl);

    // show or hide the error
    warningEl.innerHTML = error.message || error || '';
}

function onNewColumnMouseDown(evt) { // to be called with filter object as syntax
    if (saveFolder.call(this, this.filter.columnFilters)) {
        evt.preventDefault(); // do not drop down
    } else {
        // (re)build the drop-down contents, with same prompt, but excluding columns with active filter subexpressions
        var ctrl = evt.target,
            prompt = ctrl.options[0].text.replace('', ''), // use original but w/o ellipsis as .build() appends one
            blacklist = this.filter.columnFilters.children.map(function(columnFilter) {
                return columnFilter.children.length && columnFilter.children[0].column;
            }),
            options = {
                prompt: prompt,
                blacklist: blacklist
            };

        popMenu.build(ctrl, this.filter.root.schema, options);
    }
}

function onNewColumnChange(evt) {
    var ctrl = evt.target,
        tabColumnQB = this.tabz.folder('#tableQB'),
        tab = this.tabz.enabledTab(tabColumnQB.parentElement),
        isQueryBuilder = tab === tabColumnQB,
        tabProps = tabProperties[tab.id];

    this.filter.columnFilters.add({
        state: {
            type: 'columnFilter',
            children: [ { column: ctrl.value } ]
        },
        focus: isQueryBuilder
    });

    if (tabProps.isColumnFilter && tabProps.lanugage) {
        renderFolder.call(this, tab);
    }

    // remove all but the prompt option (first child)
    ctrl.selectedIndex = 0;
    while (ctrl.lastChild !== ctrl.firstChild) {
        ctrl.removeChild(ctrl.lastChild);
    }
}

function renderFolder(tab) { // to be called with filter object as syntax
    var tabProps = tabProperties[tab.id],
        queryLanguage = tabProps.language;

    if (queryLanguage) {
        var globalFilter = this.filter,
            folder = this.tabz.folder(tab);

        if (tabProps.isTableFilter) {

            folder.querySelector('textarea').value = globalFilter.tableFilter.getState({ syntax: 'SQL' });

        } else { // column filter

            var columnFilters = globalFilter.columnFilters.children,
                el = folder.lastElementChild,
                msgEl = el.querySelector('span'),
                listEl = el.querySelector('ol'),
                copyAllLink = el.querySelector('a:first-of-type');

            msgEl.innerHTML = activeFiltersMessage(columnFilters.length);
            listEl.innerHTML = '';

            // for each column filter subtree, append an <li>...</li> element containing:
            // column title, "(copy)" link, and editable text input box containing the subexpression
            columnFilters.forEach(function(filter) {
                var conditional = filter.children[0],
                    item = conditional.schema[0],
                    name = conditional.column,
                    alias = item.alias || name,
                    expression = filter.getState({ syntax: queryLanguage }),
                    isNull = expression === '(NULL IS NULL)' || expression === '',
                    content = isNull ? '' : expression,
                    className = isNull ? 'filter-tree-error' : '',
                    li = automat.firstChild(markup[queryLanguage], alias, name, content, className);

                listEl.appendChild(li);
            });

            folder.onkeyup = setColumnFilterState.bind(this, queryLanguage);

            if (copyAllLink) {
                // if there's a "(copy all)" link, hide it if only 0 or 1 subexpressions
                copyAllLink.style.display = columnFilters.length > 1 ? 'block' : 'none';
            }
        }

    }
}

//var RETURN_KEY = 0x0d, ESCAPE_KEY = 0x1b;
/**
 * Called from key-up events from `#columnSQL` and `#columnCQL` tabs.
 * @this Filter
 * @param {string} queryLanguage
 * @param {KeyboardEvent} evt
 */
function setColumnFilterState(queryLanguage, evt) {
    var ctrl = evt.target;

    // Only handle if key was pressed inside a text box.
    if (ctrl.classList.contains('filter-text-box')) {
        //switch (evt.keyCode) {
        //    case ESCAPE_KEY:
        //        ctrl.value = oldArg;
        //    case RETURN_KEY: // eslint-disable-line no-fallthrough
        //        ctrl.blur();
        //        break;
        //    default:
        var error,
            options = { syntax: queryLanguage, alert: true };

        try {
            error = this.filter.setColumnFilterState(ctrl.name, ctrl.value, options);
        } catch (err) {
            error = err;
        }

        decorateFilterInput(ctrl, error);
        //}
    }
}

function activeFiltersMessage(n) {
    var result;

    switch (n) {
        case 0:
            result = 'There are no active column filters.';
            break;
        case 1:
            result = 'There is 1 active column filter:';
            break;
        default:
            result = 'There are ' + n + ' active column filters:';
    }

    return result;
}


module.exports = ManageFilters;

},{"../../html":2,"../lib/DOM/copy-input":109,"./Dialog":88,"automat":5,"pop-menu":44,"tabz":47}],90:[function(require,module,exports){
'use strict';

module.exports.ColumnPicker = require('./ColumnPicker');
module.exports.ManageFilters = require('./ManageFilters');

},{"./ColumnPicker":87,"./ManageFilters":89}],91:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/* NOTE
 *
 * What this file is:
 * * This file is browserify's entry point.
 * * This file creates the `window.fin.Hypergrid` object.
 *
 * What this file is not:
 * * This file is not a node module; it has no reference to `module.exports` or `exports`; it cannot be "required" by any other file.
 * * This file is blacklisted in .npmignore and is not published to npm.
 *
 * Note: The npm "main" entry point (as noted in package.json) is src/Hypergrid.js.
 */

var Hypergrid = require('./Hypergrid');

// Expose some namespaces to users of the hypergrid.js file through `fin.Hypergrid`:
Hypergrid.images = require('../images');
Hypergrid.behaviors = require('./behaviors');
Hypergrid.dataModels = require('./dataModels');
Hypergrid.features = require('./features');
Hypergrid.analytics = require('./Shared.js').analytics;
Hypergrid.DataSourceBase = require('./dataSources').DataSourceBase;
Hypergrid.rectangular = require('rectangular');

// Create the `fin` namespace and the `fin.Hypergrid` objects:
(window.fin = window.fin || {}).Hypergrid = Hypergrid;

// Create the `datasaur` namespace and the `datasaur.base` objects:
(window.datasaur = window.datasaur || {}).base = Hypergrid.DataSourceBase;

// Note that while users of the npm module can also access the above namespaces through the Hypergrid object, in reality they also have access to any namespace through `require`, for example:
// var behaviorJSON = require('fin-hypergrid/src/behaviors/JSON');

},{"../images":4,"./Hypergrid":50,"./Shared.js":51,"./behaviors":57,"./dataModels":83,"./dataSources":85,"./features":108,"rectangular":45}],92:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var CellClick = Feature.extend('CellClick', {

    /**
     * @memberOf CellClick.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleClick: function(grid, event) {
        var consumed;

        if (
            event.gridCell.y >= grid.behavior.getHeaderRowCount() &&
            event.gridCell.x >= 0
        ) {
            consumed = grid.cellClicked(event);
        }

        if (!consumed && this.next) {
            this.next.handleClick(grid, event);
        }
    }
});

module.exports = CellClick;

},{"./Feature":101}],93:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');
var CellEditor = require('../cellEditors/CellEditor');

/**
 * @constructor
 * @extends Feature
 */
var CellEditing = Feature.extend('CellEditing', {

    /**
     * @memberOf CellEditing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function(grid, event) {
        if (
            grid.properties.editOnDoubleClick &&
            event.isGridCell
        ) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    handleClick: function(grid, event) {
        if (
            !grid.properties.editOnDoubleClick &&
            event.isGridCell
        ) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleClick(grid, event);
        }
    },

    /**
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function(grid, event) {
        var char, isVisibleChar, isDeleteChar, currentCell, editor;

        if (
            grid.properties.editOnKeydown &&
            !grid.cellEditor &&
            (
                (char = event.detail.char) === 'F2' ||
                (isVisibleChar = char.length === 1 && !(event.detail.meta || event.detail.ctrl)) ||
                (isDeleteChar = char === 'DELETE' || char === 'BACKSPACE')
            )
        ) {
            currentCell = grid.selectionModel.getLastSelection();
            if (currentCell) {
                var pseudoEvent = new grid.behavior.CellEvent(currentCell.origin.x,
                    currentCell.origin.y + grid.behavior.getHeaderRowCount());

                editor = grid.onEditorActivate(pseudoEvent);

                if (editor instanceof CellEditor) {
                    if (isVisibleChar) {
                        editor.input.value = char;
                    } else if (isDeleteChar) {
                        editor.setEditorValue('');
                    }
                    event.detail.primitiveEvent.preventDefault();
                }
            }
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

module.exports = CellEditing;

},{"../cellEditors/CellEditor":58,"./Feature":101}],94:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var CellSelection = Feature.extend('CellSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @memberOf CellSelection.prototype
     */
    currentDrag: null,

    /**
     * the cell coordinates of the where the mouse pointer is during a drag operation
     * @type {Object}
     * @memberOf CellSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbAutoStart: 0,

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var dx = event.gridCell.x,
            dy = event.dataCell.y,
            isSelectable = grid.behavior.getCellProperty(event.dataCell.x, event.gridCell.y, 'cellSelection');

        if (isSelectable && event.isGridCell && !event.primitiveEvent.detail.isRightClick) {
            var dCell = grid.newPoint(dx, dy),
                primEvent = event.primitiveEvent,
                keys = primEvent.detail.keys;
            this.dragging = true;
            this.extendSelection(grid, dCell, keys);
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.dragging && grid.isCellSelection() && !event.primitiveEvent.detail.isRightClick) {
            this.currentDrag = event.primitiveEvent.detail.mouse;
            this.lastDragCell = grid.newPoint(event.gridCell.x, event.dataCell.y);
            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, this.lastDragCell, event.primitiveEvent.detail.keys);
        } else  if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var handler;
        if ((handler = this['handle' + event.detail.char])) {
            handler.call(this, grid, event.detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle a mousedrag selection.
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {
        var x = Math.max(0, gridCell.x),
            y = Math.max(0, gridCell.y),
            previousDragExtent = grid.getDragExtent(),
            mouseDown = grid.getMouseDown(),
            newX = x - mouseDown.x,
            newY = y - mouseDown.y;

        if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
            return;
        }

        grid.clearMostRecentSelection();

        grid.select(mouseDown.x, mouseDown.y, newX, newY);
        grid.setDragExtent(grid.newPoint(newX, newY));

        grid.repaint();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.properties.scrollingEnabled) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var dragStartedInHeaderArea = grid.isMouseDownInHeaderArea(),
            lastDragCell = this.lastDragCell,
            b = grid.getDataBounds(),

            xOffset = 0,
            yOffset = 0,

            numFixedColumns = grid.getFixedColumnCount(),
            numFixedRows = grid.getFixedRowCount(),

            dragEndInFixedAreaX = lastDragCell.x < numFixedColumns,
            dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (!dragStartedInHeaderArea) {
            if (this.currentDrag.x < b.origin.x) {
                xOffset = -1;
            }
            if (this.currentDrag.y < b.origin.y) {
                yOffset = -1;
            }
        }
        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }
        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }
        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        var hasCTRL = keys.indexOf('CTRL') >= 0,
            hasSHIFT = keys.indexOf('SHIFT') >= 0,
            mousePoint = grid.getMouseDown(),
            x = gridCell.x, // - numFixedColumns + scrollLeft;
            y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        if (
            hasCTRL &&
            x === mousePoint.x &&
            y === mousePoint.y
        ) {
            grid.clearMostRecentSelection();
            grid.popMouseDown();
            grid.repaint();
            return;
        }

        if (!hasCTRL && !hasSHIFT) {
            grid.clearSelections();
        }

        if (hasSHIFT) {
            grid.clearMostRecentSelection();
            grid.select(mousePoint.x, mousePoint.y, x - mousePoint.x, y - mousePoint.y);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x, y - mousePoint.y));
        } else {
            grid.select(x, y, 0, 0);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, 1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, -1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        this.moveSingleSelect(grid, 0, count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        this.moveSingleSelect(grid, 0, -count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX, offsetY) {

        var maxColumns = grid.getColumnCount() - 1,
            maxRows = grid.getRowCount() - 1,

            maxViewableColumns = grid.renderer.visibleColumns.length - 1,
            maxViewableRows = grid.renderer.visibleRows.length - 1,

            origin = grid.getMouseDown(),
            extent = grid.getDragExtent(),

            newX = extent.x + offsetX,
            newY = extent.y + offsetY;

        if (!grid.properties.scrollingEnabled) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));
        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentSelection();
        grid.select(origin.x, origin.y, newX, newY);

        grid.setDragExtent(grid.newPoint(newX, newY));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }
        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX, offsetY) {
        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent()),

            newX = mouseCorner.x + offsetX,
            newY = mouseCorner.y + offsetY,

            maxColumns = grid.getColumnCount() - 1,
            maxRows = grid.getRowCount() - 1,

            maxViewableColumns = grid.getVisibleColumnsCount() - 1,
            maxViewableRows = grid.getVisibleRowsCount() - 1;

        if (!grid.properties.scrollingEnabled) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        newX = Math.min(maxColumns, Math.max(0, newX));
        newY = Math.min(maxRows, Math.max(0, newY));

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        grid.selectCellAndScrollToMakeVisible(newX, newY);

        // if (grid.insureModelColIsVisible(newX, offsetX)) {
        //     this.pingAutoScroll();
        // }
        // if (grid.insureModelRowIsVisible(newY, offsetY)) {
        //     this.pingAutoScroll();
        // }

        grid.repaint();

    }

});

module.exports = CellSelection;

},{"./Feature":101}],95:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var ColumnAutosizing = Feature.extend('ColumnAutosizing', {

    /**
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf ColumnAutosizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        var headerRowCount = grid.getHeaderRowCount();
        //var headerColCount = grid.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (gridCell.y <= headerRowCount) {
            grid.autosizeColumn(gridCell.x);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    }

});

module.exports = ColumnAutosizing;

},{"./Feature":101}],96:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

// This feature is responsible for column drag and drop reordering.
// This object is a mess and desperately needs a complete rewrite.....

var Feature = require('./Feature');

var canDragCursorName = '-webkit-grab',
    draggingCursorName = '-webkit-grabbing';

var columnAnimationTime = 150;
var dragger;
var draggerCTX;
var floatColumn;
var floatColumnCTX;

/**
 * @constructor
 * @extends Feature
 */
var ColumnMoving = Feature.extend('ColumnMoving', {

    /**
     * queue up the animations that need to play so they are done synchronously
     * @type {Array}
     * @memberOf CellMoving.prototype
     */
    floaterAnimationQueue: [],

    /**
     * am I currently auto scrolling right
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingRight: false,

    /**
     * am I currently auto scrolling left
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingLeft: false,

    /**
     * is the drag mechanism currently enabled ("armed")
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragArmed: false,

    /**
     * am I dragging right now
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragging: false,

    /**
     * the column index of the currently dragged column
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragCol: -1,

    /**
     * an offset to position the dragged item from the cursor
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragOffset: 0,

    /**
     * @memberOf CellMoving.prototype
     * @desc give me an opportunity to initialize stuff on the grid
     * @param {Hypergrid} grid
     */
    initializeOn: function(grid) {
        this.isFloatingNow = false;
        this.initializeAnimationSupport(grid);
        if (this.next) {
            this.next.initializeOn(grid);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc initialize animation support on the grid
     * @param {Hypergrid} grid
     */
    initializeAnimationSupport: function(grid) {
        if (!dragger) {
            dragger = document.createElement('canvas');
            dragger.setAttribute('width', '0px');
            dragger.setAttribute('height', '0px');
            dragger.style.position = 'fixed';

            document.body.appendChild(dragger);
            draggerCTX = dragger.getContext('2d');
        }
        if (!floatColumn) {
            floatColumn = document.createElement('canvas');
            floatColumn.setAttribute('width', '0px');
            floatColumn.setAttribute('height', '0px');
            floatColumn.style.position = 'fixed';

            document.body.appendChild(floatColumn);
            floatColumnCTX = floatColumn.getContext('2d');
        }

    },

    /**
     * @memberOf CellMoving.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {

        var gridCell = event.gridCell;
        var x;
        //var y;

        var distance = Math.abs(event.primitiveEvent.detail.dragstart.x - event.primitiveEvent.detail.mouse.x);

        if (distance < 10 || event.isColumnFixed) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
            return;
        }

        if (event.isHeaderCell && this.dragArmed && !this.dragging) {
            this.dragging = true;
            this.dragCol = gridCell.x;
            this.dragOffset = event.mousePoint.x;
            this.detachChain();
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.createDragColumn(grid, x, this.dragCol);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }

        if (this.dragging) {
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.dragColumn(grid, x);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (
            grid.behavior.isColumnReorderable() &&
            !event.isColumnFixed
        ) {
            if (event.isHeaderCell) {
                this.dragArmed = true;
                this.cursor = draggingCursorName;
                grid.clearSelections();
            }
        }
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        //var col = event.gridCell.x;
        if (this.dragging) {
            this.cursor = null;
            //delay here to give other events a chance to be dropped
            var self = this;
            this.endDragColumn(grid);
            setTimeout(function() {
                self.attachChain();
            }, 200);
        }
        this.dragCol = -1;
        this.dragging = false;
        this.dragArmed = false;
        this.cursor = null;
        grid.repaint();

        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }

    },

    /**
     * @memberOf CellMoving.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (
            grid.behavior.isColumnReorderable() &&
            !event.isColumnFixed &&
            !this.dragging &&
            event.isHeaderCell &&
            event.mousePoint.y < grid.properties.columnGrabMargin
        ) {
            this.cursor = canDragCursorName;
        } else {
            this.cursor = null;
        }

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }

        if (event.isHeaderCell && this.dragging) {
            this.cursor = draggingCursorName; //move';
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this is the main event handler that manages the dragging of the column
     * @param {Hypergrid} grid
     * @param {boolean} draggedToTheRight - are we moving to the right
     */
    floatColumnTo: function(grid, draggedToTheRight) {
        this.floatingNow = true;

        var visibleColumns = grid.renderer.visibleColumns;
        var scrollLeft = grid.getHScrollValue();
        var floaterIndex = grid.renderOverridesCache.floater.columnIndex;
        var draggerIndex = grid.renderOverridesCache.dragger.columnIndex;
        var hdpiratio = grid.renderOverridesCache.dragger.hdpiratio;

        var draggerStartX;
        var floaterStartX;
        var fixedColumnCount = grid.getFixedColumnCount();
        var draggerWidth = grid.getColumnWidth(draggerIndex);
        var floaterWidth = grid.getColumnWidth(floaterIndex);

        var max = grid.getVisibleColumnsCount();

        var doffset = 0;
        var foffset = 0;

        if (draggerIndex >= fixedColumnCount) {
            doffset = scrollLeft;
        }
        if (floaterIndex >= fixedColumnCount) {
            foffset = scrollLeft;
        }

        if (draggedToTheRight) {
            draggerStartX = visibleColumns[Math.min(max, draggerIndex - doffset)].left;
            floaterStartX = visibleColumns[Math.min(max, floaterIndex - foffset)].left;

            grid.renderOverridesCache.dragger.startX = (draggerStartX + floaterWidth) * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;

        } else {
            floaterStartX = visibleColumns[Math.min(max, floaterIndex - foffset)].left;
            draggerStartX = floaterStartX + draggerWidth;

            grid.renderOverridesCache.dragger.startX = floaterStartX * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;
        }
        grid.swapColumns(draggerIndex, floaterIndex);
        grid.renderOverridesCache.dragger.columnIndex = floaterIndex;
        grid.renderOverridesCache.floater.columnIndex = draggerIndex;


        this.floaterAnimationQueue.unshift(this.doColumnMoveAnimation(grid, floaterStartX, draggerStartX));

        this.doFloaterAnimation(grid);

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the column drag and drop animation
     * @param {Hypergrid} grid
     * @param {number} floaterStartX - the x start coordinate of the column underneath that floats behind the dragged column
     * @param {number} draggerStartX - the x start coordinate of the dragged column
     */
    doColumnMoveAnimation: function(grid, floaterStartX, draggerStartX) {
        var self = this;
        return function() {
            var d = floatColumn;
            d.style.display = 'inline';
            self.setCrossBrowserProperty(d, 'transform', 'translate(' + floaterStartX + 'px, ' + 0 + 'px)');

            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';
            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';

            requestAnimationFrame(function() {
                self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease');
                self.setCrossBrowserProperty(d, 'transform', 'translate(' + draggerStartX + 'px, ' + -2 + 'px)');
            });
            grid.repaint();
            //need to change this to key frames

            setTimeout(function() {
                self.setCrossBrowserProperty(d, 'transition', '');
                grid.renderOverridesCache.floater = null;
                grid.repaint();
                self.doFloaterAnimation(grid);
                requestAnimationFrame(function() {
                    d.style.display = 'none';
                    self.isFloatingNow = false;
                });
            }, columnAnimationTime + 50);
        };
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the floater animation
     * @param {Hypergrid} grid
     */
    doFloaterAnimation: function(grid) {
        if (this.floaterAnimationQueue.length === 0) {
            this.floatingNow = false;
            grid.repaint();
            return;
        }
        var animation = this.floaterAnimationQueue.pop();
        animation();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the float column at columnIndex underneath the dragged column
     * @param {Hypergrid} grid
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createFloatColumn: function(grid, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = floatColumn;
        var style = d.style;
        var location = grid.div.getBoundingClientRect();

        style.top = (location.top - 2) + 'px';
        style.left = location.left + 'px';

        var hdpiRatio = grid.getHiDPI(floatColumnCTX);

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');
        style.boxShadow = '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)';
        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';
        style.borderTop = '1px solid ' + grid.properties.lineColor;
        style.backgroundColor = grid.properties.backgroundColor;

        var startX = grid.renderer.visibleColumns[columnIndex - scrollLeft].left * hdpiRatio;

        floatColumnCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.floater = {
            columnIndex: columnIndex,
            ctx: floatColumnCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        style.zIndex = '4';
        this.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -2 + 'px)');
        style.cursor = draggingCursorName;
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting cross browser css properties
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setCrossBrowserProperty: function(element, property, value) {
        var uProperty = property[0].toUpperCase() + property.substr(1);
        this.setProp(element, 'webkit' + uProperty, value);
        this.setProp(element, 'Moz' + uProperty, value);
        this.setProp(element, 'ms' + uProperty, value);
        this.setProp(element, 'O' + uProperty, value);
        this.setProp(element, property, value);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting properties on HTMLElements
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setProp: function(element, property, value) {
        if (property in element.style) {
            element.style[property] = value;
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the dragged column at columnIndex above the floated column
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createDragColumn: function(grid, x, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var hdpiRatio = grid.getHiDPI(draggerCTX);
        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = dragger;
        var location = grid.div.getBoundingClientRect();
        var style = d.style;

        style.top = location.top + 'px';
        style.left = location.left + 'px';
        style.opacity = 0.85;
        style.boxShadow = '0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22)';
        //style.zIndex = 100;
        style.borderTop = '1px solid ' + grid.properties.lineColor;
        style.backgroundColor = grid.properties.backgroundColor;

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');

        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';

        var startX = grid.renderer.visibleColumns[columnIndex - scrollLeft].left * hdpiRatio;

        draggerCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.dragger = {
            columnIndex: columnIndex,
            startIndex: columnIndex,
            ctx: draggerCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, -5px)');
        style.zIndex = '5';
        style.cursor = draggingCursorName;
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this function is the main dragging logic
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    dragColumn: function(grid, x) {

        //TODO: this function is overly complex, refactor this in to something more reasonable
        var self = this;

        var autoScrollingNow = this.columnDragAutoScrollingRight || this.columnDragAutoScrollingLeft;

        var hdpiRatio = grid.getHiDPI(draggerCTX);

        var dragColumnIndex = grid.renderOverridesCache.dragger.columnIndex;

        var minX = 0;
        var maxX = grid.renderer.getFinalVisibleColumnBoundary();
        x = Math.min(x, maxX + 15);
        x = Math.max(minX - 15, x);

        //am I at my lower bound
        var atMin = x < minX && dragColumnIndex !== 0;

        //am I at my upper bound
        var atMax = x > maxX;

        var d = dragger;

        this.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + 0 + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, ' + -10 + 'px)');
        requestAnimationFrame(function() {
            d.style.display = 'inline';
        });

        var overCol = grid.renderer.getColumnFromPixelX(x + (d.width / 2 / hdpiRatio));

        if (atMin) {
            overCol = 0;
        }

        if (atMax) {
            overCol = grid.getColumnCount() - 1;
        }

        var doAFloat = dragColumnIndex > overCol;
        doAFloat = doAFloat || (overCol - dragColumnIndex >= 1);

        if (doAFloat && !atMax && !autoScrollingNow) {
            var draggedToTheRight = dragColumnIndex < overCol;
            // if (draggedToTheRight) {
            //     overCol -= 1;
            // }
            if (this.isFloatingNow) {
                return;
            }

            this.isFloatingNow = true;
            this.createFloatColumn(grid, overCol);
            this.floatColumnTo(grid, draggedToTheRight);
        } else {

            if (x < minX - 10) {
                this.checkAutoScrollToLeft(grid, x);
            }
            if (x > minX - 10) {
                this.columnDragAutoScrollingLeft = false;
            }
            //lets check for autoscroll to right if were up against it
            if (atMax || x > maxX + 10) {
                this.checkAutoScrollToRight(grid, x);
                return;
            }
            if (x < maxX + 10) {
                this.columnDragAutoScrollingRight = false;
            }
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the right if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToRight: function(grid, x) {
        if (this.columnDragAutoScrollingRight) {
            return;
        }
        this.columnDragAutoScrollingRight = true;
        this._checkAutoScrollToRight(grid, x);
    },

    _checkAutoScrollToRight: function(grid, x) {
        if (!this.columnDragAutoScrollingRight) {
            return;
        }
        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft > (grid.sbHScroller.range.max - 2)) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.scrollBy(1, 0);
        var newIndex = draggedIndex + 1;

        grid.swapColumns(newIndex, draggedIndex);
        grid.renderOverridesCache.dragger.columnIndex = newIndex;

        setTimeout(this._checkAutoScrollToRight.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the left if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToLeft: function(grid, x) {
        if (this.columnDragAutoScrollingLeft) {
            return;
        }
        this.columnDragAutoScrollingLeft = true;
        this._checkAutoScrollToLeft(grid, x);
    },

    _checkAutoScrollToLeft: function(grid, x) {
        if (!this.columnDragAutoScrollingLeft) {
            return;
        }

        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft < 1) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.swapColumns(draggedIndex + scrollLeft, draggedIndex + scrollLeft - 1);
        grid.scrollBy(-1, 0);
        setTimeout(this._checkAutoScrollToLeft.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc a column drag has completed, update data and cleanup
     * @param {Hypergrid} grid
     */
    endDragColumn: function(grid) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        var columnIndex = grid.renderOverridesCache.dragger.columnIndex;

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var self = this;
        var startX = grid.renderer.visibleColumns[columnIndex - scrollLeft].left;
        var d = dragger;
        var changed = grid.renderOverridesCache.dragger.startIndex !== grid.renderOverridesCache.dragger.columnIndex;
        self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');
        self.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -1 + 'px)');
        d.style.boxShadow = '0px 0px 0px #888888';

        setTimeout(function() {
            grid.renderOverridesCache.dragger = null;
            grid.repaint();
            requestAnimationFrame(function() {
                d.style.display = 'none';
                grid.endDragColumnNotification(); //internal notification
                if (changed){
                    grid.fireSyntheticOnColumnsChangedEvent(); //public notification
                }
            });
        }, columnAnimationTime + 50);

    }

});

module.exports = ColumnMoving;

},{"./Feature":101}],97:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var ColumnPicker = Feature.extend('ColumnPicker', {

    /**
     * @memberOf ColumnPicker.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyUp: function(grid, event) {
        var key = event.detail.char.toLowerCase();
        var keys = grid.properties.editorActivationKeys;
        if (keys.indexOf(key) > -1) {
           grid.toggleDialog('ColumnPicker');
        }
    },

});

module.exports = ColumnPicker;

},{"./Feature":101}],98:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var ColumnResizing = Feature.extend('ColumnResizing', {

    /**
     * the index of the column wall were currently dragging
     * @type {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    dragIndex: -2,

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragIndexStartingSize: -1,

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.x;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the grid cell x,y coordinate
     * @returns {number}
     * @param {window.fin.rectangular.Point} gridCell
     */
    getGridCellValue: function(gridCell) {
        return gridCell.y;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the grids x,y scroll value
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getScrollValue: function(grid) {
        return grid.getHScrollValue();
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the width/height of the row/column of interest
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getAreaSize: function(grid, index) {
        return grid.getColumnWidth(index);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc set the width/height of the row/column at index
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     * @param {number} value - the width/height to set to
     */
    setAreaSize: function(grid, index, value) {
        grid.setColumnWidth(index, value);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the recently rendered area's width/height
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getPreviousAbsoluteSize: function(grid, index) {
        return grid.getRenderedWidth(index);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        return grid.overColumnDivider(event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc am I over the column/row area
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedOtherArea: function(grid, event) {
        return this.isFirstFixedRow(grid, event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'col-resize';
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.dragIndex > -2) {
            //var fixedAreaCount = this.getFixedAreaCount(grid);
            //var offset = this.getFixedAreaSize(grid, fixedAreaCount + areaIndex);
            var mouse = this.getMouseValue(event);
            var scrollValue = this.getScrollValue(grid);
            if (this.dragIndex < this.getFixedAreaCount(grid)) {
                scrollValue = 0;
            }
            var previous = this.getPreviousAbsoluteSize(grid, this.dragIndex - scrollValue);
            var distance = mouse - previous;
            this.setAreaSize(grid, this.dragIndex, distance);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the width/height of a specific row/column
     * @param {Hypergrid} grid
     * @param {number} areaIndex - the row/column index of interest
     */
    getSize: function(grid, areaIndex) {
        return this.getAreaSize(grid, areaIndex);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the fixed area rows/columns count
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getOtherFixedAreaCount: function(grid) {
        return grid.getFixedRowCount();
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        var overArea = this.overAreaDivider(grid, event);
        if (isEnabled && overArea > -1 && this.isFirstFixedOtherArea(grid, event)) {
            var scrollValue = this.getScrollValue(grid);
            if (overArea < this.getFixedAreaCount(grid)) {
                scrollValue = 0;
            }
            this.dragIndex = overArea - 1 + scrollValue;
            this.dragStart = this.getMouseValue(event);
            this.dragIndexStartingSize = 0;
            this.detachChain();
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        if (isEnabled && this.dragIndex > -2) {
            this.cursor = null;
            this.dragIndex = -2;

            event.primitiveEvent.stopPropagation();
            //delay here to give other events a chance to be dropped
            var self = this;
            grid.synchronizeScrollingBoundaries();
            setTimeout(function() {
                self.attachChain();
            }, 200);
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (this.dragIndex > -2) {
            return;
        }
        this.cursor = null;
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
        this.checkForAreaResizeCursorChange(grid, event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc fill this in
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    checkForAreaResizeCursorChange: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        if (isEnabled && this.overAreaDivider(grid, event) > -1 && this.isFirstFixedOtherArea(grid, event)) {
            this.cursor = this.getCursorName();
        } else {
            this.cursor = null;
        }

    },

    /**
     * @param {Hypergrid} grid
     * @returns {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    getFixedAreaCount: function(grid) {
        var count = grid.getFixedColumnCount() + (grid.isShowRowNumbers() ? 1 : 0) + (grid.hasHierarchyColumn() ? 1 : 0);
        return count;
    },

    /**
     * @param {Hypergrid} grid
     * @param event
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        var hasCursor = this.overAreaDivider(grid, event) > -1; //this.cursor !== null;
        var headerRowCount = grid.getHeaderRowCount();
        //var headerColCount = grid.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (isEnabled && hasCursor && (gridCell.y <= headerRowCount)) {
            grid.autosizeColumn(gridCell.x - 1);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @param {Hypergrid} grid
     * @returns {boolean}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    isEnabled: function(grid) {
        return true;
    }

});

module.exports = ColumnResizing;

},{"./Feature":101}],99:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * Extra msecs to avoid race condition with fincanvas's double click timer.
 * @type {number}
 * @defaultvalue 50
 * NOTE: 50 msecs seems to work well. 10 and even 25 proved insufficient in Chrome.
 * @private
 */
var RACE_TIME = 50;

/**
 * @constructor
 * @extends Feature
 */
var ColumnSelection = Feature.extend('ColumnSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    currentDrag: null,

    /**
     * The horizontal cell coordinate of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    lastDragColumn: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbAutoStart: 0,


    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    handleDoubleClick: function(grid, event) {
        if (this.doubleClickTimer) {
            clearTimeout(this.doubleClickTimer); // prevent mouseDown from continuing
            this.doubleClickTimer = undefined;
        }
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.doubleClickTimer) {
            return;
        }

        // todo: >= 5 depends on header being top-most row which is currently always true but we may allow header "section" to be arbitrary position within quadrant (see also handleMouseDown in ColumnMoving.js)
        if (
            grid.isColumnSelection() &&
            event.mousePoint.y >= 5 &&
            !event.primitiveEvent.detail.isRightClick &&
            event.isHeaderCell
        ) {
            // HOLD OFF WHILE WAITING FOR DOUBLE-CLICK
            this.doubleClickTimer = setTimeout(function() {
                this.doubleClickTimer = undefined;
                this.dragging = true;
                this.extendSelection(grid, event.gridCell.x, event.primitiveEvent.detail.keys);
            }.bind(this), grid.properties.doubleClickDelay + RACE_TIME);
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (
            grid.isColumnSelection() &&
            !this.isColumnDragging(grid) &&
            !event.primitiveEvent.detail.isRightClick &&
            this.dragging
        ) {
            //if we are in the fixed area do not apply the scroll values
            this.lastDragColumn = event.gridCell.x;
            this.currentDrag = event.primitiveEvent.detail.mouse;
            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, this.lastDragColumn, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var handler;
        if (
            grid.getLastSelectionType() === 'column' &&
            (handler = this['handle' + event.detail.char])
        ) {
            handler.call(this, grid, event.detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, x, keys) {
        var mouseX = grid.getMouseDown().x;

        grid.clearMostRecentColumnSelection();

        grid.selectColumn(mouseX, x);
        grid.setDragExtent(grid.newPoint(x - mouseX, 0));

        grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (
            grid.properties.scrollingEnabled &&
            grid.getDataBounds().contains(mouse)
        ) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else {
            if (!grid.isScrollingNow()) {
                grid.setScrollingNow(true);
                this.scrollDrag(grid);
            }
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var b = grid.getDataBounds(),
            xOffset;

        if (this.currentDrag.x < b.origin.x) {
            xOffset = -1;
        } else if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }

        if (xOffset) {
            if (this.lastDragColumn >= grid.getFixedColumnCount()) {
                this.lastDragColumn += xOffset;
            }
            grid.scrollBy(xOffset, 0);
        }

        this.handleMouseDragCellSelection(grid, this.lastDragColumn, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, x, keys) {
        if (!grid.abortEditing()) { return; }

        var mouseX = grid.getMouseDown().x,
            hasSHIFT = keys.indexOf('SHIFT') > 0;

        if (x < 0) { // outside of the grid?
            return; // do nothing
        }

        if (hasSHIFT) {
            grid.clearMostRecentColumnSelection();
            grid.selectColumn(x, mouseX);
            grid.setDragExtent(grid.newPoint(x - mouseX, 0));
        } else {
            grid.toggleSelectColumn(x, keys);
            grid.setMouseDown(grid.newPoint(x, 0));
            grid.setDragExtent(grid.newPoint(0, 0));
        }

        grid.repaint();
    },


    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {

        // var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        // var maxRows = grid.getRowCount() - 1;

        // var newX = mouseCorner.x;
        // var newY = grid.getHeaderRowCount() + grid.getVScrollValue();

        // newY = Math.min(maxRows, newY);

        // grid.clearSelections();
        // grid.select(newX, newY, 0, 0);
        // grid.setMouseDown(new grid.rectangular.Point(newX, newY));
        // grid.setDragExtent(new grid.rectangular.Point(0, 0));

        // grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var elapsed = this.getAutoScrollDuration() / 2000;
        return Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX) {
        var origin = grid.getMouseDown(),
            extent = grid.getDragExtent(),
            newX = extent.x + offsetX,
            maxViewableColumns = grid.renderer.visibleColumns.length - 1,
            maxColumns = grid.getColumnCount() - 1;

        if (!grid.properties.scrollingEnabled) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));

        grid.clearMostRecentColumnSelection();
        grid.selectColumn(origin.x, origin.x + newX);
        grid.setDragExtent(grid.newPoint(newX, 0));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX) {
        var extent = grid.getDragExtent(),
            mouseCorner = grid.getMouseDown().plus(extent),
            newX = mouseCorner.x + offsetX,
            maxColumns = grid.getColumnCount() - 1,
            maxViewableColumns = grid.getVisibleColumnsCount() - 1;

        if (!grid.properties.scrollingEnabled) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        newX = Math.min(maxColumns, Math.max(0, newX));

        grid.clearSelections();
        grid.selectColumn(newX);
        grid.setMouseDown(grid.newPoint(newX, 0));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelColIsVisible(newX, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();
    },

    isColumnDragging: function(grid) {
        var dragger = grid.lookupFeature('ColumnMoving');
        return dragger && dragger.dragging && !this.dragging;
    }

});

module.exports = ColumnSelection;

},{"./Feature":101}],100:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 * @extends Feature
 */
var ColumnSorting = Feature.extend('ColumnSorting', {

    /**
     * @memberOf ColumnSorting.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */

    handleDoubleClick: function(grid, event) {
        var columnProperties;
        if (
            event.isHeaderCell &&
            (columnProperties = grid.behavior.getColumnProperties(event.gridCell.x)) &&
            !columnProperties.unsortable
        ) {
            grid.fireSyntheticColumnSortEvent(event.gridCell.x, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSorting.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        var columnProperties;
        if (
            event.isRowFixed &&
            event.isHeaderCell &&
            (columnProperties = grid.behavior.getColumnProperties(event.gridCell.x)) &&
            !columnProperties.unsortable
        ) {
            this.cursor = 'pointer';
        } else {
            this.cursor = null;
        }
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    }

});

module.exports = ColumnSorting;

},{"./Feature":101}],101:[function(require,module,exports){
'use strict';

var Base = require('../Base');

var warned = {};

/**
 * Instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
 * @constructor
 */
var Feature = Base.extend('Feature', {

    /**
     * the next feature to be given a chance to handle incoming events
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    next: null,

    /**
     * a temporary holding field for my next feature when I'm in a disconnected state
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    detached: null,

    /**
     * the cursor I want to be displayed
     * @type {string}
     * @default null
     * @memberOf Feature.prototype
     */
    cursor: null,

    /**
     * the cell location where the cursor is currently
     * @type {Point}
     * @default null
     * @memberOf Feature.prototype
     */
    currentHoverCell: null,

    /**
     * @memberOf Feature.prototype
     * @desc set my next field, or if it's populated delegate to the feature in my next field
     * @param {Feature} nextFeature - this is how we build the chain of responsibility
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    setNext: function(nextFeature) {
        if (this.next) {
            this.next.setNext(nextFeature);
        } else {
            this.next = nextFeature;
            this.detached = nextFeature;
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc disconnect my child
     */
    detachChain: function() {
        this.next = null;
    },

    /**
     * @memberOf Feature.prototype
     * @desc reattach my child from the detached reference
     */
    attachChain: function() {
        this.next = this.detached;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle mouse move down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseMove: function(grid, event) {
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseExit: function(grid, event) {
        if (this.next) {
            this.next.handleMouseExit(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseEnter: function(grid, event) {
        if (this.next) {
            this.next.handleMouseEnter(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseDown: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseUp: function(grid, event) {
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleKeyDown: function(grid, event) {
        if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleKeyUp: function(grid, event) {
        if (this.next) {
            this.next.handleKeyUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleWheelMoved: function(grid, event) {
        if (this.next) {
            this.next.handleWheelMoved(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleDoubleClick: function(grid, event) {
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleClick: function(grid, event) {
        if (this.next) {
            this.next.handleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleMouseDrag: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    handleContextMenu: function(grid, event) {
        if (this.next) {
            this.next.handleContextMenu(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc toggle the column picker
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    moveSingleSelect: function(grid, x, y) {
        if (this.next) {
            this.next.moveSingleSelect(grid, x, y);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedRow: function(grid, event) {
        if (!warned.isFixedRow) {
            warned.isFixedRow = true;
            console.warn('isFixedRow(grid, event) has been deprecated as of v1.2.0 in favor of event.isRowFixed and will be removed in a future version.');
        }
        return event.isRowFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedRow: function(grid, event) {
        return event.gridCell.y < 1;
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedColumn: function(grid, event) {
        if (!warned.isFixedColumn) {
            warned.isFixedColumn = true;
            console.warn('isFixedColumn(grid, event) has been deprecated as of v1.2.0 in favor of event.isColumnFixed and will be removed in a future version.');
        }
        return event.isColumnFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedColumn: function(grid, event) {
        return event.gridCell.x === 0;
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isTopLeft: function(grid, event) {
        if (!warned.isTopLeft) {
            warned.isTopLeft = true;
            console.warn('isTopLeft(grid, event) has been deprecated as of v1.2.0 in favor of event.isCellFixed and will be removed in a future version.');
        }
        return event.isCellFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    setCursor: function(grid) {
        if (this.next) {
            this.next.setCursor(grid);
        }
        if (this.cursor) {
            grid.beCursor(this.cursor);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @private Not really private but was cluttering up all the feature doc pages.
     */
    initializeOn: function(grid) {
        if (this.next) {
            this.next.initializeOn(grid);
        }
    }

});

module.exports = Feature;

},{"../Base":49}],102:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 */
var Filters = Feature.extend('Filters', {

    handleDoubleClick: function(grid, event) {
        if (event.isFilterCell) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    handleClick: function(grid, event) {
        if (event.isFilterCell) {
            grid.onEditorActivate(event);
        } else if (this.next) {
            this.next.handleClick(grid, event);
        }
    }

});

module.exports = Filters;

},{"./Feature":101}],103:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

var commands = {
    PAGEDOWN: function(grid) { grid.pageDown(); },
    PAGEUP: function(grid) { grid.pageUp(); },
    PAGELEFT: function(grid) { grid.pageLeft(); },
    PAGERIGHT: function(grid) { grid.pageRight(); }
};

/**
 * @constructor
 */
var KeyPaging = Feature.extend('KeyPaging', {

    /**
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function(grid, event) {
        var func = commands[event.detail.char];
        if (func) {
            func(grid);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

module.exports = KeyPaging;

},{"./Feature":101}],104:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 */
var OnHover = Feature.extend('OnHover', {

    /**
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf OnHover.prototype
     */
    handleMouseMove: function(grid, event) {
        var hoverCell = grid.hoverCell;
        if (!event.gridCell.equals(hoverCell)) {
            if (hoverCell) {
                this.handleMouseExit(grid, hoverCell);
            }
            this.handleMouseEnter(grid, event);
            grid.setHoverCell(event.gridCell);
        } else if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    }

});

module.exports = OnHover;

},{"./Feature":101}],105:[function(require,module,exports){
'use strict';

var ColumnResizing = require('./ColumnResizing');

/**
 * @constructor
 * @extends ColumnResizing
 */
var RowResizing = ColumnResizing.extend('RowResizing', {

    /**
     * the index of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragArea: -1,

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragAreaStartingSize: -1,

    /**
     * @memberOf RowResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.y;
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc get the grid cell x,y coordinate
     * @returns {number}
     * @param {Point} gridCell
     */
    getGridCellValue: function(gridCell) {
        return gridCell.x;
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the grids x,y scroll value
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getScrollValue: function(grid) {
        return grid.getVScrollValue();
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the width/height of the row/column of interest
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getAreaSize: function(grid, index) {
        return grid.getRowHeight(index);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc set the width/height of the row/column at index
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     * @param {number} value - the width/height to set to
     */
    setAreaSize: function(grid, index, value) {
        grid.setRowHeight(index, value);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        return grid.overRowDivider(event);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc am I over the column/row area
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedOtherArea: function(grid, event) {
        return this.isFirstFixedColumn(grid, event);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'row-resize';
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the recently rendered area's width/height
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getPreviousAbsoluteSize: function(grid, index) {
        return grid.getRenderedHeight(index);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the fixed area rows/columns count
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getOtherFixedAreaCount: function(grid) {
        return grid.getFixedColumnCount();
    },

    /**
     *
     * @param {Hypergrid} grid
     * @returns {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    getFixedAreaCount: function(grid) {
        return grid.getFixedRowCount() + grid.getHeaderRowCount();
    },

    /**
     *
     * @param {Hypergrid} grid
     * @returns {boolean}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    isEnabled: function(grid) {
        return grid.isRowResizeable();
    }

});

module.exports = RowResizing;

},{"./ColumnResizing":98}],106:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 */
var RowSelection = Feature.extend('RowSelection', {

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {Point}
     * @default null
     * @memberOf RowSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf RowSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbAutoStart: 0,

    dragArmed: false,

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragArmed) {
            this.dragArmed = false;
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.dragging) {
            this.dragging = false;
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var rowSelectable = grid.isRowSelection() &&
            !event.primitiveEvent.detail.isRightClick &&
            grid.isShowRowNumbers() &&
            event.isHandleColumn;

        if (rowSelectable && event.isHeaderHandle) {
            //global row selection
            grid.toggleSelectAllRows();
        } else if (rowSelectable && event.isGridRow)  {
            // if we are in the fixed area, do not apply the scroll values
            this.dragArmed = true;
            this.extendSelection(grid, event.dataCell.y, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (
            this.dragArmed &&
            grid.isRowSelection() &&
            !event.primitiveEvent.detail.isRightClick
        ) {
            //if we are in the fixed area do not apply the scroll values
            this.lastDragRow = event.dataCell.y;
            this.dragging = true;
            this.currentDrag = event.primitiveEvent.detail.mouse;
            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, this.lastDragRow, event.primitiveEvent.detail.keys);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var handler;
        if (
            grid.getLastSelectionType() === 'row' &&
            (handler = this['handle' + event.detail.char])
        ) {
            handler.call(this, grid, event.detail);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, y, keys) {
        var mouseY = grid.getMouseDown().y;

        grid.clearMostRecentRowSelection();

        grid.selectRow(mouseY, y);
        grid.setDragExtent(grid.newPoint(0, y - mouseY));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (
            grid.properties.scrollingEnabled &&
            grid.getDataBounds().contains(mouse)
        ) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else {
            if (!grid.isScrollingNow()) {
                grid.setScrollingNow(true);
                this.scrollDrag(grid);
            }
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var b = grid.getDataBounds(),
            yOffset;

        if (this.currentDrag.y < b.origin.y) {
            yOffset = -1;
        } else if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        if (yOffset) {
            if (this.lastDragRow >= grid.getFixedRowCount()) {
                this.lastDragRow += yOffset;
            }
            grid.scrollBy(0, yOffset);
        }

        this.handleMouseDragCellSelection(grid, this.lastDragRow, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, y, keys) {
        if (!grid.abortEditing()) { return; }

        var mouseY = grid.getMouseDown().y,
            hasSHIFT = keys.indexOf('SHIFT') > 0;

        if (y < 0) { // outside of the grid?
            return; // do nothing
        }

        if (hasSHIFT) {
            grid.clearMostRecentRowSelection();
            grid.selectRow(y, mouseY);
            grid.setDragExtent(grid.newPoint(0, y - mouseY));
        } else {
            grid.toggleSelectRow(y, keys);
            grid.setMouseDown(grid.newPoint(0, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }

        grid.repaint();
    },


    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent()),
            maxColumns = grid.getColumnCount() - 1,
            newX = grid.getHScrollValue(),
            newY = mouseCorner.y;

        newX = Math.min(maxColumns, newX);

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetY) {
        var origin = grid.getMouseDown(),
            extent = grid.getDragExtent(),
            maxViewableRows = grid.renderer.visibleRows.length - 1,
            maxRows = grid.getRowCount() - 1;

        if (!grid.properties.scrollingEnabled) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var newY = extent.y + offsetY;

        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentRowSelection();
        grid.selectRow(origin.y, origin.y + newY);
        grid.setDragExtent(grid.newPoint(0, newY));

        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetY) {
        var maxRows = grid.getRowCount() - 1,
            maxViewableRows = grid.getVisibleRowsCount() - 1,
            mouseCorner = grid.getMouseDown().plus(grid.getDragExtent()),
            newY = mouseCorner.y + offsetY;

        if (!grid.properties.scrollingEnabled) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        newY = Math.min(maxRows, Math.max(0, newY));

        grid.clearSelections();
        grid.selectRow(newY);
        grid.setMouseDown(grid.newPoint(0, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelRowIsVisible(newY, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();
    },

    isSingleRowSelection: function() {
        return true;
    }

});

module.exports = RowSelection;

},{"./Feature":101}],107:[function(require,module,exports){
'use strict';

var Feature = require('./Feature');

/**
 * @constructor
 */
var ThumbwheelScrolling = Feature.extend('ThumbwheelScrolling', {

    /**
     * @memberOf ThumbwheelScrolling.prototype
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function(grid, e) {
        if (!grid.properties.scrollingEnabled) {
            return;
        }

        var primEvent = e.primitiveEvent,
            deltaX = Math.sign(primEvent.wheelDeltaX || -primEvent.deltaX),
            deltaY = Math.sign(primEvent.wheelDeltaY || -primEvent.deltaY);

        if (deltaX || deltaY) {
            grid.scrollBy(
                -deltaX || 0, // 0 if NaN
                -deltaY || 0
            );
        }
    }

});


module.exports = ThumbwheelScrolling;

},{"./Feature":101}],108:[function(require,module,exports){
'use strict';

module.exports = {
    Feature: require('./Feature'), // abstract base class
    CellClick: require('./CellClick'),
    CellEditing: require('./CellEditing'),
    CellSelection: require('./CellSelection'),
    ColumnAutosizing: require('./ColumnAutosizing'),
    ColumnMoving: require('./ColumnMoving'),
    ColumnResizing: require('./ColumnResizing'),
    ColumnSelection: require('./ColumnSelection'),
    ColumnSorting: require('./ColumnSorting'),
    Filters: require('./Filters'),
    KeyPaging: require('./KeyPaging'),
    OnHover: require('./OnHover'),
    ColumnPicker: require('./ColumnPicker'),
    RowResizing: require('./RowResizing'),
    RowSelection: require('./RowSelection'),
    ThumbwheelScrolling: require('./ThumbwheelScrolling')
};

},{"./CellClick":92,"./CellEditing":93,"./CellSelection":94,"./ColumnAutosizing":95,"./ColumnMoving":96,"./ColumnPicker":97,"./ColumnResizing":98,"./ColumnSelection":99,"./ColumnSorting":100,"./Feature":101,"./Filters":102,"./KeyPaging":103,"./OnHover":104,"./RowResizing":105,"./RowSelection":106,"./ThumbwheelScrolling":107}],109:[function(require,module,exports){
/* eslint-env browser */

'use strict';

/**
 *
 * @param {HTMLElement} [containingEl=document]
 * @param {string} [prefix='']
 * @param {string} [separator='']
 * @param {string} [suffix='']
 * @param {function} [transformer=multiLineTrim] - Function to transform each input control's text value.
 */
function copyAll(containingEl, prefix, separator, suffix, transformer) {
    var texts = [], lastTextEl, text;

    Array.prototype.forEach.call((containingEl || document).querySelectorAll(copyAll.selector), function(textEl) {
        text = (transformer || multiLineTrim)(textEl.value);
        if (text) { texts.push(text); }
        lastTextEl = textEl;
    });

    if (lastTextEl) {
        copy(lastTextEl, (prefix || '') + texts.join(separator || '') + (suffix || ''));
    }
}

/**
 * 1. Trim the text in the given input element
 * 2. select it
 * 3. copy it to the clipboard
 * 4. deselect it
 * 5. return it
 * @param {HTMLElement|HTMLTextAreaElement} el
 * @param {string} [text=el.value] - Text to copy.
 * @returns {undefined|string} Trimmed text in element or undefined if unable to copy.
 */
function copy(el, text) {
    var result, textWas;

    if (text) {
        textWas = el.value;
        el.value = text;
    } else {
        text = el.value;
    }

    el.value = multiLineTrim(text);

    try {
        el.select();
        result = document.execCommand('copy');
    } catch (err) {
        result = false;
    } finally {
        if (textWas !== undefined) {
            el.value = textWas;
        }
        el.blur();
    }
    return result;
}

function multiLineTrim(s) {
    return s.replace(/^\s*(.*?)\s*$/, '$1');
}

copy.all = copyAll;
copy.multiLineTrim = multiLineTrim;
copy.selectorTextControls = 'input:not([type]), input[type=text], textarea';

module.exports = copy;

},{}],110:[function(require,module,exports){
/* eslint-env browser */

/** @module effects */

/** @typedef {function} effectFunction
 * @desc Element to perform transitions upon is `options.el` if defined or `this.el`.
 * @param {object} [options]
 * @param {HTMLElement} [options.el=this.el]
 * @param {function} [options.callback] Function to call at conclusion of transitions.
 * @param {string} [options.duration='0.065s'] - Duration of each transition.
 * @param {object} [options.styles=defaultGlowerStyles] - Hash of CSS styles and values to transition. (For {@link effects~glower|glower} only.
 */

'use strict';

/**
 * Shake element back and fourth a few times as if to say, "Nope!"
 * @type {effectFunction}
 * @memberOf module:effects
 */
exports.shaker = function(options) {
    options = options || {};
    var context = this,
        el = options.el || context.el,
        duration = options.duration || '0.065s',
        computedStyle = window.getComputedStyle(el),
        transitions = computedStyle.transition.split(','),
        position = computedStyle.position,
        x = parseInt(computedStyle.left),
        dx = -3,
        shakes = 6;

    transitions.push('left ' + duration);
    el.style.transition = transitions.join(',');
    el.addEventListener('transitionend', shaker);
    shaker();
    function shaker(event) {
        if (!event || event.propertyName === 'left') {
            el.style.left = x + dx + 'px';
            if (!shakes--) {
                el.removeEventListener('transitionend', shaker);
                transitions.pop();
                el.style.transition = transitions.join(',');
                el.style.position = position;
                if (options.callback) {
                    options.callback.call(context, options);
                }
            }
            dx = shakes ? -dx : 0;
        }
    }
};

var defaultGlowerStyles = {
    'background-color': 'yellow',
    'box-shadow': '0 0 10px red'
};

/**
 * Transition styles on element for a moment and revert as if to say, "Whoa!."
 * @type {effectFunction}
 * @memberOf module:effects
 */
exports.glower = function(options) {
    options = options || {};
    var context = this,
        el = options.el || context.el,
        duration = options.duration || '0.25s',
        styles = options.styles || defaultGlowerStyles,
        values = styles.length,
        computedStyle = window.getComputedStyle(el),
        styleWas = {},
        transition = computedStyle.transition,
        transitions = transition.split(',');

    Object.keys(styles).forEach(function(style) {
        styleWas[style] = {
            style: computedStyle[style],
            undo: true
        };
        transitions.push(style + ' ' + duration);
    });

    el.style.transition = transitions.join(',');
    el.addEventListener('transitionend', glower);
    Object.keys(styles).forEach(function(style) {
        el.style[style] = styles[style];
    });

    function glower(event) {
        var was = styleWas[event.propertyName];
        if (was.undo) {
            el.style[event.propertyName] = was.style;
            was.undo = false;
        } else if (!--values) {
            el.removeEventListener('transitionend', glower);
            el.style.transition = transition;
            if (options.callback) {
                options.callback.call(context, options);
            }
        }
    }
};

},{}],111:[function(require,module,exports){
/* eslint-env browser */

'use strict';

module.exports.each = function(selector, iteratee, context) {
    return Array.prototype.forEach.call((context || document).querySelectorAll(selector), iteratee);
};

module.exports.find = function(selector, iteratee, context) {
    return Array.prototype.find.call((context || document).querySelectorAll(selector), iteratee);
};

},{}],112:[function(require,module,exports){
'use strict';

function Queueless(element, context) {
    this.element = element;
    this.context = context;
    this.transitioning = false;
}

Queueless.prototype.begin = function(callback) {
    var self = this;

    this.transitioning = true;

    this.element.addEventListener('transitionend', function end(transEvent) {
        self.element.removeEventListener('transitionend', end);

        if (callback) {
            callback.call(this, transEvent, self);
        }

        self.transitioning = false;
    });
};

module.exports = Queueless;

},{}],113:[function(require,module,exports){
/* eslint-env browser */

/**
 * @module localization
 */

'use strict';

var Base = require('../Base');
var deprecated = require('./deprecated');


/**
 * @param {string} defaultLocale
 * @param {string} [locale=defaultlocale]
 * @param {object} [options]
 * @constructor
 */
var Formatter = Base.extend({
    initialize: function(defaultLocale, locale, options) {
        if (typeof locale === 'object') {
            options = locale;
            locale = defaultLocale;
        }

        this.locale = locale;

        if (options) {
            if (typeof options.invalid === 'function') {
                this.invalid = options.invalid;
            }

            if (options.expectation) {
                this.expectation = options.expectation;
            }
        }
    }
});


// Safari has no Intl implementation
if (!window.Intl) {
    window.Intl = {
        NumberFormat: function(locale, options) {
            var digits = '0123456789';
            this.format = function(n) {
                var s = n.toString();
                if (!options || options.useGrouping === undefined || options.useGrouping) {
                    var dp = s.indexOf('.');
                    if (dp < 0) {
                        dp = s.length;
                    }
                    while ((dp -= 3) > 0 && digits.indexOf(s[dp - 1]) >= 0) {
                        s = s.substr(0, dp) + ',' + s.substr(dp);
                    }
                }
                return s;
            };
        },
        DateTimeFormat: function(locale, options) {
            this.format = function(date) {
                if (date != null) {
                    if (typeof date !== 'object') {
                        date = new Date(date);
                    }
                    date = date.getMonth() + 1 + '-' + date.getDate() + '-' + date.getFullYear();
                } else {
                    date = null;
                }
                return date;
            };
        }
    };
}


/**
 * @summary Create a number localizer.
 * @implements localizerInterface
 * @desc Create an object conforming to {@link localizerInterface} for numbers, using {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat|Intl.NumberFormat}.
 * @param {string} defaultLocale
 * @param {string} [locale=defaultLocale] - Passed to the {@link Intl.NumberFormat|https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat} constructor.
 * @param {object} [options] - Passed to the `Intl.NumberFormat` constructor.
 * @param {boolean} [options.acceptStandardDigits=false] - Accept standard digits and decimal point interchangeably with localized digits and decimal point. (This option is interpreted here; it is not used by `Intl.NumberFormat`.)
 * @constructor
 * @extends Formatter
 * @tutorial localization
 */
var NumberFormatter = Formatter.extend('NumberFormatter', {
    initialize: function(defaultLocale, locale, options) {
        if (typeof locale === 'object') {
            options = locale;
        }

        options = options || {};

        this.format = new Intl.NumberFormat(this.locale, options).format;

        var mapperOptions = { useGrouping: false },
            mapper = new Intl.NumberFormat(this.locale, mapperOptions).format;

        this.demapper = demap.bind(this);

        /**
         * @summary A string containing the valid characters.
         * @desc Contains all localized digits + localized decimal point.
         * If we're accepting standard digits, will also contain all the standard digits + standard decimal point (if different than localized versions).
         * @type {string}
         * @private
         * @desc Localized digits and decimal point. Will also include standardized digits and decimal point if `options.acceptStandardDigits` is truthy.
         *
         * For internal use by the {@link NumberFormatter#parse|parse} method.
         * @memberOf NumberFormatter.prototype
         */
        this.map = mapper(10123456789.5).substr(1, 11); // localized '0123456789.'

        if (options.acceptStandardDigits && this.map !== '0123456789.') {
            this.map += '0123456789.';  // standard '0123456789.'
        }

        /** @summary A regex that tests `true` on first invalid character.
         * @type {RegExp}
         * @private
         * @desc Valid characters include:
         *
         * * Localized digits
         * * Localized decimal point
         * * Standard digits (when `options.acceptStandardDigits` is truthy)
         * * Standard decimal point (when `options.acceptStandardDigits` is truthy)
         * * Cosmetic characters added by formatter as per `options` (for human-friendly readability).
         *
         * Any characters outside this set are considered invalid.
         *
         * Set by the constructor; consumed by the {@link module:localization~NumberFormatter#invalid|invalid} method.
         *
         * Testing a string against this pattern yields `true` if at least one invalid character or `false` if all characters are valid.
         * @memberOf NumberFormatter.prototype
         */
        this.invalids = new RegExp(
            '[^' +
            this.format(11111).replace(this.map[1], '') + // thousands separator if in use
            this.map + // digits + decimal point
            ']'
        );
    },

    /** @summary Tests for invalid characters.
     * @desc Tests a localized string representation of a number that it contains any invalid characters.
     *
     * The number may be unformatted or it may be formatted with any of the permitted formatting characters, as implied by the constructor's `options` (passed to `Intl.NumberFormat`). Any other characters are considered invalid.
     *
     * However, standard digits and the standard decimal point are considered valid if the value of `options.acceptStandardDigits` as provided to the constructor was truthy. (Of course, these are always valid for locales that use them.)
     *
     * Use this method to:
     * 1. Filter out invalid characters on a `onkeydown` event; or
     * 2. Test an edited string prior to calling the {@link module:localization~NumberFormatter#parse|parse}.
     *
     * NOTE: This method does not check grammatical syntax; it only checks for invalid characters.
     *
     * @param number
     * @returns {boolean|string} Falsy means valid which in this case means contains only valid characters.
     * @memberOf NumberFormatter.prototype
     */
    invalid: function(number) {
        return this.invalids.test(number);
    },

    expectation:
        'Expected a number with optional commas (thousands grouping separator), optional decimal point, and an optional fractional part.\n' +
        'Comma separators are part of the format and will always be displayed for values >= 1000.\n' +
        'Edited values are always saved in their entirety even though the formatted value is rounded to the specified number of decimal places.',

    /**
     * This method will:
     * * Convert localized digits and decimal point characters to standard digits and decimal point characters.
     * * "Clean" the string by ignoring all other characters.
     * * Coerce the string to a number primitive.
     * @param {string} formattedLocalizedNumber - May or may not be formatted.
     * @returns {number} Number primitive.
     * @throws {string} Invalid number.
     * @memberOf NumberFormatter.prototype
     */
    parse: function(formattedLocalizedNumber) {
        var number = Number(
            formattedLocalizedNumber.split('').map(this.demapper).join('')
        );

        if (isNaN(number)) {
            throw 'Invalid Number';
        }

        return number;
    }
});

function demap(c) {
    var d = this.map.indexOf(c) % 11;
    return d < 0 ? '' : d < 10 ? d : '.';
}

/**
 * @implements localizerInterface
 * @param {string} defaultLocale
 * @param {string} [locale=defaultlocale] - Passed to the {@link Intl.DateFormat|https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateFormat} constructor.
 * @param {object} [options] - Passed to the `Intl.DateFormat` constructor.
 * @constructor
 * @extends Formatter
 */
var DateFormatter = Formatter.extend('DateFormatter', {
    initialize: function(defaultLocale, locale, options) {
        if (typeof locale === 'object') {
            options = locale;
        }

        options = options || {};

        /** @summary Transform a date object into human-friendly string representation.
         * @method
         */
        this.format = new Intl.DateTimeFormat(this.locale, options).format;

        // Get digits because may be chinese or "real Arabic" numerals.
        var testOptions = { useGrouping: false, style: 'decimal' },
            localizeNumber = new Intl.NumberFormat(this.locale, testOptions).format,
            localizedDigits = this.localizedDigits = localizeNumber(10123456789).substr(1, 10); // all localized digits in numerical order

        this.digitFormatter = formatDigit.bind(this);
        this.digitParser = parseDigit.bind(this);

        // Localize a test date with the default numeric parts to find out the resulting order of these parts.
        var yy = 1987,
            mm = 12,
            dd = 30,
            YY = this.transformNumber(this.digitFormatter, yy),
            MM = this.transformNumber(this.digitFormatter, mm),
            DD = this.transformNumber(this.digitFormatter, dd),
            testDate = new Date(yy, mm - 1, dd),
            localizeDate = new Intl.DateTimeFormat(this.locale).format,
            localizedDate = localizeDate(testDate), // all localized digits + localized punctuation
            missingDigits = new Intl.NumberFormat(this.locale).format(456),
            localizedNumberPattern = this.localizedNumberPattern = new RegExp('[' + localizedDigits + ']+', 'g'),
            parts = localizedDate.match(localizedNumberPattern);

        this.partsMap = {
            yy: parts.indexOf(YY),
            mm: parts.indexOf(MM),
            dd: parts.indexOf(DD)
        };

        if (options.acceptStandardDigits) {
            missingDigits += '1234567890';
        }

        /** @summary A regex that tests `true` on first invalid character.
         * @type {RegExp}
         * @private
         * @desc Valid characters include:
         *
         * * Localized digits
         * * Standard digits (when `options.acceptStandardDigits` is truthy)
         * * Localized punctuation to delimit date parts
         *
         * Any characters outside this set are considered invalid. Note that this only currently implemented when all three date parts are numeric
         *
         * Set by the constructor; consumed by the {@link NumberFormatter#valid|valid} method.
         *
         * Testing a string against this pattern yields `true` if at least one invalid character or `false` if all characters are valid.
         * @memberOf DateFormatter.prototype
         */
        this.invalids = new RegExp(
            '[^' +
            localizedDate.replace(/-/g, '\\-') +
            missingDigits +
            ']'
        );
    },

    /** @summary Tests for invalid characters.
     * @desc Tests a localized string representation of a number that it contains any invalid characters.
     *
     * The date is assumed to contain localized digits and punctuation as would be returned by `Intl.DateFormat` with the given `locale` and `options`. Any other characters are considered invalid.
     *
     * However, standard digits and the standard decimal point are also considered valid if the value of `options.acceptStandardDigits` as provided to the constructor was truthy. (Of course, these are always valid for locales that use them.)
     *
     * Use this method to:
     * 1. Filter out invalid characters on a `onkeydown` event; or
     * 2. Test an edited string prior to calling the {@link module:localization~DateFormatter#parse|parse}.
     *
     * NOTE: The current implementation only supports date formats using all numerics (which is the default for `Intl.DateFormat`).
     *
     * NOTE: This method does not check grammatical syntax; it only checks for invalid characters.
     *
     * @param number
     * @returns {boolean} Contains only valid characters.
     * @memberOf DateFormatter.prototype
     */
    invalid: function(number) {
        return this.invalids.test(number);
    },

    /**
     * This method will:
     * * Convert localized date to Date object.
     * * "Clean" the string by ignoring all other characters.
     * * Coerce the string to a number primitive.
     * @param {string} localizedDate
     * @returns {Date}
     * @throws {string} Invalid date.
     * @memberOf DateFormatter.prototype
     */
    parse: function(localizedDate) {
        var date,
            parts = localizedDate.match(this.localizedNumberPattern);

        if (parts && parts.length === 3) {
            var y = this.transformNumber(this.digitParser, parts[this.partsMap.yy]),
                m = this.transformNumber(this.digitParser, parts[this.partsMap.mm]) - 1,
                d = this.transformNumber(this.digitParser, parts[this.partsMap.dd]);

            date = new Date(y, m, d);
        } else {
            throw 'Invalid Date';
        }

        return date;
    },

    /**
     * Transform a number to or from a string representation with localized digits.
     * @param {function} digitTransformer - A function bound to `this`.
     * @param {number} number
     * @returns {string}
     * @private
     * @memberOf DateFormatter.prototype
     */
    transformNumber: function(digitTransformer, number) {
        return number.toString().split('').map(digitTransformer).join('');
    }
});

function formatDigit(d) {
    return this.localizedDigits[d];
}

function parseDigit(c) {
    var d = this.localizedDigits.indexOf(c);
    if (d < 0) { d = ''; }
    return d;
}

/**
 * All members are localizers (conform to {@link localizerInterface}) with exception of `get`, `set`, and localizer constructors which are named (by convention) ending in "Formmatter".
 *
 * The application developer is free to add localizers and localizer factory methods. See the {@link Localization#construct|construct} convenience method which may be helpful in this regard.
 * @param locale
 * @param {object} [numberOptions]
 * @param {object} [dateOptions]
 * @constructor
 */
function Localization(locale, numberOptions, dateOptions) {
    this.locale = locale;

    /**
     * @name number
     * @see The {@link NumberFormatter|NumberFormatter} class
     * @memberOf Localization.prototype
     */
    this.int = this.float = this.construct('number', NumberFormatter, numberOptions);

    /**
     * @see The {@link DateFormatter|DateFormatter} class
     * @memberOf Localization.prototype
     */
    this.construct('date', DateFormatter, dateOptions);
}

Localization.prototype = {
    constructor: Localization.prototype.constructor,

    /** @summary Creates a localizer from a localizer factory object using the default locale.
     * @desc Performs the following actions:
     * 1. Binds `Constructor` to `locale`.
     * 2. Adds the newly bound constructor to this object (for future reference) with the key "NameFormatter" (where "Name" is the localizer name, all lower case but with an initial capital).
     * 3. Uses the newly bound constructor to create a new localized localizer with the provided options.
     * 4. Adds new localizer to this object via {@link Localization#add|add}.
     *
     * @param {string} localizerName
     * @param {Constructor
     * @param {object} {factoryOptions}
     * @returns {localizeInerface} The new localizer.
     */
    construct: function(localizerName, Constructor, factoryOptions) {
        var constructorName = localizerName[0].toUpperCase() + localizerName.substr(1).toLowerCase() + 'Formatter',
            BoundConstructor = Constructor.bind(null, this.locale),
            localizer = new BoundConstructor(factoryOptions);

        this[constructorName] = BoundConstructor;

        return this.add(localizerName, localizer);
    },

    /** @summary Register a localizer.
     * @desc Checks the provided localizer that it conforms to {@link localizerInterface}
     * and adds it to the object using localizerName all lower case as the key.
     * @param {string} name
     * @param {localizerInterface} localizer
     * @memberOf Localization.prototype
     * @returns {localizeInerface} The provided localizer.
     */
    add: function(name, localizer) {
        if (typeof name === 'object') {
            localizer = name;
            name = undefined;
        }

        if (
            typeof localizer !== 'object' ||
            typeof localizer.format !== 'function' ||
            typeof localizer.parse !== 'function' ||
            localizer.invalid && typeof localizer.invalid !== 'function' ||
            localizer.expectation && typeof localizer.expectation !== 'string'
        ) {
            throw 'Expected localizer object to conform to interface.';
        }

        name = name || localizer.name;
        name = name && name.toLowerCase();
        this[name] = localizer;

        return localizer;
    },
    deprecated: deprecated,
    set: function(name) {
        return this.deprecated('set(name, localizer)', 'add(name, localizer)', '1.0.6', arguments);
    },

    /**
     *
     * @param localizerName
     * @returns {localizerInterface}
     * @memberOf Localization.prototype
     */
    get: function(name) {
        return this[name && name.toLowerCase()] || this.string;
    },

    ///  ///  ///  ///  ///    LOCALIZERS    ///  ///  ///  ///  ///

    // Special localizer for use by Chrome's date input control.
    chromeDate: {
        format: function(date) {
            if (date != null) {
                if (typeof date !== 'object') {
                    date = new Date(date);
                }

                var yy = date.getFullYear(),
                    m = date.getMonth() + 1, mm = m < 10 ? '0' + m : m,
                    d = date.getDate(), dd = d < 10 ? '0' + d : d;

                date = yy + '-' + mm + '-' + dd;
            } else {
                date = null;
            }
            return date;
        },
        parse: function(str) {
            var date,
                parts = str.split('-');
            if (parts && parts.length === 3) {
                date = new Date(parts[0], parts[1] - 1, parts[2]);
            } else {
                date = null;
            }
            return date;
        }
    },

    null: {
        format: function(value) {
            return value;
        },
        parse: function(str) {
            return str;
        }
    },

    string: {
        format: function(value) {
            return value + '';
        },
        parse: function(str) {
            return str + '';
        }
    }
};

module.exports = Localization;

},{"../Base":49,"./deprecated":117}],114:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var _ = require('object-iterators');

var Base = require('../Base');
var images = require('../../images');

/** @typedef {object} CanvasRenderingContext2D
 * @see [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
 */

/** @typedef {object} visibleColumnDescriptor
 * @property {number} index - A back reference to the element's array index in {@link Renderer#visibleColumns}.
 * @property {number} columnIndex - Dereferences {@link Behavior#columns}, the subset of _active_ columns, specifying which column to show in that position.
 * @property {number} left - Pixel coordinate of the left edge of this column, rounded to nearest integer.
 * @property {number} right - Pixel coordinate of the right edge of this column, rounded to nearest integer.
 * @property {number} width - Width of this column in pixels, rounded to nearest integer.
 */

/** @typedef {object} visibleRowDescriptor
 * @property {number} index - A back reference to the element's array index in {@link Renderer#visibleRows}.
 * @property {number} rowIndex - Local vertical row coordinate within the subgrid to which the row belongs, adjusted for scrolling.
 * @property {DataModel} subgrid - A reference to the subgrid to which the row belongs.
 * @property {number} top - Pixel coordinate of the top edge of this row, rounded to nearest integer.
 * @property {number} bottom - Pixel coordinate of the bottom edge of this row, rounded to nearest integer.
 * @property {number} height - Height of this row in pixels, rounded to nearest integer.
 */

/**
 * @constructor
 * @desc fin-hypergrid-renderer is the canvas enabled top level sub component that handles the renderering of the Grid.
 *
 * It relies on two other external subprojects
 *
 * 1. fin-canvas: a wrapper to provide a simpler interface to the HTML5 canvas component
 * 2. rectangular: a small npm module providing Point and Rectangle objects
 *
 * The fin-hypergrid-renderer is in a unique position to provide critical functionality to the fin-hypergrid in a hightly performant manner.
 * Because it MUST iterate over all the visible cells it can store various bits of information that can be encapsulated as a service for consumption by the fin-hypergrid component.
 *
 * Instances of this object have basically four main functions.
 *
 * 1. render fixed row headers
 * 2. render fixed col headers
 * 3. render main data cells
 * 4. render grid lines
 *
 * Same parameters as {@link Renderer#initialize|initialize}, which is called by this constructor.
 *
 */
var Renderer = Base.extend('Renderer', {

    //the shared single item "pooled" cell object for drawing each cell
    cell: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    },

    scrollHeight: 0,

    viewHeight: 0,

    reset: function() {
        this.bounds = {
            width: 0,
            height: 0
        };
        this.renderedColumnMinWidths = [];

        /**
         * Represents the ordered set of visible columns. Array size is always the exact number of visible columns, the last of which may only be partially visible.
         *
         * This sequence of elements' `columnIndex` values assumes one of three patterns. Which pattern is base on the following two questions:
         * * Are there "fixed" columns on the left?
         * * Is the grid horizontally scrolled?
         *
         * The set of `columnIndex` values consists of:
         * 1. The first element will be -1 if the row handle column is being rendered.
         * 2. A zero-based list of consecutive of integers representing the fixed columns (if any).
         * 3. An n-based list of consecutive of integers representing the scrollable columns (where n = number of fixed columns + the number of columns scrolled off to the left).
         * @type {visibleColumnDescriptor}
         */
        this.visibleColumns = [];

        /**
         * Represents the ordered set of visible rows. Array size is always the exact number of visible rows.
         *
         * The sequence of elements' `rowIndex` values is local to each subgrid.
         * * **For each non-scrollable subgrid:** The sequence is a zero-based list of consecutive integers.
         * * **For the scrollable subgrid:**
         *   1. A zero-based list of consecutive of integers representing the fixed rows (if any).
         *   2. An n-based list of consecutive of integers representing the scrollable rows (where n = number of fixed rows + the number of rows scrolled off the top).
         *
         * Note that non-scrollable subgrids can come both before _and_ after the scrollable subgrid.
         * @type {visibleRowDescriptor}
         */
        this.visibleRows = [];

        this.insertionBounds = [];
    },

    /**
     * @summary Constructor logic
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     * @memberOf Renderer.prototype
     */
    initialize: function(grid) {
        this.grid = grid;
        this.reset();
    },

    /**
     * This function creates several data structures:
     * * {@link Renderer#visibleColumns}
     * Original comment:
     * "this function computes the grid coordinates used for extremely fast iteration over
     * painting the grid cells. this function is very fast, for thousand rows X 100 columns
     * on a modest machine taking usually 0ms and no more that 3 ms."
     */
    computeCellsBounds: function() {

        //var startTime = Date.now();

        var scrollTop = this.getScrollTop(),
            scrollLeft = this.getScrollLeft(),

            fixedColumnCount = this.getFixedColumnCount(),
            fixedRowCount = this.getFixedRowCount(),

            numRows = this.getRowCount(),
            bounds = this.getBounds(),
            grid = this.grid,
            behavior = grid.behavior,
            editorCellEvent = grid.cellEditor && grid.cellEditor.event,
            dx = editorCellEvent && editorCellEvent.gridCell.x,
            dy = editorCellEvent && editorCellEvent.dataCell.y,
            vcEd,
            vrEd,

            insertionBoundsCursor = 0,
            previousInsertionBoundsCursorValue = 0,

            lineWidth = grid.properties.lineWidth,

            start = this.grid.isShowRowNumbers() ? -1 : 0,
            x, X, // horizontal pixel loop index and limit
            y, Y, // vertical pixel loop index and limit
            c, C, // column loop index and limit
            g, G, // subgrid loop index and limit
            r, R, // row loop index and limitrows in current subgrid
            subrows, // rows in subgrid g
            base, // sum of rows for all subgrids so far
            subgrids = behavior.subgrids,
            subgrid,
            rowIndex,
            scrollableSubgrid,
            footerHeight,
            vx, vy,
            vr, vc,
            width, height,
            firstVX, lastVX,
            firstVY, lastVY,
            topR,
            xSpaced, widthSpaced, heightSpaced; // adjusted for cell spacing

        this.scrollHeight = 0;

        this.visibleColumns.length = 0;
        this.visibleRows.length = 0;

        this.visibleColumnsByIndex = []; // array because number of columns will always be reasonable
        this.visibleRowsByDataRowIndex = {}; // hash because keyed by (fixed and) scrolled row indexes

        this.insertionBounds = [];

        for (
            x = 0, c = start, C = this.getColumnCount(), X = bounds.width || grid.canvas.width;
            c < C && x <= X;
            c++
        ) {
            vx = c;
            if (c >= fixedColumnCount) {
                lastVX = vx += scrollLeft;
                if (firstVX === undefined) {
                    firstVX = lastVX;
                }
            }
            if (vx >= C) {
                break; // scrolled beyond last column
            }

            width = grid.getColumnWidth(vx);

            xSpaced = x ? x + lineWidth : x;
            widthSpaced = x ? width - lineWidth : width;
            this.visibleColumns[c] = this.visibleColumnsByIndex[vx] = vc = {
                index: c,
                columnIndex: vx,
                left: xSpaced,
                width: widthSpaced,
                right: xSpaced + widthSpaced
            };
            if (dx === vx) {
                vcEd = vc;
            }

            x += width;

            insertionBoundsCursor += Math.round(width / 2) + previousInsertionBoundsCursorValue;
            this.insertionBounds.push(insertionBoundsCursor);
            previousInsertionBoundsCursorValue = Math.round(width / 2);
        }

        footerHeight = grid.properties.defaultRowHeight * subgrids.reduce(function(rows, subgrid) {
            if (scrollableSubgrid) {
                rows += subgrid.getRowCount();
            } else {
                scrollableSubgrid = !subgrid.type;
            }
            return rows;
        }, 0);

        for (
            base = r = g = y = 0, G = subgrids.length, Y = bounds.height - footerHeight;
            g < G;
            g++, base += subrows
        ) {
            subgrid = subgrids[g];
            subrows = subgrid.getRowCount();
            scrollableSubgrid = !subgrid.type;
            topR = r;

            // For each row of each subgrid...
            for (R = Math.min(numRows, r + subrows); r < R && y < Y; r++) {
                vy = r;
                if (scrollableSubgrid && r >= fixedRowCount) {
                    vy += scrollTop;
                    lastVY = vy - base;
                    if (firstVY === undefined) {
                        firstVY = lastVY;
                    }
                    if (vy >= R) {
                        break; // scrolled beyond last row
                    }
                }


                rowIndex = vy - base;
                height = behavior.getRowHeight(rowIndex, subgrid);

                heightSpaced = height - lineWidth;
                this.visibleRows[r] = vr = {
                    index: r,
                    subgrid: subgrid,
                    rowIndex: rowIndex,
                    top: y,
                    height: heightSpaced,
                    bottom: y + heightSpaced
                };
                if (scrollableSubgrid) {
                    this.visibleRowsByDataRowIndex[vy - base] = vr;
                    if (dy === rowIndex) {
                        vrEd = vr;
                    }
                }

                y += height;
            }

            if (scrollableSubgrid) {
                subrows = r - topR;
                Y += footerHeight;
            }
        }

        if (editorCellEvent) {
            editorCellEvent.visibleColumn = vcEd;
            editorCellEvent.visibleRow = vrEd;
            editorCellEvent.gridCell.y = vrEd && vrEd.index;
            editorCellEvent._bounds = null;
        }

        this.viewHeight = Y;

        this.dataWindow = this.grid.newRectangle(firstVX, firstVY, lastVX - firstVX, lastVY - firstVY);
    },

    /**
     * Keep in place! Used by fin-canvas.
     * @memberOf Renderer.prototype
     * @returns {Object} a property value at a key, delegates to the grid
     */
    resolveProperty: function(key) {
        return this.grid.properties[key];
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Notify the fin-hypergrid everytime we've repainted.
     * @desc This is the entry point from fin-canvas.
     * @param {CanvasRenderingContext2D} gc
     */
    paint: function(gc) {
        if (this.grid) {
            if (!this.hasData()) {
                var message = this.grid.properties.noDataMessage;
                gc.font = '20px Arial';
                gc.fillText(message, 20, 30);
            } else {
                this.renderGrid(gc);
                this.grid.gridRenderedNotification();
            }
        }
    },

    hasData: function() {
        var data = this.grid.behavior.getData();
        if (data) {
            return data.length > 0;
        }
        return false;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Answer how many rows we rendered
     */
    getVisibleRowsCount: function() {
        return this.visibleRows.length - 1;
    },

    getVisibleScrollHeight: function() {
        return this.viewHeight - this.grid.getFixedRowsHeight();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number[]} Rows we just rendered.
     */
    getVisibleRows: function() {
        warn('getVisibleRows', 'The getVisibleRows() method has been deprecated as of v1.2.0 and will be removed in a future version. Previously returned the this.visibleRows array but because this.visibleRows is no longer a simple array of integers but is now an array of objects, it now returns an array mapped to this.visibleRows[*].rowIndex. Note however that this mapping is not equivalent to what this method previously returned because while each object\'s .rowIndex property is still adjusted for scrolling within the data subgrid, the index is now local to (zero-based within) each subgrid');
        return this.visibleRows.map(function(vr) { return vr.rowIndex; });
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Number of columns we just rendered.
     */
    getVisibleColumnsCount: function() {
        return this.visibleColumns.length - 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Columns we just rendered.
     */
    getVisibleColumns: function() {
        warn('visibleColumns', 'The getVisibleColumns() method has been deprecated as of v1.2.0 and will be removed in a future version. Previously returned the this.visibleColumns but because this.visibleColumns is no longer a simple array of integers but is now an array of objects, it now returns an array mapped to the equivalent visibleColumns[*].columnIndex.');
        return this.visibleColumns.map(function(vc) { return vc.columnIndex; });
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The column index when the mouseEvent coordinates are over a column divider.
     */
    overColumnDivider: function(x) {
        var vc = this.visibleColumns,
            xi = Math.round(x),
            x1 = xi - 3,
            x2 = xi + 1;

        for (var c = (-1 in vc ? -1 : 0), C = vc.length; c < C; ++c) {
            x = vc[c].right;
            if (x1 <= x && x <= x2) {
                return c + 1;
            }
        }

        return -1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row index when the mouseEvent coordinates are over a row divider.
     */
    overRowDivider: function(y) {
        var vr = this.visibleRows,
            yi = Math.round(y),
            y1 = yi - 3,
            y2 = yi + 1;

        for (var r = 0, R = vr.length; r < R; ++r) {
            y = vr[r].bottom;
            if (y1 <= y && y <= y2) {
                return r + 1;
            }
        }

        return -1;
    },

    /**
     * @memberOf Renderer.prototype
     * @param {CellEvent|number} x - CellEvent object or grid column coordinate.
     * @param {number} [y] - Grid row coordinate. Omit if `xOrCellEvent` is a CellEvent.
     * @returns {Rectangle} Bounding rect of cell with the given coordinates.
     */
    getBoundsOfCell: function(x, y) {
        var vc = this.visibleColumns[x],
            vr = this.visibleRows[y];

        return {
            x: vc.left,
            y: vr.top,
            width: vc.width,
            height: vr.height
        };
    },

    /**
     * @memberOf Renderer.prototype
     * @desc answer the column index under the coordinate at pixelX
     * @param {number} pixelX - The horizontal coordinate.
     * @returns {number} The column index under the coordinate at pixelX.
     */
    getColumnFromPixelX: function(pixelX) {
        var width = 0,
            fixedColumnCount = this.getFixedColumnCount(),
            scrollLeft = this.grid.getHScrollValue(),
            visibleColumns = this.visibleColumns;

        for (var c = 1; c < visibleColumns.length - 1; c++) {
            width = visibleColumns[c].left - (visibleColumns[c].left - visibleColumns[c - 1].left) / 2;
            if (pixelX < width) {
                if (c > fixedColumnCount) {
                    c += scrollLeft;
                }
                return c - 1;
            }
        }
        if (c > fixedColumnCount) {
            c += scrollLeft;
        }
        return c - 1;
    },


    /**
     * @memberOf Renderer.prototype
     * @desc Answer specific data cell coordinates given mouse coordinates in pixels.
     * @param {Point} point
     * @returns {Point} Cell coordinates
     */
    getGridCellFromMousePoint: function(point) {
        var x = point.x,
            y = point.y,
            vrs = this.visibleRows,
            vcs = this.visibleColumns,
            firstColumn = vcs[this.grid.isShowRowNumbers() ? -1 : 0],
            inFirstColumn = x < firstColumn.right,
            vc = inFirstColumn ? firstColumn : vcs.find(function(vc) { return x < vc.right; }) || vcs[vcs.length - 1],
            vr = vrs.find(function(vr) { return y < vr.bottom; }) || vrs[vrs.length - 1],
            mousePoint = this.grid.newPoint(x - vc.left, y - vr.top),
            cellEvent = new this.grid.behavior.CellEvent(vc.columnIndex, vr.index);

        // cellEvent.visibleColumn = vc;
        // cellEvent.visibleRow = vr;

        return Object.defineProperty(cellEvent, 'mousePoint', { value: mousePoint });
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a column is visible.
     * @param {number} colIndex - the column index*
     * @returns {boolean} The given column is fully visible.
     */
    isColumnVisible: function(columnIndex) {
        return !!this.visibleColumns.find(function(vc) { return vc.columnIndex === columnIndex; });
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The width x coordinate of the last rendered column
     */
    getFinalVisibleColumnBoundary: function() {
        var chop = this.isLastColumnVisible() ? 2 : 1;
        var colWall = this.visibleColumns[this.visibleColumns.length - chop].right;
        return Math.min(colWall, this.getBounds().width);
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines visibility of a row.
     * @param {number} y - The physical (unscrolled) grid row index.
     * @returns {boolean} The given row is fully visible.
     */
    isRowVisible: function(y) {
        return !!this.visibleRows[y];
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a cell is selected.
     * @param {number} x - the x cell coordinate
     * @param {number} y - the y cell coordinate*
     * @returns {boolean} The given cell is fully visible.
     */
    isSelected: function(x, y) {
        return this.grid.isSelected(x, y);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc This is the main forking of the renderering task.
     * @param {CanvasRenderingContext2D} gc
     */
    renderGrid: function(gc) {
        gc.beginPath();

        this.paintCells(gc);
        this.renderOverrides(gc);
        this.renderLastSelection(gc);
        gc.closePath();
    },

    renderLastSelection: function(gc) {
        gc.beginPath();
        this._renderLastSelection(gc);
        gc.closePath();
    },

    _renderLastSelection: function(gc) {
        var selections = this.grid.selectionModel.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var selection = this.grid.selectionModel.getLastSelection();

        if (selection.origin.x === -1) {
            // no selected area, lets exit
            return;
        }

        var vci = this.visibleColumnsByIndex,
            vri = this.visibleRowsByDataRowIndex,
            lastColumn = this.visibleColumns[this.visibleColumns.length - 1], // last column in scrollable section
            lastRow = vri[this.dataWindow.corner.y]; // last row in scrollable data section

        if (
            !lastColumn || !lastRow ||
            selection.origin.x > lastColumn.columnIndex ||
            selection.origin.y > lastRow.rowIndex
        ) {
            // selection area begins to right or below grid
            return;
        }

        var vcOrigin = vci[selection.origin.x],
            vcCorner = vci[selection.corner.x],
            vrOrigin = vri[selection.origin.y],
            vrCorner = vri[selection.corner.y];

        if (
            !(vcOrigin || vcCorner) || // entire selection scrolled out of view to left of scrollable region
            !(vrOrigin || vrCorner)    // entire selection scrolled out of view above scrollable region
        ) {
            return;
        }

        var props = this.grid.properties;
        vcOrigin = vcOrigin || lastColumn;
        vcCorner = vcCorner || selection.corner.x > lastColumn.columnIndex
            ? lastColumn.columnIndex
            : vci[props.fixedColumnCount - 1];
        vrOrigin = vrOrigin || lastRow;
        vrCorner = vrCorner || selection.corner.y > lastRow.rowIndex
            ? lastRow.rowIndex
            : vri[props.fixedRowCount - 1];

        // Render the selection model around the bounds
        var config = {
            bounds: {
                x: vcOrigin.left,
                y: vrOrigin.top,
                width: vcCorner.right - vcOrigin.left,
                height: vrCorner.bottom - vrOrigin.top
            },
            selectionRegionOverlayColor: this.grid.properties.selectionRegionOverlayColor,
            selectionRegionOutlineColor: this.grid.properties.selectionRegionOutlineColor
        };
        this.grid.cellRenderers.get('lastselection').paint(gc, config);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc iterate the renderering overrides and manifest each
     * @param {CanvasRenderingContext2D} gc
     */
    renderOverrides: function(gc) {
        var cache = this.grid.renderOverridesCache;
        for (var key in cache) {
            if (cache.hasOwnProperty(key)) {
                var override = cache[key];
                if (override) {
                    this.renderOverride(gc, override);
                }
            }
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @desc copy each overrides specified area to it's target and blank out the source area
     * @param {CanvasRenderingContext2D} gc
     * @param {OverrideObject} override - an object with details contain an area and a target context
     */
    renderOverride: function(gc, override) {
        //lets blank out the drag row
        var hdpiRatio = override.hdpiratio;
        var startX = override.startX; //hdpiRatio * edges[override.columnIndex];
        var width = override.width + 1;
        var height = override.height;
        var targetCTX = override.ctx;
        var imgData = gc.getImageData(startX, 0, Math.round(width * hdpiRatio), Math.round(height * hdpiRatio));
        targetCTX.putImageData(imgData, 0, 0);
        gc.fillStyle = this.grid.properties.backgroundColor2;
        gc.fillRect(Math.round(startX / hdpiRatio), 0, width, height);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current vertical scroll value.
     */
    getScrollTop: function() {
        return this.grid.getVScrollValue();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current horizontal scroll value.
     */
    getScrollLeft: function() {
        return this.grid.getHScrollValue();
    },

    getColumnEdges: function() {
        warn('columnEdges', 'The getColumnEdges() mehtod has been deprecated as of version 1.2.0 in favor of visibleColumns[*].top and will be removed in a future version. Note however that columnEdges had one additional element (representing the right edge of the last visible column) which visibleColumns lacks. Instead you can reference visibleColumns[*].bottom.');
        return this.visibleColumns.map(function(vc) { return vc.left; }).concat([this.visibleColumns[this.visibleColumns.length - 1].right]);
    },

    getRowEdges: function() {
        warn('rowEdges', 'The getRowEdges() method has been deprecated as of version 1.2.0 in favor of visibleRows[*].top and will be removed in a future version. Note however that rowEdges had one additional element (representing the bottom edge of the last visible row) which visibleRows lacks. Instead you can reference visibleRows[*].bottom.');
        return this.visibleRows.map(function(vr) { return vr.top; }).concat([this.visibleRows[this.visibleRows.length - 1].bottom]);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} The last col was rendered (is visible)
     */
    isLastColumnVisible: function() {
        var lastColumnIndex = this.getColumnCount() - 1;
        return !!this.visibleColumns.find(function(vc) { return vc.columnIndex === lastColumnIndex; });
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered column width at index
     */
    getRenderedWidth: function(index) {
        var result,
            columns = this.visibleColumns;

        if (index >= columns.length) {
            result = columns[columns.length - 1].right;
        } else {
            result = columns[index].left;
        }

        return result;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered row height at index
     */
    getRenderedHeight: function(index) {
        var result,
            rows = this.visibleRows;

        if (index >= rows.length) {
            var last = rows[rows.length - 1];
            result = last.bottom;
        } else {
            result = rows[index].top;
        }

        return result;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {fin-canvas} my [fin-canvas](https://github.com/stevewirts/fin-canvas)
     */
    getCanvas: function() {
        return this.grid.getCanvas();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} User is currently dragging a column for reordering.
     */
    isDraggingColumn: function() {
        return this.grid.isDraggingColumn();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to go to for a page up.
     */
    getPageUpRow: function() {
        var grid = this.grid,
            scrollHeight = this.getVisibleScrollHeight(),
            top = this.dataWindow.origin.y - this.grid.properties.fixedRowCount - 1,
            scanHeight = 0;
        while (scanHeight < scrollHeight && top >= 0) {
            scanHeight += grid.getRowHeight(top);
            top--;
        }
        return top + 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page down.
     */
    getPageDownRow: function() {
        return this.dataWindow.corner.y - this.grid.properties.fixedRowCount + 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.grid.getColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of rows.
     */
    getRowCount: function() {
        return this.grid.getRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.grid.getFixedColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.grid.getFixedRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of header rows.
     */
    getHeaderRowCount: function() {
        return this.grid.getHeaderRowCount();
    },

    /** @summary Smart render the grid.
     * @desc Paint all the cells of a grid, including all "fixed" columns and rows.
     * We snapshot the context to insure against its pollution.
     * `try...catch` surrounds each cell paint in case a cell renderer throws an error.
     * The error message is error-logged to console AND displayed in cell.
     *
     * For performance reasons, we do not create a new `CellEvent` on for each `_paintCell` call.
     * Rather, we create one for all the calls and maintain the instance variables in the loops
     * (which is why `CellEvent` uses `WritablePoint` instead of `Point` for `gridCell` and `dataCell`):
     * * Set in column loop:
     *   * `cellEvent.column`
     *   * `cellEvent.gridCell.x`
     *   * `cellEvent.dataCell.x`
     *   * `cellEvent.bounds.x`
     *   * `cellEvent.bounds.width`
     * * Set in subgrid loop:
     *   * `cellEvent.subgrid`
     * * Set in row loop:
     *   * `cellEvent.gridCell.y`
     *   * `cellEvent.dataCell.y`
     *   * `cellEvent.bounds.y`
     *   * `cellEvent.bounds.height`
     * @memberOf Renderer.prototype
     * @param {CanvasRenderingContext2D} gc
     */
    paintCells: function(gc) {
        var message,
            behavior = this.grid.behavior,
            c, C, // column loop index and limit
            r, R, // row loop index and limit
            cellEvent = new behavior.CellEvent(0, 0),
            bounds = cellEvent._bounds = { x:0, y:0, width:0, height:0 },
            gridCell = cellEvent.gridCell,
            dataCell = cellEvent.dataCell,
            vc, visibleColumns = this.visibleColumns,
            vr, visibleRows = this.visibleRows,
            clipHeight = this.getBounds().height;

        this.buttonCells = {};

        // For each column...
        for (
            c = this.grid.isShowRowNumbers() ? -1 : 0, C = visibleColumns.length;
            c < C;
            c++
        ) {
            cellEvent.visibleColumn = vc = visibleColumns[c];
            cellEvent.column = behavior.getActiveColumn(vc.columnIndex);

            gridCell.x = vc.columnIndex;
            dataCell.x = cellEvent.column && cellEvent.column.index;

            bounds.x = vc.left;
            bounds.width = vc.width;

            this.renderedColumnMinWidths[gridCell.x] = 0;

            gc.save();

            // Clip to visible portion of column to prevent overflow to right. Previously we clipped to entire visible grid and dealt with overflow by overpainting with next column. However, this strategy fails when transparent background (no background color).
            // TODO: if extra clip() calls per column affect performance (not the clipping itself which was happening anyway, but the clip calls which set up the clipping), use previous strategy when there is a background color
            gc.beginPath();
            gc.rect(0, 0, bounds.x + bounds.width, clipHeight);
            gc.clip();

            // For each row of each subgrid (of each column)...
            for (
                r = 0, R = visibleRows.length;
                r < R;
                r++
            ) {
                cellEvent.visibleRow = vr = visibleRows[r];

                bounds.y = vr.top;
                bounds.height = vr.height;

                gridCell.y = vr.index;
                dataCell.y = vr.rowIndex;

                try {
                    this._paintCell(gc, cellEvent);
                } catch (e) {
                    message = e && (e.message || e) || 'Unknown error.';

                    console.error(message);

                    var rawGc = gc.gc || gc, // Don't log these canvas calls
                        errX = vc.left, errWidth = vc.right,
                        errY = vr.top, errHeight = vr.bottom,
                        config = { bounds: { c: errX, y: errY, width: errWidth, height: errHeight } };

                    rawGc.save(); // define clipping region
                    rawGc.beginPath();
                    rawGc.rect(errX, errY, errWidth, errHeight);
                    rawGc.clip();

                    this.grid.cellRenderers.get('errorcell').paint(rawGc, config, message);

                    rawGc.restore(); // discard clipping region
                }
            }

            gc.restore(); // Remove column's clip region (and anything else renderCellError() might have set)
        }

        setNumberColumnWidth(gc, behavior, this.grid.getRowCount());
    },

    /**
     * @memberOf Renderer.prototype
     * @param {CanvasRenderingContext2D} gc
     * @param x
     * @param y
     */
    paintCell: function(gc, x, y) {
        gc.moveTo(0, 0);

        var c = this.visibleColumns[x].index, // todo refac
            r = this.visibleRows[y].index;

        if (c) { //something is being viewed at at the moment (otherwise returns undefined)
            this._paintCell(gc, c, r);
        }
    },

    _paintCell: function(gc, cellEvent) {

        var grid = this.grid,
            behavior = grid.behavior,
            x = cellEvent.gridCell.x,
            // y = cellEvent.gridCell.y,
            c = cellEvent.dataCell.x,
            r = cellEvent.dataCell.y,

            isHandleColumn = cellEvent.isHandleColumn,
            isHierarchyColumn = cellEvent.isHierarchyColumn,
            isColumnSelected = cellEvent.isColumnSelected,

            isShowRowNumbers = grid.isShowRowNumbers(),
            isRowHandleOrHierarchyColumn = isShowRowNumbers && isHandleColumn || isHierarchyColumn,

            isGridRow = cellEvent.isGridRow,
            isRowSelected = cellEvent.isRowSelected,
            isCellSelected = cellEvent.isCellSelected,

            isHeaderRow = cellEvent.isHeaderRow,
            isFilterRow = cellEvent.isFilterRow,

            cellProperties = behavior.getCellOwnProperties(cellEvent),
            baseProperties,
            nonGridCellProps,
            config = this.config;

        if (cellProperties && cellProperties.applyCellProperties) {
            this.c = undefined;
            config = undefined;
            baseProperties = cellProperties;
            nonGridCellProps = !isGridRow;
        } else if (!config || c !== this.c) {
            this.c = c;
            config = undefined;
        }

        var configType;
        if (isRowHandleOrHierarchyColumn) {
            configType = isRowSelected ? 1 : 2;
        } else if (isGridRow) {
            configType = 3;
        } else if (isFilterRow) {
            configType = 4;
        } else if (isColumnSelected) {
            configType = 5;
        } else { // header or summary or other
            configType = 6;
        }

        if (!config || configType !== this.configType) {
            this.configType = configType;
            if (!baseProperties) {
                baseProperties = behavior.getColumnProperties(c);
                if (!baseProperties) {
                    this.config = undefined;
                    return;
                }
            }
            switch (configType) {
                case 1: config = Object.create(baseProperties.rowHeaderRowSelection); break;
                case 2: config = Object.create(baseProperties.rowHeader); break;
                case 3: config = Object.create(baseProperties); break;
                case 4: config = Object.create(baseProperties.filterProperties); break;
                case 5: config = Object.create(baseProperties.columnHeaderColumnSelection); break;
                case 6: config = Object.create(baseProperties.columnHeader); break;
            }
            this.config = config;
            this.baseProperties = baseProperties;
        }

        // Create `config` (render props) object
        // * with appropriate prototype
        // * set `isSelected` (added to `config` below as a read-only property)
        // * for row handle column, set `config.halign` to `'right'`
        // * for hierarchy column, set `config.halign` to `'left'`
        var isSelected;
        if (isRowHandleOrHierarchyColumn) {
            isSelected = isRowSelected || grid.isCellSelectedInRow(r);
            config.halign = isHierarchyColumn ? 'left' : 'right';
        } else if (isGridRow) {
            isSelected = isCellSelected || isRowSelected || isColumnSelected;
        } else if (isFilterRow) {
            isSelected = false;
        } else if (isColumnSelected) {
            isSelected = true;
        } else { // header or summary or other
            isSelected = grid.isCellSelectedInColumn(x);
        }

        // Set cell contents:
        // * For all cells: set `config.value` (writable property)
        // * For cells outside of row handle column: also set `config.dataRow` for use by valOrFunc
        if (!isHandleColumn) {
            config.dataRow = grid.getRow(r);
            config.value = cellEvent.value;
        } else if (isGridRow) {
            // row handle for a data row
            config.value = [images.checkbox(isRowSelected), r + 1, null]; // row number is 1-based
        } else if (isHeaderRow) {
            // row handle for header row: gets "master" checkbox
            config.value = [images.checkbox(grid.areAllRowsSelected()), '', null];
        } else if (isFilterRow) {
            // row handle for filter row: gets filter icon
            config.value = [images.filter(false), '', null];
        } else {
            // row handles for "summary" or other rows: empty
            config.value = '';
        }

        config.isSelected = isSelected;
        config.isGridColumn = !isRowHandleOrHierarchyColumn;
        config.isGridRow = isGridRow;
        config.isHeaderRow = isHeaderRow;
        config.isFilterRow = isFilterRow;
        config.isUserDataArea = !isRowHandleOrHierarchyColumn && isGridRow;
        config.isColumnHovered = cellEvent.isColumnHovered;
        config.isRowHovered = cellEvent.isRowHovered;
        config.isCellHovered = cellEvent.isCellHovered;
        config.bounds = cellEvent.bounds;
        config.isCellSelected = isCellSelected;
        config.isRowSelected = isRowSelected;
        config.isColumnSelected = isColumnSelected;
        config.isInCurrentSelectionRectangle = grid.isInCurrentSelectionRectangle(x, r);

        if (grid.mouseDownState) {
            config.mouseDown = grid.mouseDownState.gridCell.equals(cellEvent.gridCell);
        }

        // This call's dataModel.getCell which developer can override to:
        // * mutate the (writable) properties of `config`
        // * mutate cell renderer choice (instance of which is returned)
        var cellRenderer = behavior.getCellRenderer(config, cellEvent);

        // Overwrite possibly mutated cell properties, if requested to do so by `getCell` override
        if (config.reapplyCellProperties || nonGridCellProps) {
            _(config).extendOwn(cellProperties);
        }

        behavior.cellPropertiesPrePaintNotification(config);

        //allow the renderer to identify itself if it's a button
        config.buttonCells = this.buttonCells;

        config.formatValue = grid.getFormatter(config.isUserDataArea && config.format);

        cellRenderer.paint(gc, config);

        this.renderedColumnMinWidths[x] = Math.max(config.minWidth || 0, this.renderedColumnMinWidths[x]);
        this.baseProperties.preferredWidth = this.renderedColumnMinWidths[x];
    },

    isViewableButton: function(c, r) {
        var key = c + ',' + r;
        return this.buttonCells[key] === true;
    },

    startAnimator: function() {
        var self = this;
        requestAnimationFrame(function animate() {
            self.animate();
            requestAnimationFrame(animate);
        });
    },

    animate: function() {
        var ctx = this.getCanvas().canvasCTX;
        ctx.beginPath();
        ctx.save();
        this.renderLastSelection(ctx);
        ctx.restore();
        ctx.closePath();
    },

    getBounds: function() {
        return this.bounds;
    },

    setBounds: function(bounds) {
        return (this.bounds = bounds);
    }

});

function setNumberColumnWidth(gc, behavior, maxRow) {
    var columnProperties = behavior.getColumnProperties(-1),
        cellProperties = columnProperties.rowHeader,
        icon = images.checked;

    gc.font = cellProperties.font;

    columnProperties.preferredWidth = icon.width + 7 + cellProperties.getTextWidth(gc, maxRow + 1);
}

var warnings = {};
function warn(name, message) {
    if (!warnings[name]) {
        warnings[name] = true;
        console.warn(message);
    }
}

module.exports = Renderer;

},{"../../images":4,"../Base":49,"object-iterators":42}],115:[function(require,module,exports){
'use strict';

var RangeSelectionModel = require('sparse-boolean-array');

/**
 *
 * @constructor
 * @desc We represent selections as a list of rectangles because large areas can be represented and tested against quickly with a minimal amount of memory usage. Also we need to maintain the selection rectangles flattened counter parts so we can test for single dimension contains. This is how we know to highlight the fixed regions on the edges of the grid.
 */

function SelectionModel(grid) {

    this.grid = grid;

    /**
     * @name multipleSelections
     * @type {boolean}
     * @summary Can select multiple cell regions.
     * @memberOf SelectionModel.prototype
     */
    this.multipleSelections = grid[grid.behavior ? 'getProperties' : '_getProperties']().multipleSelections;

    /**
     * @name selections
     * @type {Rectangle[]}
     * @summary The selection rectangles.
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.selections = [];

    /**
     * @name flattenedX
     * @type {Rectangle[]}
     * @summary The selection rectangles flattened in the horizontal direction (no width).
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.flattenedX = [];

    /**
     * @name flattenedY
     * @type {Rectangle[]}
     * @summary The selection rectangles flattened in the vertical direction (no height).
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.flattenedY = [];

    /**
     * @name rowSelectionModel
     * @type {RangeSelectionModel}
     * @summary The selection rectangles.
     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.rowSelectionModel = new RangeSelectionModel();

    /**
     * @name columnSelectionModel
     * @type {RangeSelectionModel}
     * @summary The selection rectangles.
     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.columnSelectionModel = new RangeSelectionModel();

    this.setLastSelectionType('');
}

SelectionModel.prototype = {

    constructor: SelectionModel.prototype.constructor,

    /**
     * @type {boolean}
     * @memberOf SelectionModel.prototype
     */
    allRowsSelected: false,

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelection: function() {
        var sels = this.selections;
        var sel = sels[sels.length - 1];
        return sel;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelectionType: function() {
        return this.lastSelectionType;
    },

    /**
     * @param type
     * @memberOf SelectionModel.prototype
     */
    setLastSelectionType: function(type) {
        this.lastSelectionType = type;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @description Select the region described by the given coordinates.
     *
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     * @param {boolean} silent - whether to fire selection changed event
     */
    select: function(ox, oy, ex, ey, silent) {
        var newSelection = this.grid.newRectangle(ox, oy, ex, ey);

        //Cache the first selected cell before it gets normalized to top-left origin
        newSelection.firstSelectedCell = this.grid.newPoint(ox, oy);

        newSelection.lastSelectedCell = (
            newSelection.firstSelectedCell.x === newSelection.origin.x &&
            newSelection.firstSelectedCell.y === newSelection.origin.y
        )
            ? newSelection.corner
            : newSelection.origin;

        if (this.multipleSelections) {
            this.selections.push(newSelection);
            this.flattenedX.push(newSelection.flattenXAt(0));
            this.flattenedY.push(newSelection.flattenYAt(0));
        } else {
            this.selections[0] = newSelection;
            this.flattenedX[0] = newSelection.flattenXAt(0);
            this.flattenedY[0] = newSelection.flattenYAt(0);
        }
        this.setLastSelectionType('cell');

        if (!silent) {
            this.grid.selectionChanged();
        }
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     */
    toggleSelect: function(ox, oy, ex, ey) {

        var selected, index;

        selected = this.selections.find(function(selection, idx) {
            index = idx;
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });

        if (selected) {
            this.selections.splice(index, 1);
            this.flattenedX.splice(index, 1);
            this.flattenedY.splice(index, 1);
            this.grid.selectionChanged();
        } else {
            this.select(ox, oy, ex, ey);
        }
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc Remove the last selection that was created.
     */
    clearMostRecentSelection: function(dontClearRowSelections) {
        dontClearRowSelections = dontClearRowSelections === true;
        if (!dontClearRowSelections) {
            this.setAllRowsSelected(false);
        }
        if (this.selections.length) { --this.selections.length; }
        if (this.flattenedX.length) { --this.flattenedX.length; }
        if (this.flattenedY.length) { --this.flattenedY.length; }
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentColumnSelection: function() {
        this.columnSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentRowSelection: function() {
        this.rowSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearRowSelection: function() {
        this.rowSelectionModel.clear();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelections: function() {
        return this.selections;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean} There are active selection(s).
     */
    hasSelections: function() {
        return this.selections.length !== 0;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasRowSelections: function() {
        return !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasColumnSelections: function() {
        return !this.columnSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @return {boolean} Selection covers a specific column.
     * @param {number} y
     */
    isCellSelectedInRow: function(y) {
        return this._isCellSelected(this.flattenedX, 0, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns Selection covers a specific row.
     * @param {number} x
     */
    isCellSelectedInColumn: function(x) {
        return this._isCellSelected(this.flattenedY, x, 0);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @summary Selection query function.
     * @returns {boolean} The given cell is selected (part of an active selection).
     * @param {Rectangle[]} selections - Selection rectangles to search through.
     * @param {number} x
     * @param {number} y
     */
    isSelected: function(x, y) {
        return (
            this.isColumnSelected(x) ||
            this.isRowSelected(y) ||
            this._isCellSelected(this.selections, x, y)
        );
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isCellSelected: function(x, y) {
        return this._isCellSelected(this.selections, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param selections
     * @param x
     * @param y
     * @returns {boolean}
     * @private
     */
    _isCellSelected: function(selections, x, y) {
        var self = this;
        return !!selections.find(function(selection) {
            return self.rectangleContains(selection, x, y);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc empty out all our state
     *
     */
    clear: function(dontClearRowSelections) {
        dontClearRowSelections = dontClearRowSelections === true;
        this.selections.length = 0;
        this.flattenedX.length = 0;
        this.flattenedY.length = 0;
        this.columnSelectionModel.clear();
        if (!dontClearRowSelections) {
            this.setAllRowsSelected(false);
            this.rowSelectionModel.clear();
        }
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     * @returns {boolean}
     */
    isRectangleSelected: function(ox, oy, ex, ey) {
        return !!this.selections.find(function(selection) {
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @returns {*}
     */
    isColumnSelected: function(x) {
        return this.columnSelectionModel.isSelected(x);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y
     * @returns {boolean|*}
     */
    isRowSelected: function(y) {
        return this.allRowsSelected || this.rowSelectionModel.isSelected(y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    selectColumn: function(x1, x2) {
        this.columnSelectionModel.select(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    selectAllRows: function() {
        this.clear();
        this.setAllRowsSelected(true);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */

    setAllRowsSelected: function(isIt) {
        this.allRowsSelected = isIt;
    },

    areAllRowsSelected: function() {
        return this.allRowsSelected;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    selectRow: function(y1, y2) {
        this.rowSelectionModel.select(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    deselectColumn: function(x1, x2) {
        this.columnSelectionModel.deselect(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    deselectRow: function(y1, y2) {
        if (this.areAllRowsSelected()) {
            // To deselect a row, we must first remove the all rows flag...
            this.setAllRowsSelected(false);
            // ...and create a single range representing all rows
            this.rowSelectionModel.select(0, this.grid.getRowCount() - 1);
        }
        this.rowSelectionModel.deselect(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelectedRows: function() {
        if (this.areAllRowsSelected()) {
            var headerRows = this.grid.getHeaderRowCount();
            var rowCount = this.grid.getRowCount() - headerRows;
            var result = new Array(rowCount);
            for (var i = 0; i < rowCount; i++) {
                result[i] = i + headerRows;
            }
            return result;
        }
        return this.rowSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*|Array.Array.number}
     */
    getSelectedColumns: function() {
        return this.columnSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
     isColumnOrRowSelected: function() {
        return !this.columnSelectionModel.isEmpty() || !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {Array}
     */
    getFlattenedYs: function() {
        var result = [];
        var set = {};
        this.selections.forEach(function(selection) {
            var top = selection.origin.y;
            var size = selection.extent.y + 1;
            for (var r = 0; r < size; r++) {
                var ti = r + top;
                if (!set[ti]) {
                    result.push(ti);
                    set[ti] = true;
                }
            }
        });
        result.sort(function(x, y) {
            return x - y;
        });
        return result;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectRowsFromCells: function(offset, dontClearRowSelections) {
        offset = offset || 0;
        dontClearRowSelections = dontClearRowSelections === true;

        var sm = this.rowSelectionModel;

        if (!dontClearRowSelections) {
            this.setAllRowsSelected(false);
            sm.clear();
        }

        this.selections.forEach(function(selection) {
            var top = selection.origin.y,
                extent = selection.extent.y;
            top += offset;
            sm.select(top, top + extent);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectColumnsFromCells: function(offset) {
        offset = offset || 0;

        var sm = this.columnSelectionModel;
        sm.clear();

        this.selections.forEach(function(selection) {
            var left = selection.origin.x,
                extent = selection.extent.x;
            left += offset;
            sm.select(left, left + extent);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isInCurrentSelectionRectangle: function(x, y) {
        var last = this.selections[this.selections.length - 1];
        return last && this.rectangleContains(last, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param rect
     * @param x
     * @param y
     * @returns {boolean}
     */
    rectangleContains: function(rect, x, y) { //TODO: explore why this works and contains on rectanglular does not
        var minX = rect.origin.x;
        var minY = rect.origin.y;
        var maxX = minX + rect.extent.x;
        var maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        var result =
            x >= minX &&
            y >= minY &&
            x <= maxX &&
            y <= maxY;

        return result;
    }
};

module.exports = SelectionModel;

},{"sparse-boolean-array":46}],116:[function(require,module,exports){
'use strict';

var rectangular = require('rectangular');

// Variation of rectangular.Point but with writable x and y:
function WritablePoint(x, y) {
    this.x = x;
    this.y = y;
}

WritablePoint.prototype = rectangular.Point.prototype;

// The nullSubgrid is for CellEvents representing clicks below last row.
// var nullSubgrid = {};

var prototype = Object.defineProperties({}, {
    value: {
        get: function() { return this.visibleRow.subgrid.getValue(this.dataCell.x, this.dataCell.y); },
        set: function(value) { this.visibleRow.subgrid.setValue(this.dataCell.x, this.dataCell.y, value); }
    },

    formattedValue: {
        get: function() { return this.grid.formatValue(this.getCellProperty('format'), this.value); }
    },

    bounds: {
        get: function() {
            return this._bounds || (this._bounds = {
                x: this.visibleColumn.left,
                y: this.visibleRow.top,
                width: this.visibleColumn.width,
                height: this.visibleRow.height
            });
        }
    },

    getCellProperty: {
        value: function(propName) { return this.column.getCellProperty(this.dataCell.y, propName, this.visibleRow.subgrid); }
    },

    // "Visible" means scrolled into view.
    isRowVisible:    { get: function() { return !!this.visibleRow; } },
    isColumnVisible: { get: function() { return !!this.visibleColumn; } },
    isCellVisible:   { get: function() { return this.isRowVisible && this.isColumnVisible; } },

    isGridRow:    { get: function() { return !this.visibleRow.subgrid.type; } },
    isGridColumn: { get: function() { return this.gridCell.x >= 0; } },
    isGridCell:   { get: function() { return this.isGridRow && this.isGridColumn; } },

    isRowSelected:    { get: function() { return this.isGridRow && this.selectionModel.isRowSelected(this.dataCell.y); } },
    isColumnSelected: { get: function() { return this.isGridColumn && this.selectionModel.isColumnSelected(this.gridCell.x); } },
    isCellSelected:   { get: function() { return this.selectionModel.isCellSelected(this.gridCell.x, this.dataCell.y); } },

    isRowHovered:    { get: function() { return this.isGridRow && this.grid.hoverCell && this.grid.hoverCell.y === this.gridCell.y; } },
    isColumnHovered: { get: function() { return this.isGridColumn && this.grid.hoverCell && this.grid.hoverCell.x === this.gridCell.x; } },
    isCellHovered:   { get: function() { return this.isRowHovered && this.isColumnHovered; } },

    isRowFixed:    { get: function() { return this.isGridRow && this.dataCell.y < this.grid.properties.fixedRowCount; } },
    isColumnFixed: { get: function() { return this.isGridColumn && this.gridCell.x < this.grid.properties.fixedColumnCount; } },
    isCellFixed:   { get: function() { return this.isRowFixed && this.isColumnFixed; } },

    isHandleColumn: { get: function() { return !this.isGridColumn; } },
    isHandleCell:   { get: function() { return this.isHandleColumn && this.isGridRow; } },

    isHierarchyColumn: { get: function() { return this.gridCell.x === 0 && this.grid.properties.showTreeColumn && this.dataModel.isDrillDown(this.dataCell.x); } },

    isHeaderRow:    { get: function() { return this.visibleRow.subgrid.type === 'header'; } },
    isHeaderHandle: { get: function() { return this.isHeaderRow && this.isHandleColumn; } },
    isHeaderCell:   { get: function() { return this.isHeaderRow && this.isGridColumn; } },

    isFilterRow:    { get: function() { return this.visibleRow.subgrid.type === 'filter'; } },
    isFilterHandle: { get: function() { return this.isFilterRow && this.isHandleColumn; } },
    isFilterCell:   { get: function() { return this.isFilterRow && this.isGridColumn; } },

    isSummaryRow:    { get: function() { return this.visibleRow.subgrid.type === 'summary'; } },
    isSummaryHandle: { get: function() { return this.isSummaryRow && this.isHandleColumn; } },
    isSummaryCell:   { get: function() { return this.isSummaryRow && this.isGridColumn; } },

    isTopTotalsRow:    { get: function() { return this.visibleRow.subgrid === this.behavior.subgrids.topTotals; } },
    isTopTotalsHandle: { get: function() { return this.isTopTotalsRow && this.isHandleColumn; } },
    isTopTotalsCell:   { get: function() { return this.isTopTotalsRow && this.isGridColumn; } },

    isBottomTotalsRow:    { get: function() { return this.visibleRow.subgrid === this.behavior.subgrids.bottomTotals; } },
    isBottomTotalsHandle: { get: function() { return this.isBottomTotalsRow && this.isHandleColumn; } },
    isBottomTotalsCell:   { get: function() { return this.isBottomTotalsRow && this.isGridColumn; } }
});

/**
 * @classdesc `CellEvent` is a very low-level object that needs to be super-efficient. JavaScript objects are well known to be light weight in general, but at this level we need to be careful.
 *
 * These objects were originally only being created on mouse events. This was no big deal as mouse events are few and far between. However, as of v1.2.0, the renderer now also creates one for each visible cell on each and every grid paint.
 *
 * For this reason, to maintain performance, each grid gets a custom definition of `CellEvent`, created by this class factory, with the following optimizations:
 *
 * * Use of `extend-me` is avoided because its `initialize` chain is a bit too heavy here.
 * * Custom versions of `CellEvent` for each grid lightens the load on the constructor.
 *
 * @summary Create a custom `CellEvent` class.
 *
 * @desc Create a custom definition of `CellEvent` for each grid instance, setting the `grid`, `behavior`, and `dataModel` properties on the prototype. As this happens once per grid instantiation, it avoids having to perform this set up work on every `CellEvent` instantiation.
 *
 * @param {HyperGrid} grid
 *
 * @returns {CellEvent}
 */
function CellEvent(grid) {

    /**
     * @summary Create a new CellEvent object.
     * @desc All own enumerable properties are mixed into cell editor:
     * * Includes `this.column` defined by constructor (as enumerable).
     * * Excludes `this.gridCell`, `this.dataCell`, `this.visibleRow.subgrid` defined by constructor (as non-enumerable).
     * * Any additional (enumerable) members mixed in by application's `getCellEditorAt` override.
     * @param {number} x - grid cell coordinate (adjusted for horizontal scrolling after fixed columns)
     * @param {number} y - grid cell coordinate, adjusted (adjusted for vertical scrolling if data subgrid)
     * @constructor
     */
    function CellEvent(x, y) {
        var visibleRow = grid.renderer.visibleRows[y];

        /**
         * @summary Reference to column's {@link Column} object.
         * @desc Notes:
         * * Defined as enumerable so that `CellEditor` constructor mixes into itself.
         * * Defined as writable so it can be overwritten in `renderer.paintCells`.
         * @name column
         * @type {Column}
         * @memberOf CellEvent#
         */
        this.column = grid.behavior.getActiveColumn(x);


        // remaining instance vars are non-enumerable so `CellEditor` constructor won't mix them in (for mustache use).
        Object.defineProperties(this, {
            /**
             * @name visibleColumn
             * @type {visibleColumnDescriptor}
             * @memberOf CellEvent#
             */
            visibleColumn: {
                writable: true, // Allow to be overwritten in `renderer.paintCells` and `.computeCellsBounds`.
                value: this.grid.renderer.visibleColumns.find(function(vc) { return vc.columnIndex === x; })
            },

            /**
             * @name visibleRow
             * @type {visibleRowDescriptor}
             * @memberOf CellEvent#
             */
            visibleRow: {
                writable: true, // Allow to be overwritten in `renderer.paintCells` and `.computeCellsBounds`.
                value: visibleRow
            },

            /**
             * @name gridCell
             * @type {WritablePoint}
             * @memberOf CellEvent#
             */
            gridCell: {
                value: new WritablePoint(x, y)
            },

            /**
             * @name dataCell
             * @type {WritablePoint}
             * @memberOf CellEvent#
             */
            dataCell: {
                value: new WritablePoint(this.column && this.column.index, visibleRow.rowIndex)
            }
        });
    }

    CellEvent.prototype = Object.create(prototype);

    Object.defineProperties(CellEvent.prototype, {
        constructor: { value: CellEvent },
        grid: { value: grid },
        renderer: { value: grid.renderer },
        selectionModel: { value: grid.selectionModel },
        behavior: { value: grid.behavior },
        dataModel: { value: grid.behavior.dataModel }
    });

    return CellEvent;
}

module.exports = CellEvent;

},{"rectangular":45}],117:[function(require,module,exports){
'use strict';

// console.warn polyfill as needed
// used for deprecation warnings
if (!console.warn) {
    console.warn = function() {
        console.log.apply(console, ['WARNING:'].concat(Array.prototype.slice.call(arguments)));
    };
}

var warned = {};

var regexIsMethod = /\)$/;

/**
 * User is warned and new property is returned or new method is called and the result is returned.
 * @param {string} methodName - Deprecated method name with parentheses (required) containing argument list (optional; see `args` below).
 * @param {string} dotProps - Dot-separated new property name to invoke or method name to call. Method names are indicated by including parentheses with optional argument list. The arguments in each list are drawn from the arguments presented in the `methodName` parameter.
 * @param {string} since - Version in which the name was deprecated.
 * @param {Arguments|Array} [args] - The actual arguments in the order listed in `methodName`. Only needed when arguments need to be forwarded.
 * @param {string} [notes] - Notes to add to message.
 * @returns {*} Return value of new property or method call.
 */
var deprecated = function(methodName, dotProps, since, args, notes) {
    if (!regexIsMethod.test(methodName)) {
        throw 'Expected method name to have parentheses.';
    }

    if (typeof args === 'string') {
        // `args` omitted
        notes = args;
        args = undefined;
    }

    var chain = dotProps.split('.'),
        formalArgList = argList(methodName),
        result = this;

    if (!(methodName in warned)) {
        warned[methodName] = deprecated.warnings;
    }
    if (warned[methodName]) {
        var memberType = regexIsMethod.test(dotProps) ? 'method' : 'property';
        var warning = 'The .' + methodName + ' method is deprecated as of v' + since +
            ' in favor of the .' + chain.join('.') + ' ' + memberType + '.' +
            ' (Will be removed in a future release.)';

        if (notes) {
            warning += ' ' + notes;
        }

        console.warn(warning);

        --warned[methodName];
    }

    function mapToFormalArg(argName) {
        var index = formalArgList.indexOf(argName);
        if (index === -1) {
            throw 'Actual arg "' + argName + '" not found in formal arg list ' + formalArgList;
        }
        return args[index];
    }

    for (var i = 0, last = chain.length - 1; i <= last; ++i) {
        var link = chain[i],
            name = link.match(/\w+/)[0],
            isMethod = regexIsMethod.test(link),
            actualArgList = isMethod ? argList(link) : undefined,
            actualArgs = [];

        if (actualArgList) {
            actualArgs = actualArgList.map(mapToFormalArg);
            result = result[name].apply(result, actualArgs);
        } else if (isMethod) {
            result = result[name]();
        } else {
            result = result[name];
        }
    }

    return result;
};

deprecated.warnings = 1; // 3 or 5 would get more attention

function argList(s) {
    return s.match(/^\w+\((.*)\)$/)[1].match(/(\w+)/g);
}

module.exports = deprecated;

},{}],118:[function(require,module,exports){
'use strict';

function HypergridError(message) {
    this.message = message;
}

// extend from `Error`
HypergridError.prototype = Object.create(Error.prototype);

// override error name displayed in console
HypergridError.prototype.name = 'HypergridError';

module.exports = HypergridError;

},{}],119:[function(require,module,exports){
'use strict';


/* IMPORTANT NOTE:
 * If any of the modules listed below is removed from Hypergrid, the polyfill(s) they define must be added here!!!
 *
 * 1. object-iterators defines Array.prototype.find
 */


/* eslint-disable no-extend-native */

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill
Math.sign = Math.sign || function(x) {
    x = +x; // convert to a number
    if (x === 0 || isNaN(x)) {
        return x;
    }
    return x > 0 ? 1 : -1;
};

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
if (!Array.prototype.findIndex) {
    Array.prototype.findIndex = function(predicate) {
        if (this == null) {
            throw new TypeError('Array.prototype.findIndex called on null or undefined');
        }
        if (typeof predicate !== 'function') {
            throw new TypeError('predicate must be a function');
        }
        var list = Object(this);
        var length = list.length >>> 0;
        var thisArg = arguments[1];
        var value;

        for (var i = 0; i < length; i++) {
            value = list[i];
            if (predicate.call(thisArg, value, i, list)) {
                return i;
            }
        }
        return -1;
    };
}

},{}],120:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var automat = require('automat');

var css = require('../../css');

// note the position of the  first "natural" stylesheet. We will insert our stylesheets before this node.
var head = document.querySelector('head');
var refNode = Array.prototype.slice.call(head.children).find(function(child) {
    return child.tagName === 'STYLE' ||
        child.tagName === 'LINK' &&
        child.getAttribute('rel') === 'stylesheet' &&
        child.getAttribute('type') === 'text/css';
});

exports.prefix = 'injected-stylesheet-';

exports.inject = function(id, replacements) {
    var stylesheet = document.querySelector('#' + this.prefix + id);

    if (!stylesheet) {
        stylesheet = css[id];
        stylesheet = '<style>\n' + stylesheet + '\n</style>\n';
        var args = [stylesheet, head, refNode].concat(Array.prototype.slice.call(arguments, 1));
        stylesheet = automat.append.apply(null, args)[0];
        stylesheet.id = this.prefix + id;
    }

    return stylesheet;
};

},{"../../css":1,"automat":5}]},{},[91])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvY3NzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9odG1sL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9pbWFnZXMvaW1hZ2VzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9pbWFnZXMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9hdXRvbWF0L2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvY3NzLWluamVjdG9yL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZXh0ZW5kLW1lL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmluLWh5cGVyZ3JpZC1kYXRhLXNvdXJjZS1iYXNlL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvZmluYmFycy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbmNhbnZhcy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbmNhbnZhcy9qcy9HcmFwaGljc0NvbnRleHQuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5jYW52YXMvanMvZ2MtY29uc29sZS1sb2dnZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvQWdncmVnYXRvck5vZGVCYXNlTWl4aW4uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvQWdncmVnYXRvck5vZGVHcm91cC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9BZ2dyZWdhdG9yTm9kZUxlYWYuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvQWdncmVnYXRvck5vZGVUcmVlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0Jhc2UuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YU5vZGVCYXNlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFOb2RlR3JvdXAuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YU5vZGVHcm91cFNvcnRlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhTm9kZUxlYWYuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YU5vZGVUcmVlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFTb3VyY2UuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZUFnZ3JlZ2F0b3IuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZURlcHRoU29ydGVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFTb3VyY2VHbG9iYWxGaWx0ZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZUdyb3VwVmlldy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlSW5kZXhlZC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlU29ydGVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvRGF0YVNvdXJjZVRyZWV2aWV3LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL2pzL0RhdGFTb3VyY2VUcmVldmlld0ZpbHRlci5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy9EYXRhU291cmNlVHJlZXZpZXdTb3J0ZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3MvanMvdXRpbC9NYXBweS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy91dGlsL2FnZ3JlZ2F0aW9ucy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy91dGlsL2hlYWRlcmlmeS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9qcy91dGlsL3N0YWJsZVNvcnQuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9saXN0LWRyYWdvbi9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9saWIvbHJ1LWNhY2hlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvbXVzdGFjaGUvbXVzdGFjaGUuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9vYmplY3QtaXRlcmF0b3JzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvb3ZlcnJpZGVyL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvcG9wLW1lbnUvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9yZWN0YW5ndWxhci9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL3NwYXJzZS1ib29sZWFuLWFycmF5L2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvdGFiei9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL3RlbXBsZXgvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9CYXNlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvSHlwZXJncmlkLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvU2hhcmVkLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL0JlaGF2aW9yLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL0NvbHVtbi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9KU09OLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL2NlbGxQcm9wZXJ0aWVzLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL2NvbHVtblByb3BlcnRpZXMuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9DZWxsRWRpdG9yLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvQ29sb3IuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9Db21ib0JveC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL0RhdGUuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9GaWx0ZXJCb3guanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9OdW1iZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9TbGlkZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9TcGlubmVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvVGV4dGZpZWxkLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsUmVuZGVyZXJzL0J1dHRvbi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxSZW5kZXJlcnMvQ2VsbFJlbmRlcmVyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9FcnJvckNlbGwuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsUmVuZGVyZXJzL0xhc3RTZWxlY3Rpb24uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsUmVuZGVyZXJzL1NpbXBsZUNlbGwuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsUmVuZGVyZXJzL1NsaWRlckNlbGwuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsUmVuZGVyZXJzL1NwYXJrQmFyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9TcGFya0xpbmUuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9jZWxsUmVuZGVyZXJzL1RyZWVDZWxsLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbFJlbmRlcmVycy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2RhdGFNb2RlbHMvRGF0YU1vZGVsLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZGF0YU1vZGVscy9GaWx0ZXJTdWJncmlkLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZGF0YU1vZGVscy9IZWFkZXJTdWJncmlkLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZGF0YU1vZGVscy9KU09OLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZGF0YU1vZGVscy9TdW1tYXJ5U3ViZ3JpZC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2RhdGFNb2RlbHMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9kYXRhU291cmNlcy9EYXRhU291cmNlT3JpZ2luLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZGF0YVNvdXJjZXMvaW5kZXguanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9kZWZhdWx0cy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2RpYWxvZ3MvQ29sdW1uUGlja2VyLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZGlhbG9ncy9EaWFsb2cuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9kaWFsb2dzL01hbmFnZUZpbHRlcnMuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9kaWFsb2dzL2luZGV4LmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmFrZV9kY2Y3NmY3Ny5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NlbGxDbGljay5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NlbGxFZGl0aW5nLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ2VsbFNlbGVjdGlvbi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtbkF1dG9zaXppbmcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Db2x1bW5Nb3ZpbmcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Db2x1bW5QaWNrZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Db2x1bW5SZXNpemluZy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtblNlbGVjdGlvbi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtblNvcnRpbmcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9GZWF0dXJlLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvRmlsdGVycy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0tleVBhZ2luZy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL09uSG92ZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Sb3dSZXNpemluZy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL1Jvd1NlbGVjdGlvbi5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL1RodW1id2hlZWxTY3JvbGxpbmcuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9pbmRleC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9ET00vY29weS1pbnB1dC5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9ET00vZWZmZWN0cy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9ET00vZWxmb3IuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvRE9NL3F1ZXVlbGVzcy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9Mb2NhbGl6YXRpb24uanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvUmVuZGVyZXIuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvU2VsZWN0aW9uTW9kZWwuanMiLCIvVXNlcnMvam9uYXRoYW4vcmVwb3MvdGVtcC9maW4taHlwZXJncmlkL3NyYy9saWIvY2VsbEV2ZW50RmFjdG9yeS5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9kZXByZWNhdGVkLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvbGliL2Vycm9yLmpzIiwiL1VzZXJzL2pvbmF0aGFuL3JlcG9zL3RlbXAvZmluLWh5cGVyZ3JpZC9zcmMvbGliL3BvbHlmaWxscy5qcyIsIi9Vc2Vycy9qb25hdGhhbi9yZXBvcy90ZW1wL2Zpbi1oeXBlcmdyaWQvc3JjL2xpYi9zdHlsZXNoZWV0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNweEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDandCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbm5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ArR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeDJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNycEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5ncmlkID0gW1xuJy5oeXBlcmdyaWQtY29udGFpbmVyIHsnLFxuJ1x0cG9zaXRpb246IHJlbGF0aXZlOycsXG4nXHRoZWlnaHQ6IDUwMHB4OycsXG4nfScsXG4nLmh5cGVyZ3JpZC10ZXh0ZmllbGQgeycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGZvbnQtc2l6ZTogMTJweDsnLFxuJ1x0Y29sb3I6IGJsYWNrOycsXG4nXHRiYWNrZ3JvdW5kLWNvbG9yOiBpdm9yeTsnLFxuJ1x0Ym94LXNpemluZzogYm9yZGVyLWJveDsnLFxuJ1x0bWFyZ2luOiAwOycsXG4nXHRwYWRkaW5nOiAwIDVweDsnLFxuJ1x0Ym9yZGVyOiAwOyAvKmJvcmRlcjogMXB4IHNvbGlkICM3Nzc7Ki8nLFxuJ1x0b3V0bGluZTogMDsnLFxuJ30nLFxuJycsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCB7JyxcbidcdHBvc2l0aW9uOiBhYnNvbHV0ZTsnLFxuJ1x0ZGlzcGxheTogbm9uZTsnLFxuJ1x0b3V0bGluZTogMDsnLFxuJ1x0cGFkZGluZzogMDsnLFxuJ1x0Ym9yZGVyOiAwOyAvKmJvcmRlcjogMXB4IHNvbGlkICM3Nzc7Ki8nLFxuJ1x0Ym94LXNpemluZzogYm9yZGVyLWJveDsnLFxuJ1x0YmFja2dyb3VuZC1jb2xvcjogaXZvcnk7JyxcbidcdGNvbG9yOiBibGFjazsnLFxuJ1x0Zm9udC1zaXplOiAxMnB4OycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCA+IGlucHV0IHsnLFxuJ1x0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRtYXJnaW4tdG9wOiAtMXB4OycsXG4nXHRoZWlnaHQ6IDEwMCU7JyxcbidcdHJpZ2h0OiAyMHB4OycsXG4nXHRsZWZ0OiAwOycsXG4nXHR3aWR0aDogMTAwJTsnLFxuJ1x0b3V0bGluZTogMDsnLFxuJ1x0cGFkZGluZzogMDsnLFxuJycsXG4nXHRib3JkZXI6IDVweCBzb2xpZCB0cmFuc3BhcmVudDsnLFxuJ1x0Ym9yZGVyLXJpZ2h0LXdpZHRoOiAyMHB4OycsXG4nXHRib3JkZXItYm90dG9tLXdpZHRoOiAwOycsXG4nXHRib3JkZXItdG9wLXdpZHRoOiAwOycsXG4nXHRib3gtc2l6aW5nOiBib3JkZXItYm94OycsXG4nJyxcbidcdGZvbnQtc2l6ZTogMTJweDsnLFxuJ1x0Y29sb3I6IGJsYWNrOycsXG4nXHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtY29tYm9ib3ggPiBzcGFuIHsnLFxuJ1x0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRib3gtc2l6aW5nOiBib3JkZXItYm94OycsXG4nXHR3aWR0aDogMjBweDsnLFxuJ1x0aGVpZ2h0OiAxMDAlOycsXG4nXHRyaWdodDogMDsnLFxuJ1x0dGV4dC1hbGlnbjogY2VudGVyOycsXG4nXHRmb250LXNpemU6IDEuNWVtOycsXG4nXHRsaW5lLWhlaWdodDogMWVtOycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCBzcGFuW3RpdGxlXSB7JyxcbidcdGNvbG9yOiBsaWdodGdyZXk7JyxcbidcdGN1cnNvcjogcG9pbnRlcjsnLFxuJ1x0bWFyZ2luLXRvcDogLTJweDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtY29tYm9ib3ggc3Bhblt0aXRsZV06aG92ZXIgeycsXG4nXHRjb2xvcjogZ3JleTsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtY29tYm9ib3ggc3Bhblt0aXRsZV06YWN0aXZlLCBkaXYuaHlwZXJncmlkLWNvbWJvYm94IHNwYW5bdGl0bGVdLmFjdGl2ZSB7JyxcbidcdGNvbG9yOiBibHVlOycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCA+IHNwYW4geycsXG4nXHRtYXJnaW4tdG9wOiAtMXB4OycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCA+IHNwYW46OmFmdGVyIHsnLFxuJ1x0Y29udGVudDogXFwnXFxcXDI1QkVcXCc7JyxcbidcdGZvbnQtc2l6ZTogMjBweDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtY29tYm9ib3ggPiBkaXYgeycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdGxlZnQ6IC0xcHg7JyxcbidcdHJpZ2h0OiAtMXB4OycsXG4nXHR0b3A6IDE0cHg7JyxcbidcdGhlaWdodDogMDsnLFxuJ1x0dHJhbnNpdGlvbjogaGVpZ2h0IC4yNXM7JyxcbidcdHZpc2liaWxpdHk6IGhpZGRlbjsnLFxuJ1x0Lypib3gtc2hhZG93OiB3aGl0ZSAwIDAgMXB4IDFweDsqLycsXG4nXHRib3gtc2l6aW5nOiBib3JkZXItYm94OycsXG4nXHRib3JkZXI6IDFweCBzb2xpZCAjNzc3OycsXG4nXHRiYWNrZ3JvdW5kLWNvbG9yOiBpdm9yeTsnLFxuJ1x0LXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsnLFxuJ1x0LW1vei11c2VyLXNlbGVjdDogbm9uZTsnLFxuJ1x0LW1zLXVzZXItc2VsZWN0OiBub25lOycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCA+IGRpdiA+IGRpdiB7JyxcbidcdHBvc2l0aW9uOiBhYnNvbHV0ZTsnLFxuJ1x0aGVpZ2h0OiAxM3B4OycsXG4nXHR3aWR0aDogMTAwJTsnLFxuJ1x0dGV4dC1hbGlnbjogY2VudGVyOycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCA+IGRpdiBzcGFuW3RpdGxlXSB7JyxcbidcdGZvbnQtd2VpZ2h0OiBib2xkOycsXG4nXHRmb250LXNpemU6IDEycHg7JyxcbidcdGZvbnQtZmFtaWx5OiB2ZXJkYW5hLCBnZW5ldmEsIHNhbnMtc2VyaWY7JyxcbidcdG1hcmdpbi1sZWZ0OiA2cHg7JyxcbidcdG1hcmdpbi1yaWdodDogNnB4OycsXG4nfScsXG4nZGl2Lmh5cGVyZ3JpZC1jb21ib2JveCA+IGRpdiBzcGFuOm5vdChbdGl0bGVdKSB7JyxcbidcdGZvbnQtc3R5bGU6IGl0YWxpYzsnLFxuJ1x0cGFkZGluZy10b3A6IDFweDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtY29tYm9ib3ggPiBkaXYgc2VsZWN0IHsnLFxuJ1x0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRwYWRkaW5nLXRvcDogMnB4OycsXG4nXHRib3JkZXI6IDA7JyxcbidcdG91dGxpbmU6IDA7JyxcbidcdGJvcmRlci10b3A6IDFweCBzb2xpZCAjNzc3OycsXG4nXHR3aWR0aDogMTAwJTsnLFxuJ1x0dG9wOiAxNXB4OycsXG4nXHRib3R0b206IDA7JyxcbidcdGxlZnQ6IDA7JyxcbidcdHJpZ2h0OiAwOycsXG4nXHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsnLFxuJ1x0Zm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7JyxcbidcdGZvbnQtd2VpZ2h0OiBib2xkOycsXG4nXHRmb250LXNpemU6IDlweDsnLFxuJ30nLFxuJ2Rpdi5oeXBlcmdyaWQtY29tYm9ib3ggPiBkaXYgc2VsZWN0IG9wdGlvbjpob3ZlciB7JyxcbidcdGJhY2tncm91bmQtY29sb3I6ICM3Nzc7JyxcbidcdGNvbG9yOiBpdm9yeTsnLFxuJ30nXG5dLmpvaW4oJ1xcbicpO1xuXG5leHBvcnRzWydsaXN0LWRyYWdvbi1hZGRlbmR1bSddID0gW1xuJ2Rpdi5kcmFnb24tbGlzdCwgbGkuZHJhZ29uLXBvcCB7JyxcbidcdGZvbnQtZmFtaWx5OiBSb2JvdG8sIHNhbnMtc2VyaWY7JyxcbidcdHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplOyB9JyxcbidkaXYuZHJhZ29uLWxpc3QgeycsXG4nXHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdHRvcDogNCU7JyxcbidcdGxlZnQ6IDQlOycsXG4nXHRoZWlnaHQ6IDkyJTsnLFxuJ1x0d2lkdGg6IDIwJTsgfScsXG4nZGl2LmRyYWdvbi1saXN0Om50aC1jaGlsZCgyKSB7IGxlZnQ6IDI4JTsgfScsXG4nZGl2LmRyYWdvbi1saXN0Om50aC1jaGlsZCgzKSB7IGxlZnQ6IDUyJTsgfScsXG4nZGl2LmRyYWdvbi1saXN0Om50aC1jaGlsZCg0KSB7IGxlZnQ6IDc2JTsgfScsXG4nZGl2LmRyYWdvbi1saXN0ID4gZGl2LCBkaXYuZHJhZ29uLWxpc3QgPiB1bCA+IGxpLCBsaS5kcmFnb24tcG9wIHsgbGluZS1oZWlnaHQ6IDQ2cHg7IH0nLFxuJ2Rpdi5kcmFnb24tbGlzdCA+IHVsIHsgdG9wOiA0NnB4OyB9JyxcbidkaXYuZHJhZ29uLWxpc3QgPiB1bCA+IGxpOm5vdCg6bGFzdC1jaGlsZCk6OmJlZm9yZSwgbGkuZHJhZ29uLXBvcDo6YmVmb3JlIHsnLFxuJ1x0Y29udGVudDogXFwnXFxcXDJiMjRcXCc7JyxcbidcdGNvbG9yOiAjYjZiNmI2OycsXG4nXHRmb250LXNpemU6IDMwcHg7JyxcbidcdG1hcmdpbjogOHB4IDE0cHggOHB4IDhweDsgfScsXG4nbGkuZHJhZ29uLXBvcCB7IG9wYWNpdHk6Ljg7IH0nXG5dLmpvaW4oJ1xcbicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkNRTCA9IFtcbic8bGk+JyxcbidcdDxsYWJlbCB0aXRsZT1cIiR7MX1cIj4nLFxuJ1x0XHQ8YSB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJmaWx0ZXItY29weVwiPjwvYT4nLFxuJ1x0XHQ8ZGl2IGNsYXNzPVwiZmlsdGVyLXRyZWUtcmVtb3ZlLWJ1dHRvblwiIHRpdGxlPVwiZGVsZXRlIGNvbmRpdGlvbmFsXCI+PC9kaXY+JyxcbidcdFx0PHN0cm9uZz4lezB9Ojwvc3Ryb25nPicsXG4nXHRcdDxpbnB1dCBuYW1lPVwiJHsxfVwiIGNsYXNzPVwiZmlsdGVyLXRleHQtYm94ICR7M31cIiB2YWx1ZT1cIiV7Mn1cIj4nLFxuJ1x0PC9sYWJlbD4nLFxuJ1x0PGRpdiBjbGFzcz1cImZpbHRlci10cmVlLXdhcm5cIj48L2Rpdj4nLFxuJzwvbGk+J1xuXS5qb2luKCdcXG4nKTtcblxuZXhwb3J0cy5TUUwgPSBbXG4nPGxpPicsXG4nXHQ8bGFiZWwgdGl0bGU9XCIkezF9XCI+JyxcbidcdFx0PGEgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiZmlsdGVyLWNvcHlcIj48L2E+JyxcbidcdFx0PGRpdiBjbGFzcz1cImZpbHRlci10cmVlLXJlbW92ZS1idXR0b25cIiB0aXRsZT1cImRlbGV0ZSBjb25kaXRpb25hbFwiPjwvZGl2PicsXG4nXHRcdDxzdHJvbmc+JXswfTo8L3N0cm9uZz4nLFxuJ1x0XHQ8dGV4dGFyZWEgbmFtZT1cIiR7MX1cIiByb3dzPVwiMVwiIGNsYXNzPVwiZmlsdGVyLXRleHQtYm94ICR7M31cIj4lezJ9PC90ZXh0YXJlYT4nLFxuJ1x0PC9sYWJlbD4nLFxuJ1x0PGRpdiBjbGFzcz1cImZpbHRlci10cmVlLXdhcm5cIj48L2Rpdj4nLFxuJzwvbGk+J1xuXS5qb2luKCdcXG4nKTtcblxuZXhwb3J0cy5kaWFsb2cgPSBbXG4nPGRpdiBpZD1cImh5cGVyZ3JpZC1kaWFsb2dcIj4nLFxuJycsXG4nXHQ8c3R5bGU+JyxcbidcdFx0I2h5cGVyZ3JpZC1kaWFsb2cgeycsXG4nXHRcdFx0cG9zaXRpb246IGFic29sdXRlOycsXG4nXHRcdFx0dG9wOiAwOycsXG4nXHRcdFx0bGVmdDogMDsnLFxuJ1x0XHRcdGJvdHRvbTogMDsnLFxuJ1x0XHRcdHJpZ2h0OiAwOycsXG4nXHRcdFx0YmFja2dyb3VuZC1jb2xvcjogd2hpdGU7JyxcbidcdFx0XHRmb250OiAxMHB0IHNhbnMtc2VyaWY7JyxcbidcdFx0XHRvcGFjaXR5OiAwOycsXG4nXHRcdFx0dHJhbnNpdGlvbjogb3BhY2l0eSAxczsnLFxuJ1x0XHRcdGJveC1zaGFkb3c6IHJnYmEoMCwgMCwgMCwgMC4yOTgwMzkpIDBweCAxOXB4IDM4cHgsIHJnYmEoMCwgMCwgMCwgMC4yMTk2MDgpIDBweCAxNXB4IDEycHg7JyxcbidcdFx0fScsXG4nXHRcdCNoeXBlcmdyaWQtZGlhbG9nLmh5cGVyZ3JpZC1kaWFsb2ctdmlzaWJsZSB7JyxcbidcdFx0XHRvcGFjaXR5OiAxOycsXG4nXHRcdFx0dHJhbnNpdGlvbjogb3BhY2l0eSAxczsnLFxuJ1x0XHR9JyxcbicnLFxuJ1x0XHQjaHlwZXJncmlkLWRpYWxvZyAuaHlwZXJncmlkLWRpYWxvZy1jb250cm9sLXBhbmVsIHsnLFxuJ1x0XHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTsnLFxuJ1x0XHRcdHRvcDogMHB4OycsXG4nXHRcdFx0cmlnaHQ6IDEycHg7JyxcbidcdFx0fScsXG4nXHRcdCNoeXBlcmdyaWQtZGlhbG9nIC5oeXBlcmdyaWQtZGlhbG9nLWNvbnRyb2wtcGFuZWwgYSB7JyxcbidcdFx0XHRjb2xvcjogIzk5OTsnLFxuJ1x0XHRcdGZvbnQtc2l6ZTogMzNweDsnLFxuJ1x0XHRcdHRyYW5zaXRpb246IHRleHQtc2hhZG93IC4zNXMsIGNvbG9yIC4zNXM7JyxcbidcdFx0XHR0ZXh0LWRlY29yYXRpb246IG5vbmU7JyxcbidcdFx0fScsXG4nXHRcdCNoeXBlcmdyaWQtZGlhbG9nIC5oeXBlcmdyaWQtZGlhbG9nLWNsb3NlOmFmdGVyIHsnLFxuJ1x0XHRcdGNvbnRlbnQ6IFxcJ1xcXFxEN1xcJzsnLFxuJ1x0XHR9JyxcbidcdFx0I2h5cGVyZ3JpZC1kaWFsb2cgLmh5cGVyZ3JpZC1kaWFsb2ctc2V0dGluZ3M6YWZ0ZXIgeycsXG4nXHRcdFx0Zm9udC1mYW1pbHk6IEFwcGxlIFN5bWJvbHM7JyxcbidcdFx0XHRjb250ZW50OiBcXCdcXFxcMjY5OVxcJzsnLFxuJ1x0XHR9JyxcbidcdFx0I2h5cGVyZ3JpZC1kaWFsb2cgLmh5cGVyZ3JpZC1kaWFsb2ctY29udHJvbC1wYW5lbCBhOmhvdmVyIHsnLFxuJ1x0XHRcdGNvbG9yOiBibGFjazsnLFxuJ1x0XHRcdHRleHQtc2hhZG93OiAwIDAgNnB4ICMzMzdhYjc7JyxcbidcdFx0XHR0cmFuc2l0aW9uOiB0ZXh0LXNoYWRvdyAuMzVzLCBjb2xvciAuMzVzOycsXG4nXHRcdH0nLFxuJ1x0XHQjaHlwZXJncmlkLWRpYWxvZyAuaHlwZXJncmlkLWRpYWxvZy1jb250cm9sLXBhbmVsIGE6YWN0aXZlIHsnLFxuJ1x0XHRcdGNvbG9yOiAjZDAwOycsXG4nXHRcdFx0dHJhbnNpdGlvbjogY29sb3IgMHM7JyxcbidcdFx0fScsXG4nXHQ8L3N0eWxlPicsXG4nJyxcbidcdDxzcGFuIGNsYXNzPVwiaHlwZXJncmlkLWRpYWxvZy1jb250cm9sLXBhbmVsXCI+JyxcbidcdFx0PGEgY2xhc3M9XCJoeXBlcmdyaWQtZGlhbG9nLXNldHRpbmdzXCIgdGl0bGU9XCIoVGhlcmUgYXJlIG5vIHNldHRpbmdzIGZvciBNYW5hZ2UgRmlsdGVycyBhdCB0aGlzIHRpbWUuKVwiPjwvYT4nLFxuJ1x0XHQ8YSBjbGFzcz1cImh5cGVyZ3JpZC1kaWFsb2ctY2xvc2VcIj48L2E+JyxcbidcdDwvc3Bhbj4nLFxuJycsXG4nPC9kaXY+J1xuXS5qb2luKCdcXG4nKTtcblxuZXhwb3J0cy5maWx0ZXJUcmVlcyA9IFtcbic8c3R5bGU+JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nID4gZGl2IHsnLFxuJ1x0XHRwb3NpdGlvbjogYWJzb2x1dGU7JyxcbidcdFx0dG9wOiAwOycsXG4nXHRcdGxlZnQ6IDA7JyxcbidcdFx0Ym90dG9tOiAwOycsXG4nXHRcdHJpZ2h0OiAwOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nID4gZGl2OmZpcnN0LW9mLXR5cGUgeycsXG4nXHRcdHBhZGRpbmc6IDFlbSAxZW0gMWVtIDAuNWVtOycsXG4nXHRcdG1hcmdpbi1sZWZ0OiA1MCU7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgPiBkaXY6bGFzdC1vZi10eXBlIHsnLFxuJ1x0XHRwYWRkaW5nOiAxZW0gMC41ZW0gMWVtIDFlbTsnLFxuJ1x0XHRtYXJnaW4tcmlnaHQ6IDUwJTsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyA+IGRpdiA+IHA6Zmlyc3QtY2hpbGQgeycsXG4nXHRcdG1hcmdpbi10b3A6IDA7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgPiBkaXYgPiBwID4gc3BhbjpmaXJzdC1jaGlsZCB7JyxcbidcdFx0Zm9udC1zaXplOiBsYXJnZXI7JyxcbidcdFx0bGV0dGVyLXNwYWNpbmc6IDJweDsnLFxuJ1x0XHRmb250LXdlaWdodDogYm9sZDsnLFxuJ1x0XHRjb2xvcjogIzY2NjsnLFxuJ1x0XHRtYXJnaW4tcmlnaHQ6IDFlbTsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyBpbnB1dCwgI2h5cGVyZ3JpZC1kaWFsb2cgdGV4dGFyZWEgeycsXG4nXHRcdG91dGxpbmU6IDA7JyxcbidcdFx0bGluZS1oZWlnaHQ6IGluaXRpYWw7JyxcbidcdH0nLFxuJycsXG4nXHQudGFieiB7IHotaW5kZXg6IDAgfScsXG4nXHQudGFieiA+IHA6Zmlyc3QtY2hpbGQsIC50YWJ6ID4gc2VjdGlvbiA+IHA6Zmlyc3QtY2hpbGQsIC50YWJ6ID4gc2VjdGlvbiA+IGRpdiA+IHA6Zmlyc3QtY2hpbGQgeyBtYXJnaW4tdG9wOiAwIH0nLFxuJycsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyBhLm1vcmUtaW5mbyB7IGZvbnQtc2l6ZTogc21hbGxlcjsgfScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyBhLm1vcmUtaW5mbzo6YWZ0ZXIgeyBjb250ZW50OiBcXCcobW9yZSBpbmZvKVxcJzsgfScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyBhLm1vcmUtaW5mby5oaWRlLWluZm8geyBjb2xvcjogcmVkOyB9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIGEubW9yZS1pbmZvLmhpZGUtaW5mbzo6YWZ0ZXIgeyBjb250ZW50OiBcXCcoaGlkZSBpbmZvKVxcJzsgfScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyBkaXYubW9yZS1pbmZvIHsnLFxuJ1x0XHRib3JkZXI6IDFweCB0YW4gc29saWQ7JyxcbidcdFx0Ym9yZGVyLXJhZGl1czogOHB4OycsXG4nXHRcdHBhZGRpbmc6IDAgOHB4IC4yZW07JyxcbidcdFx0ZGlzcGxheTogbm9uZTsnLFxuJ1x0XHRiYWNrZ3JvdW5kLWNvbG9yOiBpdm9yeTsnLFxuJ1x0XHRib3gtc2hhZG93OiAzcHggM3B4IDVweCAjNzA3MDcwOycsXG4nXHRcdG1hcmdpbi1ib3R0b206IDFlbTsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyBkaXYubW9yZS1pbmZvID4gcCB7IG1hcmdpbjogLjVlbSAwOyB9JyxcbicnLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogdWwgeycsXG4nXHRcdHBhZGRpbmctbGVmdDogMS41ZW07JyxcbidcdFx0bGlzdC1zdHlsZS10eXBlOiBjaXJjbGU7JyxcbidcdFx0Zm9udC13ZWlnaHQ6IGJvbGQ7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogdWwgPiBsaSA+IHVsIHsnLFxuJ1x0XHRsaXN0LXN0eWxlLXR5cGU6IGRpc2M7JyxcbidcdFx0Zm9udC13ZWlnaHQ6IG5vcm1hbDsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiBsaSB7JyxcbidcdFx0bWFyZ2luOiAuM2VtIDA7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogbGkgPiBjb2RlIHsnLFxuJ1x0XHRiYWNrZ3JvdW5kOiAjZTBlMGUwOycsXG4nXHRcdG1hcmdpbjogMCAuMWVtOycsXG4nXHRcdHBhZGRpbmc6IDAgNXB4OycsXG4nXHRcdGJvcmRlci1yYWRpdXM6IDRweDsnLFxuJ1x0fScsXG4nJyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6ID4gc2VjdGlvbi5maWx0ZXItZXhwcmVzc2lvbi1zeW50YXggPiBkaXY6bGFzdC1jaGlsZCBvbCB7JyxcbidcdFx0cGFkZGluZy1sZWZ0OiAxLjZlbTsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiA+IHNlY3Rpb24uZmlsdGVyLWV4cHJlc3Npb24tc3ludGF4ID4gZGl2Omxhc3QtY2hpbGQgb2wgPiBsaSA+IGxhYmVsIHsnLFxuJ1x0XHR3aWR0aDogMTAwJTsnLFxuJ1x0XHRmb250LXdlaWdodDogbm9ybWFsOycsXG4nXHRcdGRpc3BsYXk6IGlubGluZTsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiAuZmlsdGVyLXRyZWUtd2FybiB7JyxcbidcdFx0Y29sb3I6IGRhcmtyZWQ7JyxcbidcdFx0Zm9udC1zaXplOiBzbWFsbGVyOycsXG4nXHRcdGZvbnQtc3R5bGU6IGl0YWxpYzsnLFxuJ1x0XHRsaW5lLWhlaWdodDogaW5pdGlhbDsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiA+IHNlY3Rpb24uZmlsdGVyLWV4cHJlc3Npb24tc3ludGF4ID4gdGV4dGFyZWEsJyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6ID4gc2VjdGlvbi5maWx0ZXItZXhwcmVzc2lvbi1zeW50YXggPiBkaXY6bGFzdC1jaGlsZCB0ZXh0YXJlYSwnLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogPiBzZWN0aW9uLmZpbHRlci1leHByZXNzaW9uLXN5bnRheCA+IGRpdjpsYXN0LWNoaWxkIGlucHV0IHsnLFxuJ1x0XHRkaXNwbGF5OiBibG9jazsnLFxuJ1x0XHRwb3NpdGlvbjogcmVsYXRpdmU7JyxcbidcdFx0bWluLXdpZHRoOiAxMDAlOycsXG4nXHRcdG1heC13aWR0aDogMTAwJTsnLFxuJ1x0XHRib3gtc2l6aW5nOiBib3JkZXItYm94OycsXG4nXHRcdGJvcmRlcjogMXB4IHNvbGlkIGJsYWNrOycsXG4nXHRcdHBhZGRpbmc6IC40ZW0gLjdlbTsnLFxuJ1x0XHRmb250LWZhbWlseTogbW9ub3NwYWNlOycsXG4nXHRcdGZvbnQtc2l6ZTogOXB0OycsXG4nXHRcdG1hcmdpbi10b3A6IDNweDsnLFxuJ1x0fScsXG4nXHQjaHlwZXJncmlkLWRpYWxvZyAudGFieiA+IHNlY3Rpb24uZmlsdGVyLWV4cHJlc3Npb24tc3ludGF4ID4gdGV4dGFyZWEgeycsXG4nXHRcdGhlaWdodDogOTYlOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6IGEuZmlsdGVyLWNvcHkgeycsXG4nXHRcdGRpc3BsYXk6IGJsb2NrOycsXG4nXHRcdGZsb2F0OiByaWdodDsnLFxuJ1x0XHRmb250LXNpemU6IHNtYWxsZXI7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogYS5maWx0ZXItY29weTpiZWZvcmUgeycsXG4nXHRcdGNvbnRlbnQ6IFxcJyhjb3B5XFwnOycsXG4nXHR9JyxcbidcdCNoeXBlcmdyaWQtZGlhbG9nIC50YWJ6IGEuZmlsdGVyLWNvcHk6YWZ0ZXIgeycsXG4nXHRcdGNvbnRlbnQ6IFxcJylcXCc7JyxcbidcdH0nLFxuJ1x0I2h5cGVyZ3JpZC1kaWFsb2cgLnRhYnogYS5maWx0ZXItY29weTphY3RpdmUgeycsXG4nXHRcdGNvbG9yOiByZWQ7JyxcbidcdH0nLFxuJzwvc3R5bGU+JyxcbicnLFxuJzxkaXY+JyxcbidcdDxzZWxlY3QgaWQ9XCJhZGQtY29sdW1uLWZpbHRlci1zdWJleHByZXNzaW9uXCIgc3R5bGU9XCJmbG9hdDpyaWdodDsgbWFyZ2luLWxlZnQ6MWVtOyBtYXJnaW4tcmlnaHQ6NGVtO1wiPicsXG4nXHRcdDxvcHRpb24gdmFsdWU9XCJcIj5OZXcgY29sdW1uIGZpbHRlciZoZWxsaXA7PC9vcHRpb24+JyxcbidcdDwvc2VsZWN0PicsXG4nJyxcbidcdDxwPicsXG4nXHRcdDxzcGFuPkNvbHVtbiBGaWx0ZXJzPC9zcGFuPicsXG4nXHRcdDxhIGNsYXNzPVwibW9yZS1pbmZvXCI+PC9hPicsXG4nXHQ8L3A+JyxcbidcdDxkaXYgY2xhc3M9XCJtb3JlLWluZm9cIj4nLFxuJ1x0XHQ8cD5UaGUgdGFibGUgZmlsdGVyIGNhbiBiZSB2aWV3ZWQgaW4gdGhlIFF1ZXJ5IEJ1aWxkZXIgb3IgYXMgU1FMIFdIRVJFIGNsYXVzZSBzeW50YXguIEJvdGggaW50ZXJmYWNlcyBtYW5pcHVsYXRlIHRoZSBzYW1lIHVuZGVybHlpbmcgZmlsdGVyIGRhdGEgc3RydWN0dXJlLjwvcD4nLFxuJ1x0XHQ8cD5BbGwgY29sdW1uIGZpbHRlcnMgYXJlIEFORCZyc3F1bztkIHRvZ2V0aGVyLiBFYWNoIGdyaWQgcm93IGlzIGZpcnN0IHF1YWxpZmllZCBieSB0aGUgdGFibGUgZmlsdGVyIGFuZCB0aGVuIHN1Y2Nlc3NpdmVseSBxdWFsaWZpZWQgYnkgZWFjaCBjb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb24uPC9wPicsXG4nXHQ8L2Rpdj4nLFxuJycsXG4nXHQ8ZGl2IGNsYXNzPVwidGFielwiIGlkPVwiY29sdW1uRmlsdGVyc1BhbmVsXCI+JyxcbicnLFxuJ1x0XHQ8aGVhZGVyIGlkPVwiY29sdW1uc1FCXCIgY2xhc3M9XCJkZWZhdWx0LXRhYlwiPicsXG4nXHRcdFx0UXVlcnkgQnVpbGRlcicsXG4nXHRcdDwvaGVhZGVyPicsXG4nJyxcbidcdFx0PHNlY3Rpb24+JyxcbidcdFx0PC9zZWN0aW9uPicsXG4nJyxcbidcdFx0PGhlYWRlciBpZD1cImNvbHVtbnNTUUxcIiBjbGFzcz1cInRhYnotYmcyXCI+JyxcbidcdFx0XHRTUUwnLFxuJ1x0XHQ8L2hlYWRlcj4nLFxuJycsXG4nXHRcdDxzZWN0aW9uIGNsYXNzPVwiZmlsdGVyLWV4cHJlc3Npb24tc3ludGF4IHRhYnotYmcyXCI+JyxcbidcdFx0XHQ8ZGl2PicsXG4nXHRcdFx0XHQ8cD4nLFxuJ1x0XHRcdFx0XHQ8c3Bhbj48L3NwYW4+JyxcbidcdFx0XHRcdFx0PGEgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiZmlsdGVyLWNvcHlcIiB0aXRsZT1cIlRoZSBzdGF0ZSBvZiB0aGUgY29sdW1uIGZpbHRlcnMgc3VidHJlZSBleHByZXNzZWQgaW4gU1FMIHN5bnRheCAoYWxsIHRoZSBjb2x1bW4gZmlsdGVyIHN1YmV4cHJlc3Npb25zIHNob3duIGJlbG93IEFORCZyc3F1bztkIHRvZ2V0aGVyKS5cIj4nLFxuJ1x0XHRcdFx0XHRcdGFsbDwvYT4nLFxuJ1x0XHRcdFx0PC9wPicsXG4nXHRcdFx0XHQ8b2w+PC9vbD4nLFxuJ1x0XHRcdDwvZGl2PicsXG4nXHRcdDwvc2VjdGlvbj4nLFxuJycsXG4nXHRcdDxoZWFkZXIgaWQ9XCJjb2x1bW5zQ1FMXCIgY2xhc3M9XCJ0YWJ6LWJnMVwiPicsXG4nXHRcdFx0Q1FMJyxcbidcdFx0PC9oZWFkZXI+JyxcbicnLFxuJ1x0XHQ8c2VjdGlvbiBjbGFzcz1cImZpbHRlci1leHByZXNzaW9uLXN5bnRheCB0YWJ6LWJnMVwiPicsXG4nXHRcdFx0PHA+JyxcbidcdFx0XHRcdDxlbT4nLFxuJ1x0XHRcdFx0XHQ8c21hbGw+Q29sdW1uIGZpbHRlciBjZWxscyBhY2NlcHQgYSBzaW1wbGlmaWVkLCBjb21wYWN0LCBhbmQgaW50dWl0aXZlIHN5bnRheCwgd2hpY2ggaXMgaG93ZXZlciBub3QgYXMgZmxleGlibGUgb3IgY29uY2lzZSBhcyBTUUwgc3ludGF4IG9yIHVzaW5nIHRoZSBRdWVyeSBCdWlsZGVyLjwvc21hbGw+JyxcbidcdFx0XHRcdFx0PGEgY2xhc3M9XCJtb3JlLWluZm9cIj48L2E+JyxcbidcdFx0XHRcdDwvZW0+JyxcbidcdFx0XHQ8L3A+JyxcbidcdFx0XHQ8ZGl2IGNsYXNzPVwibW9yZS1pbmZvXCI+JyxcbidcdFx0XHRcdDx1bD4nLFxuJ1x0XHRcdFx0XHQ8bGk+JyxcbidcdFx0XHRcdFx0XHRTaW1wbGUgZXhwcmVzc2lvbnMnLFxuJ1x0XHRcdFx0XHRcdDx1bD4nLFxuJ1x0XHRcdFx0XHRcdFx0PGxpPkFsbCBzaW1wbGUgZXhwcmVzc2lvbnMgdGFrZSB0aGUgZm9ybSA8aT5vcGVyYXRvciBsaXRlcmFsPC9pPiBvciA8aT5vcGVyYXRvciBpZGVudGlmaWVyPC9pPi4gVGhlIChsZWZ0IHNpZGUpIGNvbHVtbiBpcyBhbHdheXMgaW1wbGllZCBhbmQgaXMgdGhlIHNhbWUgZm9yIGFsbCBzaW1wbGUgZXhwcmVzc2lvbnMgaW4gYSBjb21wb3VuZCBleHByZXNzaW9uLiBUaGlzIGlzIGJlY2F1c2UgY29sdW1uIGZpbHRlcnMgYXJlIGFsd2F5cyB0aWVkIHRvIGEga25vd24gY29sdW1uLjwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdFx0PGxpPklmIHRoZSBvcGVyYXRvciBpcyBhbiBlcXVhbHMgc2lnbiAoPSksIGl0IG1heSBiZSBvbWl0dGVkLjwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdFx0PGxpPkJlc2lkZXMgb3BlcmF0b3JzLCBubyBvdGhlciBwdW5jdHVhdGlvbiBpcyBwZXJtaXR0ZWQsIG1lYW5pbmcgdGhhdCBubyBxdW90YXRpb24gbWFya3MgYW5kIG5vIHBhcmVudGhlc2VzLjwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdFx0PGxpPklmIGEgbGl0ZXJhbCBleGFjdGx5IG1hdGNoZXMgYSBjb2x1bW4gbmFtZSBvciBhbGlhcywgdGhlIG9wZXJhbmQgaXMgbm90IHRha2VuIGxpdGVyYWxseSBhbmQgaW5zdGVhZCByZWZlcnMgdG8gdGhlIHZhbHVlIGluIHRoYXQgY29sdW1uLiAoVGhlcmUgYXJlIHByb3BlcnRpZXMgdG8gY29udHJvbCB3aGF0IGNvbnN0aXR1dGVzIHN1Y2ggYSBtYXRjaDogQ29sdW1uIG5hbWUsIGFsaWFzLCBvciBlaXRoZXI7IGFuZCB0aGUgY2FzZS1zZW5zaXRpdml0eSBvZiB0aGUgbWF0Y2guKTwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdFx0PGxpPkFzIGxpdGVyYWxzIGFyZSB1bnF1b3RlZCwgYW55IG9wZXJhdG9yIHN5bWJvbCBvciBvcGVyYXRvciB3b3JkIChpbmNsdWRpbmcgbG9naWNhbCBvcGVyYXRvcnMgZm9yIGNvbXBvdW5kIGV4cHJlc3Npb25zKSB0ZXJtaW5hdGVzIGEgbGl0ZXJhbC48L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHRcdDxsaT5BbiBpbXBvcnRhbnQgY29yb2xsYXJ5IHRvIHRoZSBhYm92ZSBmZWF0dXJlcyBpcyB0aGF0IG9wZXJhdG9ycyBtYXkgbm90IGFwcGVhciBpbiBsaXRlcmFscy48L2xpPicsXG4nXHRcdFx0XHRcdFx0PC91bD4nLFxuJ1x0XHRcdFx0XHQ8L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0PGxpPicsXG4nXHRcdFx0XHRcdFx0Q29tcG91bmQgZXhwcmVzc2lvbnMnLFxuJ1x0XHRcdFx0XHRcdDx1bD4nLFxuJ1x0XHRcdFx0XHRcdFx0PGxpPkNvbXBvdW5kIGV4cHJlc3Npb25zIGFyZSBmb3JtZWQgYnkgY29ubmVjdGluZyBzaW1wbGUgZXhwcmVzc2lvbnMgd2l0aCB0aGUgbG9naWNhbCBvcGVyYXRvcnMgPGNvZGU+QU5EPC9jb2RlPiwgPGNvZGU+T1I8L2NvZGU+LCA8Y29kZT5OT1I8L2NvZGU+LCBvciA8Y29kZT5OQU5EPC9jb2RlPiAoXCJub3QgYW5kXCIpLjwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdFx0PGxpPkhvd2V2ZXIsIGFsbCBsb2dpY2FsIG9wZXJhdG9ycyB1c2VkIGluIGEgY29tcG91bmQgY29sdW1uIGZpbHRlciBleHByZXNzaW9uIG11c3QgYmUgaG9tb2dlbmVvdXMuIFlvdSBtYXkgbm90IG1peCB0aGUgYWJvdmUgbG9naWNhbCBvcGVyYXRvcnMgaW4gYSBzaW5nbGUgY29sdW1uLiAoSWYgeW91IG5lZWQgdG8gZG8gdGhpcywgY3JlYXRlIGEgdGFibGUgZmlsdGVyIGV4cHJlc3Npb24gaW5zdGVhZC4pPC9saT4nLFxuJ1x0XHRcdFx0XHRcdDwvdWw+JyxcbidcdFx0XHRcdFx0PC9saT4nLFxuJycsXG4nXHRcdFx0XHRcdDxsaT4nLFxuJ1x0XHRcdFx0XHRcdEhpZGRlbiBsb2dpYycsXG4nXHRcdFx0XHRcdFx0PHVsPicsXG4nXHRcdFx0XHRcdFx0XHQ8bGk+SWYgdGhlIGNvbHVtbiBpcyBhbHNvIHJlZmVyZW5jZWQgaW4gYSB0YWJsZSBmaWx0ZXIgZXhwcmVzc2lvbiAob24gdGhlIGxlZnQgc2lkZSBvZiBhIHNpbXBsZSBleHByZXNzaW9uKSwgdGhlIGNvbHVtbiBmaWx0ZXIgaXMgZmxhZ2dlZCBpbiBpdHMgZ3JpZCBjZWxsIHdpdGggYSBzcGVjaWFsIHN0YXIgY2hhcmFjdGVyLiBUaGlzIGlzIGp1c3QgYSBmbGFnOyBpdCBpcyBub3QgcGFydCBvZiB0aGUgc3ludGF4LiA8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDsgZm9udC1zdHlsZTppdGFsaWNcIj5Ob3QgeWV0IGltcGxlbWVudGVkLjwvc3Bhbj48L2xpPicsXG4nXHRcdFx0XHRcdFx0PC91bD4nLFxuJ1x0XHRcdFx0XHQ8L2xpPicsXG4nXHRcdFx0XHQ8L3VsPicsXG4nXHRcdFx0PC9kaXY+JyxcbicnLFxuJ1x0XHRcdDxkaXY+JyxcbidcdFx0XHRcdDxwPjxzcGFuPjwvc3Bhbj48L3A+JyxcbidcdFx0XHRcdDxvbD48L29sPicsXG4nXHRcdFx0PC9kaXY+JyxcbidcdFx0PC9zZWN0aW9uPicsXG4nXHQ8L2Rpdj4nLFxuJzwvZGl2PicsXG4nJyxcbic8ZGl2PicsXG4nXHQ8cD4nLFxuJ1x0XHQ8c3Bhbj5UYWJsZSBGaWx0ZXI8L3NwYW4+JyxcbidcdFx0PGEgY2xhc3M9XCJtb3JlLWluZm9cIj48L2E+JyxcbidcdDwvcD4nLFxuJ1x0PGRpdiBjbGFzcz1cIm1vcmUtaW5mb1wiPicsXG4nXHRcdDxwPlRoZSB0YWJsZSBmaWx0ZXIgY2FuIGJlIHZpZXdlZCBpbiB0aGUgUXVlcnkgQnVpbGRlciBvciBhcyBTUUwgV0hFUkUgY2xhdXNlIHN5bnRheC4gQm90aCBpbnRlcmZhY2VzIG1hbmlwdWxhdGUgdGhlIHNhbWUgdW5kZXJseWluZyBmaWx0ZXIgZGF0YSBzdHJ1Y3R1cmUuPC9wPicsXG4nXHRcdDxwPicsXG4nXHRcdFx0VGhlc2UgZmlsdGVyIHN1YmV4cHJlc3Npb25zIGFyZSBib3RoIHJlcXVpcmVkICg8Y29kZT5BTkQ8L2NvZGU+JnJzcXVvO2QgdG9nZXRoZXIpLCByZXN1bHRpbmcgaW4gYSBzdWJzZXQgb2YgPGVtPnF1YWxpZmllZCByb3dzPC9lbT4gd2hpY2ggaGF2ZSBwYXNzZWQgdGhyb3VnaCBib3RoIGZpbHRlcnMuJyxcbidcdFx0XHRJdFxcJ3MgY2FsbGVkIGEgPGRmbj50cmVlPC9kZm4+IGJlY2F1c2UgaXQgY29udGFpbnMgYm90aCA8ZGZuPmJyYW5jaGVzPC9kZm4+IGFuZCA8ZGZuPmxlYXZlczwvZGZuPi4nLFxuJ1x0XHRcdFRoZSBsZWF2ZXMgcmVwcmVzZW50IDxkZm4+Y29uZGl0aW9uYWwgZXhwcmVzc2lvbnM8L2Rmbj4gKG9yIHNpbXBseSA8ZGZuPmNvbmRpdGlvbmFsczwvZGZuPikuJyxcbidcdFx0XHRUaGUgYnJhbmNoZXMsIGFsc28ga25vd24gYXMgPGRmbj5zdWJ0cmVlczwvZGZuPiwgY29udGFpbiBsZWF2ZXMgYW5kL29yIG90aGVyIGJyYW5jaGVzIGFuZCByZXByZXNlbnQgc3ViZXhwcmVzc2lvbnMgdGhhdCBncm91cCBjb25kaXRpb25hbHMgdG9nZXRoZXIuJyxcbidcdFx0XHRHcm91cGVkIGNvbmRpdGlvbmFscyBhcmUgZXZhbHVhdGVkIHRvZ2V0aGVyLCBiZWZvcmUgY29uZGl0aW9uYWxzIG91dHNpZGUgdGhlIGdyb3VwLicsXG4nXHRcdDwvcD4nLFxuJ1x0PC9kaXY+JyxcbicnLFxuJ1x0PGRpdiBjbGFzcz1cInRhYnpcIiBpZD1cInRhYmxlRmlsdGVyUGFuZWxcIj4nLFxuJ1x0XHQ8aGVhZGVyIGlkPVwidGFibGVRQlwiPicsXG4nXHRcdFx0UXVlcnkgQnVpbGRlcicsXG4nXHRcdDwvaGVhZGVyPicsXG4nJyxcbidcdFx0PHNlY3Rpb24+JyxcbidcdFx0PC9zZWN0aW9uPicsXG4nJyxcbidcdFx0PGhlYWRlciBpZD1cInRhYmxlU1FMXCIgY2xhc3M9XCJ0YWJ6LWJnMlwiPicsXG4nXHRcdFx0U1FMJyxcbidcdFx0PC9oZWFkZXI+JyxcbicnLFxuJ1x0XHQ8c2VjdGlvbiBjbGFzcz1cImZpbHRlci1leHByZXNzaW9uLXN5bnRheCB0YWJ6LWJnMlwiPicsXG4nXHRcdFx0PGRpdj4nLFxuJ1x0XHRcdFx0PHA+JyxcbidcdFx0XHRcdFx0U1FMIFdIRVJFIGNsYXVzZSBzeW50YXggd2l0aCBjZXJ0YWluIHJlc3RyaWN0aW9ucy4nLFxuJ1x0XHRcdFx0XHQ8YSBjbGFzcz1cIm1vcmUtaW5mb1wiPjwvYT4nLFxuJ1x0XHRcdFx0PC9wPicsXG4nXHRcdFx0XHQ8ZGl2IGNsYXNzPVwibW9yZS1pbmZvXCI+JyxcbidcdFx0XHRcdFx0PHVsPicsXG4nXHRcdFx0XHRcdFx0PGxpPicsXG4nXHRcdFx0XHRcdFx0XHRTaW1wbGUgZXhwcmVzc2lvbnMnLFxuJ1x0XHRcdFx0XHRcdFx0PHVsPicsXG4nXHRcdFx0XHRcdFx0XHRcdDxsaT5BbGwgc2ltcGxlIGV4cHJlc3Npb25zIG11c3QgYmUgb2YgdGhlIGZvcm0gPGk+Y29sdW1uIG9wZXJhdG9yIGxpdGVyYWw8L2k+IG9yIDxpPmNvbHVtbiBvcGVyYXRvciBpZGVudGlmaWVyPC9pPi4gVGhhdCBpcywgdGhlIGxlZnQgc2lkZSBtdXN0IHJlZmVyIHRvIGEgY29sdW1uIChtYXkgbm90IGJlIGEgbGl0ZXJhbCk7IHdoZXJlYXMgdGhlIHJpZ2h0IHNpZGUgbWF5IGJlIGVpdGhlci48L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHRcdFx0PGxpPkNvbHVtbiBuYW1lcyBtYXkgYmUgcXVvdGVkIHdpdGggdGhlIGN1cnJlbnRseSBzZXQgcXVvdGUgY2hhcmFjdGVycyAodHlwaWNhbGx5IGRvdWJsZS1xdW90ZXMpLiBJZiB1bnF1b3RlZCwgdGhleSBtdXN0IGNvbnNpc3Qgb2YgY2xhc3NpYyBpZGVudGlmaWVyIHN5bnRheCAoYWxwaGFudW1lcmljcyBhbmQgdW5kZXJzY29yZSwgYnV0IG5vdCBiZWdpbm5pbmcgd2l0aCBhIG51bWVyYWwpLjwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdFx0XHQ8bGk+QWxsIGxpdGVyYWxzIG11c3QgYmUgcXVvdGVkIHN0cmluZ3MgKHVzaW5nIHNpbmdsZSBxdW90ZXMpLiAoSW4gYSBmdXR1cmUgcmVsZWFzZSB3ZSBleHBlY3QgdG8gc3VwcG9ydCB1bnF1b3RlZCBudW1lcmljIHN5bnRheCBmb3IgY29sdW1ucyBleHBsaWNpdGx5IHR5cGVkIGFzIG51bWVyaWMuKTwvbGk+JyxcbidcdFx0XHRcdFx0XHRcdDwvdWw+JyxcbidcdFx0XHRcdFx0XHQ8L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHQ8bGk+JyxcbidcdFx0XHRcdFx0XHRcdENvbXBvdW5kIGV4cHJlc3Npb25zJyxcbidcdFx0XHRcdFx0XHRcdDx1bD4nLFxuJ1x0XHRcdFx0XHRcdFx0XHQ8bGk+Q29tcG91bmQgZXhwcmVzc2lvbnMgYXJlIGZvcm1lZCBieSBjb25uZWN0aW5nIHNpbXBsZSBleHByZXNzaW9ucyB3aXRoIHRoZSBsb2dpY2FsIG9wZXJhdG9ycyA8Y29kZT5BTkQ8L2NvZGU+IG9yIDxjb2RlPk9SPC9jb2RlPi48L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHRcdFx0PGxpPkhvd2V2ZXIsIGFsbCBsb2dpY2FsIG9wZXJhdG9ycyBhdCBlYWNoIGxldmVsIGluIGEgY29tcGxleCBleHByZXNzaW9uIChlYWNoIHBhcmVudGhlc2l6ZWQgc3ViZXhwcmVzc2lvbikgbXVzdCBiZSBob21vZ2VuZW91cywgPGk+aS5lLiw8L2k+IGVpdGhlciA8Y29kZT5BTkQ8L2NvZGU+IG9yIDxjb2RlPk9SPC9jb2RlPiBidXQgbm90IGEgbWl4dHVyZSBvZiB0aGUgdHdvLiBJbiBvdGhlciB3b3JkcywgdGhlcmUgaXMgbm8gaW1wbGljaXQgb3BlcmF0b3IgcHJlY2VkZW5jZTsgZ3JvdXBpbmcgb2YgZXhwcmVzc2lvbnMgbXVzdCBhbHdheXMgYmUgZXhwbGljaXRseSBzdGF0ZWQgd2l0aCBwYXJlbnRoZXNlcy48L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHRcdFx0PGxpPlRoZSB1bmFyeSBsb2dpY2FsIG9wZXJhdG9yIDxjb2RlPk5PVDwvY29kZT4gaXMgc3Vwb29ydGVkIGJlZm9yZSBwYXJlbnRoZXNlcyBvbmx5LiBXaGlsZSB0aGUgUXVlcnkgQnVpbGRlciBhbmQgdGhlIENvbHVtbiBGaWx0ZXIgYWxsb3cgdGhleSBzeW50YXggPGNvZGU+JmhlbGxpcDsgTk9UIDxpPm9wZXJhdG9yPC9pPiAmaGVsbGlwOzwvY29kZT4gKHdoZXJlIDxjb2RlPjxpPm9wZXJhdG9yPC9pPjwvY29kZT4gaXMgPGNvZGU+SU48L2NvZGU+LCA8Y29kZT5MSUtFPC9jb2RlPiwgPGk+ZXRjLjwvaT4pLCB0aGVzZSBtdXN0IGJlIGV4cHJlc3NlZCBoZXJlIHdpdGggcGFyZW50aGV0aGVzOiA8Y29kZT5OT1QgKCZoZWxsaXA7IDxpPm9wZXJhdG9yPC9pPiAmaGVsbGlwOyk8L2NvZGU+LjwvbGk+JyxcbicnLFxuJ1x0XHRcdFx0XHRcdFx0XHQ8bGk+V2hpbGUgdGhlIFF1ZXJ5IEJ1aWxkZXIgYW5kIENvbHVtbiBGaWx0ZXIgc3ludGF4IHN1cHBvcnQgdGhlIHBzZXVkby1vcGVyYXRvcnMgPGNvZGU+Tk9SPC9jb2RlPiBhbmQgPGNvZGU+TkFORDwvY29kZT4sIGluIFNRTCB0aGVzZSBtdXN0IGJlIGV4cHJlc3NlZCBhcyA8Y29kZT5OT1QgKCZoZWxsaXA7IE9SICZoZWxsaXA7KTwvY29kZT4gYW5kIDxjb2RlPk5PVCAoJmhlbGxpcDsgQU5EICZoZWxsaXA7KTwvY29kZT4sIHJlc3BlY3RpdmVseS48L2xpPicsXG4nJyxcbidcdFx0XHRcdFx0XHRcdFx0PGxpPlRoZSBRdWVyeSBCdWlsZGVyIGFuZCBDb2x1bW4gRmlsdGVyIHN5bnRheCBhbHNvIHN1cHBvcnQgdGhlIHBzZXVkby1vcGVyYXRvcnMgPGNvZGU+QkVHSU5TIGFiYzwvY29kZT4sIDxjb2RlPkVORFMgeHl6PC9jb2RlPiwgYW5kIDxjb2RlPkNPTlRBSU5TIGRlZjwvY29kZT4uIFRoZXNlIGFyZSBleHByZXNzZWQgaW4gU1FMIGJ5IDxjb2RlPkxJS0UgXFwnYWJjJVxcJzwvY29kZT4sIDxjb2RlPkxJS0UgXFwnJXh5elxcJzwvY29kZT4sIGFuZCA8Y29kZT5MSUtFIFxcJyVkZWYlXFwnPC9jb2RlPiwgcmVzcGVjdGl2ZWx5LjwvbGk+JyxcbidcdFx0XHRcdFx0XHRcdDwvdWw+JyxcbidcdFx0XHRcdFx0XHQ8L2xpPicsXG4nXHRcdFx0XHRcdDwvdWw+JyxcbidcdFx0XHRcdDwvZGl2PicsXG4nXHRcdFx0PC9kaXY+JyxcbidcdFx0XHQ8ZGl2IGNsYXNzPVwiZmlsdGVyLXRyZWUtd2FyblwiPjwvZGl2PicsXG4nXHRcdFx0PHRleHRhcmVhPjwvdGV4dGFyZWE+JyxcbidcdFx0PC9zZWN0aW9uPicsXG4nJyxcbidcdDwvZGl2PicsXG4nPC9kaXY+J1xuXS5qb2luKCdcXG4nKTtcbiIsIm1vZHVsZS5leHBvcnRzID0geyAvLyBUaGlzIGZpbGUgZ2VuZXJhdGVkIGJ5IGd1bHAtaW1hZ2luZS02NCBhdCAxMToyMzo0OSBBTSBvbiAxMC8yOC8yMDE2XG5cdFwiY2FsZW5kYXJcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQW9BQUFBS0NBWUFBQUNOTXMrOUFBQUFjMGxFUVZSNG5JWFF3UWtDTVJTRTRVOVpMTUNUOVhqYXEyQWZOaGZZVTVvUUxNQU90b040OEVXZWk1aUJJUlBlL3lZUTNxcmhmMWxGRzdpS2NFYUp4U2Z1a1V2TVdnZEhhdnQwdVdIdGcyUXd4WG5BbkpaMnVPTHlWWnR5Ynp6aGdXTm1mb0ZsMC9ZQjg3TmJ6UjFjalA5eGVRSFNEQzZtY0wxeEZRQUFBQUJKUlU1RXJrSmdnZz09XCJcblx0fSxcblx0XCJjaGVja2VkXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUEwQUFBQVBDQVlBQUFBL0kwVjNBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQVlKSlJFRlVPRStOa3N0TGdsRVF4ZjBmYWhHMGlGclV4bTJFbEZEWUxvaENxQ0RhQ0FrV1BheElSYkZGRUpFYUdFS0xEQ29NRVRSRlVBTUx5YUlIQlVHNnNTS0lNdEtGcUVoTFQ4MThaVWdtRGh6dTNEUG45ejB1VjFScm1Vd215R1F5cU5WcWZGdlZpd0J4dTVSRlBadUxTeUdNS2h6L3FsRXNSVjE5Szh4bTZ5K3c3YnBCUEZuQWZlcmpqM2JkUVg2RHBIY0FVd2F2QUhVTjJSR0laeEJKWkhIMm1DL1RVZXlkd3dUWnZCZWdMRU5OZ3c3c1g2V2gxRnN3Tm1QRW1qUENEeUdSUndDdFc5RTN0TWdkQXRRdzdHWmpZY05YK2d6YTJ3SjNaWHNTWlV1UTB2V0NPVjhTSGZKSi91bHVoYkhVajF2OFBLTk1zeklvUU5STUhDU2hENldoOHp5aHJiT1B3ejh3K1NUS2xDQ0o3b1JOVXpRSDYza0JzNXRoQmdoZVBYeGxqMmFVb1N4RFBjdVhQTmlMQWM1RUVaNkhJa2JtVjJEWWlYQlBIczBvMDc5K0swRFRWai9zMTFtRTAwQTBMK2c0VmNEcDEwcUtaTUF6eXRCaE1hVFJhUG1ZZzg4NURsY1N6U2lqMGVvRWlJb3VvVXFscXFxYUwycmxFb2srQWQ0dmxmelBvVkRzQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwiZGlhbG9nXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUg0QUFBQVVDQU1BQUFCOGtubUdBQUFBWFZCTVZFWG40dGZtNGRmbjR0am40OW5vNU5ycDVkenA1TnZtNGRiaTNORGcyczNvNU52bDROVGgyODdrMzlQcDVkdmgzTS9qM2RIazM5VGw0TlhnMjg3azN0UGkzZEhoM05EbTR0ZmozdExoMjgvbzQ5cm80OW5nMnM3bDRkYmw0TmI2VmJFeUFBQUMxRWxFUVZSNEFYVlYwWUtES0F3RTRBQVZLNlN3QzlidC8zL21uWUoydEY3ZXdNRUp5V1JnakhNdWhGVC9uRU1iMjYxaHhicnFoMjNoUm9tWWh4THJZZlhBVFRtNkRUdjA2MHEwdnhoOStiK1NZajNNdWozYzVJT1JBRk1CRXREMHJLZ29BSElKTFdMbGZwSUc4cUFBSWszd2s5dEpLejJFODRHckhVdmJWaExieXZ3MGlBMi82b3RhL1FiYnZ2K1liVWVrYlVWNlIvRGczWVdOK1p5elQvYThYNktwQkxwVzNjdGEyRkNPTEZNa0x1WmU5N1BnRkpNN2pvYUc5YlVIbFZ5WldNNjN0R2xsWnAreXpJd2lwR0ZKUXdKNXJxZ1gyZTcvdzlLcnd1WU1BdEJrZ1RiUzczejByOUpEOUlKeXkyR0pFalNRRDlrSndpSWVUU054eUM5RHoyVmNHaUtUNklIcGxyN1Z5bmJBK1VwVkErYnhRWWkva05Qa25KdFNEbjlDZmViQk5QU3JaZEswcis2SW1FOHA1UnpEbTRzemdGdElRTnFtZTNaa2NCc1AxclJ2SlpCYmZyNmM0TzhRYzA0cGdmSnJZNXJzNGRKNWhoWjB6OXo2K3gwdnlzOE95ajVuS0VNVFA4b0xCdys3T0FoOVRrQ2RKOC81Tm5vNGR0NmQ1MDZkeWJVWWJoVERtRmp0eHd4alR2alZEaElUaUpWTm9lNUx5b0dJUWs0RnRkK1FFY25sWVBGK0tZK0RXYzFXZ1BTcUplWGpYeFBwVDl1WG9CcUd4Nm03anlseXZSdm04aEdBcHVOQXlXaXM5OHJYWXZldlpWU2d1emdmdzhrR2YzYVI0Z2QyRE5VY1FYMXFYSGF2dkxGcnB2NkwvbnQvZCs5UlhWOE9GRENGRUFoSEJ0K3FTcjYvRk4rMzdKVlM3QkM5endPWGo2L0pXMDRKTEI3bTk4NHYvSElpWDc3bTdpSDVrTDExOThvdjhPSTB6aVgwMWIzMkZvOWMzVkh6Y2U5eGRjcytMQzBUZUhQS1JmbXVsT0xjWmZUeVcySUN6NkRyNUZsNEY0MW8xcTFuWWVBdHM2YnVoaWVTeTNlK2txek03UFA4ODVBdGZCMEZKT0NvVVpuVVFTeWxsQVUza21rNGNrQXVScUMyT1hBaDFiM3lsYUJqOUthM1BpZFFReEpjQkV0R3JXUm5jdjJlanJFalZDblNYOXRZT3VCazA3WUk0SjZNWXBwY0JVMHBFZ092RHR2K3hDQ1RydHdMNWw4N3dWTzNPL2c1R1FBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXHR9LFxuXHRcImRvd24tcmVjdGFuZ2xlXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFrQUFBQUVDQVlBQUFCY0R4WE9BQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQWFkRVZZZEZOdlpuUjNZWEpsQUZCaGFXNTBMazVGVkNCMk15NDFMakV4Ui9OQ053QUFBQnBKUkVGVUdGZGpnSUwvZURBS0lLZ0FCZ2dxZ0FFMEJRd01BUFRsRC9GcGkwSmZBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJmaWx0ZXItb2ZmXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQU1DQVlBQUFCU2dJemFBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQVlkRVZZZEZOdlpuUjNZWEpsQUhCaGFXNTBMbTVsZENBMExqQXVOV1dGTW1VQUFBQ2hTVVJCVkNoVHpaSEJDb1VnRkVUOVRxRWlza2d5V291dFF2UkxSSXIrY1I3WFFBamlKVy8xQmdabU1VZXZYc1k1eHk5T29ERUdNY1lpVXplQjY3cWliVnV3UWpWTkE2MzExVitXQmVNNHZzTERNRUFwZGUvMWZZOXBtdEk0NTNuZUhFS0FsQkpkMXowZlh0YzE2UGJqT0RLMDd6dm1lVVpWVmQ4bm9vYzc1ekpJT1gzR202aTBiVnNHS2Y4eEtJUkl1eUpUTGdKSjNudlF6c2pXMmdlSXNRL3ByOWhNVnJTbmNBQUFBQUJKUlU1RXJrSmdnZz09XCJcblx0fSxcblx0XCJmaWx0ZXItb25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBTUNBWUFBQUJTZ0l6YUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWWRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU5XV0ZNbVVBQUFDb1NVUkJWQ2hUWTNCcWZQMmZIQXpXbURiajdmOHAyOTRSaFZPQmFzRWEwMmUrL2UvVkJtUVFDVHhhWC85UG52WUdvajV5d3B2L1FkMkVOZnQzdnY0ZjFnZlZCQVArblcvK2gvYStBVHRuMXE3M0tIanl0dmRnZzMwNzBEVEJnSHZMNi84ZzIyZnNRR2lhRG1TSEEyMXhheWJnSXBESGl4YThoV3NzbkE4TkRFSUFwQ2gzTGtJamlEMklOWUpDTDJYNlczQjhnZGhFYVFRQlVPQ0E0Z3lFOCtlOXhhS0pnUUVBLzc0Qk5FM2NFbGtBQUFBQVNVVk9SSzVDWUlJPVwiXG5cdH0sXG5cdFwidW5jaGVja2VkXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUEwQUFBQVBDQVlBQUFBL0kwVjNBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQVJCSlJFRlVPRSs5a3J0dWcxQVFSUGxkU2lvN0ZRMXRaSW1Pa29LT0JvbUdUMEVVUkM1aW5vNTR5VHc5MFd5d1FoVGtJa1ZXR29GMnp1eGRybEQrdDB6VGhLWnBUMFZteGI4Q1FSQ2c2enIwZmI4cmVyN3Zmd2NQeHhkY3J4K1lwZ256UEdOWmxoOWlieHhIbEdVSnNoTFNkVjBhdDl0TnBnN0RJQnJYNStPa1BNOUJWa0tHWVNCSkV0UjFqYlpyQmRpcWJWdFVWWVUwVFVGV1FxK25FK0k0eHZ2bEltR2FXN0ZIand4WkNWbVdoYmZ6R1ZtV29TZ0tXWFVyOXVpUklTc2h4M0ZrRWxkb211YlhhdXpSSTBOV1FwN255VVIrTkcvcmZyL2pVWHhuang1dm1LeUViTnVXb3g5WHZpZDZaTWhLNkhBNHduVmRoR0dJS0lwMlJZOE1XUW14K0p1b3F2cFVaRmI4TDZVb255WUwzdU90ckZIK0FBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcInVwLWRvd24tc3BpblwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFQQ0FZQUFBRFVGUDUwQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd1FBQURzRUJ1SkZyN1FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFHSkpSRUZVT0UrbGt3RUtBQ0VJQkgyWmIvUG5Ic29HZWFWSkRVakdPZ1JScEtwa2lJait5NE1NRTNlRFI3a2FLT1ZOc0p5TU5qSUh6R3k5WW5XNko3cUljcnJpUWltZUNxT1JOQUJkMGZwUlRrdDh1VlVqN0VzeEM2dnMvcTNlL1E2aUQyYnduQnlqUFhITkFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcInVwLWRvd25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBUENBWUFBQURVRlA1MEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dRQUFEc0VCdUpGcjdRQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBR0ZKUkVGVU9FK2xra0VLUUNFSVJEMlpKM1BoM2lONFdEOUdmbHBZaGowWVlvd3BHZ0ptYmlrZDNnak1ERm9rd2J1VDFpQWl1ckc1bm9tZ3FvNVFhUG85RVJRUkk2SmY3c2ZHanVkeTJqZTIzK2kwV2wyb1E4NVRPZGxmckpRT2F6RjhicitycVRYUUtuMEFBQUFBU1VWT1JLNUNZSUk9XCJcblx0fSxcbn07XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxudmFyIGltYWdlcyA9IHJlcXVpcmUoJy4vaW1hZ2VzJyk7IC8vIHRoaXMgaXMgdGhlIGZpbGUgZ2VuZXJhdGVkIGJ5IGd1bHBmaWxlLmpzIChhbmQgaWdub3JlZCBieSBnaXQpXG5cbl8oaW1hZ2VzKS5lYWNoKGZ1bmN0aW9uKGltYWdlLCBrZXkpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgIGVsZW1lbnQuc3JjID0gJ2RhdGE6JyArIGltYWdlLnR5cGUgKyAnO2Jhc2U2NCwnICsgaW1hZ2UuZGF0YTtcbiAgICBpbWFnZXNba2V5XSA9IGVsZW1lbnQ7XG59KTtcblxuaW1hZ2VzLmNoZWNrYm94ID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gaW1hZ2VzW3N0YXRlID8gJ2NoZWNrZWQnIDogJ3VuY2hlY2tlZCddO1xufTtcblxuaW1hZ2VzLmZpbHRlciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIGltYWdlc1tzdGF0ZSA/ICdmaWx0ZXItb24nIDogJ2ZpbHRlci1vZmYnXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW1hZ2VzO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqIEBtb2R1bGUgYXV0b21hdCAqL1xuXG52YXIgRU5DT0RFUlMgPSAvJVxceyhcXGQrKVxcfS9nOyAvLyBkb3VibGUgJCQgdG8gZW5jb2RlXG5cbnZhciBSRVBMQUNFUlMgPSAvXFwkXFx7KC4qPylcXH0vZzsgLy8gc2luZ2xlICQgdG8gcmVwbGFjZVxuXG5cbi8qKlxuICogQHN1bW1hcnkgU3RyaW5nIGZvcm1hdHRlci5cbiAqXG4gKiBAZGVzYyBTdHJpbmcgc3Vic3RpdHV0aW9uIGlzIHBlcmZvcm1lZCBvbiBudW1iZXJlZCBfcmVwbGFjZXJfIHBhdHRlcm5zIGxpa2UgYCR7bn1gIG9yIF9lbmNvZGVyXyBwYXR0ZXJucyBsaWtlIGAle259YCB3aGVyZSBuIGlzIHRoZSB6ZXJvLWJhc2VkIGBhcmd1bWVudHNgIGluZGV4LiBTbyBgJHswfWAgd291bGQgYmUgcmVwbGFjZWQgd2l0aCB0aGUgZmlyc3QgYXJndW1lbnQgZm9sbG93aW5nIGB0ZXh0YC5cbiAqXG4gKiBFbmNvZGVycyBhcmUganVzdCBsaWtlIHJlcGxhY2VycyBleGNlcHQgdGhlIGFyZ3VtZW50IGlzIEhUTUwtZW5jb2RlZCBiZWZvcmUgYmVpbmcgdXNlZC5cbiAqXG4gKiBUbyBjaGFuZ2UgdGhlIGZvcm1hdCBwYXR0ZXJucywgYXNzaWduIG5ldyBgUmVnRXhwYCBwYXR0ZXJucyB0byBgYXV0b21hdC5lbmNvZGVyc2AgYW5kIGBhdXRvbWF0LnJlcGxhY2Vyc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHRlbXBsYXRlIC0gQSB0ZW1wbGF0ZSB0byBiZSBmb3JtYXR0ZWQgYXMgZGVzY3JpYmVkIGFib3ZlLiBPdmVybG9hZHM6XG4gKiAqIEEgc3RyaW5nIHByaW1pdGl2ZSBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZS5cbiAqICogQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCBgdGhpc2AgYXMgdGhlIGNhbGxpbmcgY29udGV4dC4gVGhlIHRlbXBsYXRlIGlzIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC5cbiAqXG4gKiBAcGFyYW0gey4uLip9IFtyZXBsYWNlbWVudHNdIC0gUmVwbGFjZW1lbnQgdmFsdWVzIGZvciBudW1iZXJlZCBmb3JtYXQgcGF0dGVybnMuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHRleHQuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmZ1bmN0aW9uIGF1dG9tYXQodGVtcGxhdGUsIHJlcGxhY2VtZW50cy8qLi4uKi8pIHtcbiAgICB2YXIgaGFzUmVwbGFjZW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDE7XG5cbiAgICAvLyBpZiBgdGVtcGxhdGVgIGlzIGEgZnVuY3Rpb24sIGNvbnZlcnQgaXQgdG8gdGV4dFxuICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jYWxsKHRoaXMpOyAvLyBub24tdGVtcGxhdGUgZnVuY3Rpb246IGNhbGwgaXQgd2l0aCBjb250ZXh0IGFuZCB1c2UgcmV0dXJuIHZhbHVlXG4gICAgfVxuXG4gICAgaWYgKGhhc1JlcGxhY2VtZW50cykge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKGF1dG9tYXQucmVwbGFjZXJzUmVnZXgsIGZ1bmN0aW9uKG1hdGNoLCBrZXkpIHtcbiAgICAgICAgICAgIGtleSAtPSAtMTsgLy8gY29udmVydCB0byBudW1iZXIgYW5kIGluY3JlbWVudFxuICAgICAgICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoID4ga2V5ID8gYXJnc1trZXldIDogJyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZShhdXRvbWF0LmVuY29kZXJzUmVnZXgsIGZ1bmN0aW9uKG1hdGNoLCBrZXkpIHtcbiAgICAgICAgICAgIGtleSAtPSAtMTsgLy8gY29udmVydCB0byBudW1iZXIgYW5kIGluY3JlbWVudFxuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4ga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGh0bWxFbmNvZGVyTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICAgICAgICAgIGh0bWxFbmNvZGVyTm9kZS50ZXh0Q29udGVudCA9IGFyZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHRtbEVuY29kZXJOb2RlLmlubmVySFRNTDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgUmVwbGFjZSBjb250ZW50cyBvZiBgZWxgIHdpdGggYE5vZGVzYCBnZW5lcmF0ZWQgZnJvbSBmb3JtYXR0ZWQgdGVtcGxhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHRlbXBsYXRlIC0gU2VlIGB0ZW1wbGF0ZWAgcGFyYW1ldGVyIG9mIHtAbGluayBhdXRvbWF0fS5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbZWxdIC0gTm9kZSBpbiB3aGljaCB0byByZXR1cm4gbWFya3VwIGdlbmVyYXRlZCBmcm9tIHRlbXBsYXRlLiBJZiBvbWl0dGVkLCBhIG5ldyBgPGRpdj4uLi48L2Rpdj5gIGVsZW1lbnQgd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gey4uLip9IFtyZXBsYWNlbWVudHNdIC0gUmVwbGFjZW1lbnQgdmFsdWVzIGZvciBudW1iZXJlZCBmb3JtYXQgcGF0dGVybnMuXG4gKlxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9IFRoZSBgZWxgIHByb3ZpZGVkIG9yIGEgbmV3IGA8ZGl2Pi4uLjwvZGl2PmAgZWxlbWVudCwgaXRzIGBpbm5lckhUTUxgIHNldCB0byB0aGUgZm9ybWF0dGVkIHRleHQuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2UodGVtcGxhdGUsIGVsLCByZXBsYWNlbWVudHMvKi4uLiovKSB7XG4gICAgdmFyIGVsT21pdHRlZCA9IHR5cGVvZiBlbCAhPT0gJ29iamVjdCcsXG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgaWYgKGVsT21pdHRlZCkge1xuICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICBhcmdzLnVuc2hpZnQodGVtcGxhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3NbMF0gPSB0ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBlbC5pbm5lckhUTUwgPSBhdXRvbWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gICAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIEBzdW1tYXJ5IEFwcGVuZCBvciBpbnNlcnQgYE5vZGVgcyBnZW5lcmF0ZWQgZnJvbSBmb3JtYXR0ZWQgdGVtcGxhdGUgaW50byBnaXZlbiBgZWxgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB0ZW1wbGF0ZSAtIFNlZSBgdGVtcGxhdGVgIHBhcmFtZXRlciBvZiB7QGxpbmsgYXV0b21hdH0uXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqXG4gKiBAcGFyYW0ge05vZGV9IFtyZWZlcmVuY2VOb2RlPW51bGxdIEluc2VydHMgYmVmb3JlIHRoaXMgZWxlbWVudCB3aXRoaW4gYGVsYCBvciBhdCBlbmQgb2YgYGVsYCBpZiBgbnVsbGAuXG4gKlxuICogQHBhcmFtIHsuLi4qfSBbcmVwbGFjZW1lbnRzXSAtIFJlcGxhY2VtZW50IHZhbHVlcyBmb3IgbnVtYmVyZWQgZm9ybWF0IHBhdHRlcm5zLlxuICpcbiAqIEByZXR1cm5zIHtOb2RlW119IEFycmF5IG9mIHRoZSBnZW5lcmF0ZWQgbm9kZXMgKHRoaXMgaXMgYW4gYWN0dWFsIEFycmF5IGluc3RhbmNlOyBub3QgYW4gQXJyYXktbGlrZSBvYmplY3QpLlxuICpcbiAqIEBtZW1iZXJPZiBtb2R1bGU6YXV0b21hdFxuICovXG5mdW5jdGlvbiBhcHBlbmQodGVtcGxhdGUsIGVsLCByZWZlcmVuY2VOb2RlLCByZXBsYWNlbWVudHMvKi4uLiovKSB7XG4gICAgdmFyIHJlcGxhY2VtZW50c1N0YXJ0QXQgPSAzLFxuICAgICAgICByZWZlcmVuY2VOb2RlT21pdHRlZCA9IHR5cGVvZiByZWZlcmVuY2VOb2RlICE9PSAnb2JqZWN0JzsgIC8vIHJlcGxhY2VtZW50cyBhcmUgbmV2ZXIgb2JqZWN0c1xuXG4gICAgaWYgKHJlZmVyZW5jZU5vZGVPbWl0dGVkKSB7XG4gICAgICAgIHJlZmVyZW5jZU5vZGUgPSBudWxsO1xuICAgICAgICByZXBsYWNlbWVudHNTdGFydEF0ID0gMjtcbiAgICB9XG5cbiAgICByZXBsYWNlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIHJlcGxhY2VtZW50c1N0YXJ0QXQpO1xuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgZGl2ID0gcmVwbGFjZS5hcHBseShudWxsLCBbdGVtcGxhdGVdLmNvbmNhdChyZXBsYWNlbWVudHMpKTtcblxuICAgIHdoaWxlIChkaXYuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICBlbC5pbnNlcnRCZWZvcmUoZGl2LmZpcnN0Q2hpbGQsIHJlZmVyZW5jZU5vZGUpOyAvLyByZW1vdmVzIGNoaWxkIGZyb20gZGl2XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBVc2UgdGhpcyBjb252ZW5pZW5jZSB3cmFwcGVyIHRvIHJldHVybiB0aGUgZmlyc3QgY2hpbGQgbm9kZSBkZXNjcmliZWQgaW4gYHRlbXBsYXRlYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gdGVtcGxhdGUgLSBJZiBhIGZ1bmN0aW9uLCBleHRyYWN0IHRlbXBsYXRlIGZyb20gY29tbWVudCB3aXRoaW4uXG4gKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50fSBUaGUgZmlyc3QgYE5vZGVgIGluIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmZ1bmN0aW9uIGZpcnN0Q2hpbGQodGVtcGxhdGUsIHJlcGxhY2VtZW50cy8qLi4uKi8pIHtcbiAgICByZXR1cm4gcmVwbGFjZS5hcHBseShudWxsLCBhcmd1bWVudHMpLmZpcnN0Q2hpbGQ7XG59XG5cbi8qKlxuICogVXNlIHRoaXMgY29udmVuaWVuY2Ugd3JhcHBlciB0byByZXR1cm4gdGhlIGZpcnN0IGNoaWxkIGVsZW1lbnQgZGVzY3JpYmVkIGluIGB0ZW1wbGF0ZWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHRlbXBsYXRlIC0gSWYgYSBmdW5jdGlvbiwgZXh0cmFjdCB0ZW1wbGF0ZSBmcm9tIGNvbW1lbnQgd2l0aGluLlxuICpcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIGZpcnN0IGBIVE1MRWxlbWVudGAgaW4geW91ciB0ZW1wbGF0ZS5cbiAqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOmF1dG9tYXRcbiAqL1xuZnVuY3Rpb24gZmlyc3RFbGVtZW50KHRlbXBsYXRlLCByZXBsYWNlbWVudHMvKi4uLiovKSB7XG4gICAgcmV0dXJuIHJlcGxhY2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5maXJzdEVsZW1lbnRDaGlsZDtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBGaW5kcyBzdHJpbmcgc3Vic3RpdHV0aW9uIGxleGVtZXMgdGhhdCByZXF1aXJlIEhUTUwgZW5jb2RpbmcuXG4gKiBAZGVzYyBNb2RpZnkgdG8gc3VpdC5cbiAqIEBkZWZhdWx0ICV7bn1cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAbWVtYmVyT2YgbW9kdWxlOmF1dG9tYXRcbiAqL1xuYXV0b21hdC5lbmNvZGVyc1JlZ2V4ID0gRU5DT0RFUlM7XG5cbi8qKlxuICogQHN1bW1hcnkgRmluZHMgc3RyaW5nIHN1YnN0aXR1dGlvbiBsZXhlbWVzLlxuICogQGRlc2MgTW9kaWZ5IHRvIHN1aXQuXG4gKiBAZGVmYXVsdCAke259XG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQG1lbWJlck9mIG1vZHVsZTphdXRvbWF0XG4gKi9cbmF1dG9tYXQucmVwbGFjZXJzUmVnZXggPSBSRVBMQUNFUlM7XG5cbmF1dG9tYXQuZm9ybWF0ID0gYXV0b21hdDsgLy8gaWYgeW91IGZpbmQgdXNpbmcganVzdCBgYXV0b21hdCgpYCBjb25mdXNpbmdcbmF1dG9tYXQucmVwbGFjZSA9IHJlcGxhY2U7XG5hdXRvbWF0LmFwcGVuZCA9IGFwcGVuZDtcbmF1dG9tYXQuZmlyc3RDaGlsZCA9IGZpcnN0Q2hpbGQ7XG5hdXRvbWF0LmZpcnN0RWxlbWVudCA9IGZpcnN0RWxlbWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBhdXRvbWF0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqIEBuYW1lc3BhY2UgY3NzSW5qZWN0b3IgKi9cblxuLyoqXG4gKiBAc3VtbWFyeSBJbnNlcnQgYmFzZSBzdHlsZXNoZWV0IGludG8gRE9NXG4gKlxuICogQGRlc2MgQ3JlYXRlcyBhIG5ldyBgPHN0eWxlPi4uLjwvc3R5bGU+YCBlbGVtZW50IGZyb20gdGhlIG5hbWVkIHRleHQgc3RyaW5nKHMpIGFuZCBpbnNlcnRzIGl0IGJ1dCBvbmx5IGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QgaW4gdGhlIHNwZWNpZmllZCBjb250YWluZXIgYXMgcGVyIGByZWZlcmVuY2VFbGVtZW50YC5cbiAqXG4gKiA+IENhdmVhdDogSWYgc3R5bGVzaGVldCBpcyBmb3IgdXNlIGluIGEgc2hhZG93IERPTSwgeW91IG11c3Qgc3BlY2lmeSBhIGxvY2FsIGByZWZlcmVuY2VFbGVtZW50YC5cbiAqXG4gKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgbmV3bHkgY3JlYXRlZCBgPHN0eWxlPi4uLjwvc3R5bGU+YCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBjc3NSdWxlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtJRF1cbiAqIEBwYXJhbSB7dW5kZWZpbmVkfG51bGx8RWxlbWVudHxzdHJpbmd9IFtyZWZlcmVuY2VFbGVtZW50XSAtIENvbnRhaW5lciBmb3IgaW5zZXJ0aW9uLiBPdmVybG9hZHM6XG4gKiAqIGB1bmRlZmluZWRgIHR5cGUgKG9yIG9taXR0ZWQpOiBpbmplY3RzIHN0eWxlc2hlZXQgYXQgdG9wIG9mIGA8aGVhZD4uLi48L2hlYWQ+YCBlbGVtZW50XG4gKiAqIGBudWxsYCB2YWx1ZTogaW5qZWN0cyBzdHlsZXNoZWV0IGF0IGJvdHRvbSBvZiBgPGhlYWQ+Li4uPC9oZWFkPmAgZWxlbWVudFxuICogKiBgRWxlbWVudGAgdHlwZTogaW5qZWN0cyBzdHlsZXNoZWV0IGltbWVkaWF0ZWx5IGJlZm9yZSBnaXZlbiBlbGVtZW50LCB3aGVyZXZlciBpdCBpcyBmb3VuZC5cbiAqICogYHN0cmluZ2AgdHlwZTogaW5qZWN0cyBzdHlsZXNoZWV0IGltbWVkaWF0ZWx5IGJlZm9yZSBnaXZlbiBmaXJzdCBlbGVtZW50IGZvdW5kIHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gY3NzIHNlbGVjdG9yLlxuICpcbiAqIEBtZW1iZXJPZiBjc3NJbmplY3RvclxuICovXG5mdW5jdGlvbiBjc3NJbmplY3Rvcihjc3NSdWxlcywgSUQsIHJlZmVyZW5jZUVsZW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIHJlZmVyZW5jZUVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJlZmVyZW5jZUVsZW1lbnQpO1xuICAgICAgICBpZiAoIXJlZmVyZW5jZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRocm93ICdDYW5ub3QgZmluZCByZWZlcmVuY2UgZWxlbWVudCBmb3IgQ1NTIGluamVjdGlvbi4nO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZlcmVuY2VFbGVtZW50ICYmICEocmVmZXJlbmNlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgIHRocm93ICdHaXZlbiB2YWx1ZSBub3QgYSByZWZlcmVuY2UgZWxlbWVudC4nO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXIgPSByZWZlcmVuY2VFbGVtZW50ICYmIHJlZmVyZW5jZUVsZW1lbnQucGFyZW50Tm9kZSB8fCBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cbiAgICBpZiAoSUQpIHtcbiAgICAgICAgSUQgPSBjc3NJbmplY3Rvci5pZFByZWZpeCArIElEO1xuXG4gICAgICAgIGlmIChjb250YWluZXIucXVlcnlTZWxlY3RvcignIycgKyBJRCkpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gc3R5bGVzaGVldCBhbHJlYWR5IGluIERPTVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcbiAgICBpZiAoSUQpIHtcbiAgICAgICAgc3R5bGUuaWQgPSBJRDtcbiAgICB9XG4gICAgaWYgKGNzc1J1bGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY3NzUnVsZXMgPSBjc3NSdWxlcy5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgY3NzUnVsZXMgPSAnXFxuJyArIGNzc1J1bGVzICsgJ1xcbic7XG4gICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzUnVsZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzUnVsZXMpKTtcbiAgICB9XG5cbiAgICBpZiAocmVmZXJlbmNlRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHN0eWxlLCByZWZlcmVuY2VFbGVtZW50KTtcblxuICAgIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBPcHRpb25hbCBwcmVmaXggZm9yIGA8c3R5bGU+YCB0YWcgSURzLlxuICogQGRlc2MgRGVmYXVsdHMgdG8gYCdpbmplY3RlZC1zdHlsZXNoZWV0LSdgLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBtZW1iZXJPZiBjc3NJbmplY3RvclxuICovXG5jc3NJbmplY3Rvci5pZFByZWZpeCA9ICdpbmplY3RlZC1zdHlsZXNoZWV0LSc7XG5cbi8vIEludGVyZmFjZVxubW9kdWxlLmV4cG9ydHMgPSBjc3NJbmplY3RvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG92ZXJyaWRlciA9IHJlcXVpcmUoJ292ZXJyaWRlcicpO1xuXG4vKiogQG5hbWVzcGFjZSBleHRlbmQtbWUgKiovXG5cbi8qKiBAc3VtbWFyeSBFeHRlbmRzIGFuIGV4aXN0aW5nIGNvbnN0cnVjdG9yIGludG8gYSBuZXcgY29uc3RydWN0b3IuXG4gKlxuICogQHJldHVybnMge0NoaWxkQ29uc3RydWN0b3J9IEEgbmV3IGNvbnN0cnVjdG9yLCBleHRlbmRlZCBmcm9tIHRoZSBnaXZlbiBjb250ZXh0LCBwb3NzaWJseSB3aXRoIHNvbWUgcHJvdG90eXBlIGFkZGl0aW9ucy5cbiAqXG4gKiBAZGVzYyBFeHRlbmRzIFwib2JqZWN0c1wiIChjb25zdHJ1Y3RvcnMpLCB3aXRoIG9wdGlvbmFsIGFkZGl0aW9uYWwgY29kZSwgb3B0aW9uYWwgcHJvdG90eXBlIGFkZGl0aW9ucywgYW5kIG9wdGlvbmFsIHByb3RvdHlwZSBtZW1iZXIgYWxpYXNlcy5cbiAqXG4gKiA+IENBVkVBVDogTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggVW5kZXJzY29yZS1zdHlsZSAuZXh0ZW5kKCkgd2hpY2ggaXMgc29tZXRoaW5nIGVsc2UgZW50aXJlbHkuIEkndmUgdXNlZCB0aGUgbmFtZSBcImV4dGVuZFwiIGhlcmUgYmVjYXVzZSBvdGhlciBwYWNrYWdlcyAobGlrZSBCYWNrYm9uZS5qcykgdXNlIGl0IHRoaXMgd2F5LiBZb3UgYXJlIGZyZWUgdG8gY2FsbCBpdCB3aGF0ZXZlciB5b3Ugd2FudCB3aGVuIHlvdSBcInJlcXVpcmVcIiBpdCwgc3VjaCBhcyBgdmFyIGluaGVyaXRzID0gcmVxdWlyZSgnZXh0ZW5kJylgLlxuICpcbiAqIFByb3ZpZGUgYSBjb25zdHJ1Y3RvciBhcyB0aGUgY29udGV4dCBhbmQgYW55IHByb3RvdHlwZSBhZGRpdGlvbnMgeW91IHJlcXVpcmUgaW4gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3Ugd2lzaCB0byBiZSBhYmxlIHRvIGV4dGVuZCBgQmFzZUNvbnN0cnVjdG9yYCB0byBhIG5ldyBjb25zdHJ1Y3RvciB3aXRoIHByb3RvdHlwZSBvdmVycmlkZXMgYW5kL29yIGFkZGl0aW9ucywgYmFzaWMgdXNhZ2UgaXM6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xuICogdmFyIEJhc2VDb25zdHJ1Y3RvciA9IEJhc2UuZXh0ZW5kKGJhc2VQcm90b3R5cGUpOyAvLyBtaXhlcyBpbiAuZXh0ZW5kXG4gKiB2YXIgQ2hpbGRDb25zdHJ1Y3RvciA9IEJhc2VDb25zdHJ1Y3Rvci5leHRlbmQoY2hpbGRQcm90b3R5cGVPdmVycmlkZXNBbmRBZGRpdGlvbnMpO1xuICogdmFyIEdyYW5kY2hpbGRDb25zdHJ1Y3RvciA9IENoaWxkQ29uc3RydWN0b3IuZXh0ZW5kKGdyYW5kY2hpbGRQcm90b3R5cGVPdmVycmlkZXNBbmRBZGRpdGlvbnMpO1xuICogYGBgXG4gKlxuICogVGhpcyBmdW5jdGlvbiAoYGV4dGVuZCgpYCkgaXMgYWRkZWQgdG8gdGhlIG5ldyBleHRlbmRlZCBvYmplY3QgY29uc3RydWN0b3IgYXMgYSBwcm9wZXJ0eSBgLmV4dGVuZGAsIGVzc2VudGlhbGx5IG1ha2luZyB0aGUgb2JqZWN0IGNvbnN0cnVjdG9yIGl0c2VsZiBlYXNpbHkgXCJleHRlbmRhYmxlLlwiIChOb3RlOiBUaGlzIGlzIGEgcHJvcGVydHkgb2YgZWFjaCBjb25zdHJ1Y3RvciBhbmQgbm90IGEgbWV0aG9kIG9mIGl0cyBwcm90b3R5cGUhKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXh0ZW5kZWRDbGFzc05hbWVdIC0gVGhpcyBpcyBzaW1wbHkgYWRkZWQgdG8gdGhlIHByb3RvdHlwZSBhcyAkJENMQVNTX05BTUUuIFVzZWZ1bCBmb3IgZGVidWdnaW5nIGJlY2F1c2UgYWxsIGRlcml2ZWQgY29uc3RydWN0b3JzIGFwcGVhciB0byBoYXZlIHRoZSBzYW1lIG5hbWUgKFwiQ29uc3RydWN0b3JcIikgaW4gdGhlIGRlYnVnZ2VyLlxuICpcbiAqIEBwYXJhbSB7ZXh0ZW5kZWRQcm90b3R5cGVBZGRpdGlvbnNPYmplY3R9IFtwcm90b3R5cGVBZGRpdGlvbnNdIC0gT2JqZWN0IHdpdGggbWVtYmVycyB0byBjb3B5IHRvIG5ldyBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZS5cbiAqXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZWJ1Z10gLSBTZWUgcGFyYW1ldGVyIGBleHRlbmRlZENsYXNzTmFtZWAgXyhhYm92ZSlfLlxuICpcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBCYXNlIC0gQSBjb252ZW5pZW50IGJhc2UgY2xhc3MgZnJvbSB3aGljaCBhbGwgb3RoZXIgY2xhc3NlcyBjYW4gYmUgZXh0ZW5kZWQuXG4gKlxuICogQG1lbWJlck9mIGV4dGVuZC1tZVxuICovXG5mdW5jdGlvbiBleHRlbmQoZXh0ZW5kZWRDbGFzc05hbWUsIHByb3RvdHlwZUFkZGl0aW9ucykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwcm90b3R5cGVBZGRpdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBleHRlbmRlZENsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIHByb3RvdHlwZUFkZGl0aW9ucyA9IGV4dGVuZGVkQ2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZENsYXNzTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlQWRkaXRpb25zID0ge307XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdTaW5nbGUtcGFyYW1ldGVyIG92ZXJsb2FkIG11c3QgYmUgZWl0aGVyIHN0cmluZyBvciBvYmplY3QuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dGVuZGVkQ2xhc3NOYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvdG90eXBlQWRkaXRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93ICdUd28tcGFyYW1ldGVyIG92ZXJsb2FkIG11c3QgYmUgc3RyaW5nLCBvYmplY3QuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1RvbyBtYW55IHBhcmFtZXRlcnMnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENvbnN0cnVjdG9yKCkge1xuICAgICAgICBpZiAocHJvdG90eXBlQWRkaXRpb25zLnByZUluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIHByb3RvdHlwZUFkZGl0aW9ucy5wcmVJbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0aWFsaXplUHJvdG90eXBlQ2hhaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICBpZiAocHJvdG90eXBlQWRkaXRpb25zLnBvc3RJbml0aWFsaXplKSB7XG4gICAgICAgICAgICBwcm90b3R5cGVBZGRpdGlvbnMucG9zdEluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIENvbnN0cnVjdG9yLmV4dGVuZCA9IGV4dGVuZDtcblxuICAgIHZhciBwcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcbiAgICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcblxuICAgIGlmIChleHRlbmRlZENsYXNzTmFtZSkge1xuICAgICAgICBwcm90b3R5cGUuJCRDTEFTU19OQU1FID0gZXh0ZW5kZWRDbGFzc05hbWU7XG4gICAgfVxuXG4gICAgb3ZlcnJpZGVyKHByb3RvdHlwZSwgcHJvdG90eXBlQWRkaXRpb25zKTtcblxuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gQmFzZSgpIHt9XG5CYXNlLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQmFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IsXG4gICAgZ2V0IHN1cGVyKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgfVxufTtcbkJhc2UuZXh0ZW5kID0gZXh0ZW5kO1xuZXh0ZW5kLkJhc2UgPSBCYXNlO1xuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9ufSBleHRlbmRlZENvbnN0cnVjdG9yXG4gKiBAcHJvcGVydHkgcHJvdG90eXBlLnN1cGVyIC0gQSByZWZlcmVuY2UgdG8gdGhlIHByb3RvdHlwZSB0aGlzIGNvbnN0cnVjdG9yIHdhcyBleHRlbmRlZCBmcm9tLlxuICogQHByb3BlcnR5IFtleHRlbmRdIC0gSWYgYHByb3RvdHlwZUFkZGl0aW9ucy5leHRlbmRhYmxlYCB3YXMgdHJ1dGh5LCB0aGlzIHdpbGwgYmUgYSByZWZlcmVuY2UgdG8ge0BsaW5rIGV4dGVuZC5leHRlbmR8ZXh0ZW5kfS5cbiAqL1xuXG4vKiogQHR5cGVkZWYge29iamVjdH0gZXh0ZW5kZWRQcm90b3R5cGVBZGRpdGlvbnNPYmplY3RcbiAqIEBkZXNjIEFsbCBtZW1iZXJzIGFyZSBjb3BpZWQgdG8gdGhlIG5ldyBvYmplY3QuIFRoZSBmb2xsb3dpbmcgaGF2ZSBzcGVjaWFsIG1lYW5pbmcuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbaW5pdGlhbGl6ZV0gLSBBZGRpdGlvbmFsIGNvbnN0cnVjdG9yIGNvZGUgZm9yIG5ldyBvYmplY3QuIFRoaXMgbWV0aG9kIGlzIGFkZGVkIHRvIHRoZSBuZXcgY29uc3RydWN0b3IncyBwcm90b3R5cGUuIEdldHMgcGFzc2VkIG5ldyBvYmplY3QgYXMgY29udGV4dCArIHNhbWUgYXJncyBhcyBjb25zdHJ1Y3RvciBpdHNlbGYuIENhbGxlZCBvbiBpbnN0YW50aWF0aW9uIGFmdGVyIHNpbWlsYXIgZnVuY3Rpb24gaW4gYWxsIGFuY2VzdG9ycyBjYWxsZWQgd2l0aCBzYW1lIHNpZ25hdHVyZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtwcmVJbml0aWFsaXplXSAtIENhbGxlZCBiZWZvcmUgdGhlIGBpbml0aWFsaXplYCBjYXNjYWRlLiBHZXRzIHBhc3NlZCBuZXcgb2JqZWN0IGFzIGNvbnRleHQgKyBzYW1lIGFyZ3MgYXMgY29uc3RydWN0b3IgaXRzZWxmLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3Bvc3RJbml0aWFsaXplXSAtIENhbGxlZCBhZnRlciB0aGUgYGluaXRpYWxpemVgIGNhc2NhZGUuIEdldHMgcGFzc2VkIG5ldyBvYmplY3QgYXMgY29udGV4dCArIHNhbWUgYXJncyBhcyBjb25zdHJ1Y3RvciBpdHNlbGYuXG4gKi9cblxuLyoqIEBzdW1tYXJ5IENhbGwgYWxsIGBpbml0aWFsaXplYCBtZXRob2RzIGZvdW5kIGluIHByb3RvdHlwZSBjaGFpbiwgYmVnaW5uaW5nIHdpdGggdGhlIG1vc3Qgc2VuaW9yIGFuY2VzdG9yJ3MgZmlyc3QuXG4gKiBAZGVzYyBUaGlzIHJlY3Vyc2l2ZSByb3V0aW5lIGlzIGNhbGxlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gKiAxLiBXYWxrcyBiYWNrIHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gYE9iamVjdGAncyBwcm90b3R5cGVcbiAqIDIuIFdhbGtzIGZvcndhcmQgdG8gbmV3IG9iamVjdCwgY2FsbGluZyBhbnkgYGluaXRpYWxpemVgIG1ldGhvZHMgaXQgZmluZHMgYWxvbmcgdGhlIHdheSB3aXRoIHRoZSBzYW1lIGNvbnRleHQgYW5kIGFyZ3VtZW50cyB3aXRoIHdoaWNoIHRoZSBjb25zdHJ1Y3RvciB3YXMgY2FsbGVkLlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJPZiBleHRlbmQtbWVcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb3RvdHlwZUNoYWluKCkge1xuICAgIHZhciB0ZXJtID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZWN1cih0ZXJtKTtcblxuICAgIGZ1bmN0aW9uIHJlY3VyKG9iaikge1xuICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgaWYgKHByb3RvLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHJlY3VyKHByb3RvKTtcbiAgICAgICAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnaW5pdGlhbGl6ZScpKSB7XG4gICAgICAgICAgICAgICAgcHJvdG8uaW5pdGlhbGl6ZS5hcHBseSh0ZXJtLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIERhdGFTb3VyY2VCYXNlKCkge31cblxuRGF0YVNvdXJjZUJhc2UuZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kLW1lJyk7XG5cbkRhdGFTb3VyY2VCYXNlLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogRGF0YVNvdXJjZUJhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgcmVwbGFjZUluZGVudDogJ18nLFxuXG4gICAgaXNOdWxsT2JqZWN0OiB0cnVlLFxuXG4gICAgRGF0YVNvdXJjZUVycm9yOiBEYXRhU291cmNlRXJyb3IsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgfSxcblxuICAgIC8vIEdFVFRFUlMvU0VUVEVSU1xuXG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zY2hlbWE7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNldCBzY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvLyBcIlNFVFwiIE1FVEhPRFMgKEFMV0FZUyBIQVZFIEFSR1MpXG5cbiAgICBzZXRTY2hlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNldFNjaGVtYS5hcHBseSh0aGlzLmRhdGFTb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0RGF0YS5hcHBseSh0aGlzLmRhdGFTb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNldFZhbHVlLmFwcGx5KHRoaXMuZGF0YVNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8vIFwiR0VUXCIgTUVUSE9EUyBXSVRIT1VUIEFSR1NcblxuICAgIGdldFNjaGVtYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0U2NoZW1hKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0R3JhbmRUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3JvdzogSWRlYWxseSB0aGlzIHNob3VsZCBiZSBzZXQgYW5kIGdldCBib3R0b20vdG9wIHRvdGFsc1xuICAgICAgICAvL0N1cnJlbnRseSB0aGlzIGZ1bmN0aW9uIGlzIGp1c3Qgc2VuZGluZyB0aGUgc2FtZSBmb3IgYm90aCBpbiBhZ2dyZWdhdGlvbnNcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRHcmFuZFRvdGFscygpO1xuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgLy8gXCJHRVRcIiBNRVRIT0RTIFdJVEggQVJHU1xuXG4gICAgZ2V0UHJvcGVydHk6IGZ1bmN0aW9uIGdldFByb3BlcnR5KHByb3BOYW1lKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1twcm9wTmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UHJvcGVydHkuY2FsbCh0aGlzLmRhdGFTb3VyY2UsIHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldERhdGFJbmRleC5hcHBseSh0aGlzLmRhdGFTb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Um93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3cuYXBwbHkodGhpcy5kYXRhU291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmZpbmRSb3cuYXBwbHkodGhpcy5kYXRhU291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJldmVhbFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UucmV2ZWFsUm93LmFwcGx5KHRoaXMuZGF0YVNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0VmFsdWUuYXBwbHkodGhpcy5kYXRhU291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5jbGljay5hcHBseSh0aGlzLmRhdGFTb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvLyBCT09MRUFOIE1FVEhPRFMgKE5PIEFSR1MpXG5cbiAgICBpc0RyaWxsRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuaXNEcmlsbERvd24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2aWV3TWFrZXNTZW5zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uudmlld01ha2VzU2Vuc2UoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8vIE9USEVSIE1FVEhPRFNcblxuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGFTb3VyY2VFcnJvcignTm90aGluZyB0byBhcHBseS4nKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbmV3IG9iamVjdCB3aXRoIG5hbWUgYW5kIGluZGV4IGdpdmVuIHRoZSBuYW1lIG9yIHRoZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtjb2x1bW5dIC0gQ29sdW1uIG5hbWUgb3IgaW5kZXguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtkZWZhdWx0TmFtZV0gLSBOYW1lIHRvIHVzZSB3aGVuIGNvbHVtbiBpcyBvbWl0dGVkIG9yIHVuZGVmaW5lZC4gTWF5IGJlIG9taXR0ZWQgd2hlbiBjb2x1bW4gaXMgZGVmaW5pdGVseSBkZWZpbmVkLlxuICAgICAqIEByZXR1cm5zIHt7bmFtZTogc3RyaW5nLCBpbmRleDogbnVtYmVyfX1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5JbmZvOiBmdW5jdGlvbihjb2x1bW4sIGRlZmF1bHROYW1lKSB7XG4gICAgICAgIHZhciBuYW1lLCBpbmRleDtcbiAgICAgICAgaWYgKGNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSBkZWZhdWx0TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLmdldEZpZWxkcygpW2luZGV4ID0gY29sdW1uXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5nZXRGaWVsZHMoKS5pbmRleE9mKG5hbWUgPSBjb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICYmIGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZml4SW5kZW50Rm9yVGFibGVEaXNwbGF5OiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gc3RyaW5nLnNlYXJjaCgvXFxTLyk7XG4gICAgICAgIHZhciBlbmQgPSBzdHJpbmcuc3Vic3RyaW5nKGNvdW50KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGNvdW50ICsgMSkuam9pbih0aGlzLnJlcGxhY2VJbmRlbnQpICsgZW5kO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBkdW1wOiBmdW5jdGlvbihtYXgpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5taW4odGhpcy5nZXRSb3dDb3VudCgpLCBtYXggfHwgTWF0aC5tYXgoMTAwLCB0aGlzLmdldFJvd0NvdW50KCkpKTtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuc2NoZW1hID8gdGhpcy5zY2hlbWEubWFwKGZ1bmN0aW9uKGNzKSB7IHJldHVybiBjcy5uYW1lOyB9KSA6IHRoaXMuZ2V0SGVhZGVycygpO1xuICAgICAgICB2YXIgY0NvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgdmlld01ha2VzU2Vuc2UgPSB0aGlzLnZpZXdNYWtlc1NlbnNlO1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IG1heDsgcisrKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNDb3VudDsgYysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMuZ2V0VmFsdWUoYywgcik7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IDAgJiYgdmlld01ha2VzU2Vuc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5maXhJbmRlbnRGb3JUYWJsZURpc3BsYXkodmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm93W2ZpZWxkc1tjXV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhW3JdID0gcm93O1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUudGFibGUoZGF0YSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gRGF0YVNvdXJjZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG4vLyBleHRlbmQgZnJvbSBgRXJyb3JgXG5EYXRhU291cmNlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuXG4vLyBvdmVycmlkZSBlcnJvciBuYW1lIGRpc3BsYXllZCBpbiBjb25zb2xlXG5EYXRhU291cmNlRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnRGF0YVNvdXJjZUVycm9yJztcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlQmFzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBub2RlLCBicm93c2VyICovXG5cbnZhciBjc3NJbmplY3RvciA9IHJlcXVpcmUoJ2Nzcy1pbmplY3RvcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBGaW5CYXJcbiAqIEBzdW1tYXJ5IENyZWF0ZSBhIHNjcm9sbGJhciBvYmplY3QuXG4gKiBAZGVzYyBDcmVhdGluZyBhIHNjcm9sbGJhciBpcyBhIHRocmVlLXN0ZXAgcHJvY2VzczpcbiAqXG4gKiAxLiBJbnN0YW50aWF0ZSB0aGUgc2Nyb2xsYmFyIG9iamVjdCBieSBjYWxsaW5nIHRoaXMgY29uc3RydWN0b3IgZnVuY3Rpb24uIFVwb24gaW5zdGFudGlhdGlvbiwgdGhlIERPTSBlbGVtZW50IGZvciB0aGUgc2Nyb2xsYmFyICh3aXRoIGEgc2luZ2xlIGNoaWxkIGVsZW1lbnQgZm9yIHRoZSBzY3JvbGxiYXIgXCJ0aHVtYlwiKSBpcyBjcmVhdGVkIGJ1dCBpcyBub3QgaW5zZXJ0IGl0IGludG8gdGhlIERPTS5cbiAqIDIuIEFmdGVyIGluc3RhbnRpYXRpb24sIGl0IGlzIHRoZSBjYWxsZXIncyByZXNwb25zaWJpbGl0eSB0byBpbnNlcnQgdGhlIHNjcm9sbGJhciwge0BsaW5rIEZpbkJhciNiYXJ8dGhpcy5iYXJ9LCBpbnRvIHRoZSBET00uXG4gKiAzLiBBZnRlciBpbnNlcnRpb24sIHRoZSBjYWxsZXIgbXVzdCBjYWxsIHtAbGluayBGaW5CYXIjcmVzaXplfHJlc2l6ZSgpfSBhdCBsZWFzdCBvbmNlIHRvIHNpemUgYW5kIHBvc2l0aW9uIHRoZSBzY3JvbGxiYXIgYW5kIGl0cyB0aHVtYi4gQWZ0ZXIgdGhhdCwgYHJlc2l6ZSgpYCBzaG91bGQgYWxzbyBiZSBjYWxsZWQgcmVwZWF0ZWRseSBvbiByZXNpemUgZXZlbnRzIChhcyB0aGUgY29udGVudCBlbGVtZW50IGlzIGJlaW5nIHJlc2l6ZWQpLlxuICpcbiAqIFN1Z2dlc3RlZCBjb25maWd1cmF0aW9uczpcbiAqICogXyoqVW5ib3VuZCoqXzxici8+XG4gKiBUaGUgc2Nyb2xsYmFyIHNlcnZlcyBtZXJlbHkgYXMgYSBzaW1wbGUgcmFuZ2UgKHNsaWRlcikgY29udHJvbC4gT21pdCBib3RoIGBvcHRpb25zLm9uY2hhbmdlYCBhbmQgYG9wdGlvbnMuY29udGVudGAuXG4gKiAqIF8qKkJvdW5kIHRvIHZpcnR1YWwgY29udGVudCBlbGVtZW50KipfPGJyLz5cbiAqIFZpcnR1YWwgY29udGVudCBpcyBwcm9qZWN0ZWQgaW50byB0aGUgZWxlbWVudCB1c2luZyBhIGN1c3RvbSBldmVudCBoYW5kbGVyIHN1cHBsaWVkIGJ5IHRoZSBwcm9ncmFtbWVyIGluIGBvcHRpb25zLm9uY2hhbmdlYC4gQSB0eXBpY2FsIHVzZSBjYXNlIHdvdWxkIGJlIHRvIGhhbmRsZSBzY3JvbGxpbmcgb2YgdGhlIHZpcnR1YWwgY29udGVudC4gT3RoZXIgdXNlIGNhc2VzIGluY2x1ZGUgZGF0YSB0cmFuc2Zvcm1hdGlvbnMsIGdyYXBoaWNzIHRyYW5zZm9ybWF0aW9ucywgX2V0Yy5fXG4gKiAqIF8qKkJvdW5kIHRvIHJlYWwgY29udGVudCoqXzxici8+XG4gKiBTZXQgYG9wdGlvbnMuY29udGVudGAgdG8gdGhlIFwicmVhbFwiIGNvbnRlbnQgZWxlbWVudCBidXQgb21pdCBgb3B0aW9ucy5vbmNoYW5nZWAuIFRoaXMgd2lsbCBjYXVzZSB0aGUgc2Nyb2xsYmFyIHRvIHVzZSB0aGUgYnVpbHQtaW4gZXZlbnQgaGFuZGxlciAoYHRoaXMuc2Nyb2xsUmVhbENvbnRlbnRgKSB3aGljaCBpbXBsZW1lbnRzIHNtb290aCBzY3JvbGxpbmcgb2YgdGhlIGNvbnRlbnQgZWxlbWVudCB3aXRoaW4gdGhlIGNvbnRhaW5lci5cbiAqXG4gKiBAcGFyYW0ge2ZpbmJhck9wdGlvbnN9IFtvcHRpb25zPXt9XSAtIE9wdGlvbnMgb2JqZWN0LiBTZWUgdGhlIHR5cGUgZGVmaW5pdGlvbiBmb3IgbWVtYmVyIGRldGFpbHMuXG4gKi9cbmZ1bmN0aW9uIEZpbkJhcihvcHRpb25zKSB7XG5cbiAgICAvLyBtYWtlIGJvdW5kIHZlcnNpb25zIG9mIGFsbCB0aGUgbW91c2UgZXZlbnQgaGFuZGxlclxuICAgIHZhciBib3VuZCA9IHRoaXMuX2JvdW5kID0ge307XG4gICAgZm9yIChrZXkgaW4gaGFuZGxlcnNUb0JlQm91bmQpIHtcbiAgICAgICAgYm91bmRba2V5XSA9IGhhbmRsZXJzVG9CZUJvdW5kW2tleV0uYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSB0aHVtYlxuICAgICAqIEBzdW1tYXJ5IFRoZSBnZW5lcmF0ZWQgc2Nyb2xsYmFyIHRodW1iIGVsZW1lbnQuXG4gICAgICogQGRlc2MgVGhlIHRodW1iIGVsZW1lbnQncyBwYXJlbnQgZWxlbWVudCBpcyBhbHdheXMgdGhlIHtAbGluayBGaW5CYXIjYmFyfGJhcn0gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgdHlwaWNhbGx5IHJlZmVyZW5jZWQgaW50ZXJuYWxseSBvbmx5LiBUaGUgc2l6ZSBhbmQgcG9zaXRpb24gb2YgdGhlIHRodW1iIGVsZW1lbnQgaXMgbWFpbnRhaW5lZCBieSBgX2NhbGNUaHVtYigpYC5cbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHZhciB0aHVtYiA9IHRoaXMudGh1bWIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aHVtYi5jbGFzc0xpc3QuYWRkKCd0aHVtYicpO1xuICAgIHRodW1iLm9uY2xpY2sgPSBib3VuZC5zaG9ydFN0b3A7XG4gICAgdGh1bWIub25tb3VzZW92ZXIgPSBib3VuZC5vbm1vdXNlb3ZlcjtcbiAgICB0aHVtYi5vbm1vdXNlb3V0ID0gdGhpcy5fYm91bmQub25tb3VzZW91dDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGJhclxuICAgICAqIEBzdW1tYXJ5IFRoZSBnZW5lcmF0ZWQgc2Nyb2xsYmFyIGVsZW1lbnQuXG4gICAgICogQGRlc2MgVGhlIGNhbGxlciBpbnNlcnRzIHRoaXMgZWxlbWVudCBpbnRvIHRoZSBET00gKHR5cGljYWxseSBpbnRvIHRoZSBjb250ZW50IGNvbnRhaW5lcikgYW5kIHRoZW4gY2FsbHMgaXRzIHtAbGluayBGaW5CYXIjcmVzaXplfHJlc2l6ZSgpfSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBUaHVzIHRoZSBub2RlIHRyZWUgaXMgdHlwaWNhbGx5OlxuICAgICAqICogQSAqKmNvbnRlbnQgY29udGFpbmVyKiogZWxlbWVudCwgd2hpY2ggY29udGFpbnM6XG4gICAgICogICAqIFRoZSBjb250ZW50IGVsZW1lbnQocylcbiAgICAgKiAgICogVGhpcyAqKnNjcm9sbGJhciBlbGVtZW50KiosIHdoaWNoIGluIHR1cm4gY29udGFpbnM6XG4gICAgICogICAgICogVGhlICoqdGh1bWIgZWxlbWVudCoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHZhciBiYXIgPSB0aGlzLmJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJhci5jbGFzc0xpc3QuYWRkKCdmaW5iYXItdmVydGljYWwnKTtcbiAgICBiYXIub25tb3VzZWRvd24gPSB0aGlzLl9ib3VuZC5vbm1vdXNlZG93bjtcbiAgICBpZiAodGhpcy5wYWdpbmcpIHsgYmFyLm9uY2xpY2sgPSBib3VuZC5vbmNsaWNrOyB9XG4gICAgYmFyLmFwcGVuZENoaWxkKHRodW1iKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gcHJlc2V0c1xuICAgIHRoaXMub3JpZW50YXRpb24gPSAndmVydGljYWwnO1xuICAgIHRoaXMuX21pbiA9IHRoaXMuX2luZGV4ID0gMDtcbiAgICB0aGlzLl9tYXggPSAxMDA7XG5cbiAgICAvLyBvcHRpb25zXG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbiA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpbmRleCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3JhbmdlJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRSYW5nZShvcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9taW4gPSBvcHRpb24ubWluO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXggPSBvcHRpb24ubWF4O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gb3B0aW9uLm1heCAtIG9wdGlvbi5taW4gKyAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS5jaGFyQXQoMCkgIT09ICdfJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIEZpbkJhci5wcm90b3R5cGVba2V5XSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG92ZXJyaWRlIHByb3RvdHlwZSBkZWZhdWx0cyBmb3Igc3RhbmRhcmQgO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZW5kIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzIChmb3IgdXNlIGluIG9uY2hhbmdlIGV2ZW50IGhhbmRsZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjc3NJbmplY3Rvcihjc3NGaW5CYXJzLCAnZmluYmFyLWJhc2UnLCBvcHRpb25zLmNzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50KTtcbn1cblxuRmluQmFyLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFRoZSBzY3JvbGxiYXIgb3JpZW50YXRpb24uXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvciB0byBlaXRoZXIgYCd2ZXJ0aWNhbCdgIG9yIGAnaG9yaXpvbnRhbCdgLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIFVzZWZ1bCB2YWx1ZXMgYXJlIGAndmVydGljYWwnYCAodGhlIGRlZmF1bHQpIG9yIGAnaG9yaXpvbnRhbCdgLlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IHJlc2V0cyBgdGhpcy5vaGAgYW5kIGB0aGlzLmRlbHRhUHJvcGAgYW5kIGNoYW5nZXMgdGhlIGNsYXNzIG5hbWVzIHNvIGFzIHRvIHJlcG9zaXRpb24gdGhlIHNjcm9sbGJhciBhcyBwZXIgdGhlIENTUyBydWxlcyBmb3IgdGhlIG5ldyBvcmllbnRhdGlvbi5cbiAgICAgKiBAZGVmYXVsdCAndmVydGljYWwnXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBvcmllbnRhdGlvbihvcmllbnRhdGlvbikge1xuICAgICAgICBpZiAob3JpZW50YXRpb24gPT09IHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG5hbWUgb2hcbiAgICAgICAgICogQHN1bW1hcnkgPHU+TzwvdT5yaWVudGF0aW9uIDx1Pmg8L3U+YXNoIGZvciB0aGlzIHNjcm9sbGJhci5cbiAgICAgICAgICogQGRlc2MgU2V0IGJ5IHRoZSBgb3JpZW50YXRpb25gIHNldHRlciB0byBlaXRoZXIgdGhlIHZlcnRpY2FsIG9yIHRoZSBob3Jpem9udGFsIG9yaWVudGF0aW9uIGhhc2guIFRoZSBwcm9wZXJ0eSBzaG91bGQgYWx3YXlzIGJlIHN5bmNocm9uaXplZCB3aXRoIGBvcmllbnRhdGlvbmA7IGRvIG5vdCB1cGRhdGUgZGlyZWN0bHkhXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgb2JqZWN0IGlzIHVzZWQgaW50ZXJuYWxseSB0byBhY2Nlc3Mgc2Nyb2xsYmFycycgRE9NIGVsZW1lbnQgcHJvcGVydGllcyBpbiBhIGdlbmVyYWxpemVkIHdheSB3aXRob3V0IG5lZWRpbmcgdG8gY29uc3RhbnRseSBxdWVyeSB0aGUgc2Nyb2xsYmFyIG9yaWVudGF0aW9uLiBGb3IgZXhhbXBsZSwgaW5zdGVhZCBvZiBleHBsaWNpdGx5IGNvZGluZyBgdGhpcy5iYXIudG9wYCBmb3IgYSB2ZXJ0aWNhbCBzY3JvbGxiYXIgYW5kIGB0aGlzLmJhci5sZWZ0YCBmb3IgYSBob3Jpem9udGFsIHNjcm9sbGJhciwgc2ltcGx5IGNvZGUgYHRoaXMuYmFyW3RoaXMub2gubGVhZGluZ11gIGluc3RlYWQuIFNlZSB0aGUge0BsaW5rIG9yaWVudGF0aW9uSGFzaFR5cGV9IGRlZmluaXRpb24gZm9yIGRldGFpbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgb2JqZWN0IGlzIHVzZWZ1bCBleHRlcm5hbGx5IGZvciBjb2RpbmcgZ2VuZXJhbGl6ZWQge0BsaW5rIGZpbmJhck9uQ2hhbmdlfSBldmVudCBoYW5kbGVyIGZ1bmN0aW9ucyB0aGF0IHNlcnZlIGJvdGggaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2Nyb2xsYmFycy5cbiAgICAgICAgICogQHR5cGUge29yaWVudGF0aW9uSGFzaFR5cGV9XG4gICAgICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9oID0gb3JpZW50YXRpb25IYXNoZXNbdGhpcy5fb3JpZW50YXRpb25dO1xuXG4gICAgICAgIGlmICghdGhpcy5vaCkge1xuICAgICAgICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIGBvcHRpb25zLl9vcmllbnRhdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBkZWx0YVByb3BcbiAgICAgICAgICogQHN1bW1hcnkgVGhlIG5hbWUgb2YgdGhlIGBXaGVlbEV2ZW50YCBwcm9wZXJ0eSB0aGlzIHNjcm9sbGJhciBzaG91bGQgbGlzdGVuIHRvLlxuICAgICAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlZnVsIHZhbHVlcyBhcmUgYCdkZWx0YVgnYCwgYCdkZWx0YVknYCwgb3IgYCdkZWx0YVonYC4gQSB2YWx1ZSBvZiBgbnVsbGAgbWVhbnMgdG8gaWdub3JlIG1vdXNlIHdoZWVsIGV2ZW50cyBlbnRpcmVseS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIG1vdXNlIHdoZWVsIGlzIG9uZS1kaW1lbnNpb25hbCBhbmQgb25seSBlbWl0cyBldmVudHMgd2l0aCBgZGVsdGFZYCBkYXRhLiBUaGlzIHByb3BlcnR5IGlzIHByb3ZpZGVkIHNvIHRoYXQgeW91IGNhbiBvdmVycmlkZSB0aGUgZGVmYXVsdCBvZiBgJ2RlbHRhWCdgIHdpdGggYSB2YWx1ZSBvZiBgJ2RlbHRhWSdgIG9uIHlvdXIgaG9yaXpvbnRhbCBzY3JvbGxiYXIgcHJpbWFyaWx5IHRvIGFjY29tbW9kYXRlIGNlcnRhaW4gXCJwYW5vcmFtaWNcIiBpbnRlcmZhY2UgZGVzaWducyB3aGVyZSB0aGUgbW91c2Ugd2hlZWwgc2hvdWxkIGNvbnRyb2wgaG9yaXpvbnRhbCByYXRoZXIgdGhhbiB2ZXJ0aWNhbCBzY3JvbGxpbmcuIEp1c3QgZ2l2ZSBgeyBkZWx0YVByb3A6ICdkZWx0YVknIH1gIGluIHlvdXIgaG9yaXpvbnRhbCBzY3JvbGxiYXIgaW5zdGFudGlhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2F2ZWF0OiBOb3RlIHRoYXQgYSAyLWZpbmdlciBkcmFnIG9uIGFuIEFwcGxlIHRyYWNrcGFkIGVtaXRzIGV2ZW50cyB3aXRoIF9ib3RoXyBgZGVsdGFYIGAgYW5kIGBkZWx0YVlgIGRhdGEgc28geW91IG1pZ2h0IHdhbnQgdG8gZGVsYXkgbWFraW5nIHRoZSBhYm92ZSBhZGp1c3RtZW50IHVudGlsIHlvdSBjYW4gZGV0ZXJtaW5lIHRoYXQgeW91IGFyZSBnZXR0aW5nIFkgZGF0YSBvbmx5IHdpdGggbm8gWCBkYXRhIGF0IGFsbCAod2hpY2ggaXMgYSBzdXJlIGJldCB5b3Ugb24gYSBtb3VzZSB3aGVlbCByYXRoZXIgdGhhbiBhIHRyYWNrcGFkKS5cblxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fG51bGx9XG4gICAgICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbHRhUHJvcCA9IHRoaXMub2guZGVsdGE7XG5cbiAgICAgICAgdGhpcy5iYXIuY2xhc3NOYW1lID0gdGhpcy5iYXIuY2xhc3NOYW1lLnJlcGxhY2UoLyh2ZXJ0aWNhbHxob3Jpem9udGFsKS9nLCBvcmllbnRhdGlvbik7XG5cbiAgICAgICAgaWYgKHRoaXMuYmFyLnN0eWxlLmNzc1RleHQgfHwgdGhpcy50aHVtYi5zdHlsZS5jc3NUZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmJhci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLnRodW1iLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldCBvcmllbnRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDYWxsYmFjayBmb3Igc2Nyb2xsIGV2ZW50cy5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yIHZpYSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LiBBZnRlciBpbnN0YW50aWF0aW9uLCBgdGhpcy5vbmNoYW5nZWAgbWF5IGJlIHVwZGF0ZWQgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGV2ZW50IGhhbmRsZXIgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBvZiB0aGUgc2Nyb2xsYmFyIGlzIGNoYW5nZWQgdGhyb3VnaCB1c2VyIGludGVyYWN0aW9uLiBUaGUgdHlwaWNhbCB1c2UgY2FzZSBpcyB3aGVuIHRoZSBjb250ZW50IGlzIHNjcm9sbGVkLiBJdCBpcyBjYWxsZWQgd2l0aCB0aGUgYEZpbkJhcmAgb2JqZWN0IGFzIGl0cyBjb250ZXh0IGFuZCB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc2Nyb2xsYmFyIChpdHMgaW5kZXgsIHJvdW5kZWQpIGFzIHRoZSBvbmx5IHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIFNldCB0aGlzIHByb3BlcnR5IHRvIGBudWxsYCB0byBzdG9wIGVtaXR0aW5nIHN1Y2ggZXZlbnRzLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIpfG51bGx9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBvbmNoYW5nZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIHRoZSBiYXIgZWxlbWVudCdzIGNsYXNzIGxpc3QuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0IHdpbGwgYWx3YXlzIGluY2x1ZGUgYGZpbmJhci12ZXJ0aWNhbGAgKG9yIGBmaW5iYXItaG9yaXpvbnRhbGAgYmFzZWQgb24gdGhlIGN1cnJlbnQgb3JpZW50YXRpb24pLiBXaGVuZXZlciB0aGlzIHByb3BlcnR5IGlzIHNldCB0byBzb21lIHZhbHVlLCBmaXJzdCB0aGUgb2xkIHByZWZpeCtvcmllbnRhdGlvbiBpcyByZW1vdmVkIGZyb20gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdDsgdGhlbiB0aGUgbmV3IHByZWZpeCtvcmllbnRhdGlvbiBpcyBhZGRlZCB0byB0aGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0LiBUaGlzIHByb3BlcnR5IGNhdXNlcyBfYW4gYWRkaXRpb25hbF8gY2xhc3MgbmFtZSB0byBiZSBhZGRlZCB0byB0aGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0LiBUaGVyZWZvcmUsIHRoaXMgcHJvcGVydHkgd2lsbCBvbmx5IGFkZCBhdCBtb3N0IG9uZSBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgdG8gdGhlIGxpc3QuXG4gICAgICpcbiAgICAgKiBUbyByZW1vdmUgX2NsYXNzbmFtZS1vcmllbnRhdGlvbl8gZnJvbSB0aGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0LCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBhIGZhbHN5IHZhbHVlLCBzdWNoIGFzIGBudWxsYC5cbiAgICAgKlxuICAgICAqID4gTk9URTogWW91IG9ubHkgbmVlZCB0byBzcGVjaWZ5IGFuIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSB3aGVuIHlvdSBuZWVkIHRvIGhhdmUgbXVsbHRpcGxlIGRpZmZlcmVudCBzdHlsZXMgb2Ygc2Nyb2xsYmFycyBvbiB0aGUgc2FtZSBwYWdlLiBJZiB0aGlzIGlzIG5vdCBhIHJlcXVpcmVtZW50LCB0aGVuIHlvdSBkb24ndCBuZWVkIHRvIG1ha2UgYSBuZXcgY2xhc3M7IHlvdSB3b3VsZCBqdXN0IGNyZWF0ZSBzb21lIGFkZGl0aW9uYWwgcnVsZXMgdXNpbmcgdGhlIHNhbWUgc2VsZWN0b3JzIGluIHRoZSBidWlsdC1pbiBzdHlsZXNoZWV0ICguLi9jc3MvZmluYmFycy5jc3MpOlxuICAgICAqICpgZGl2LmZpbmJhci12ZXJ0aWNhbGAgKG9yIGBkaXYuZmluYmFyLWhvcml6b250YWxgKSBmb3IgdGhlIHNjcm9sbGJhclxuICAgICAqICpgZGl2LmZpbmJhci12ZXJ0aWNhbCA+IGRpdmAgKG9yIGBkaXYuZmluYmFyLWhvcml6b250YWwgPiBkaXZgKSBmb3IgdGhlIFwidGh1bWIuXCJcbiAgICAgKlxuICAgICAqIE9mIGNvdXJzZSwgeW91ciBydWxlcyBzaG91bGQgY29tZSBhZnRlciB0aGUgYnVpbHQtaW5zLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXQgY2xhc3NQcmVmaXgocHJlZml4KSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGFzc1ByZWZpeCkge1xuICAgICAgICAgICAgdGhpcy5iYXIuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc1ByZWZpeCArIHRoaXMub3JpZW50YXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2xhc3NQcmVmaXggPSBwcmVmaXg7XG5cbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgdGhpcy5iYXIuY2xhc3NMaXN0LmFkZChwcmVmaXggKyAnLScgKyB0aGlzLm9yaWVudGF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IGNsYXNzUHJlZml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3NQcmVmaXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGluY3JlbWVudFxuICAgICAqIEBzdW1tYXJ5IE51bWJlciBvZiBzY3JvbGxiYXIgaW5kZXggdW5pdHMgcmVwcmVzZW50aW5nIGEgcGFnZWZ1bC4gVXNlZCBleGNsdXNpdmVseSBmb3IgcGFnaW5nIHVwIGFuZCBkb3duIGFuZCBmb3Igc2V0dGluZyB0aHVtYiBzaXplIHJlbGF0aXZlIHRvIGNvbnRlbnQgc2l6ZS5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIENhbiBhbHNvIGJlIGdpdmVuIGFzIGEgcGFyYW1ldGVyIHRvIHRoZSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemV9IG1ldGhvZCwgd2hpY2ggaXMgcGVydGluZW50IGJlY2F1c2UgY29udGVudCBhcmVhIHNpemUgY2hhbmdlcyBhZmZlY3QgdGhlIGRlZmluaXRpb24gb2YgYSBcInBhZ2VmdWwuXCIgSG93ZXZlciwgeW91IG9ubHkgbmVlZCB0byBkbyB0aGlzIGlmIHRoaXMgdmFsdWUgaXMgYmVpbmcgdXNlZC4gSXQgbm90IHVzZWQgd2hlbjpcbiAgICAgKiAqIHlvdSBkZWZpbmUgYHBhZ2luZy51cGAgYW5kIGBwYWdpbmcuZG93bmBcbiAgICAgKiAqIHlvdXIgc2Nyb2xsYmFyIGlzIHVzaW5nIGBzY3JvbGxSZWFsQ29udGVudGBcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5jcmVtZW50OiAxLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgYmFyU3R5bGVzXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsYmFyIHN0eWxlcyB0byBiZSBhcHBsaWVkIGJ5IHtAbGluayBGaW5CYXIjcmVzaXplfHJlc2l6ZSgpfS5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSB2YWx1ZSB0byBiZSBhc3NpZ25lZCB0byB7QGxpbmsgRmluQmFyI3N0eWxlc3xzdHlsZXN9IG9uIGVhY2ggY2FsbCB0byB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0uIFRoYXQgaXMsIGEgaGFzaCBvZiB2YWx1ZXMgdG8gYmUgY29waWVkIHRvIHRoZSBzY3JvbGxiYXIgZWxlbWVudCdzIHN0eWxlIG9iamVjdCBvbiByZXNpemU7IG9yIGBudWxsYCBmb3Igbm9uZS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNzdHlsZXxzdHlsZX1cbiAgICAgKiBAdHlwZSB7ZmluYmFyU3R5bGVzfG51bGx9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBiYXJTdHlsZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBzdHlsZVxuICAgICAqIEBzdW1tYXJ5IEFkZGl0aW9uYWwgc2Nyb2xsYmFyIHN0eWxlcy5cbiAgICAgKiBAZGVzYyBTZWUgdHlwZSBkZWZpbml0aW9uIGZvciBtb3JlIGRldGFpbHMuIFRoZXNlIHN0eWxlcyBhcmUgYXBwbGllZCBkaXJlY3RseSB0byB0aGUgc2Nyb2xsYmFyJ3MgYGJhcmAgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFZhbHVlcyBhcmUgYWRqdXN0ZWQgYXMgZm9sbG93cyBiZWZvcmUgYmVpbmcgYXBwbGllZCB0byB0aGUgZWxlbWVudDpcbiAgICAgKiAxLiBJbmNsdWRlZCBcInBzZXVkby1wcm9wZXJ0eVwiIG5hbWVzIGZyb20gdGhlIHNjcm9sbGJhcidzIG9yaWVudGF0aW9uIGhhc2gsIHtAbGluayBGaW5CYXIjb2h8b2h9LCBhcmUgdHJhbnNsYXRlZCB0byBhY3R1YWwgcHJvcGVydHkgbmFtZXMgYmVmb3JlIGJlaW5nIGFwcGxpZWQuXG4gICAgICogMi4gV2hlbiB0aGVyZSBhcmUgbWFyZ2lucywgcGVyY2VudGFnZXMgYXJlIHRyYW5zbGF0ZWQgdG8gYWJzb2x1dGUgcGl4ZWwgdmFsdWVzIGJlY2F1c2UgQ1NTIGlnbm9yZXMgbWFyZ2lucyBpbiBpdHMgcGVyY2VudGFnZSBjYWxjdWxhdGlvbnMuXG4gICAgICogMy4gSWYgeW91IGdpdmUgYSB2YWx1ZSB3aXRob3V0IGEgdW5pdCAoYSByYXcgbnVtYmVyKSwgXCJweFwiIHVuaXQgaXMgYXBwZW5kZWQuXG4gICAgICpcbiAgICAgKiBHZW5lcmFsIG5vdGVzOlxuICAgICAqIDEuIEl0IGlzIGFsd2F5cyBwcmVmZXJhYmxlIHRvIHNwZWNpZnkgc3R5bGVzIHZpYSBhIHN0eWxlc2hlZXQuIE9ubHkgc2V0IHRoaXMgcHJvcGVydHkgd2hlbiB5b3UgbmVlZCB0byBzcGVjaWZpY2FsbHkgb3ZlcnJpZGUgKGEpIHN0eWxlc2hlZXQgdmFsdWUocykuXG4gICAgICogMi4gQ2FuIGJlIHNldCBkaXJlY3RseSBvciB2aWEgY2FsbHMgdG8gdGhlIHtAbGluayBGaW5CYXIjcmVzaXplfHJlc2l6ZX0gbWV0aG9kLlxuICAgICAqIDMuIFNob3VsZCBvbmx5IGJlIHNldCBhZnRlciB0aGUgc2Nyb2xsYmFyIGhhcyBiZWVuIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICAgKiA0LiBCZWZvcmUgYXBwbHlpbmcgdGhlc2UgbmV3IHZhbHVlcyB0byB0aGUgZWxlbWVudCwgX2FsbF8gaW4tbGluZSBzdHlsZSB2YWx1ZXMgYXJlIHJlc2V0IChieSByZW1vdmluZyB0aGUgZWxlbWVudCdzIGBzdHlsZWAgYXR0cmlidXRlKSwgZXhwb3NpbmcgaW5oZXJpdGVkIHZhbHVlcyAoZnJvbSBzdHlsZXNoZWV0cykuXG4gICAgICogNS4gRW1wdHkgb2JqZWN0IGhhcyBubyBlZmZlY3QuXG4gICAgICogNi4gRmFsc2V5IHZhbHVlIGluIHBsYWNlIG9mIG9iamVjdCBoYXMgbm8gZWZmZWN0LlxuICAgICAqXG4gICAgICogPiBDQVZFQVQ6IERvIG5vdCBhdHRlbXB0IHRvIHRyZWF0IHRoZSBvYmplY3QgeW91IGFzc2lnbiB0byB0aGlzIHByb3BlcnR5IGFzIGlmIGl0IHdlcmUgYHRoaXMuYmFyLnN0eWxlYC4gU3BlY2lmaWNhbGx5LCBjaGFuZ2luZyB0aGlzIG9iamVjdCBhZnRlciBhc3NpZ25pbmcgaXQgd2lsbCBoYXZlIG5vIGVmZmVjdCBvbiB0aGUgc2Nyb2xsYmFyLiBZb3UgbXVzdCBhc3NpZ24gaXQgYWdhaW4gaWYgeW91IHdhbnQgaXQgdG8gaGF2ZSBhbiBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjYmFyU3R5bGVzfGJhclN0eWxlc31cbiAgICAgKiBAdHlwZSB7ZmluYmFyU3R5bGVzfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IHN0eWxlKHN0eWxlcykge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHN0eWxlcyA9IGV4dGVuZCh7fSwgc3R5bGVzLCB0aGlzLl9hdXhTdHlsZXMpKTtcblxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBiYXIgPSB0aGlzLmJhcixcbiAgICAgICAgICAgICAgICBiYXJSZWN0ID0gYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyIHx8IGJhci5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICAgb2ggPSB0aGlzLm9oO1xuXG4gICAgICAgICAgICAvLyBCZWZvcmUgYXBwbHlpbmcgbmV3IHN0eWxlcywgcmV2ZXJ0IGFsbCBzdHlsZXMgdG8gdmFsdWVzIGluaGVyaXRlZCBmcm9tIHN0eWxlc2hlZXRzXG4gICAgICAgICAgICBiYXIucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBzdHlsZXNba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gb2gpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gb2hba2V5XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKE51bWJlcih2YWwpKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAodmFsIHx8IDApICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC8lJC8udGVzdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gYmFyIHNpemUgZ2l2ZW4gYXMgcGVyY2VudGFnZSBvZiBjb250YWluZXIsIGlmIGJhciBoYXMgbWFyZ2lucywgcmVzdGF0ZSBzaXplIGluIHBpeGVscyBsZXNzIG1hcmdpbnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIChJZiBsZWZ0IGFzIHBlcmNlbnRhZ2UsIENTUydzIGNhbGN1bGF0aW9uIHdpbGwgbm90IGV4Y2x1ZGUgbWFyZ2lucy4pXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmllbnRlZCA9IGF4aXNba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbnMgPSBiYXJSZWN0W29yaWVudGVkLm1hcmdpbkxlYWRpbmddICsgYmFyUmVjdFtvcmllbnRlZC5tYXJnaW5UcmFpbGluZ107XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJnaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUludCh2YWwsIDEwKSAvIDEwMCAqIGNvbnRhaW5lclJlY3Rbb3JpZW50ZWQuc2l6ZV0gLSBtYXJnaW5zICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJhci5zdHlsZVtrZXldID0gdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG5hbWUgcGFnaW5nXG4gICAgICogQHN1bW1hcnkgRW5hYmxlIHBhZ2UgdXAvZG4gY2xpY2tzLlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogSWYgdHJ1dGh5LCBsaXN0ZW4gZm9yIGNsaWNrcyBpbiBwYWdlLXVwIGFuZCBwYWdlLWRvd24gcmVnaW9ucyBvZiBzY3JvbGxiYXIuXG4gICAgICpcbiAgICAgKiBJZiBhbiBvYmplY3QsIGNhbGwgYC5wYWdpbmcudXAoKWAgb24gcGFnZS11cCBjbGlja3MgYW5kIGAucGFnaW5nLmRvd24oKWAgd2lsbCBiZSBjYWxsZWQgb24gcGFnZS1kb3duIGNsaWNrcy5cbiAgICAgKlxuICAgICAqIENoYW5naW5nIHRoZSB0cnV0aGluZXNzIG9mIHRoaXMgdmFsdWUgYWZ0ZXIgaW5zdGFudGlhdGlvbiBjdXJyZW50bHkgaGFzIG5vIGVmZmVjdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnxvYmplY3R9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWdpbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSByYW5nZVxuICAgICAqIEBzdW1tYXJ5IFNldHRlciBmb3IgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gc2Nyb2xsIHZhbHVlcy5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBUaGVzZSB2YWx1ZXMgYXJlIHRoZSBsaW1pdHMgZm9yIHtAbGluayBGb29CYXIjaW5kZXh8aW5kZXh9LlxuICAgICAqXG4gICAgICogVGhlIHNldHRlciBhY2NlcHRzIGFuIG9iamVjdCB3aXRoIGV4YWN0bHkgdHdvIG51bWVyaWMgcHJvcGVydGllczogYC5taW5gIHdoaWNoIG11c3QgYmUgbGVzcyB0aGFuIGAubWF4YC4gVGhlIHZhbHVlcyBhcmUgZXh0cmFjdGVkIGFuZCB0aGUgb2JqZWN0IGlzIGRpc2NhcmRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBnZXR0ZXIgcmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBgLm1pbmAgYW5kICcubWF4YC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtyYW5nZVR5cGV9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXQgcmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgdmFsaWRSYW5nZShyYW5nZSk7XG4gICAgICAgIHRoaXMuX21pbiA9IHJhbmdlLm1pbjtcbiAgICAgICAgdGhpcy5fbWF4ID0gcmFuZ2UubWF4O1xuICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gcmFuZ2UubWF4IC0gcmFuZ2UubWluICsgMTtcbiAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuaW5kZXg7IC8vIHJlLWNsYW1wXG4gICAgfSxcbiAgICBnZXQgcmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IHRoaXMuX21pbixcbiAgICAgICAgICAgIG1heDogdGhpcy5fbWF4XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEluZGV4IHZhbHVlIG9mIHRoZSBzY3JvbGxiYXIuXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgcG9zaXRpb24gb2YgdGhlIHNjcm9sbCB0aHVtYi5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyB2YWx1ZSBjbGFtcHMgaXQgdG8ge0BsaW5rIEZpbkJhciNtaW58bWlufS4ue0BsaW5rIEZpbkJhciNtYXh8bWF4fSwgc2Nyb2xsIHRoZSBjb250ZW50LCBhbmQgbW92ZXMgdGh1bWIuXG4gICAgICpcbiAgICAgKiBHZXR0aW5nIHRoaXMgdmFsdWUgcmV0dXJucyB0aGUgY3VycmVudCBpbmRleC4gVGhlIHJldHVybmVkIHZhbHVlIHdpbGwgYmUgaW4gdGhlIHJhbmdlIGBtaW5gLi5gbWF4YC4gSXQgaXMgaW50ZW50aW9uYWxseSBub3Qgcm91bmRlZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIHZhbHVlIGFzIGFuIGFsdGVybmF0aXZlIHRvIChvciBpbiBhZGRpdGlvbiB0bykgdXNpbmcgdGhlIHtAbGluayBGaW5CYXIjb25jaGFuZ2V8b25jaGFuZ2V9IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI19zZXRTY3JvbGx8X3NldFNjcm9sbH1cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IGluZGV4KGlkeCkge1xuICAgICAgICBpZHggPSBNYXRoLm1pbih0aGlzLl9tYXgsIE1hdGgubWF4KHRoaXMuX21pbiwgaWR4KSk7IC8vIGNsYW1wIGl0XG4gICAgICAgIHRoaXMuX3NldFNjcm9sbChpZHgpO1xuICAgICAgICAvLyB0aGlzLl9zZXRUaHVtYlNpemUoKTtcbiAgICB9LFxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzdW1tYXJ5IE1vdmUgdGhlIHRodW1iLlxuICAgICAqIEBkZXNjIEFsc28gZGlzcGxheXMgdGhlIGluZGV4IHZhbHVlIGluIHRoZSB0ZXN0IHBhbmVsIGFuZCBpbnZva2VzIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0gaWR4IC0gVGhlIG5ldyBzY3JvbGwgaW5kZXgsIGEgdmFsdWUgaW4gdGhlIHJhbmdlIGBtaW5gLi5gbWF4YC5cbiAgICAgKiBAcGFyYW0gW3NjYWxlZD1mKGlkeCldIC0gVGhlIG5ldyB0aHVtYiBwb3NpdGlvbiBpbiBwaXhlbHMgYW5kIHNjYWxlZCByZWxhdGl2ZSB0byB0aGUgY29udGFpbmluZyB7QGxpbmsgRmluQmFyI2JhcnxiYXJ9IGVsZW1lbnQsIGkuZS4sIGEgcHJvcG9ydGlvbmFsIG51bWJlciBpbiB0aGUgcmFuZ2UgYDBgLi5gdGh1bWJNYXhgLiBXaGVuIG9taXR0ZWQsIGEgZnVuY3Rpb24gb2YgYGlkeGAgaXMgdXNlZC5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIF9zZXRTY3JvbGw6IGZ1bmN0aW9uIChpZHgsIHNjYWxlZCkge1xuICAgICAgICB0aGlzLl9pbmRleCA9IGlkeDtcblxuICAgICAgICAvLyBEaXNwbGF5IHRoZSBpbmRleCB2YWx1ZSBpbiB0aGUgdGVzdCBwYW5lbFxuICAgICAgICBpZiAodGhpcy50ZXN0UGFuZWxJdGVtICYmIHRoaXMudGVzdFBhbmVsSXRlbS5pbmRleCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudGVzdFBhbmVsSXRlbS5pbmRleC5pbm5lckhUTUwgPSBNYXRoLnJvdW5kKGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFja1xuICAgICAgICBpZiAodGhpcy5vbmNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbmNoYW5nZS5jYWxsKHRoaXMsIE1hdGgucm91bmQoaWR4KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ZlIHRoZSB0aHVtYlxuICAgICAgICBpZiAoc2NhbGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNjYWxlZCA9IChpZHggLSB0aGlzLl9taW4pIC8gKHRoaXMuX21heCAtIHRoaXMuX21pbikgKiB0aGlzLl90aHVtYk1heDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRodW1iLnN0eWxlW3RoaXMub2gubGVhZGluZ10gPSBzY2FsZWQgKyAncHgnO1xuICAgIH0sXG5cbiAgICBzY3JvbGxSZWFsQ29udGVudDogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICB2YXIgY29udGFpbmVyUmVjdCA9IHRoaXMuY29udGVudC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgc2l6ZVByb3AgPSB0aGlzLm9oLnNpemUsXG4gICAgICAgICAgICBtYXhTY3JvbGwgPSBNYXRoLm1heCgwLCB0aGlzLmNvbnRlbnRbc2l6ZVByb3BdIC0gY29udGFpbmVyUmVjdFtzaXplUHJvcF0pLFxuICAgICAgICAgICAgLy9zY3JvbGwgPSBNYXRoLm1pbihpZHgsIG1heFNjcm9sbCk7XG4gICAgICAgICAgICBzY3JvbGwgPSAoaWR4IC0gdGhpcy5fbWluKSAvICh0aGlzLl9tYXggLSB0aGlzLl9taW4pICogbWF4U2Nyb2xsO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdzY3JvbGw6ICcgKyBzY3JvbGwpO1xuICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGVbdGhpcy5vaC5sZWFkaW5nXSA9IC1zY3JvbGwgKyAncHgnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZWNhbGN1bGF0ZSB0aHVtYiBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHJlY2FsY3VsYXRlcyB0aGUgdGh1bWIgc2l6ZSBhbmQgcG9zaXRpb24uIENhbGwgaXQgb25jZSBhZnRlciBpbnNlcnRpbmcgeW91ciBzY3JvbGxiYXIgaW50byB0aGUgRE9NLCBhbmQgcmVwZWF0ZWRseSB3aGlsZSByZXNpemluZyB0aGUgc2Nyb2xsYmFyICh3aGljaCB0eXBpY2FsbHkgaGFwcGVucyB3aGVuIHRoZSBzY3JvbGxiYXIncyBwYXJlbnQgaXMgcmVzaXplZCBieSB1c2VyLlxuICAgICAqXG4gICAgICogPiBUaGlzIGZ1bmN0aW9uIHNoaWZ0cyBhcmdzIGlmIGZpcnN0IGFyZyBvbWl0dGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmNyZW1lbnQ9dGhpcy5pbmNyZW1lbnRdIC0gUmVzZXRzIHtAbGluayBGb29CYXIjaW5jcmVtZW50fGluY3JlbWVudH0gKHNlZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ZpbmJhclN0eWxlc30gW2JhclN0eWxlcz10aGlzLmJhclN0eWxlc10gLSAoU2VlIHR5cGUgZGVmaW5pdGlvbiBmb3IgZGV0YWlscy4pIFNjcm9sbGJhciBzdHlsZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgYmFyIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBPbmx5IHNwZWNpZnkgYSBgYmFyU3R5bGVzYCBvYmplY3Qgd2hlbiB5b3UgbmVlZCB0byBvdmVycmlkZSBzdHlsZXNoZWV0IHZhbHVlcy4gSWYgcHJvdmlkZWQsIGJlY29tZXMgdGhlIG5ldyBkZWZhdWx0IChgdGhpcy5iYXJTdHlsZXNgKSwgZm9yIHVzZSBhcyBhIGRlZmF1bHQgb24gc3Vic2VxdWVudCBjYWxscy5cbiAgICAgKlxuICAgICAqIEl0IGlzIGdlbmVyYWxseSB0aGUgY2FzZSB0aGF0IHRoZSBzY3JvbGxiYXIncyBuZXcgcG9zaXRpb24gaXMgc3VmZmljaWVudGx5IGRlc2NyaWJlZCBieSB0aGUgY3VycmVudCBzdHlsZXMuIFRoZXJlZm9yZSwgaXQgaXMgdW51c3VhbCB0byBuZWVkIHRvIHByb3ZpZGUgYSBgYmFyU3R5bGVzYCBvYmplY3Qgb24gZXZlcnkgY2FsbCB0byBgcmVzaXplYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGaW5CYXJ9IFNlbGYgZm9yIGNoYWluaW5nLlxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbiAoaW5jcmVtZW50LCBiYXJTdHlsZXMpIHtcbiAgICAgICAgdmFyIGJhciA9IHRoaXMuYmFyO1xuXG4gICAgICAgIGlmICghYmFyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gbm90IGluIERPTSB5ZXQgc28gbm90aGluZyB0byBkb1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyIHx8IGJhci5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAvLyBzaGlmdCBhcmdzIGlmIGlmIDFzdCBhcmcgb21pdHRlZFxuICAgICAgICBpZiAodHlwZW9mIGluY3JlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGJhclN0eWxlcyA9IGluY3JlbWVudDtcbiAgICAgICAgICAgIGluY3JlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3R5bGUgPSB0aGlzLmJhclN0eWxlcyA9IGJhclN0eWxlcyB8fCB0aGlzLmJhclN0eWxlcztcblxuICAgICAgICAvLyBCb3VuZCB0byByZWFsIGNvbnRlbnQ6IENvbnRlbnQgd2FzIGdpdmVuIGJ1dCBubyBvbmNoYW5nZSBoYW5kbGVyLlxuICAgICAgICAvLyBTZXQgdXAgLm9uY2hhbmdlLCAuY29udGFpbmVyU2l6ZSwgYW5kIC5pbmNyZW1lbnQuXG4gICAgICAgIC8vIE5vdGUgdGhpcyBvbmx5IG1ha2VzIHNlbnNlIGlmIHlvdXIgaW5kZXggdW5pdCBpcyBwaXhlbHMuXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vbmNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25jaGFuZ2UgPSB0aGlzLnNjcm9sbFJlYWxDb250ZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFNpemUgPSB0aGlzLmNvbnRlbnRbdGhpcy5vaC5zaXplXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW4gPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX21heCA9IHRoaXMuY29udGVudFNpemUgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uY2hhbmdlID09PSB0aGlzLnNjcm9sbFJlYWxDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclNpemUgPSBjb250YWluZXJSZWN0W3RoaXMub2guc2l6ZV07XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudCA9IHRoaXMuY29udGFpbmVyU2l6ZSAvICh0aGlzLmNvbnRlbnRTaXplIC0gdGhpcy5jb250YWluZXJTaXplKSAqICh0aGlzLl9tYXggLSB0aGlzLl9taW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJTaXplID0gMTtcbiAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50ID0gaW5jcmVtZW50IHx8IHRoaXMuaW5jcmVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy50ZXN0UGFuZWxJdGVtID0gdGhpcy50ZXN0UGFuZWxJdGVtIHx8IHRoaXMuX2FkZFRlc3RQYW5lbEl0ZW0oKTtcbiAgICAgICAgdGhpcy5fc2V0VGh1bWJTaXplKCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcblxuICAgICAgICBpZiAodGhpcy5kZWx0YVByb3AgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX2JvdW5kLm9ud2hlZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNob3J0ZW4gdHJhaWxpbmcgZW5kIG9mIHNjcm9sbGJhciBieSB0aGlja25lc3Mgb2Ygc29tZSBvdGhlciBzY3JvbGxiYXIuXG4gICAgICogQGRlc2MgSW4gdGhlIFwiY2xhc3NpY2FsXCIgc2NlbmFyaW8gd2hlcmUgdmVydGljYWwgc2Nyb2xsIGJhciBpcyBvbiB0aGUgcmlnaHQgYW5kIGhvcml6b250YWwgc2Nyb2xsYmFyIGlzIG9uIHRoZSBib3R0b20sIHlvdSB3YW50IHRvIHNob3J0ZW4gdGhlIFwidHJhaWxpbmcgZW5kXCIgKGJvdHRvbSBhbmQgcmlnaHQgZW5kcywgcmVzcGVjdGl2ZWx5KSBvZiBhdCBsZWFzdCBvbmUgb2YgdGhlbSBzbyB0aGV5IGRvbid0IG92ZXJsYXkuXG4gICAgICpcbiAgICAgKiBUaGlzIGNvbnZlbmllbmNlIGZ1bmN0aW9uIGlzIGFuIHByb2dyYW1tYXRpYyBhbHRlcm5hdGl2ZSB0byBoYXJkY29kaW5nIHRoZSBjb3JyZWN0IHN0eWxlIHdpdGggdGhlIGNvcnJlY3QgdmFsdWUgaW4geW91ciBzdHlsZXNoZWV0OyBvciBzZXR0aW5nIHRoZSBjb3JyZWN0IHN0eWxlIHdpdGggdGhlIGNvcnJlY3QgdmFsdWUgaW4gdGhlIHtAbGluayBGaW5CYXIjYmFyU3R5bGVzfGJhclN0eWxlc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI2ZvcmVzaG9ydGVuQnl8Zm9yZXNob3J0ZW5CeX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZpbkJhcnxudWxsfSBvdGhlckZpbkJhciAtIE90aGVyIHNjcm9sbGJhciB0byBhdm9pZCBieSBzaG9ydGVuaW5nIHRoaXMgb25lOyBgbnVsbGAgcmVtb3ZlcyB0aGUgdHJhaWxpbmcgc3BhY2VcbiAgICAgKiBAcmV0dXJucyB7RmluQmFyfSBGb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBzaG9ydGVuQnk6IGZ1bmN0aW9uIChvdGhlckZpbkJhcikgeyByZXR1cm4gdGhpcy5zaG9ydGVuRW5kQnkoJ3RyYWlsaW5nJywgb3RoZXJGaW5CYXIpOyB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2hvcnRlbiBsZWFkaW5nIGVuZCBvZiBzY3JvbGxiYXIgYnkgdGhpY2tuZXNzIG9mIHNvbWUgb3RoZXIgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIFN1cHBvcnRzIG5vbi1jbGFzc2ljYWwgc2Nyb2xsYmFyIHNjZW5hcmlvcyB3aGVyZSB2ZXJ0aWNhbCBzY3JvbGwgYmFyIG1heSBiZSBvbiBsZWZ0IGFuZCBob3Jpem9udGFsIHNjcm9sbGJhciBtYXkgYmUgb24gdG9wLCBpbiB3aGljaCBjYXNlIHlvdSB3YW50IHRvIHNob3J0ZW4gdGhlIFwibGVhZGluZyBlbmRcIiByYXRoZXIgdGhhbiB0aGUgdHJhaWxpbmcgZW5kLlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNzaG9ydGVuQnl8c2hvcnRlbkJ5fS5cbiAgICAgKiBAcGFyYW0ge0ZpbkJhcnxudWxsfSBvdGhlckZpbkJhciAtIE90aGVyIHNjcm9sbGJhciB0byBhdm9pZCBieSBzaG9ydGVuaW5nIHRoaXMgb25lOyBgbnVsbGAgcmVtb3ZlcyB0aGUgdHJhaWxpbmcgc3BhY2VcbiAgICAgKiBAcmV0dXJucyB7RmluQmFyfSBGb3IgY2hhaW5pbmdcbiAgICAgKi9cbiAgICBmb3Jlc2hvcnRlbkJ5OiBmdW5jdGlvbiAob3RoZXJGaW5CYXIpIHsgcmV0dXJuIHRoaXMuc2hvcnRlbkVuZEJ5KCdsZWFkaW5nJywgb3RoZXJGaW5CYXIpOyB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2VuZXJhbGl6ZWQgc2hvcnRlbmluZyBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc2hvcnRlbkJ5fHNob3J0ZW5CeX0uXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI2ZvcmVzaG9ydGVuQnl8Zm9yZXNob3J0ZW5CeX0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdoaWNoRW5kIC0gYSBDU1Mgc3R5bGUgcHJvcGVydHkgbmFtZSBvciBhbiBvcmllbnRhdGlvbiBoYXNoIG5hbWUgdGhhdCB0cmFuc2xhdGVzIHRvIGEgQ1NTIHN0eWxlIHByb3BlcnR5IG5hbWUuXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgc2hvcnRlbkVuZEJ5OiBmdW5jdGlvbiAod2hpY2hFbmQsIG90aGVyRmluQmFyKSB7XG4gICAgICAgIGlmICghb3RoZXJGaW5CYXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hdXhTdHlsZXM7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoZXJGaW5CYXIgaW5zdGFuY2VvZiBGaW5CYXIgJiYgb3RoZXJGaW5CYXIub3JpZW50YXRpb24gIT09IHRoaXMub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBvdGhlclN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUob3RoZXJGaW5CYXIuYmFyKSxcbiAgICAgICAgICAgICAgICBvb2ggPSBvcmllbnRhdGlvbkhhc2hlc1tvdGhlckZpbkJhci5vcmllbnRhdGlvbl07XG4gICAgICAgICAgICB0aGlzLl9hdXhTdHlsZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2F1eFN0eWxlc1t3aGljaEVuZF0gPSBvdGhlclN0eWxlW29vaC50aGlja25lc3NdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSBTZXRzIHRoZSBwcm9wb3J0aW9uYWwgdGh1bWIgc2l6ZSBhbmQgaGlkZXMgdGh1bWIgd2hlbiAxMDAlLlxuICAgICAqIEBkZXNjIFRoZSB0aHVtYiBzaXplIGhhcyBhbiBhYnNvbHV0ZSBtaW5pbXVtIG9mIDIwIChwaXhlbHMpLlxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgX3NldFRodW1iU2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2ggPSB0aGlzLm9oLFxuICAgICAgICAgICAgdGh1bWJDb21wID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy50aHVtYiksXG4gICAgICAgICAgICB0aHVtYk1hcmdpbkxlYWRpbmcgPSBwYXJzZUludCh0aHVtYkNvbXBbb2gubWFyZ2luTGVhZGluZ10pLFxuICAgICAgICAgICAgdGh1bWJNYXJnaW5UcmFpbGluZyA9IHBhcnNlSW50KHRodW1iQ29tcFtvaC5tYXJnaW5UcmFpbGluZ10pLFxuICAgICAgICAgICAgdGh1bWJNYXJnaW5zID0gdGh1bWJNYXJnaW5MZWFkaW5nICsgdGh1bWJNYXJnaW5UcmFpbGluZyxcbiAgICAgICAgICAgIGJhclNpemUgPSB0aGlzLmJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtvaC5zaXplXSxcbiAgICAgICAgICAgIHRodW1iU2l6ZSA9IE1hdGgubWF4KDIwLCBiYXJTaXplICogdGhpcy5jb250YWluZXJTaXplIC8gdGhpcy5jb250ZW50U2l6ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyU2l6ZSA8IHRoaXMuY29udGVudFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICB0aGlzLnRodW1iLnN0eWxlW29oLnNpemVdID0gdGh1bWJTaXplICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbmFtZSBfdGh1bWJNYXhcbiAgICAgICAgICogQHN1bW1hcnkgTWF4aW11bSBvZmZzZXQgb2YgdGh1bWIncyBsZWFkaW5nIGVkZ2UuXG4gICAgICAgICAqIEBkZXNjIFRoaXMgaXMgdGhlIHBpeGVsIG9mZnNldCB3aXRoaW4gdGhlIHNjcm9sbGJhciBvZiB0aGUgdGh1bWIgd2hlbiBpdCBpcyBhdCBpdHMgbWF4aW11bSBwb3NpdGlvbiBhdCB0aGUgZXh0cmVtZSBlbmQgb2YgaXRzIHJhbmdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHZhbHVlIHRha2VzIGludG8gYWNjb3VudCB0aGUgbmV3bHkgY2FsY3VsYXRlZCBzaXplIG9mIHRoZSB0aHVtYiBlbGVtZW50IChpbmNsdWRpbmcgaXRzIG1hcmdpbnMpIGFuZCB0aGUgaW5uZXIgc2l6ZSBvZiB0aGUgc2Nyb2xsYmFyICh0aGUgdGh1bWIncyBjb250YWluaW5nIGVsZW1lbnQsIGluY2x1ZGluZyBfaXRzXyBtYXJnaW5zKS5cbiAgICAgICAgICpcbiAgICAgICAgICogTk9URTogU2Nyb2xsYmFyIHBhZGRpbmcgaXMgbm90IHRha2VuIGludG8gYWNjb3VudCBhbmQgYXNzdW1lZCB0byBiZSAwIGluIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIGFuZCBpcyBhc3N1bWVkIHRvIGJlIGAwYDsgdXNlIHRodW1iIG1hcmdpbnMgaW4gcGxhY2Ugb2Ygc2Nyb2xsYmFyIHBhZGRpbmcuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90aHVtYk1heCA9IGJhclNpemUgLSB0aHVtYlNpemUgLSB0aHVtYk1hcmdpbnM7XG5cbiAgICAgICAgdGhpcy5fdGh1bWJNYXJnaW5MZWFkaW5nID0gdGh1bWJNYXJnaW5MZWFkaW5nOyAvLyB1c2VkIGluIG1vdXNlZG93blxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZW1vdmUgdGhlIHNjcm9sbGJhci5cbiAgICAgKiBAZGVzYyBVbmhvb2tzIGFsbCB0aGUgZXZlbnQgaGFuZGxlcnMgYW5kIHRoZW4gcmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00uIEFsd2F5cyBjYWxsIHRoaXMgbWV0aG9kIHByaW9yIHRvIGRpc3Bvc2luZyBvZiB0aGUgc2Nyb2xsYmFyIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJhci5vbm1vdXNlZG93biA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2Vtb3ZlJyk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2V1cCcpO1xuXG4gICAgICAgICh0aGlzLmNvbnRhaW5lciB8fCB0aGlzLmJhci5wYXJlbnRFbGVtZW50KS5fcmVtb3ZlRXZ0KCd3aGVlbCcsIHRoaXMuX2JvdW5kLm9ud2hlZWwpO1xuXG4gICAgICAgIHRoaXMuYmFyLm9uY2xpY2sgPVxuICAgICAgICAgICAgdGhpcy50aHVtYi5vbmNsaWNrID1cbiAgICAgICAgICAgICAgICB0aGlzLnRodW1iLm9ubW91c2VvdmVyID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50aHVtYi50cmFuc2l0aW9uZW5kID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGh1bWIub25tb3VzZW91dCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5iYXIucmVtb3ZlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIF9hZGRUZXN0UGFuZWxJdGVtXG4gICAgICogQHN1bW1hcnkgQXBwZW5kIGEgdGVzdCBwYW5lbCBlbGVtZW50LlxuICAgICAqIEBkZXNjIElmIHRoZXJlIGlzIGEgdGVzdCBwYW5lbCBpbiB0aGUgRE9NICh0eXBpY2FsbHkgYW4gYDxvbD4uLi48L29sPmAgZWxlbWVudCkgd2l0aCBjbGFzcyBuYW1lcyBvZiBib3RoIGB0aGlzLmNsYXNzUHJlZml4YCBhbmQgYCd0ZXN0LXBhbmVsJ2AgKG9yLCBiYXJyaW5nIHRoYXQsIGFueSBlbGVtZW50IHdpdGggY2xhc3MgbmFtZSBgJ3Rlc3QtcGFuZWwnYCksIGFuIGA8bGk+Li4uPC9saT5gIGVsZW1lbnQgd2lsbCBiZSBjcmVhdGVkIGFuZCBhcHBlbmRlZCB0byBpdC4gVGhpcyBuZXcgZWxlbWVudCB3aWxsIGNvbnRhaW4gYSBzcGFuIGZvciBlYWNoIGNsYXNzIG5hbWUgZ2l2ZW4uXG4gICAgICpcbiAgICAgKiBZb3Ugc2hvdWxkIGRlZmluZSBhIENTUyBzZWxlY3RvciBgLmxpc3RlbmluZ2AgZm9yIHRoZXNlIHNwYW5zLiBUaGlzIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNwYW5zIHRvIGFsdGVyIHRoZWlyIGFwcGVhcmFuY2Ugd2hlbiBhIGxpc3RlbmVyIGlzIGFkZGVkIHdpdGggdGhhdCBjbGFzcyBuYW1lIChwcmVmaXhlZCB3aXRoICdvbicpLlxuICAgICAqXG4gICAgICogKFRoaXMgaXMgYW4gaW50ZXJuYWwgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb25jZSBieSB0aGUgY29uc3RydWN0b3Igb24gZXZlcnkgaW5zdGFudGlhdGlvbi4pXG4gICAgICogQHJldHVybnMge0VsZW1lbnR8dW5kZWZpbmVkfSBUaGUgYXBwZW5kZWQgYDxsaT4uLi48L2xpPmAgZWxlbWVudCBvciBgdW5kZWZpbmVkYCBpZiB0aGVyZSBpcyBubyB0ZXN0IHBhbmVsLlxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgX2FkZFRlc3RQYW5lbEl0ZW06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRlc3RQYW5lbEl0ZW0sXG4gICAgICAgICAgICB0ZXN0UGFuZWxFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLicgKyB0aGlzLl9jbGFzc1ByZWZpeCArICcudGVzdC1wYW5lbCcpIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZXN0LXBhbmVsJyk7XG5cbiAgICAgICAgaWYgKHRlc3RQYW5lbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciB0ZXN0UGFuZWxJdGVtUGFydE5hbWVzID0gWyAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJywgJ2luZGV4JyBdLFxuICAgICAgICAgICAgICAgIGl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXG4gICAgICAgICAgICB0ZXN0UGFuZWxJdGVtUGFydE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcnROYW1lKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5pbm5lckhUTUwgKz0gJzxzcGFuIGNsYXNzPVwiJyArIHBhcnROYW1lICsgJ1wiPicgKyBwYXJ0TmFtZS5yZXBsYWNlKCdtb3VzZScsICcnKSArICc8L3NwYW4+JztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0ZXN0UGFuZWxFbGVtZW50LmFwcGVuZENoaWxkKGl0ZW0pO1xuXG4gICAgICAgICAgICB0ZXN0UGFuZWxJdGVtID0ge307XG4gICAgICAgICAgICB0ZXN0UGFuZWxJdGVtUGFydE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcnROYW1lKSB7XG4gICAgICAgICAgICAgICAgdGVzdFBhbmVsSXRlbVtwYXJ0TmFtZV0gPSBpdGVtLmdldEVsZW1lbnRzQnlDbGFzc05hbWUocGFydE5hbWUpWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGVzdFBhbmVsSXRlbTtcbiAgICB9LFxuXG4gICAgX2FkZEV2dDogZnVuY3Rpb24gKGV2dE5hbWUpIHtcbiAgICAgICAgdmFyIHNweSA9IHRoaXMudGVzdFBhbmVsSXRlbSAmJiB0aGlzLnRlc3RQYW5lbEl0ZW1bZXZ0TmFtZV07XG4gICAgICAgIGlmIChzcHkpIHsgc3B5LmNsYXNzTGlzdC5hZGQoJ2xpc3RlbmluZycpOyB9XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2dE5hbWUsIHRoaXMuX2JvdW5kWydvbicgKyBldnROYW1lXSk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVFdnQ6IGZ1bmN0aW9uIChldnROYW1lKSB7XG4gICAgICAgIHZhciBzcHkgPSB0aGlzLnRlc3RQYW5lbEl0ZW0gJiYgdGhpcy50ZXN0UGFuZWxJdGVtW2V2dE5hbWVdO1xuICAgICAgICBpZiAoc3B5KSB7IHNweS5jbGFzc0xpc3QucmVtb3ZlKCdsaXN0ZW5pbmcnKTsgfVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnROYW1lLCB0aGlzLl9ib3VuZFsnb24nICsgZXZ0TmFtZV0pO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgb2JqbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaWYgKG9iam4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmpuKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBvYmpuW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gdmFsaWRSYW5nZShyYW5nZSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmFuZ2UpLFxuICAgICAgICB2YWxpZCA9ICBrZXlzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgdHlwZW9mIHJhbmdlLm1pbiA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGVvZiByYW5nZS5tYXggPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICByYW5nZS5taW4gPD0gcmFuZ2UubWF4O1xuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCAucmFuZ2Ugb2JqZWN0LicpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFuZGxlcnNUb0JlQm91bmRcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAZGVzYyBUaGUgZnVuY3Rpb25zIGRlZmluZWQgaW4gdGhpcyBvYmplY3QgYXJlIGFsbCBET00gZXZlbnQgaGFuZGxlcnMgdGhhdCBhcmUgYm91bmQgYnkgdGhlIEZpbkJhciBjb25zdHJ1Y3RvciB0byBlYWNoIG5ldyBpbnN0YW5jZS4gSW4gb3RoZXIgd29yZHMsIHRoZSBgdGhpc2AgdmFsdWUgb2YgdGhlc2UgaGFuZGxlcnMsIG9uY2UgYm91bmQsIHJlZmVyIHRvIHRoZSBGaW5CYXIgb2JqZWN0IGFuZCBub3QgdG8gdGhlIGV2ZW50IGVtaXR0ZXIuIFwiRG8gbm90IGNvbnN1bWUgcmF3LlwiXG4gKi9cbnZhciBoYW5kbGVyc1RvQmVCb3VuZCA9IHtcbiAgICBzaG9ydFN0b3A6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG5cbiAgICBvbndoZWVsOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHRoaXMuaW5kZXggKz0gZXZ0W3RoaXMuZGVsdGFQcm9wXTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25jbGljazogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgdGh1bWJCb3ggPSB0aGlzLnRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgZ29pbmdVcCA9IGV2dFt0aGlzLm9oLmNvb3JkaW5hdGVdIDwgdGh1bWJCb3hbdGhpcy5vaC5sZWFkaW5nXTtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucGFnaW5nID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMucGFnaW5nW2dvaW5nVXAgPyAndXAnIDogJ2Rvd24nXShNYXRoLnJvdW5kKHRoaXMuaW5kZXgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gZ29pbmdVcCA/IC10aGlzLmluY3JlbWVudCA6IHRoaXMuaW5jcmVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSB0aGUgdGh1bWIgZ2xvdyBtb21lbnRhcmlseVxuICAgICAgICB0aGlzLnRodW1iLmNsYXNzTGlzdC5hZGQoJ2hvdmVyJyk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy50aHVtYi5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24gd2FpdEZvckl0KCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgd2FpdEZvckl0KTtcbiAgICAgICAgICAgIHNlbGYuX2JvdW5kLm9ubW91c2V1cChldnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIG9ubW91c2VvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGh1bWIuY2xhc3NMaXN0LmFkZCgnaG92ZXInKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRodW1iLmNsYXNzTGlzdC5yZW1vdmUoJ2hvdmVyJyk7XG4gICAgfSxcblxuICAgIG9ubW91c2Vkb3duOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHZhciB0aHVtYkJveCA9IHRoaXMudGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMucGluT2Zmc2V0ID0gZXZ0W3RoaXMub2guYXhpc10gLSB0aHVtYkJveFt0aGlzLm9oLmxlYWRpbmddICsgdGhpcy5iYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbdGhpcy5vaC5sZWFkaW5nXSArIHRoaXMuX3RodW1iTWFyZ2luTGVhZGluZztcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcblxuICAgICAgICB0aGlzLl9hZGRFdnQoJ21vdXNlbW92ZScpO1xuICAgICAgICB0aGlzLl9hZGRFdnQoJ21vdXNldXAnKTtcblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlbW92ZTogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgc2NhbGVkID0gTWF0aC5taW4odGhpcy5fdGh1bWJNYXgsIE1hdGgubWF4KDAsIGV2dFt0aGlzLm9oLmF4aXNdIC0gdGhpcy5waW5PZmZzZXQpKTtcbiAgICAgICAgdmFyIGlkeCA9IHNjYWxlZCAvIHRoaXMuX3RodW1iTWF4ICogKHRoaXMuX21heCAtIHRoaXMuX21pbikgKyB0aGlzLl9taW47XG5cbiAgICAgICAgdGhpcy5fc2V0U2Nyb2xsKGlkeCwgc2NhbGVkKTtcblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNldXA6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmN1cnNvciA9ICdhdXRvJztcblxuICAgICAgICB2YXIgdGh1bWJCb3ggPSB0aGlzLnRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aHVtYkJveC5sZWZ0IDw9IGV2dC5jbGllbnRYICYmIGV2dC5jbGllbnRYIDw9IHRodW1iQm94LnJpZ2h0ICYmXG4gICAgICAgICAgICB0aHVtYkJveC50b3AgPD0gZXZ0LmNsaWVudFkgJiYgZXZ0LmNsaWVudFkgPD0gdGh1bWJCb3guYm90dG9tXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5fYm91bmQub25tb3VzZW92ZXIoZXZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kLm9ubW91c2VvdXQoZXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxudmFyIG9yaWVudGF0aW9uSGFzaGVzID0ge1xuICAgIHZlcnRpY2FsOiB7XG4gICAgICAgIGNvb3JkaW5hdGU6ICAgICAnY2xpZW50WScsXG4gICAgICAgIGF4aXM6ICAgICAgICAgICAncGFnZVknLFxuICAgICAgICBzaXplOiAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgIG91dHNpZGU6ICAgICAgICAncmlnaHQnLFxuICAgICAgICBpbnNpZGU6ICAgICAgICAgJ2xlZnQnLFxuICAgICAgICBsZWFkaW5nOiAgICAgICAgJ3RvcCcsXG4gICAgICAgIHRyYWlsaW5nOiAgICAgICAnYm90dG9tJyxcbiAgICAgICAgbWFyZ2luTGVhZGluZzogICdtYXJnaW5Ub3AnLFxuICAgICAgICBtYXJnaW5UcmFpbGluZzogJ21hcmdpbkJvdHRvbScsXG4gICAgICAgIHRoaWNrbmVzczogICAgICAnd2lkdGgnLFxuICAgICAgICBkZWx0YTogICAgICAgICAgJ2RlbHRhWSdcbiAgICB9LFxuICAgIGhvcml6b250YWw6IHtcbiAgICAgICAgY29vcmRpbmF0ZTogICAgICdjbGllbnRYJyxcbiAgICAgICAgYXhpczogICAgICAgICAgICdwYWdlWCcsXG4gICAgICAgIHNpemU6ICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICBvdXRzaWRlOiAgICAgICAgJ2JvdHRvbScsXG4gICAgICAgIGluc2lkZTogICAgICAgICAndG9wJyxcbiAgICAgICAgbGVhZGluZzogICAgICAgICdsZWZ0JyxcbiAgICAgICAgdHJhaWxpbmc6ICAgICAgICdyaWdodCcsXG4gICAgICAgIG1hcmdpbkxlYWRpbmc6ICAnbWFyZ2luTGVmdCcsXG4gICAgICAgIG1hcmdpblRyYWlsaW5nOiAnbWFyZ2luUmlnaHQnLFxuICAgICAgICB0aGlja25lc3M6ICAgICAgJ2hlaWdodCcsXG4gICAgICAgIGRlbHRhOiAgICAgICAgICAnZGVsdGFYJ1xuICAgIH1cbn07XG5cbnZhciBheGlzID0ge1xuICAgIHRvcDogICAgJ3ZlcnRpY2FsJyxcbiAgICBib3R0b206ICd2ZXJ0aWNhbCcsXG4gICAgaGVpZ2h0OiAndmVydGljYWwnLFxuICAgIGxlZnQ6ICAgJ2hvcml6b250YWwnLFxuICAgIHJpZ2h0OiAgJ2hvcml6b250YWwnLFxuICAgIHdpZHRoOiAgJ2hvcml6b250YWwnXG59O1xuXG52YXIgY3NzRmluQmFyczsgLy8gZGVmaW5pdGlvbiBpbnNlcnRlZCBieSBndWxwZmlsZSBiZXR3ZWVuIGZvbGxvd2luZyBjb21tZW50c1xuLyogaW5qZWN0OmNzcyAqL1xuY3NzRmluQmFycyA9ICdkaXYuZmluYmFyLWhvcml6b250YWwsZGl2LmZpbmJhci12ZXJ0aWNhbHtwb3NpdGlvbjphYnNvbHV0ZTttYXJnaW46M3B4fWRpdi5maW5iYXItaG9yaXpvbnRhbD4udGh1bWIsZGl2LmZpbmJhci12ZXJ0aWNhbD4udGh1bWJ7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZC1jb2xvcjojZDNkM2QzOy13ZWJraXQtYm94LXNoYWRvdzowIDAgMXB4ICMwMDA7LW1vei1ib3gtc2hhZG93OjAgMCAxcHggIzAwMDtib3gtc2hhZG93OjAgMCAxcHggIzAwMDtib3JkZXItcmFkaXVzOjRweDttYXJnaW46MnB4O29wYWNpdHk6LjQ7dHJhbnNpdGlvbjpvcGFjaXR5IC41c31kaXYuZmluYmFyLWhvcml6b250YWw+LnRodW1iLmhvdmVyLGRpdi5maW5iYXItdmVydGljYWw+LnRodW1iLmhvdmVye29wYWNpdHk6MTt0cmFuc2l0aW9uOm9wYWNpdHkgLjVzfWRpdi5maW5iYXItdmVydGljYWx7dG9wOjA7Ym90dG9tOjA7cmlnaHQ6MDt3aWR0aDoxMXB4fWRpdi5maW5iYXItdmVydGljYWw+LnRodW1ie3RvcDowO3JpZ2h0OjA7d2lkdGg6N3B4fWRpdi5maW5iYXItaG9yaXpvbnRhbHtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDtoZWlnaHQ6MTFweH1kaXYuZmluYmFyLWhvcml6b250YWw+LnRodW1ie2xlZnQ6MDtib3R0b206MDtoZWlnaHQ6N3B4fSc7XG4vKiBlbmRpbmplY3QgKi9cblxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gICAgdGhyb3cgJ2ZpbmJhcnM6ICcgKyBtc2c7XG59XG5cbi8vIEludGVyZmFjZVxubW9kdWxlLmV4cG9ydHMgPSBGaW5CYXI7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IGZ1bmN0aW9uKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHVuZGVmaW5lZCB9O1xuICAgICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICAgIHJldHVybiBldnQ7XG4gICAgfTtcblxuICAgIHdpbmRvdy5DdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xufVxuXG52YXIgcmVjdGFuZ3VsYXIgPSByZXF1aXJlKCdyZWN0YW5ndWxhcicpO1xuXG52YXIgR3JhcGhpY3NDb250ZXh0ID0gcmVxdWlyZSgnLi9qcy9HcmFwaGljc0NvbnRleHQuanMnKTtcblxudmFyIFJFU0laRV9QT0xMSU5HX0lOVEVSVkFMID0gMjAwLFxuICAgIHBhaW50YWJsZXMgPSBbXSxcbiAgICByZXNpemFibGVzID0gW10sXG4gICAgcGFpbnRMb29wUnVubmluZyA9IHRydWUsXG4gICAgcmVzaXplTG9vcFJ1bm5pbmcgPSB0cnVlLFxuICAgIGNoYXJNYXAgPSBtYWtlQ2hhck1hcCgpO1xuXG5mdW5jdGlvbiBDYW52YXMoZGl2LCBjb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZG91YmxlQ2xpY2tEZWxheSA9IG9wdGlvbnMuZG91YmxlQ2xpY2tEZWxheSB8fCAzMjU7XG5cbiAgICB0aGlzLmRyYWdFbmR0aW1lID0gRGF0ZS5ub3coKTtcblxuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgdGhpcy5jYW52YXMuc3R5bGUub3V0bGluZSA9ICdub25lJztcblxuICAgIC8vIHRoaXMuZm9jdXNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIC8vIHRoaXMuZm9jdXNlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIC8vIHRoaXMuZm9jdXNlci5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLnpJbmRleCA9ICctMSc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgLy8gdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5mb2N1c2VyKTtcblxuICAgIHRoaXMuY2FudmFzQ1RYID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmdjID0gbmV3IEdyYXBoaWNzQ29udGV4dCh0aGlzLmNhbnZhc0NUWCk7XG5cbiAgICB0aGlzLmJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuYnVmZmVyQ1RYID0gdGhpcy5idWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmJ1ZmZlckdDID0gbmV3IEdyYXBoaWNzQ29udGV4dCh0aGlzLmJ1ZmZlckNUWCk7XG5cbiAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoLTEsIC0xKTtcbiAgICB0aGlzLmRyYWdzdGFydCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgtMSwgLTEpO1xuICAgIC8vdGhpcy5vcmlnaW4gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgcmVjdGFuZ3VsYXIuUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xuICAgIHRoaXMuaGFzTW91c2UgPSBmYWxzZTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzTW91c2UgfHwgc2VsZi5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHNlbGYuZmlubW91c2Vtb3ZlKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5tb3VzZXVwKGUpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbndoZWVsbW92ZWQoZSk7XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5rZXlkb3duKGUpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmtleXVwKGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYW52YXMub25tb3VzZW92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5oYXNNb3VzZSA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5mb2N1c2dhaW5lZChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmZvY3VzbG9zdChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmlubW91c2Vkb3duKGUpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmhhc01vdXNlID0gZmFsc2U7XG4gICAgICAgIHNlbGYuZmlubW91c2VvdXQoZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluY2xpY2soZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluY29udGV4dG1lbnUoZSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgIHRoaXMuY2FudmFzLmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgdGhpcy5iZWdpblJlc2l6aW5nKCk7XG4gICAgdGhpcy5iZWdpblBhaW50aW5nKCk7XG59XG5cbkNhbnZhcy5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENhbnZhcy5wcm90b3R5cGUuY29uc3RydWN0b3IsXG4gICAgZGl2OiBudWxsLFxuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBjYW52YXM6IG51bGwsXG4gICAgY2FudmFzQ1RYOiBudWxsLFxuICAgIGZvY3VzZXI6IG51bGwsXG4gICAgYnVmZmVyOiBudWxsLFxuICAgIGN0eDogbnVsbCxcbiAgICBtb3VzZUxvY2F0aW9uOiBudWxsLFxuICAgIGRyYWdzdGFydDogbnVsbCxcbiAgICBvcmlnaW46IG51bGwsXG4gICAgYm91bmRzOiBudWxsLFxuICAgIGRpcnR5OiBmYWxzZSxcbiAgICBzaXplOiBudWxsLFxuICAgIG1vdXNlZG93bjogZmFsc2UsXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgIHJlcGVhdEtleUNvdW50OiAwLFxuICAgIHJlcGVhdEtleTogbnVsbCxcbiAgICByZXBlYXRLZXlTdGFydFRpbWU6IDAsXG4gICAgY3VycmVudEtleXM6IFtdLFxuICAgIGhhc01vdXNlOiBmYWxzZSxcbiAgICBsYXN0RG91YmxlQ2xpY2tUaW1lOiAwLFxuICAgIGRyYWdFbmRUaW1lOiAwLFxuICAgIGxhc3RSZXBhaW50VGltZTogMCxcbiAgICBjdXJyZW50UGFpbnRDb3VudDogMCxcbiAgICBjdXJyZW50RlBTOiAwLFxuICAgIGxhc3RGUFNDb21wdXRlVGltZTogMCxcblxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBzdG9wUGFpbnRMb29wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcGFpbnRMb29wUnVubmluZyA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICByZXN0YXJ0UGFpbnRMb29wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHBhaW50TG9vcFJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gYWxyZWFkeSBydW5uaW5nXG4gICAgICAgIH1cbiAgICAgICAgcGFpbnRMb29wUnVubmluZyA9IHRydWU7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShwYWludExvb3BGdW5jdGlvbik7XG4gICAgfSxcblxuICAgIHN0b3BSZXNpemVMb29wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzaXplTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgcmVzdGFydFJlc2l6ZUxvb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmVzaXplTG9vcFJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gYWxyZWFkeSBydW5uaW5nXG4gICAgICAgIH1cbiAgICAgICAgcmVzaXplTG9vcFJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICBzZXRJbnRlcnZhbChyZXNpemFibGVzTG9vcEZ1bmN0aW9uLCAyMDApO1xuICAgIH0sXG5cbiAgICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3RvcFBhaW50aW5nKCk7XG4gICAgICAgIHRoaXMuc3RvcFJlc2l6aW5nKCk7XG4gICAgfSxcblxuICAgIHVzZUhpRFBJOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LnJlc29sdmVQcm9wZXJ0eSgndXNlSGlEUEknKTtcbiAgICB9LFxuXG4gICAgdXNlQml0QmxpdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5yZXNvbHZlUHJvcGVydHkoJ3VzZUJpdEJsaXQnKTtcbiAgICB9LFxuXG4gICAgZ2V0RlBTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZwcyA9IHRoaXMuY29tcG9uZW50LnJlc29sdmVQcm9wZXJ0eSgncmVwYWludEludGVydmFsUmF0ZScpO1xuICAgICAgICByZXR1cm4gZnBzID8gcGFyc2VJbnQoZnBzKSA6IDA7XG4gICAgfSxcblxuICAgIGdldEVuYWJsZUNvbnRpbnVvdXNSZXBhaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5yZXNvbHZlUHJvcGVydHkoJ2VuYWJsZUNvbnRpbnVvdXNSZXBhaW50Jyk7XG4gICAgfSxcblxuICAgIGdldEN1cnJlbnRGUFM6ZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RlBTO1xuICAgIH0sXG5cblxuICAgIHRpY2tQYWludDogZnVuY3Rpb24obm93KSB7XG4gICAgICAgIHZhciBmcHMgPSB0aGlzLmdldEZQUygpO1xuICAgICAgICB2YXIgaXNDb250aW51b3VzUmVwYWludCA9IHRoaXMuZ2V0RW5hYmxlQ29udGludW91c1JlcGFpbnQoKTtcbiAgICAgICAgaWYgKGZwcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDEwMDAgLyBmcHM7XG5cbiAgICAgICAgdmFyIGVsYXBzZWQgPSBub3cgLSB0aGlzLmxhc3RSZXBhaW50VGltZTtcbiAgICAgICAgaWYgKGVsYXBzZWQgPiBpbnRlcnZhbCAmJiAoaXNDb250aW51b3VzUmVwYWludCB8fCB0aGlzLmRpcnR5KSkge1xuICAgICAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVwYWludFRpbWUgPSBub3c7XG4gICAgICAgICAgICAvKiAtIChlbGFwc2VkICUgaW50ZXJ2YWwpOyovXG4gICAgICAgICAgICBpZiAoaXNDb250aW51b3VzUmVwYWludCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhaW50Q291bnQrKztcbiAgICAgICAgICAgICAgICBpZiAobm93IC0gdGhpcy5sYXN0RlBTQ29tcHV0ZVRpbWUgPj0gMTAwMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRGUFMgPSAodGhpcy5jdXJyZW50UGFpbnRDb3VudCAqIDEwMDApIC8gKG5vdyAtIHRoaXMubGFzdEZQU0NvbXB1dGVUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFpbnRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEZQU0NvbXB1dGVUaW1lID0gbm93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBiZWdpblBhaW50aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aWNrUGFpbnRlciA9IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICAgICAgc2VsZi50aWNrUGFpbnQobm93KTtcbiAgICAgICAgfTtcbiAgICAgICAgcGFpbnRhYmxlcy5wdXNoKHRoaXMpO1xuICAgIH0sXG5cbiAgICBzdG9wUGFpbnRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBwYWludGFibGVzLnNwbGljZShwYWludGFibGVzLmluZGV4T2YodGhpcyksIDEpO1xuICAgIH0sXG5cbiAgICBiZWdpblJlc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnRpY2tSZXNpemVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmNoZWNrc2l6ZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXNpemFibGVzLnB1c2godGhpcyk7XG4gICAgfSxcblxuICAgIHN0b3BSZXNpemluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc2l6YWJsZXMuc3BsaWNlKHJlc2l6YWJsZXMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgfSxcblxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5iZWdpblBhaW50aW5nKCk7XG4gICAgICAgIHRoaXMuYmVnaW5SZXNpemluZygpO1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wUGFpbnRpbmcoKTtcbiAgICAgICAgdGhpcy5zdG9wUmVzaXppbmcoKTtcbiAgICB9LFxuXG4gICAgY2hlY2tzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy90aGlzIGlzIGV4cGVuc2l2ZSBsZXRzIGRvIGl0IGF0IHNvbWUgbW9kdWxvXG4gICAgICAgIHZhciBzaXplTm93ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChzaXplTm93LndpZHRoICE9PSB0aGlzLnNpemUud2lkdGggfHwgc2l6ZU5vdy5oZWlnaHQgIT09IHRoaXMuc2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZUNoYW5nZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzaXplQ2hhbmdlZE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBib3ggPSB0aGlzLnNpemUgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB0aGlzLndpZHRoID0gYm94LndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGJveC5oZWlnaHQ7XG5cbiAgICAgICAgLy9maXggYWxhIHNpciBzcGlua2EsIHNlZVxuICAgICAgICAvL2h0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9oaWRwaS9cbiAgICAgICAgLy9qdXN0IGFkZCAnaGRwaScgYXMgYW4gYXR0cmlidXRlIHRvIHRoZSBmaW4tY2FudmFzIHRhZ1xuICAgICAgICB2YXIgcmF0aW8gPSAxO1xuICAgICAgICB2YXIgdXNlQml0QmxpdCA9IHRoaXMudXNlQml0QmxpdCgpO1xuICAgICAgICB2YXIgaXNISURQSSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICYmIHRoaXMudXNlSGlEUEkoKTtcbiAgICAgICAgaWYgKGlzSElEUEkpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgICAgIHZhciBiYWNraW5nU3RvcmVSYXRpbyA9IHRoaXMuY2FudmFzQ1RYLndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDVFgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDVFgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NUWC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAgICAgICAgIHJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICAgICAgICAgICAgLy90aGlzLmNhbnZhc0NUWC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWZmZXIud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMud2lkdGggKiByYXRpbztcbiAgICAgICAgdGhpcy5idWZmZXIuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiByYXRpbztcblxuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMuYnVmZmVyLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IHRoaXMuYnVmZmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICB0aGlzLmJ1ZmZlckNUWC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICBpZiAoaXNISURQSSAmJiAhdXNlQml0QmxpdCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNDVFguc2NhbGUocmF0aW8sIHJhdGlvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhpcy5vcmlnaW4gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoTWF0aC5yb3VuZCh0aGlzLnNpemUubGVmdCksIE1hdGgucm91bmQodGhpcy5zaXplLnRvcCkpO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyByZWN0YW5ndWxhci5SZWN0YW5nbGUoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAvL3NldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb21wID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgIGlmIChjb21wKSB7XG4gICAgICAgICAgICBjb21wLnNldEJvdW5kcyh0aGlzLmJvdW5kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNpemVOb3RpZmljYXRpb24oKTtcbiAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICAvL30pO1xuICAgIH0sXG5cbiAgICByZXNpemVOb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3RvIGJlIG92ZXJyaWRkZW5cbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzO1xuICAgIH0sXG5cbiAgICBwYWludE5vdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zYWZlUGFpbnRJbW1lZGlhdGVseShmdW5jdGlvbihnYykge1xuICAgICAgICAgICAgZ2MuY2xlYXJSZWN0KDAsIDAsIHNlbGYud2lkdGgsIHNlbGYuaGVpZ2h0KTtcblxuICAgICAgICAgICAgdmFyIGNvbXAgPSBzZWxmLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGlmIChjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcC5wYWludChnYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNhZmVQYWludEltbWVkaWF0ZWx5OiBmdW5jdGlvbihwYWludEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciB1c2VCaXRCbGl0ID0gdGhpcy51c2VCaXRCbGl0KCksXG4gICAgICAgICAgICBnYyA9IHVzZUJpdEJsaXQgPyB0aGlzLmJ1ZmZlckdDIDogdGhpcy5nYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdjLnNhdmUoKTtcbiAgICAgICAgICAgIHBhaW50RnVuY3Rpb24oZ2MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZ2MucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VCaXRCbGl0KSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmx1c2hCdWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIud2lkdGggPiAwICYmIHRoaXMuYnVmZmVyLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzQ1RYLmRyYXdJbWFnZSh0aGlzLmJ1ZmZlciwgMCwgMCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hOZXdFdmVudDogZnVuY3Rpb24oZXZlbnQsIG5hbWUsIGRldGFpbCkge1xuICAgICAgICBkZXRhaWwgPSB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbCB8fCB7fVxuICAgICAgICB9O1xuICAgICAgICBkZXRhaWwuZGV0YWlsLnByaW1pdGl2ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChuYW1lLCBkZXRhaWwpKTtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudDogZnVuY3Rpb24oZXZlbnQsIG5hbWUsIGRldGFpbCkge1xuICAgICAgICBkZXRhaWwgPSBkZXRhaWwgfHwge307XG4gICAgICAgIGRldGFpbC5tb3VzZSA9IHRoaXMubW91c2VMb2NhdGlvbjtcbiAgICAgICAgZGV0YWlsLmtleXMgPSB0aGlzLmN1cnJlbnRLZXlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaE5ld0V2ZW50KGV2ZW50LCBuYW1lLCBkZXRhaWwpO1xuICAgIH0sXG5cbiAgICBmaW5tb3VzZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSAmJiB0aGlzLm1vdXNlZG93bikge1xuICAgICAgICAgICAgdGhpcy5iZURyYWdnaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZHJhZ3N0YXJ0Jywge1xuICAgICAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kcmFnc3RhcnQgPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQodGhpcy5tb3VzZUxvY2F0aW9uLngsIHRoaXMubW91c2VMb2NhdGlvbi55KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMubW91c2VMb2NhdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWRyYWcnLCB7XG4gICAgICAgICAgICAgICAgZHJhZ3N0YXJ0OiB0aGlzLmRyYWdzdGFydCxcbiAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3VuZHMuY29udGFpbnModGhpcy5tb3VzZUxvY2F0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLW1vdXNlbW92ZScpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbm1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLm1vdXNlRG93bkxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5tb3VzZWRvd24gPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1tb3VzZWRvd24nLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRha2VGb2N1cygpO1xuICAgIH0sXG5cbiAgICBmaW5tb3VzZXVwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWRyYWdlbmQnLCB7XG4gICAgICAgICAgICAgICAgZHJhZ3N0YXJ0OiB0aGlzLmRyYWdzdGFydCxcbiAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYmVOb3REcmFnZ2luZygpO1xuICAgICAgICAgICAgdGhpcy5kcmFnRW5kdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZWRvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLW1vdXNldXAnLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgICAgICAvL3RoaXMubW91c2VMb2NhdGlvbiA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgtMSwgLTEpO1xuICAgIH0sXG5cbiAgICBmaW5tb3VzZW91dDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMubW91c2Vkb3duKSB7XG4gICAgICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoLTEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtbW91c2VvdXQnKTtcbiAgICB9LFxuXG4gICAgZmlud2hlZWxtb3ZlZDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKCkgfHwgIXRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXdoZWVsbW92ZWQnLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5jbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5kb3VibGVDbGlja1RpbWVyICYmIERhdGUubm93KCkgLSB0aGlzLmxhc3RDbGlja1RpbWUgPCB0aGlzLmRvdWJsZUNsaWNrRGVsYXkpIHtcbiAgICAgICAgICAgIC8vdGhpcyBpcyBhIGRvdWJsZSBjbGljay4uLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlQ2xpY2tUaW1lcik7IC8vIHByZXZlbnQgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuZmluZGJsY2xpY2soZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICB0aGlzLmRvdWJsZUNsaWNrVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1jbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCB0aGlzLmRvdWJsZUNsaWNrRGVsYXkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmRibGNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIHRoaXMubGFzdERvdWJsZUNsaWNrVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1kYmxjbGljaycsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2RibGNsaWNrJywgdGhpcy5jdXJyZW50S2V5cyk7XG4gICAgfSxcblxuICAgIGdldENoYXJNYXA6IGZ1bmN0aW9uKCkgeyAvL1RPRE86IFRoaXMgaXMgc3RhdGljLiBNYWtlIGl0IGEgcHJvcGVydHkgb2YgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICByZXR1cm4gY2hhck1hcDtcbiAgICB9LFxuXG4gICAgZmlua2V5ZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBrZXlDaGFyID0gZS5zaGlmdEtleSA/IGNoYXJNYXBbZS5rZXlDb2RlXVsxXSA6IGNoYXJNYXBbZS5rZXlDb2RlXVswXTtcbiAgICAgICAgaWYgKGUucmVwZWF0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRLZXkgPT09IGtleUNoYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEtleUNvdW50Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwZWF0S2V5ID0ga2V5Q2hhcjtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdEtleSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdEtleUNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMucmVwZWF0S2V5U3RhcnRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50S2V5cy5pbmRleE9mKGtleUNoYXIpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5cy5wdXNoKGtleUNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coa2V5Q2hhciwgZS5rZXlDb2RlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld0V2ZW50KGUsICdmaW4tY2FudmFzLWtleWRvd24nLCB7XG4gICAgICAgICAgICBhbHQ6IGUuYWx0S2V5LFxuICAgICAgICAgICAgY3RybDogZS5jdHJsS2V5LFxuICAgICAgICAgICAgY2hhcjoga2V5Q2hhcixcbiAgICAgICAgICAgIGNvZGU6IGUuY2hhckNvZGUsXG4gICAgICAgICAgICBrZXk6IGUua2V5Q29kZSxcbiAgICAgICAgICAgIG1ldGE6IGUubWV0YUtleSxcbiAgICAgICAgICAgIHJlcGVhdENvdW50OiB0aGlzLnJlcGVhdEtleUNvdW50LFxuICAgICAgICAgICAgcmVwZWF0U3RhcnRUaW1lOiB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSxcbiAgICAgICAgICAgIHNoaWZ0OiBlLnNoaWZ0S2V5LFxuICAgICAgICAgICAgaWRlbnRpZmllcjogZS5rZXksXG4gICAgICAgICAgICBjdXJyZW50S2V5czogdGhpcy5jdXJyZW50S2V5cy5zbGljZSgwKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmlua2V5dXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGtleUNoYXIgPSBlLnNoaWZ0S2V5ID8gY2hhck1hcFtlLmtleUNvZGVdWzFdIDogY2hhck1hcFtlLmtleUNvZGVdWzBdO1xuICAgICAgICB0aGlzLmN1cnJlbnRLZXlzLnNwbGljZSh0aGlzLmN1cnJlbnRLZXlzLmluZGV4T2Yoa2V5Q2hhciksIDEpO1xuICAgICAgICBpZiAoIXRoaXMuaGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwZWF0S2V5Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnJlcGVhdEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVwZWF0S2V5U3RhcnRUaW1lID0gMDtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld0V2ZW50KGUsICdmaW4tY2FudmFzLWtleXVwJywge1xuICAgICAgICAgICAgYWx0OiBlLmFsdEtleSxcbiAgICAgICAgICAgIGN0cmw6IGUuY3RybEtleSxcbiAgICAgICAgICAgIGNoYXI6IGtleUNoYXIsXG4gICAgICAgICAgICBjb2RlOiBlLmNoYXJDb2RlLFxuICAgICAgICAgICAga2V5OiBlLmtleUNvZGUsXG4gICAgICAgICAgICBtZXRhOiBlLm1ldGFLZXksXG4gICAgICAgICAgICByZXBlYXQ6IGUucmVwZWF0LFxuICAgICAgICAgICAgc2hpZnQ6IGUuc2hpZnRLZXksXG4gICAgICAgICAgICBpZGVudGlmaWVyOiBlLmtleSxcbiAgICAgICAgICAgIGN1cnJlbnRLZXlzOiB0aGlzLmN1cnJlbnRLZXlzLnNsaWNlKDApXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5mb2N1c2dhaW5lZDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtZ2FpbmVkJyk7XG4gICAgfSxcblxuICAgIGZpbmZvY3VzbG9zdDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtbG9zdCcpO1xuICAgIH0sXG5cbiAgICBmaW5jb250ZXh0bWVudTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5jdHJsS2V5ICYmIHRoaXMuY3VycmVudEtleXMuaW5kZXhPZignQ1RSTCcpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5cy5wdXNoKCdDVFJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyICYmIERhdGUubm93KCkgLSB0aGlzLmxhc3RDbGlja1RpbWUgPCB0aGlzLmRvdWJsZUNsaWNrRGVsYXkpIHtcbiAgICAgICAgICAgIC8vdGhpcyBpcyBhIGRvdWJsZSBjbGljay4uLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyKTsgLy8gcHJldmVudCBjb250ZXh0IG1lbnUgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5maW5kYmxjbGljayhlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdENsaWNrVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgICAgICAgIHRoaXMuZG91YmxlUmlnaHRDbGlja1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdWJsZVJpZ2h0Q2xpY2tUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtY29udGV4dC1tZW51Jywge1xuICAgICAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMuZG91YmxlQ2xpY2tEZWxheSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVwYWludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcHMgPSB0aGlzLmdldEZQUygpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFwYWludExvb3BSdW5uaW5nIHx8IGZwcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE1vdXNlTG9jYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZUxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBnZXRPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludChyZWN0LmxlZnQsIHJlY3QudG9wKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIGdldExvY2FsOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBwID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KGUuY2xpZW50WCAtIHJlY3QubGVmdCwgZS5jbGllbnRZIC0gcmVjdC50b3ApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5jYW52YXM7XG4gICAgfSxcblxuICAgIHRha2VGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYW52YXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBiZURyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICBiZU5vdERyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICBpc0RyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ2dpbmc7XG4gICAgfSxcblxuICAgIGRpc2FibGVEb2N1bWVudEVsZW1lbnRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCArICctd2Via2l0LXVzZXItc2VsZWN0OiBub25lJztcbiAgICB9LFxuXG4gICAgZW5hYmxlRG9jdW1lbnRFbGVtZW50U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgc3R5bGUuY3NzVGV4dCA9IHN0eWxlLmNzc1RleHQucmVwbGFjZSgnLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZScsICcnKTtcbiAgICB9LFxuXG4gICAgc2V0Rm9jdXNhYmxlOiBmdW5jdGlvbih0cnV0aHkpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VyLnN0eWxlLmRpc3BsYXkgPSB0cnV0aHkgPyAnJyA6ICdub25lJztcbiAgICB9LFxuXG4gICAgaXNSaWdodENsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBpc1JpZ2h0TUI7XG4gICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICBpZiAoJ3doaWNoJyBpbiBlKSB7IC8vIEdlY2tvIChGaXJlZm94KSwgV2ViS2l0IChTYWZhcmkvQ2hyb21lKSAmIE9wZXJhXG4gICAgICAgICAgICBpc1JpZ2h0TUIgPSBlLndoaWNoID09PSAzO1xuICAgICAgICB9IGVsc2UgaWYgKCdidXR0b24nIGluIGUpIHsgLy8gSUUsIE9wZXJhXG4gICAgICAgICAgICBpc1JpZ2h0TUIgPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNSaWdodE1CO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHBhaW50TG9vcEZ1bmN0aW9uKG5vdykge1xuICAgIGlmICghcGFpbnRMb29wUnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpbnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFpbnRhYmxlc1tpXS50aWNrUGFpbnRlcihub3cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShwYWludExvb3BGdW5jdGlvbik7XG59XG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGFpbnRMb29wRnVuY3Rpb24pO1xuXG5mdW5jdGlvbiByZXNpemFibGVzTG9vcEZ1bmN0aW9uKG5vdykge1xuICAgIGlmICghcmVzaXplTG9vcFJ1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2l6YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc2l6YWJsZXNbaV0udGlja1Jlc2l6ZXIobm93KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnNldEludGVydmFsKHJlc2l6YWJsZXNMb29wRnVuY3Rpb24sIFJFU0laRV9QT0xMSU5HX0lOVEVSVkFMKTtcblxuZnVuY3Rpb24gbWFrZUNoYXJNYXAoKSB7XG4gICAgdmFyIG1hcCA9IFtdO1xuXG4gICAgdmFyIGVtcHR5ID0gWycnLCAnJ107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIG1hcFtpXSA9IGVtcHR5O1xuICAgIH1cblxuICAgIG1hcFsyN10gPSBbJ0VTQycsICdFU0NTSElGVCddO1xuICAgIG1hcFsxOTJdID0gWydgJywgJ34nXTtcbiAgICBtYXBbNDldID0gWycxJywgJyEnXTtcbiAgICBtYXBbNTBdID0gWycyJywgJ0AnXTtcbiAgICBtYXBbNTFdID0gWyczJywgJyMnXTtcbiAgICBtYXBbNTJdID0gWyc0JywgJyQnXTtcbiAgICBtYXBbNTNdID0gWyc1JywgJyUnXTtcbiAgICBtYXBbNTRdID0gWyc2JywgJ14nXTtcbiAgICBtYXBbNTVdID0gWyc3JywgJyYnXTtcbiAgICBtYXBbNTZdID0gWyc4JywgJyonXTtcbiAgICBtYXBbNTddID0gWyc5JywgJygnXTtcbiAgICBtYXBbNDhdID0gWycwJywgJyknXTtcbiAgICBtYXBbMTg5XSA9IFsnLScsICdfJ107XG4gICAgbWFwWzE4N10gPSBbJz0nLCAnKyddO1xuICAgIG1hcFs4XSA9IFsnQkFDS1NQQUNFJywgJ0JBQ0tTUEFDRVNISUZUJ107XG4gICAgbWFwWzQ2XSA9IFsnREVMRVRFJywgJ0RFTEVURVNISUZUJ107XG4gICAgbWFwWzldID0gWydUQUInLCAnVEFCU0hJRlQnXTtcbiAgICBtYXBbODFdID0gWydxJywgJ1EnXTtcbiAgICBtYXBbODddID0gWyd3JywgJ1cnXTtcbiAgICBtYXBbNjldID0gWydlJywgJ0UnXTtcbiAgICBtYXBbODJdID0gWydyJywgJ1InXTtcbiAgICBtYXBbODRdID0gWyd0JywgJ1QnXTtcbiAgICBtYXBbODldID0gWyd5JywgJ1knXTtcbiAgICBtYXBbODVdID0gWyd1JywgJ1UnXTtcbiAgICBtYXBbNzNdID0gWydpJywgJ0knXTtcbiAgICBtYXBbNzldID0gWydvJywgJ08nXTtcbiAgICBtYXBbODBdID0gWydwJywgJ1AnXTtcbiAgICBtYXBbMjE5XSA9IFsnWycsICd7J107XG4gICAgbWFwWzIyMV0gPSBbJ10nLCAnfSddO1xuICAgIG1hcFsyMjBdID0gWydcXFxcJywgJ3wnXTtcbiAgICBtYXBbMjIwXSA9IFsnQ0FQU0xPQ0snLCAnQ0FQU0xPQ0tTSElGVCddO1xuICAgIG1hcFs2NV0gPSBbJ2EnLCAnQSddO1xuICAgIG1hcFs4M10gPSBbJ3MnLCAnUyddO1xuICAgIG1hcFs2OF0gPSBbJ2QnLCAnRCddO1xuICAgIG1hcFs3MF0gPSBbJ2YnLCAnRiddO1xuICAgIG1hcFs3MV0gPSBbJ2cnLCAnRyddO1xuICAgIG1hcFs3Ml0gPSBbJ2gnLCAnSCddO1xuICAgIG1hcFs3NF0gPSBbJ2onLCAnSiddO1xuICAgIG1hcFs3NV0gPSBbJ2snLCAnSyddO1xuICAgIG1hcFs3Nl0gPSBbJ2wnLCAnTCddO1xuICAgIG1hcFsxODZdID0gWyc7JywgJzonXTtcbiAgICBtYXBbMjIyXSA9IFsnXFwnJywgJ3wnXTtcbiAgICBtYXBbMTNdID0gWydSRVRVUk4nLCAnUkVUVVJOU0hJRlQnXTtcbiAgICBtYXBbMTZdID0gWydTSElGVCcsICdTSElGVCddO1xuICAgIG1hcFs5MF0gPSBbJ3onLCAnWiddO1xuICAgIG1hcFs4OF0gPSBbJ3gnLCAnWCddO1xuICAgIG1hcFs2N10gPSBbJ2MnLCAnQyddO1xuICAgIG1hcFs4Nl0gPSBbJ3YnLCAnViddO1xuICAgIG1hcFs2Nl0gPSBbJ2InLCAnQiddO1xuICAgIG1hcFs3OF0gPSBbJ24nLCAnTiddO1xuICAgIG1hcFs3N10gPSBbJ20nLCAnTSddO1xuICAgIG1hcFsxODhdID0gWycsJywgJzwnXTtcbiAgICBtYXBbMTkwXSA9IFsnLicsICc+J107XG4gICAgbWFwWzE5MV0gPSBbJy8nLCAnPyddO1xuICAgIG1hcFsxNl0gPSBbJ1NISUZUJywgJ1NISUZUJ107XG4gICAgbWFwWzE3XSA9IFsnQ1RSTCcsICdDVFJMU0hJRlQnXTtcbiAgICBtYXBbMThdID0gWydBTFQnLCAnQUxUU0hJRlQnXTtcbiAgICBtYXBbOTFdID0gWydDT01NQU5ETEVGVCcsICdDT01NQU5ETEVGVFNISUZUJ107XG4gICAgbWFwWzMyXSA9IFsnU1BBQ0UnLCAnU1BBQ0VTSElGVCddO1xuICAgIG1hcFs5M10gPSBbJ0NPTU1BTkRSSUdIVCcsICdDT01NQU5EUklHSFRTSElGVCddO1xuICAgIG1hcFsxOF0gPSBbJ0FMVCcsICdBTFRTSElGVCddO1xuICAgIG1hcFszOF0gPSBbJ1VQJywgJ1VQU0hJRlQnXTtcbiAgICBtYXBbMzddID0gWydMRUZUJywgJ0xFRlRTSElGVCddO1xuICAgIG1hcFs0MF0gPSBbJ0RPV04nLCAnRE9XTlNISUZUJ107XG4gICAgbWFwWzM5XSA9IFsnUklHSFQnLCAnUklHSFRTSElGVCddO1xuXG4gICAgbWFwWzMzXSA9IFsnUEFHRVVQJywgJ1BBR0VVUFNISUZUJ107XG4gICAgbWFwWzM0XSA9IFsnUEFHRURPV04nLCAnUEFHRURPV05TSElGVCddO1xuICAgIG1hcFszNV0gPSBbJ1BBR0VSSUdIVCcsICdQQUdFUklHSFRTSElGVCddOyAvLyBFTkRcbiAgICBtYXBbMzZdID0gWydQQUdFTEVGVCcsICdQQUdFTEVGVFNISUZUJ107IC8vIEhPTUVcblxuICAgIG1hcFsxMTJdID0gWydGMScsICdGMVNISUZUJ107XG4gICAgbWFwWzExM10gPSBbJ0YyJywgJ0YyU0hJRlQnXTtcbiAgICBtYXBbMTE0XSA9IFsnRjMnLCAnRjNTSElGVCddO1xuICAgIG1hcFsxMTVdID0gWydGNCcsICdGNFNISUZUJ107XG4gICAgbWFwWzExNl0gPSBbJ0Y1JywgJ0Y1U0hJRlQnXTtcbiAgICBtYXBbMTE3XSA9IFsnRjYnLCAnRjZTSElGVCddO1xuICAgIG1hcFsxMThdID0gWydGNycsICdGN1NISUZUJ107XG4gICAgbWFwWzExOV0gPSBbJ0Y4JywgJ0Y4U0hJRlQnXTtcbiAgICBtYXBbMTIwXSA9IFsnRjknLCAnRjlTSElGVCddO1xuICAgIG1hcFsxMjFdID0gWydGMTAnLCAnRjEwU0hJRlQnXTtcbiAgICBtYXBbMTIyXSA9IFsnRjExJywgJ0YxUzFISUZUJ107XG4gICAgbWFwWzEyM10gPSBbJ0YxMicsICdGMTIxSElGVCddO1xuXG4gICAgcmV0dXJuIG1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDYW52YXM7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uc29sZUxvZ2dlciA9IHJlcXVpcmUoJy4vZ2MtY29uc29sZS1sb2dnZXInKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBnYyAtIFRoZSAyLUQgZ3JhcGhpY3MgY29udGV4dCBmcm9tIHlvdXIgY2FudmFzXG4gKiBAcGFyYW0ge2Jvb2xlYW58YXBpTG9nZ2VyfSBbbG9nZ2VyPXRydWVdXG4gKiAqIGB0cnVlYCB1c2VzIGBnYy1jb25zb2xlLWxvZ2dlcmAgZnVuY3Rpb24gYm91bmQgdG8gJ2djLicgYXMgcHJlZml4XG4gKiAqIHN0cmluZyB1c2VzIGBnYy1jb25zb2xlLWxvZ2dlcmAgZnVuY3Rpb24gYm91bmQgdG8gc3RyaW5nXG4gKiAqIGZ1bmN0aW9uIHVzZWQgYXMgaXNcbiAqL1xuZnVuY3Rpb24gR3JhcGhpY3NDb250ZXh0KGdjLCBsb2dnZXIpIHtcbiAgICB0aGlzLmdjID0gZ2M7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlV0VCS0lUID0gL153ZWJraXQvO1xuXG4gICAgc3dpdGNoICh0eXBlb2YgbG9nZ2VyKSB7XG5cbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGxvZ2dlciA9ICBjb25zb2xlTG9nZ2VyLmJpbmQodW5kZWZpbmVkLCBsb2dnZXIgKyAnLicpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBpZiAobG9nZ2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyID0gY29uc29sZUxvZ2dlci5iaW5kKHVuZGVmaW5lZCwgJ2djLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgaWYgKGxvZ2dlci5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnR3JhcGhpY3NDb250ZXh0OiBVc2VyLXN1cHBsaWVkIEFQSSBsb2dnZXIgZnVuY3Rpb24gZG9lcyBub3QgYWNjZXB0IHRocmVlIHBhcmFtZXRlcnMuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBsb2dnZXIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTdHViIG91dCBhbGwgdGhlIHByb3RvdHlwZSBtZW1iZXJzIG9mIHRoZSBjYW52YXMgMkQgZ3JhcGhpY3MgY29udGV4dDpcbiAgICBPYmplY3Qua2V5cyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2MpKS5mb3JFYWNoKE1ha2VTdHViKTtcblxuICAgIC8vIFNvbWUgb2xkZXIgYnJvd3NlcnMgKGUuZy4sIENocm9tZSA0MCkgZGlkIG5vdCBoYXZlIGFsbCBtZW1iZXJzIG9mIGNhbnZhc1xuICAgIC8vIDJEIGdyYXBoaWNzIGNvbnRleHQgaW4gdGhlIHByb3RvdHlwZSBzbyB3ZSBtYWtlIHRoaXMgYWRkaXRpb25hbCBjYWxsOlxuICAgIE9iamVjdC5rZXlzKGdjKS5mb3JFYWNoKE1ha2VTdHViKTtcblxuICAgIGZ1bmN0aW9uIE1ha2VTdHViKGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUgfHwgcmVXRUJLSVQudGVzdChrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBnY1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzZWxmW2tleV0gPSAhbG9nZ2VyID8gZ2Nba2V5XS5iaW5kKGdjKSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIoa2V5LCBhcmd1bWVudHMsIGdjW2tleV0uYXBwbHkoZ2MsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2Nba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlciA/IGxvZ2dlcihrZXksICdnZXR0ZXInLCByZXN1bHQpIDogcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBnY1trZXldID0gbG9nZ2VyID8gbG9nZ2VyKGtleSwgJ3NldHRlcicsIHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoaWNzQ29udGV4dDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFlJRUxEUyA9ICdcXHUyN0Y5JzsgLy8gTE9ORyBSSUdIVFdBUkRTIERPVUJMRSBBUlJPV1xuXG5mdW5jdGlvbiBjb25zb2xlTG9nZ2VyKHByZWZpeCwgbmFtZSwgYXJncywgdmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXN1bHQgPSAnXCInICsgcmVzdWx0ICsgJ1wiJztcbiAgICB9XG5cbiAgICBuYW1lID0gcHJlZml4ICsgbmFtZTtcblxuICAgIHN3aXRjaCAoYXJncykge1xuICAgICAgICBjYXNlICdnZXR0ZXInOlxuICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZSwgJz0nLCByZXN1bHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2V0dGVyJzpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5hbWUsIFlJRUxEUywgcmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6IC8vIG1ldGhvZCBjYWxsXG4gICAgICAgICAgICBuYW1lICs9ICcoJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJywgJykgKyAnKSc7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZSwgWUlFTERTLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlTG9nZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBKU0RhdGFTb3VyY2U6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZScpLFxuICAgIERhdGFTb3VyY2VTb3J0ZXI6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZVNvcnRlcicpLFxuICAgIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGU6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZScpLFxuICAgIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXI6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZUdsb2JhbEZpbHRlcicpLFxuICAgIERhdGFTb3VyY2VHcm91cFZpZXc6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZUdyb3VwVmlldycpLFxuICAgIERhdGFTb3VyY2VBZ2dyZWdhdG9yOiByZXF1aXJlKCcuL2pzL0RhdGFTb3VyY2VBZ2dyZWdhdG9yJyksXG4gICAgRGF0YVNvdXJjZVRyZWV2aWV3OiByZXF1aXJlKCcuL2pzL0RhdGFTb3VyY2VUcmVldmlldycpLFxuICAgIERhdGFTb3VyY2VUcmVldmlld0ZpbHRlcjogcmVxdWlyZSgnLi9qcy9EYXRhU291cmNlVHJlZXZpZXdGaWx0ZXInKSxcbiAgICBEYXRhU291cmNlVHJlZXZpZXdTb3J0ZXI6IHJlcXVpcmUoJy4vanMvRGF0YVNvdXJjZVRyZWV2aWV3U29ydGVyJyksXG4gICAgRGF0YU5vZGVHcm91cFNvcnRlcjogcmVxdWlyZSgnLi9qcy9EYXRhTm9kZUdyb3VwU29ydGVyJyksXG4gICAgdXRpbDoge1xuICAgICAgICBhZ2dyZWdhdGlvbnM6IHJlcXVpcmUoJy4vanMvdXRpbC9hZ2dyZWdhdGlvbnMnKSxcbiAgICAgICAgTWFwcHk6IHJlcXVpcmUoJy4vanMvdXRpbC9NYXBweScpLFxuICAgICAgICBzdGFibGVTb3J0OiByZXF1aXJlKCcuL2pzL3V0aWwvc3RhYmxlU29ydCcpLFxuICAgICAgICBoZWFkZXJpZnk6IHJlcXVpcmUoJy4vanMvdXRpbC9oZWFkZXJpZnknKVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIEFnZ3JlZ2F0b3JOb2RlQmFzZU1peGluID0ge1xuICAgIGdldFJvd0RhdGE6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXG4gICAgICAgIGlmIChpbmRleC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBncm91cHNPZmZzZXQgPSBOdW1iZXIoYWdncmVnYXRvci5oYXNHcm91cHMoKSk7XG5cbiAgICAgICAgICAgIC8vIHJlZGltZW5zaW9uIHRoZSBkYXRhXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGRhdGEubGVuZ3RoID0gZ3JvdXBzT2Zmc2V0ICsgYWdncmVnYXRvci5hZ2dyZWdhdGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIHNvcnRlciA9IGFnZ3JlZ2F0b3Iuc29ydGVySW5zdGFuY2U7XG4gICAgICAgICAgICBzb3J0ZXIuaW5kZXggPSBpbmRleDtcblxuICAgICAgICAgICAgYWdncmVnYXRvci5hZ2dyZWdhdGVzLmZvckVhY2goZnVuY3Rpb24oYWdncmVnYXRlLCBpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtncm91cHNPZmZzZXQgKyBpXSA9IGFnZ3JlZ2F0ZShzb3J0ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0b3JOb2RlQmFzZU1peGluO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWdncmVnYXRvck5vZGVCYXNlTWl4aW4gPSByZXF1aXJlKCcuL0FnZ3JlZ2F0b3JOb2RlQmFzZU1peGluJyk7XG52YXIgRGF0YU5vZGVHcm91cCA9IHJlcXVpcmUoJy4vRGF0YU5vZGVHcm91cCcpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGF0YU5vZGVCYXNlXG4gKi9cbnZhciBBZ2dyZWdhdG9yTm9kZUdyb3VwID0gRGF0YU5vZGVHcm91cC5leHRlbmQoJ0FnZ3JlZ2F0b3JOb2RlR3JvdXAnLCB7XG4gICAgZ2V0Um93RGF0YTogZnVuY3Rpb24gKGRyaWxsRG93bikge1xuICAgICAgICBBZ2dyZWdhdG9yTm9kZUJhc2VNaXhpbi5nZXRSb3dEYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuZ2V0Um93RGF0YShkcmlsbERvd24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2dyZWdhdG9yTm9kZUdyb3VwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQWdncmVnYXRvck5vZGVCYXNlTWl4aW4gPSByZXF1aXJlKCcuL0FnZ3JlZ2F0b3JOb2RlQmFzZU1peGluJyk7XG52YXIgRGF0YU5vZGVMZWFmID0gcmVxdWlyZSgnLi9EYXRhTm9kZUxlYWYnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFOb2RlQmFzZVxuICovXG52YXIgQWdncmVnYXRvck5vZGVMZWFmID0gRGF0YU5vZGVMZWFmLmV4dGVuZCgnQWdncmVnYXRvck5vZGVMZWFmJywgQWdncmVnYXRvck5vZGVCYXNlTWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0b3JOb2RlTGVhZjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFnZ3JlZ2F0b3JOb2RlQmFzZU1peGluID0gcmVxdWlyZSgnLi9BZ2dyZWdhdG9yTm9kZUJhc2VNaXhpbicpO1xudmFyIERhdGFOb2RlVHJlZSA9IHJlcXVpcmUoJy4vRGF0YU5vZGVUcmVlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhTm9kZUJhc2VcbiAqL1xudmFyIEFnZ3JlZ2F0b3JOb2RlVHJlZSA9IERhdGFOb2RlVHJlZS5leHRlbmQoJ0FnZ3JlZ2F0b3JOb2RlVHJlZScsIHtcbiAgICBnZXRSb3dEYXRhOiBmdW5jdGlvbiAoZHJpbGxEb3duKSB7XG4gICAgICAgIEFnZ3JlZ2F0b3JOb2RlQmFzZU1peGluLmdldFJvd0RhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5nZXRSb3dEYXRhKGRyaWxsRG93bik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0b3JOb2RlVHJlZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCdmaW4taHlwZXJncmlkLWRhdGEtc291cmNlLWJhc2UnKTtcblxuLy8gRm9sbG93aW5nIGFyZSBmb3IgbGVnYWN5IG1ldGhvZHNcblxuQmFzZS5wcm90b3R5cGUuZ2V0RmllbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEZpZWxkcygpO1xuICAgIH1cbn07XG5cbkJhc2UucHJvdG90eXBlLmdldEhlYWRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0SGVhZGVycygpO1xuICAgIH1cbn07XG5cbkJhc2UucHJvdG90eXBlLmdldENhbGN1bGF0b3JzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZGF0YVNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnJldmVhbFJvdygpO1xuICAgIH1cbn07XG5cbkJhc2UucHJvdG90eXBlLnNldEZpZWxkcyA9IGZ1bmN0aW9uKGFycikge1xuICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXRGaWVsZHMuY2FsbCh0aGlzLmRhdGFTb3VyY2UsIGFycik7XG4gICAgfVxufTtcblxuQmFzZS5wcm90b3R5cGUuc2V0SGVhZGVycyA9IGZ1bmN0aW9uKGFycikge1xuICAgIGlmICh0aGlzLmRhdGFTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXRIZWFkZXJzLmNhbGwodGhpcy5kYXRhU291cmNlLCBhcnIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcblxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFCYXNlTm9kZSNpbml0aWFsaXplfGluaXRpYWxpemUoKX0gbWV0aG9kIGZvciBwYXJhbWV0ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhTm9kZUJhc2UgPSBCYXNlLmV4dGVuZCgnRGF0YU5vZGVCYXNlJywge1xuXG4gICAgaXNOdWxsT2JqZWN0OiBmYWxzZSxcblxuICAgIElOREVOVDogJyAgICcsIC8vIDMgc3BhY2VzXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlI1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UjXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgICAgIHRoaXMubGFiZWwgPSBrZXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UjXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IFsnJ107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUJhc2UjXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgICAgICogQGRlZmF1bHQgWycnXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IFtdOyAvLyBmb3JtZXJseSByb3dJbmRleFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlI1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQ2hpbGRyZW4gPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlI1xuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFOb2RlQmFzZSNcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVCYXNlI1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZiNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbeF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYjXG4gICAgICogQHBhcmFtIGRlcHRoXG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmI1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgY29tcHV0ZURlcHRoU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5KHRoaXMuZGVwdGggKyAxKS5qb2luKHRoaXMuSU5ERU5UKSArICcgICcgKyB0aGlzLmxhYmVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29tcHV0ZUhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmI1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRJbmRleDogZnVuY3Rpb24oKSB7IC8vIFRPRE86IGZvcm1lcmx5IGdldEFsbFJvd0luZGV4ZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYjXG4gICAgICogQHBhcmFtIGRyaWxsRG93blxuICAgICAqL1xuICAgIGdldFJvd0RhdGE6IGZ1bmN0aW9uKGRyaWxsRG93bikge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG5cbiAgICAgICAgaWYgKGluZGV4Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gR3JvdXAgYW5kIFRyZWUgbm9kZXMgd2lsbCBoYXZlIG5vIGRhdGEgYmVzaWRlcyB0aGUgdHJlZSBjb2x1bW5cbiAgICAgICAgICAgIHRoaXMuZGF0YS5sZW5ndGggPSBkcmlsbERvd24uZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmI1xuICAgICAqIEBwYXJhbSBkcmlsbERvd25cbiAgICAgKi9cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKGRyaWxsRG93bikge1xuICAgICAgICBkcmlsbERvd24uYWRkVmlldyh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlTGVhZiNcbiAgICAgKi9cbiAgICB0b2dnbGVFeHBhbnNpb25TdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vZG8gbm90aGluZyBieSBkZWZhdWx0XG4gICAgfSxcblxuICAgIHNvcnRHcm91cHM6IGZ1bmN0aW9uKGdyb3VwU29ydGVyKSB7XG4gICAgfVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZUJhc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBNYXAgPSByZXF1aXJlKCcuL3V0aWwvTWFwcHknKTtcbnZhciBEYXRhTm9kZUJhc2UgPSByZXF1aXJlKCcuL0RhdGFOb2RlQmFzZScpO1xuXG52YXIgZXhwYW5kZWRNYXAgPSB7XG4gICAgdHJ1ZTogJ1xcdTI1YmMnLCAvLyBCTEFDSyBET1dOLVBPSU5USU5HIFRSSUFOR0xFIGFrYSAn4pa8J1xuICAgIGZhbHNlOiAnXFx1MjViNicgLy8gQkxBQ0sgUklHSFQtUE9JTlRJTkcgVFJJQU5HTEUgYWthICfilrYnXG59O1xuXG4vKipcbiAqID4gU2VlIHtAbGluayBEYXRhTm9kZUdyb3VwI2luaXRpYWxpemV8aW5pdGlhbGl6ZSgpfSBtZXRob2QgZm9yIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFOb2RlQmFzZVxuICovXG52YXIgRGF0YU5vZGVHcm91cCA9IERhdGFOb2RlQmFzZS5leHRlbmQoJ0RhdGFOb2RlR3JvdXAnLCB7XG5cbiAgICBleHRlbmRhYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAjXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cCNcbiAgICAgKiBAcGFyYW0gZGVwdGhcbiAgICAgKi9cbiAgICB0b0FycmF5OiBmdW5jdGlvbihkZXB0aCkge1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnZhbHVlcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC50b0FycmF5KGRlcHRoICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cCNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGNvbXB1dGVEZXB0aFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSBBcnJheSh0aGlzLmRlcHRoICsgMSkuam9pbih0aGlzLklOREVOVCkgK1xuICAgICAgICAgICAgZXhwYW5kZWRNYXBbdGhpcy5leHBhbmRlZF0gKyAnICcgK1xuICAgICAgICAgICAgdGhpcy5sYWJlbDtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAjXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmNvbXB1dGVJbmRleCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cCNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgY29tcHV0ZUluZGV4OiBmdW5jdGlvbigpIHsgLy8gVE9ETzogZm9ybWVybHkgY29tcHV0ZUFsbFJvd0luZGV4ZXNcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICByZXN1bHQuYXBwZW5kID0gYXBwZW5kO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoY2hpbGQuZ2V0SW5kZXgoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cCNcbiAgICAgKiBAcGFyYW0gZHJpbGxEb3duXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZXhwYW5kXSAtIE9uZSBvZjpcbiAgICAgKiAqIGB0cnVlYCAtIEV4cGFuZCBhbGwgcm93cyB0aGF0IGFyZSBjdXJyZW50bHkgY29sbGFwc2VkLlxuICAgICAqICogYGZhbHNlYCAtIENvbGxhcHNlIGFsbCByb3dzIHRoYXQgYXJlIGN1cnJlbnRseSBleHBhbmRlZC5cbiAgICAgKiAqIGB1bmRlZmluZWRgIChvciBvbWl0dGVkKSAtIEV4cGFuZCBhbGwgY3VycmVudGx5IGNvbGxhcHNlZCByb3dzOyBjb2xsYXBzZSBhbGwgY3VycmVudGx5IGV4cGFuZGVkIHJvd3MuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IElmIHRoaXMgY2FsbCByZXN1bHRlZCBpbiBhIHN0YXRlIGNoYW5nZS5cbiAgICAgKi9cbiAgICB0b2dnbGVFeHBhbnNpb25TdGF0ZTogZnVuY3Rpb24oZHJpbGxEb3duLCBleHBhbmQpIHsgLyogYWdncmVnYXRvciAqL1xuICAgICAgICBpZiAoZXhwYW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cGFuZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFuZ2VkID0gdGhpcy5leHBhbmRlZCBeIGV4cGFuZDtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGV4cGFuZDtcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdGhpcy5jb21wdXRlRGVwdGhTdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Um93RGF0YShkcmlsbERvd24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIWNoYW5nZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwI1xuICAgICAqIEBwYXJhbSBkcmlsbERvd25cbiAgICAgKi9cbiAgICBnZXRSb3dEYXRhOiBmdW5jdGlvbihkcmlsbERvd24pIHtcbiAgICAgICAgRGF0YU5vZGVCYXNlLnByb3RvdHlwZS5nZXRSb3dEYXRhLmNhbGwodGhpcywgZHJpbGxEb3duKTsgLy8gY2FsbCBiYXNlIGNsYXNzJ3MgdmVyc2lvblxuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuZ2V0Um93RGF0YShkcmlsbERvd24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAjXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0b3JcbiAgICAgKi9cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKGRyaWxsRG93bikge1xuICAgICAgICBkcmlsbERvd24udmlldy5wdXNoKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuYnVpbGRWaWV3KGRyaWxsRG93bik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cCNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvbXB1dGVIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMTtcblxuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICsgY2hpbGQuY29tcHV0ZUhlaWdodCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRoaXMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgc29ydFdpdGg6IGZ1bmN0aW9uKHNvcnRlcikge1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgc29ydGVyLnNvcnRHcm91cCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnNvcnRXaXRoKHNvcnRlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2xlYXJHcm91cFNvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxPcmRlcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9yaWdpbmFsT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldID0gdGhpcy5vcmlnaW5hbE9yZGVyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQuY2xlYXJHcm91cFNvcnRzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxufSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBzdW1tYXJ5IEFycmF5IG1peGluIHRvIGFwcGVuZCBhbm90aGVyIGFycmF5IHRvIGVuZCBvZiBgdGhpc2Agb25lLlxuICogQGRlc2MgQXBwZW5kcyBpbiBwbGFjZSwgdW5saWtlIGB0aGlzLmNvbmNhdCgpYCB3aGljaCBjcmVhdGVzIGEgbmV3IGFycmF5LlxuICogVXNlcyBsZXNzIG1lbW9yeSB0aGFuIGNvbmNhdCwgaW1wb3J0YW50IHdoZW4gYGFwcGVuZGl4YCBpcyBodWdlLlxuICogPiBDQVVUSU9OOiBNdXRhdGVzIGB0aGlzYCBhcnJheSFcbiAqIEBwYXJhbSB7QXJyYXl9IGFwcGVuZGl4XG4gKiBAcmV0dXJucyB7QXJyYXl9IFJlZmVyZW5jZSB0byBgdGhpc2AgKGZvciBjb252ZW5pZW5jZSlcbiAqL1xuZnVuY3Rpb24gYXBwZW5kKGFwcGVuZGl4KSB7XG4gICAgdGhpcy5zcGxpY2UuYmluZCh0aGlzLCB0aGlzLmxlbmd0aCwgMCkuYXBwbHkodGhpcywgYXBwZW5kaXgpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFOb2RlR3JvdXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG52YXIgc3RhYmxlU29ydCA9IHJlcXVpcmUoJy4vdXRpbC9zdGFibGVTb3J0Jykuc29ydDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFTb3VyY2VJbmRleGVkXG4gKi9cbnZhciBEYXRhTm9kZUdyb3VwU29ydGVyID0gQmFzZS5leHRlbmQoJ0RhdGFOb2RlR3JvdXBTb3J0ZXInLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cFNvcnRlciNcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgIHRoaXMuc29ydHMgPSBbXTtcblxuICAgIH0sXG4gICAgLyoqXG4gICAgICogIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlI1xuICAgICAqICBAcGFyYW0gY29sdW1uSW5kZXhcbiAgICAgKiAgQHBhcmFtIGRpcmVjdGlvblxuICAgICAqL1xuXG4gICAgc29ydE9uOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuc29ydHMucHVzaCh7IGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleCwgZGlyZWN0aW9uOiBkaXJlY3Rpb24gfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwU29ydGVyI1xuICAgICAqIEBwYXJhbSB7c29ydGVyRnVuY3Rpb259IFtzb3J0ZXJdIC0gSWYgdW5kZWZpbmVkLCBkZWxldGVzIHNvcnRlci5cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHNvcnRlcikge1xuICAgICAgICBpZiAoc29ydGVyKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBpbXBsZW1lbnRzIHNvcnRlckludGVyZmFjZWlcbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlI1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNvcnRlciA9IHNvcnRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNvcnRlcjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwU29ydGVyI1xuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNvcnRHcm91cHModGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlI1xuICAgICAqL1xuICAgIGNsZWFyU29ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNvcnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5idWlsZFZpZXcoKTtcbiAgICB9LFxuXG4gICAgc29ydEdyb3VwOiBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoIWdyb3VwLm9yaWdpbmFsT3JkZXIpIHtcbiAgICAgICAgICAgIGdyb3VwLm9yaWdpbmFsT3JkZXIgPSBncm91cC5jaGlsZHJlbi5zbGljZSgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBsaXN0IG9mIHNvcnRzIGZyb20gZWl0aGVyIEFQSSBvciB1c2UgZXhpc3RpbmdcbiAgICAgICAgdGhpcy5zb3J0cyA9ICh0aGlzLnNvcnRlciAmJiB0aGlzLnNvcnRlci5wcm9wKCdzb3J0cycpKSB8fCB0aGlzLnNvcnRzO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5zb3J0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0R3JvdXBPbkVhY2goZ3JvdXAsIHRoaXMuc29ydHNbdGhpcy5zb3J0cy5sZW5ndGggLSBpIC0gMV0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNvcnRHcm91cE9uRWFjaDogZnVuY3Rpb24oZ3JvdXAsIHNvcnRTcGVjKSB7XG4gICAgICAgIC8vIHdlIGFjdHVhbGx5IHNvcnQgdGhlIGNoaWxkcmVuIGhlcmUuLi4uXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGdyb3VwLmNoaWxkcmVuLnNsaWNlKDApO1xuICAgICAgICB2YXIgaW5kZXhWZWN0b3IgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbmRleFZlY3RvcltpXSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFibGVTb3J0KGluZGV4VmVjdG9yLCBmdW5jdGlvbihyb3dOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW3Jvd051bWJlcl07XG4gICAgICAgICAgICBpZiAoc29ydFNwZWMuY29sdW1uSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuZGF0YVtzb3J0U3BlYy5jb2x1bW5JbmRleF07XG4gICAgICAgIH0sIHNvcnRTcGVjLmRpcmVjdGlvbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBncm91cC5jaGlsZHJlbltpXSA9IGNoaWxkcmVuW2luZGV4VmVjdG9yW2ldXTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbkRhdGFOb2RlR3JvdXBTb3J0ZXIucHJvdG90eXBlLmFwcGx5U29ydHMgPSBmdW5jdGlvbigpIHtcbiAgICAoY29uc29sZS53YXJuIHx8IGNvbnNvbGUubG9nKS5jYWxsKGNvbnNvbGUsICdhcHBseVNvcnRzIGRlcHJlY2F0ZWQ7IHVzZSBhcHBseScpO1xuICAgIHRoaXMuYXBwbHkoKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZUdyb3VwU29ydGVyLnByb3RvdHlwZSwgJ3R5cGUnLCB7IHZhbHVlOiAnc29ydGVyJyB9KTsgLy8gcmVhZC1vbmx5IHByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVHcm91cFNvcnRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFOb2RlQmFzZSA9IHJlcXVpcmUoJy4vRGF0YU5vZGVCYXNlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhTm9kZUJhc2VcbiAqL1xudmFyIERhdGFOb2RlTGVhZiA9IERhdGFOb2RlQmFzZS5leHRlbmQoJ0RhdGFOb2RlTGVhZicsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYjXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB0aGlzLmhhc0NoaWxkcmVuID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYjXG4gICAgICogQHBhcmFtIGRlcHRoXG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmI1xuICAgICAqIEByZXR1cm5zIHtudW1lcltdfVxuICAgICAqL1xuICAgIGdldEluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUxlYWYjXG4gICAgICogQHBhcmFtIGRyaWxsRG93blxuICAgICAqL1xuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oZHJpbGxEb3duKSB7XG4gICAgICAgIGRyaWxsRG93bi5hZGRWaWV3KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmI1xuICAgICAqIEBwYXJhbSBhZ2dyZWdhdG9yXG4gICAgICovXG4gICAgZ2V0Um93RGF0YTogZnVuY3Rpb24oZHJpbGxEb3duKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcblxuICAgICAgICBpZiAoaW5kZXgubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBzT2Zmc2V0ID0gTnVtYmVyKGRyaWxsRG93bi5oYXNHcm91cHMoKSksXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgICAgICBkYXRhTGVuID0gZHJpbGxEb3duLmdldENvbHVtbkNvdW50KCkgKyBncm91cHNPZmZzZXQsXG4gICAgICAgICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgICAgICAgc29ydGVyID0gZHJpbGxEb3duLnNvcnRlckluc3RhbmNlO1xuXG4gICAgICAgICAgICBzb3J0ZXIuaW5kZXggPSBpbmRleDtcblxuICAgICAgICAgICAgZm9yIChpOyBpIDwgZGF0YUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtncm91cHNPZmZzZXQgKyBpXSA9IHNvcnRlci5nZXRWYWx1ZShpLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVMZWFmI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29tcHV0ZUhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICBzb3J0V2l0aDogZnVuY3Rpb24oc29ydGVyKSB7XG4gICAgICAvLyBkbyBub3RoaW5nIHdlIGhhdmUgbm8gY2hpbGRyZW4gdG8gc29ydFxuICAgIH0sXG5cbiAgICBjbGVhckdyb3VwU29ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gZG8gbm90aGluZyB3ZSBoYXZlIG5vIGNoaWxkcmVuIHRvIHNvcnRcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFOb2RlTGVhZjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFOb2RlR3JvdXAgPSByZXF1aXJlKCcuL0RhdGFOb2RlR3JvdXAnKTtcblxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFOb2RlR3JvdXAjaW5pdGlhbGl6ZXxpbml0aWFsaXplKCl9IG1ldGhvZCBmb3IgcGFyYW1ldGVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGF0YU5vZGVHcm91cFxuICovXG52YXIgRGF0YU5vZGVUcmVlID0gRGF0YU5vZGVHcm91cC5leHRlbmQoJ0RhdGFOb2RlVHJlZScsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTm9kZUdyb3VwI1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAjXG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnZhbHVlcztcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC50b0FycmF5KDApO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFOb2RlR3JvdXAjXG4gICAgICogQHBhcmFtIGRyaWxsRG93blxuICAgICAqL1xuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oZHJpbGxEb3duKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQuYnVpbGRWaWV3KGRyaWxsRG93bik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YU5vZGVHcm91cCNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGNvbXB1dGVIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMTtcblxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IGhlaWdodCArIGNoaWxkLmNvbXB1dGVIZWlnaHQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLmhlaWdodCA9IGhlaWdodCk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTm9kZVRyZWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG52YXIgaGVhZGVyaWZ5ID0gcmVxdWlyZSgnLi91dGlsL2hlYWRlcmlmeScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3RbXX0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGRzXG4gKi9cbnZhciBEYXRhU291cmNlID0gQmFzZS5leHRlbmQoJ0RhdGFTb3VyY2UnLCB7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGF0YSwgZmllbGRzLCBjYWxjdWxhdG9ycykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgVGhlIGFycmF5IG9mIGRhdGEgcm93IG9iamVjdHMuXG4gICAgICAgICAqIEBkZXNjIEFjY2VzcyB0aHJvdWdoIHtAbGluayBEYXRhU291cmNlI2dldFJvd3xnZXRSb3coKX0uXG4gICAgICAgICAqIEBuYW1lIGRhdGFcbiAgICAgICAgICogQHR5cGUge29iamVjdFtdfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZSNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IFRoZSBsaXN0IG9mIGZpZWxkIG5hbWVzLlxuICAgICAgICAgKiBAZGVzYyBUaGVzZSBhcmUgYWxsIHRoZSBtZW1iZXJzIG9mIHRoZSBkYXRhIHJvdyBvYmplY3RzIHZpc2libGUgdG8gSHlwZXJncmlkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBY2Nlc3MgdGhyb3VnaCB7QGxpbmsgRGF0YVNvdXJjZSNnZXRGaWVsZHN8Z2V0RmllbGRzKCl9LlxuICAgICAgICAgKiBAbmFtZSBmaWVsZHNcbiAgICAgICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZSNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzIHx8IGNvbXB1dGVGaWVsZE5hbWVzKGRhdGFbMF0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBUaGUgbGlzdCBvZiBjYWxjdWxhdG9ycyB0aGF0IGltcGxlbWVudCBjb21wdXRlZCBjb2x1bW5zLlxuICAgICAgICAgKiBAZGVzYyBDb25ncnVlbnQgdG8ge0BsaW5rIERhdGFTb3VyY2UjZmllbGRzfGZpZWxkc30uXG4gICAgICAgICAqXG4gICAgICAgICAqIEVsZW1lbnRzIHJlcHJlc2VudGluZyByZWd1bGFyIChub24tY29tcHV0ZWQpIGZpZWxkcyBzaG91bGQgY29udGFpbiBgdW5kZWZpbmVkYC5cbiAgICAgICAgICogQG5hbWUgY2FsY3VsYXRvcnNcbiAgICAgICAgICogQHR5cGUge2Z1bmN0aW9uW119XG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWxjdWxhdG9ycyA9IGNhbGN1bGF0b3JzIHx8IEFycmF5KHRoaXMuZmllbGRzLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3ldO1xuICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICogQHN1bW1hcnkgRmluZCwgcmVwbGFjZSwgb3IgdXBkYXRlIGEgcm93IGJ5IGl0J3MgcHJpbWFyeSBrZXkgY29sdW1uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gY29sdW1uTmFtZSAtIE9uZSBvZjpcbiAgICAgKiAqIF9zdHJpbmdfIC0gQ29sdW1uIG5hbWUuIFNlZSBgdmFsdWVgLlxuICAgICAqICogX29iamVjdF8gLSBIYXNoIG9mIDAgb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfCp9IFt2YWx1ZV0gLSBPbmUgb2Y6XG4gICAgICogX29taXR0ZWRfIC0gV2hlbiBgY29sdW1uTmFtZWAgaXMgYSBoYXNoIGFuZCB5b3Ugd2FudCB0byBzZWFyY2ggYWxsIGl0cyBrZXlzLlxuICAgICAqIF9zdHJpbmdbXV8gLSBXaGVuIGBjb2x1bW5OYW1lYCBpcyBhIGhhc2ggYnV0IHlvdSBvbmx5IHdhbnQgdG8gc2VhcmNoIGNlcnRhaW4ga2V5cy5cbiAgICAgKiBfb3RoZXJ3aXNlXyAtIFdoZW4gYGNvbHVtbk5hbWVgIGlzIGEgc3RyaW5nLiBWYWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIE5vdGUgdGhhdCBgbnVsbGAgaXMgYSB2YWxpZCBzZWFyY2ggdmFsdWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R8bnVsbHx1bmRlZmluZWR9IFtyZXBsYWNlbWVudF0gLSBPbmUgb2Y6XG4gICAgICogKiBfb21pdHRlZF8gLSBJZ25vcmVkLlxuICAgICAqICogX29iamVjdF8gLSBSZXBsYWNlbWVudCBmb3IgdGhlIGRhdGEgcm93IGlmIGZvdW5kLlxuICAgICAqICogYG51bGxgIC0gRmxhZyB0byBkZWxldGUgdGhlIGRhdGEgcm93IGlmIGZvdW5kLiBUaGUgZm91bmQgZGF0YSByb3cgaXMgbm9uZXRoZWxlc3MgcmV0dXJuZWQuXG4gICAgICogKiBgdW5kZWZpbmVkYCAtIEZsYWcgdG8gcmV0dXJuIGluZGV4IG9mIGZvdW5kIHJvdyBpbnN0ZWFkIG9mIHJvdyBvYmplY3QgaXRzZWxmLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8bnVtYmVyfHVuZGVmaW5lZH0gT25lIG9mOlxuICAgICAqICogYHVuZGVmaW5lZGAgLSBkYXRhIHJvdyBub3QgZm91bmRcbiAgICAgKiAqIF9vYmplY3RfIC0gZm91bmQgZGF0YSByb3cgb2JqZWN0ICh3aWxsIGhhdmUgYmVlbiBkZWxldGVkIGlmIGByZXBsYWNlbWVudGAgd2FzIGBudWxsYClcbiAgICAgKiAqIF9udW1iZXJfIC0gaW5kZXggb2YgZm91bmQgZGF0YSByb3cgb2JqZWN0IGluIGB0aGlzLmRhdGFgIChpZiBgcmVwbGFjZW1lbnRgIHdhcyBgdW5kZWZpbmVkYClcbiAgICAgKiBAdG9kbyBVc2UgYSBiaW5hcnkgc2VhcmNoIChyYXRoZXIgdGhhbiBgQXJyYXkuLmZpbmRgKSB3aGVuIGNvbHVtbiBpcyBrbm93biB0byBiZSBpbmRleGVkIChzb3J0ZWQpLlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAqL1xuICAgIGZpbmRSb3c6IGZ1bmN0aW9uIGZpbmRSb3coY29sdW1uTmFtZSwgdmFsdWUsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQsIGluZGV4LCBrZXlzLCBoYXNoLCBhcmdzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29sdW1uTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGhhc2ggPSBjb2x1bW5OYW1lO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSAyO1xuICAgICAgICAgICAgICAgIGtleXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSBpbiBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICAgICAgICAgIH0sIDApICE9PSBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgYWxsIGtleXMgZ2l2ZW4gaW4gMm5kIGFyZyB0byBiZSBmb3VuZCBpbiBoYXNoIGdpdmVuIGluIDFzdCBhcmcuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSAxO1xuICAgICAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhoYXNoKTtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHZhbHVlOyAvLyBwcm9tb3RlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbk5hbWUgPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaGFzaFtjb2x1bW5OYW1lXTtcbiAgICAgICAgICAgICAgICBoYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZGF0YS5maW5kKGZ1bmN0aW9uKHJvdywgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpZHg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5OYW1lID0ga2V5c1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd1tjb2x1bW5OYW1lXSAhPT0gaGFzaFtjb2x1bW5OYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gYmFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBmb3VuZCFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBhdCBsZWFzdCAyIGFyZ3VtZW50cyB3aGVuIGZpcnN0IGFyZ3VtZW50IG5vdCBvYmplY3QgYnV0IGZvdW5kICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncyA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhc2gpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZGF0YS5maW5kKGZ1bmN0aW9uKHJvdywgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyb3cpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpZHg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvd1tjb2x1bW5OYW1lXSA9PT0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuZm91bmRSb3dJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgbnVsbCwgdW5kZWZpbmVkLCBvciBvYmplY3QgYnV0IGZvdW5kICcgKyB0eXBlb2YgcmVwbGFjZW1lbnQgKyAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvdW5kUm93SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZSNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0Um93KHkpO1xuICAgICAgICBpZiAoIXJvdykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd1t0aGlzLmZpZWxkc1t4XV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRSb3coeSlbdGhpcy5maWVsZHNbeF1dID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UjXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkcygpLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UjXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqL1xuICAgIGdldEZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UjXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAc3VtbWFyeSBUaGUgbGlzdCBvZiBoZWFkZXIgc3RyaW5ncy5cbiAgICAgICAgICAgICAqIEBkZXNjIENvbmdydWVudCB0byB7QGxpbmsgRGF0YVNvdXJjZSNmaWVsZHN8ZmllbGRzfS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBBY2Nlc3MgdGhyb3VnaCB7QGxpbmsgRGF0YVNvdXJjZSNnZXRIZWFkZXJzfGdldEhlYWRlcnMoKX0uXG4gICAgICAgICAgICAgKiBAbmFtZSBoZWFkZXJzXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZSNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gdGhpcy5oZWFkZXJzIHx8IHRoaXMuZ2V0RGVmYXVsdEhlYWRlcnMoKS5tYXAoZnVuY3Rpb24oZWFjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJpZnkudHJhbnNmb3JtKGVhY2gpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UjXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldERlZmF1bHRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlI1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkc1xuICAgICAqL1xuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZSNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBoZWFkZXJzXG4gICAgICovXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVycykge1xuICAgICAgICBpZiAoIShoZWFkZXJzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICBlcnJvcignc2V0SGVhZGVycycsICdwYXJhbSAjMSBgaGVhZGVyc2Agbm90IGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2UjXG4gICAgICovXG4gICAgZ2V0R3JhbmRUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL25vdGhpbmcgaGVyZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZSNcbiAgICAgKiBAcGFyYW0gYXJyYXlPZlVuaWZvcm1PYmplY3RzXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oYXJyYXlPZlVuaWZvcm1PYmplY3RzKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGFycmF5T2ZVbmlmb3JtT2JqZWN0cztcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gZXJyb3IobWV0aG9kTmFtZSwgbWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGF0YVNvdXJjZS4nICsgbWV0aG9kTmFtZSArICc6ICcgKyBtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICovXG5mdW5jdGlvbiBjb21wdXRlRmllbGROYW1lcyhvYmplY3QpIHtcbiAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QgfHwgW10pLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBlLnN1YnN0cigwLCAyKSAhPT0gJ19fJztcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpO1xudmFyIERhdGFTb3VyY2VTb3J0ZXIgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VTb3J0ZXInKTtcbnZhciBEYXRhTm9kZVRyZWUgPSByZXF1aXJlKCcuL0FnZ3JlZ2F0b3JOb2RlVHJlZScpO1xudmFyIERhdGFOb2RlR3JvdXAgPSByZXF1aXJlKCcuL0FnZ3JlZ2F0b3JOb2RlR3JvdXAnKTtcbnZhciBEYXRhTm9kZUxlYWYgPSByZXF1aXJlKCcuL0FnZ3JlZ2F0b3JOb2RlTGVhZicpO1xudmFyIGhlYWRlcmlmeSA9IHJlcXVpcmUoJy4vdXRpbC9oZWFkZXJpZnknKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RGF0YVNvdXJjZX0gZGF0YVNvdXJjZVxuICovXG52YXIgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IgPSBCYXNlLmV4dGVuZCgnRGF0YVNvdXJjZUFnZ3JlZ2F0b3InLCB7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGF0YVNvdXJjZSkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICAgICAqIEB0eXBlIHtEYXRhU291cmNlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAgICAgKiBAdHlwZSB7RGF0YVNvdXJjZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJlZUNvbHVtbkluZGV4ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAgICAgKiBAdHlwZSB7RGF0YU5vZGVUcmVlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmVlID0gbmV3IERhdGFOb2RlVHJlZSgnVG90YWxzJyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAgICAgKiBAZGVmYXVsdCBbXVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWdncmVnYXRlcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXBCeXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpZXcgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAZGVmYXVsdCB7fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb3J0ZXJJbnN0YW5jZSA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXNvcnRHcm91cHMgPSB0cnVlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBkZWZhdWx0IHt9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RBZ2dyZWdhdGUgPSB7fTtcblxuICAgICAgICB0aGlzLnNldEFnZ3JlZ2F0ZXMoe30pO1xuICAgIH0sXG5cbiAgICBpc051bGxPYmplY3Q6IGZhbHNlLFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0aW9ucywgZ3JvdXBzXG4gICAgICovXG4gICAgc2V0QWdncmVnYXRlR3JvdXBzOiBmdW5jdGlvbihhZ2dyZWdhdGlvbnMsIGdyb3Vwcykge1xuICAgICAgICB0aGlzLnNldEdyb3VwQnlzKGdyb3Vwcyk7XG4gICAgICAgIHRoaXMuc2V0QWdncmVnYXRlcyhhZ2dyZWdhdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0aW9uc1xuICAgICAqL1xuICAgIHNldEFnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKGFnZ3JlZ2F0aW9ucykge1xuICAgICAgICB0aGlzLmxhc3RBZ2dyZWdhdGUgPSBhZ2dyZWdhdGlvbnM7XG4gICAgICAgIHRoaXMuY2xlYXJBZ2dyZWdhdGlvbnMoKTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYWdncmVnYXRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEFnZ3JlZ2F0ZShrZXksIGFnZ3JlZ2F0aW9uc1trZXldKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGdldEZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEZpZWxkcygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEhlYWRlcnMoKS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUudG9Mb3dlckNhc2UoKS5zcGxpdCgnICcpLmpvaW4oJ18nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfSxcblxuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmFnZ3JlZ2F0ZXMubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmhlYWRlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmhhc0dyb3VwcygpKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnVuc2hpZnQoJ1RyZWUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcGFyYW0gbGFiZWxcbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqL1xuICAgIGFkZEFnZ3JlZ2F0ZTogZnVuY3Rpb24obGFiZWwsIGZ1bmMpIHtcbiAgICAgICAgZnVuYy5oZWFkZXIgPSBoZWFkZXJpZnkudHJhbnNmb3JtKGxhYmVsKTtcbiAgICAgICAgdGhpcy5hZ2dyZWdhdGVzLnB1c2goZnVuYyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcGFyYW0gY29sdW1uSW5kZXhBcnJheVxuICAgICAqL1xuICAgIHNldEdyb3VwQnlzOiBmdW5jdGlvbihjb2x1bW5JbmRleEFycmF5KSB7XG4gICAgICAgIHZhciBncm91cEJ5cyA9IHRoaXMuZ3JvdXBCeXM7XG4gICAgICAgIGdyb3VwQnlzLmxlbmd0aCA9IDA7XG4gICAgICAgIGNvbHVtbkluZGV4QXJyYXkuZm9yRWFjaChmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgZ3JvdXBCeXMucHVzaChjb2x1bW5JbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldEFnZ3JlZ2F0ZXModGhpcy5sYXN0QWdncmVnYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqL1xuICAgIGFkZEdyb3VwQnk6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHRoaXMuZ3JvdXBCeXMucHVzaChpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdyb3VwQnlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0FnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmFnZ3JlZ2F0ZXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHBhcmFtcyBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBhcHBseTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zICA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy5yb3dDbGljayAmJiAhb3B0aW9ucy5jb2x1bW5Tb3J0KXtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRHcm91cFRyZWUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICovXG4gICAgY2xlYXJHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdyb3VwQnlzLmxlbmd0aCA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKi9cbiAgICBjbGVhckFnZ3JlZ2F0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYWdncmVnYXRlcy5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICovXG4gICAgYnVpbGRHcm91cFRyZWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmV2ZXJzZWRHcm91cEJ5cyA9IHRoaXMuZ3JvdXBCeXMuc2xpY2UoMCkucmV2ZXJzZSgpLFxuICAgICAgICAgICAgbGVhZkRlcHRoID0gdGhpcy5ncm91cEJ5cy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgc291cmNlID0gdGhpcy5kYXRhU291cmNlLFxuICAgICAgICAgICAgcm93Q291bnQgPSBzb3VyY2UuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgICAgIHRyZWUgPSB0aGlzLnRyZWUgPSBuZXcgRGF0YU5vZGVUcmVlKCdUb3RhbHMnKTtcblxuICAgICAgICAvLyBmaXJzdCBzb3J0IGRhdGFcbiAgICAgICAgaWYgKHRoaXMucHJlc29ydEdyb3Vwcykge1xuICAgICAgICAgICAgcmV2ZXJzZWRHcm91cEJ5cy5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwQnkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBuZXcgRGF0YVNvdXJjZVNvcnRlcihzb3VyY2UpO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5zb3J0T24oZ3JvdXBCeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0cmVlO1xuXG4gICAgICAgICAgICB0aGlzLmdyb3VwQnlzLmZvckVhY2goZnVuY3Rpb24oZywgYykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBzb3VyY2UuZ2V0VmFsdWUoZywgciksXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnlEYXRhTm9kZSA9IChjID09PSBsZWFmRGVwdGgpID8gZmFjdG9yeURhdGFOb2RlTGVhZiA6IGZhY3RvcnlEYXRhTm9kZUdyb3VwO1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLmNoaWxkcmVuLmdldElmVW5kZWZpbmVkKGtleSwgZmFjdG9yeURhdGFOb2RlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwYXRoLmluZGV4LnB1c2gocik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNvcnRlckluc3RhbmNlID0gbmV3IERhdGFTb3VyY2VTb3J0ZXIoc291cmNlKTtcbiAgICAgICAgdHJlZS50b0FycmF5KCk7XG4gICAgICAgIHRyZWUuZ2V0Um93RGF0YSh0aGlzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAqIEBwYXJhbSBkYXRhTm9kZVxuICAgICAqL1xuICAgIGFkZFZpZXc6IGZ1bmN0aW9uKGRhdGFOb2RlKSB7XG4gICAgICAgIHRoaXMudmlldy5wdXNoKGRhdGFOb2RlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAqL1xuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnRyZWUuY29tcHV0ZUhlaWdodCgpO1xuICAgICAgICB0aGlzLnRyZWUuYnVpbGRWaWV3KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB2aWV3TWFrZXNTZW5zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSAmJiB0aGlzLmhhc0dyb3VwcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0RyaWxsRG93bjogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudmlld01ha2VzU2Vuc2UoKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBjb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29sdW1uSW5kZXggPT09IHRoaXMudHJlZUNvbHVtbkluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldERhdGFJbmRleDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3TWFrZXNTZW5zZSgpID8geSA6IHRoaXMuZGF0YVNvdXJjZS5nZXREYXRhSW5kZXgoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0VmFsdWUoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvdyA9IHRoaXMudmlld1t5XTtcbiAgICAgICAgcmV0dXJuIHJvdyA/IHJvdy5nZXRWYWx1ZSh4KSA6IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNldFZhbHVlKHgsIHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEhlYWRlcnMoKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5sZW5ndGg7IC8vaGVhZGVyIGNvbHVtblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUFnZ3JlZ2F0b3IjXG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBhbmRdIC0gT25lIG9mOlxuICAgICAqICogYHRydWVgIC0gRXhwYW5kIGFsbCByb3dzIHRoYXQgYXJlIGN1cnJlbnRseSBjb2xsYXBzZWQuXG4gICAgICogKiBgZmFsc2VgIC0gQ29sbGFwc2UgYWxsIHJvd3MgdGhhdCBhcmUgY3VycmVudGx5IGV4cGFuZGVkLlxuICAgICAqICogYHVuZGVmaW5lZGAgKG9yIG9taXR0ZWQpIC0gRXhwYW5kIGFsbCBjdXJyZW50bHkgY29sbGFwc2VkIHJvd3M7IGNvbGxhcHNlIGFsbCBjdXJyZW50bHkgZXhwYW5kZWQgcm93cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPUluZmluaXR5XSAtIE9uZSBvZjpcbiAgICAgKiAqIG51bWJlciA+IDAgLSBBcHBseSBvbmx5IGlmIHJvdyBkZXB0aCBpcyBhYm92ZSB0aGUgZ2l2ZW4gZGVwdGguXG4gICAgICogKiBudW1iZXIgPD0gMCAtIEFwcGx5IG9ubHkgaWYgcm93IGRlcHRoIGlzIGJlbG93IHRoZSBnaXZlbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IE9uZSBvZjpcbiAgICAgKiAqIGB1bmRlZmluZWRgIC0gcm93IHdhcyBub3QgZXhwYW5kYWJsZVxuICAgICAqICogYHRydWVgIC0gcm93IHdhcyBleHBhbmRhYmxlIF9hbmRfIHN0YXRlIGNoYW5nZWRcbiAgICAgKiAqIGBmYWxzZWAgLSByb3cgd2FzIGV4cGFuZGFibGUgX2J1dF8gc3RhdGUgZGlkIF9ub3RfIGNoYW5nZVxuICAgICAqL1xuICAgIGNsaWNrOiBmdW5jdGlvbih5LCBleHBhbmQsIGRlcHRoKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmNsaWNrLmFwcGx5KHRoaXMuZGF0YVNvdXJjZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLnZpZXdbeV0sIGV4cGFuZGFibGUsIGNoYW5nZWQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyb3VwICYmIChcbiAgICAgICAgICAgICAgICBkZXB0aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgZGVwdGggPiAwICYmIGdyb3VwLmRlcHRoIDwgZGVwdGggfHxcbiAgICAgICAgICAgICAgICBkZXB0aCA8PSAwICYmIGdyb3VwLmRlcHRoID49IC1kZXB0aFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSBncm91cC50b2dnbGVFeHBhbnNpb25TdGF0ZSh0aGlzLCBleHBhbmQpO1xuICAgICAgICAgICAgaWYgKChleHBhbmRhYmxlID0gZ3JvdXAuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZFZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleHBhbmRhYmxlID8gY2hhbmdlZCA6IHVuZGVmaW5lZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VBZ2dyZWdhdG9yI1xuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRHcmFuZFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy50cmVlO1xuICAgICAgICByZXR1cm4gW3ZpZXcuZGF0YV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3coeSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm9sbHVwcyA9IHRoaXMudmlld1t5XTtcblxuICAgICAgICByZXR1cm4gcm9sbHVwcyA/IHJvbGx1cHMgOiB0aGlzLnRyZWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlQWdncmVnYXRvciNcbiAgICAgKiBAcGFyYW0gYXJyYXlPZlVuaWZvcm1PYmplY3RzXG4gICAgICovXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oYXJyYXlPZlVuaWZvcm1PYmplY3RzKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXREYXRhKGFycmF5T2ZVbmlmb3JtT2JqZWN0cyk7XG4gICAgICAgIHRoaXMuYXBwbHkoKTtcbiAgICB9LFxuXG4gICAgc29ydEdyb3VwczogZnVuY3Rpb24oZ3JvdXBTb3J0ZXIpIHtcbiAgICAgICAgdGhpcy50cmVlLmNsZWFyR3JvdXBTb3J0cygpO1xuICAgICAgICB0aGlzLnRyZWUuc29ydFdpdGgoZ3JvdXBTb3J0ZXIpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlldygpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBmYWN0b3J5RGF0YU5vZGVMZWFmKGtleSkge1xuICAgIHJldHVybiBuZXcgRGF0YU5vZGVMZWFmKGtleSk7XG59XG5cbmZ1bmN0aW9uIGZhY3RvcnlEYXRhTm9kZUdyb3VwKGtleSkge1xuICAgIHJldHVybiBuZXcgRGF0YU5vZGVHcm91cChrZXkpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlLCAndHlwZScsIHsgdmFsdWU6ICdhZ2dyZWdhdG9yJyB9KTsgLy8gcmVhZC1vbmx5IHByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZUFnZ3JlZ2F0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcbnZhciBzdGFibGVTb3J0ID0gcmVxdWlyZSgnLi91dGlsL3N0YWJsZVNvcnQnKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFNvcnRzIG9uIG5vbi10ZXJtaW5hbCB0cmVlIG5vZGUgcm93cyBvbmx5IChfaS5lLixfIGV4cGFuZGFibGUgcm93cyB3aXRoIGNoaWxkcmVuKS5cbiAqXG4gKiBPbmUgb2YgdGhlc2Ugc29ydGVycyBpcyBjcmVhdGVkIGJ5IHtAbGluayBEYXRhU291cmNlVHJlZXZpZXdTb3J0ZXJ9IGZvciBlYWNoIGdyb3VwaW5nIGxldmVsLCBzdGFydGluZyB3aXRoIHRoZSBtYXhpbXVtIGdyb3VwIGxldmVsIGRlcHRoLCBhbmQgdGhlbiBvbmUgZm9yIGVhY2ggZ3JvdXAgbGV2ZWwgdGhyb3VnaCB0aGUgdG9wIGxldmVsICgwKSBzb3J0IGRlcHRoLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZGF0YVNvdXJjZVxuICogQGV4dGVuZHMgRGF0YVNvdXJjZUluZGV4ZWRcbiAqL1xudmFyIERhdGFTb3VyY2VEZXB0aFNvcnRlciA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZURlcHRoU29ydGVyJywge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGFTb3VyY2UsIHRyZWVWaWV3KSB7XG4gICAgICAgIHRoaXMuaWRDb2x1bW5OYW1lID0gdHJlZVZpZXcuaWRDb2x1bW4ubmFtZTtcbiAgICAgICAgdGhpcy5wYXJlbnRJZENvbHVtbk5hbWUgPSB0cmVlVmlldy5wYXJlbnRJZENvbHVtbi5uYW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBTdGFibGUtc29ydHMgbm9uLXRlcm1pbmFsIHRyZWUgbm9kZSByb3dzLiBUZXJtaW5hbCAobGVhZikgcm93cyByZW1haW4gc3RhYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBncm91cExldmVsIC0gSWYgZ3JlYXRlciB0aGFuIHJvdyBkZXB0aCwgc29ydHMgb24gYW4gX2VkZ2UgdmFsdWVfIHZhbHVlLCB3aGljaCBpcyBhIHZhbHVlIGxleGljYWxseSBpbmZlcmlvciB0byAoYXNjZW5kaW5nIHNvcnQpIG9yIHN1cGVyaW9yIHRvIChkZXNjZW5kaW5nIHNvcnQpIHRoZSByb3cgdmFsdWUuXG4gICAgICogT3RoZXJ3aXNlIHNvcnRzIG9uIHZhbHVlIG9mIGFuY2VzdG9yIG9mIHRoaXMgZGVwdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RpcmVjdGlvbj0xXSAtIE9uZSBvZjpcbiAgICAgKiBgMWAgLSBTb3J0IGFzY2VuZGluZy5cbiAgICAgKiBgLTFgIC0gU29ydCBkZXNjZW5kaW5nLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sdW1uSW5kZXhdIC0gU29ydHMgb24gdGhlIHZhbHVlcyBpbiB0aGlzIGNvbHVtbi4gT3RoZXJ3aXNlIHNvcnRzIG9uIHRoZSByb3cgaW5kZXguXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VEZXB0aFNvcnRlciNcbiAgICAgKi9cbiAgICBzb3J0T246IGZ1bmN0aW9uKGdyb3VwTGV2ZWwsIGRpcmVjdGlvbiwgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFySW5kZXgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIC0xOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UuZ2V0Um93Q291bnQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0VmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZEluZGV4KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBpbiBnZXRWYWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRnZSA9IGRpcmVjdGlvbiA9PT0gLTEgPyArSW5maW5pdHkgOiAtSW5maW5pdHk7IC8vIGZvciBudW1iZXJzLCBkYXRlIG9iamVjdHNcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWUgPSBnZXRSb3dJbmRleC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWUgPSBnZXRDb2x1bW5WYWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5OYW1lID0gdGhpcy5kYXRhU291cmNlLmdldEZpZWxkcygpW2NvbHVtbkluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRvciA9IHRoaXMuZGF0YVNvdXJjZS5nZXRQcm9wZXJ0eSgnY2FsY3VsYXRvcnMnKVtjb2x1bW5JbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGdldFZhbHVlKDApID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWRnZSA9IGRpcmVjdGlvbiA9PT0gLTEgPyAnXFx1ZmZmZicgOiAnJzsgLy8gZm9yIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVwdGggPSBncm91cExldmVsO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVTb3J0LnNvcnQodGhpcy5pbmRleCwgZ2V0VmFsdWUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldFJvd0luZGV4KHJvd0lkeCkge1xuICAgIHZhciBwYXJlbnRJRCxcbiAgICAgICAgZGF0YVJvdyA9IHRoaXMuZGF0YVNvdXJjZS5nZXRSb3cocm93SWR4KTtcblxuICAgIGlmIChkYXRhUm93Ll9fREVQVEggPCB0aGlzLmRlcHRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkZ2U7XG4gICAgfVxuXG4gICAgcm93SWR4ID0gdGhpcy5nZXREYXRhSW5kZXgocm93SWR4KTtcblxuICAgIC8vIGJ1YmJsZSB1cCB0byBncm91cCBsYWJlbCBvZiByZXF1ZXN0ZWQgZGVwdGggd2hpbGUgZWl0aGVyLi4uXG4gICAgd2hpbGUgKFxuICAgICAgICAvLyAuLi50aGlzIGlzIGEgbGVhZiByb3dcbiAgICAgICAgZGF0YVJvdy5fX0VYUEFOREVEID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgLy8gLi4ub3I6IHN0aWxsIGRlZXBlciB0aGFuIHRoZSByZXF1ZXN0ZWQgZGVwdGhcbiAgICAgICAgZGF0YVJvdy5fX0RFUFRIID4gdGhpcy5kZXB0aFxuICAgICkge1xuICAgICAgICBwYXJlbnRJRCA9IGRhdGFSb3dbdGhpcy5wYXJlbnRJZENvbHVtbk5hbWVdO1xuICAgICAgICBpZiAocGFyZW50SUQgPT0gbnVsbCkgeyBicmVhazsgfVxuICAgICAgICBkYXRhUm93ID0gdGhpcy5maW5kUm93KHRoaXMuaWRDb2x1bW5OYW1lLCBwYXJlbnRJRCk7XG4gICAgICAgIHJvd0lkeCA9IHRoaXMuZ2V0UHJvcGVydHkoJ2ZvdW5kUm93SW5kZXgnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93SWR4O1xufVxuXG5mdW5jdGlvbiBnZXRDb2x1bW5WYWx1ZShyb3dJZHgpIHtcbiAgICB2YXIgcGFyZW50SUQsXG4gICAgICAgIGRhdGFSb3cgPSB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93KHJvd0lkeCk7XG5cbiAgICBpZiAoZGF0YVJvdy5fX0RFUFRIIDwgdGhpcy5kZXB0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGdlO1xuICAgIH1cblxuICAgIC8vIGJ1YmJsZSB1cCB0byBncm91cCBsYWJlbCBvZiByZXF1ZXN0ZWQgZGVwdGggd2hpbGUgZWl0aGVyLi4uXG4gICAgd2hpbGUgKFxuICAgICAgICAvLyAuLi50aGlzIGlzIGEgbGVhZiByb3dcbiAgICAgICAgZGF0YVJvdy5fX0VYUEFOREVEID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgLy8gLi4ub3I6IHN0aWxsIGRlZXBlciB0aGFuIHRoZSByZXF1ZXN0ZWQgZGVwdGhcbiAgICAgICAgZGF0YVJvdy5fX0RFUFRIID4gdGhpcy5kZXB0aFxuICAgICkge1xuICAgICAgICBwYXJlbnRJRCA9IGRhdGFSb3dbdGhpcy5wYXJlbnRJZENvbHVtbk5hbWVdO1xuICAgICAgICBpZiAocGFyZW50SUQgPT0gbnVsbCkgeyBicmVhazsgfVxuICAgICAgICBkYXRhUm93ID0gdGhpcy5maW5kUm93KHRoaXMuaWRDb2x1bW5OYW1lLCBwYXJlbnRJRCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIERhdGFTb3VyY2VJbmRleGVkLnZhbE9yRnVuYy5jYWxsKGRhdGFSb3csIHRoaXMuY29sdW1uTmFtZSwgdGhpcy5jYWxjdWxhdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlRGVwdGhTb3J0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIGZpbHRlckludGVyZmFjZVxuICovXG5cbi8qKlxuICogQG5hbWUgZmlsdGVySW50ZXJmYWNlI3Rlc3RcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhUm93IC0gT2JqZWN0IHJlcHJlc2VudGluZyBhIHJvdyBpbiB0aGUgZ3JpZCBjb250YWluaW5nIGFsbCB0aGUgZmllbGRzIGxpc3RlZCBpbiB7QGxpbmsgRGF0YVNvdXJjZSNmaWVsZHN8ZmllbGRzfS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogKiBgdHJ1ZWAgLSBpbmNsdWRlIGluIGdyaWQgKHJvdyBwYXNzZXMgdGhyb3VnaCBmaWx0ZXIpXG4gKiAqIGBmYWxzZWAgLSBleGNsdWRlIGZyb20gZ3JpZCAocm93IGlzIGJsb2NrZWQgYnkgZmlsdGVyKVxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhU291cmNlSW5kZXhlZFxuICovXG52YXIgRGF0YVNvdXJjZUdsb2JhbEZpbHRlciA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZUdsb2JhbEZpbHRlcicsIHtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIjXG4gICAgICogQHBhcmFtIHtmaWx0ZXJGdW5jdGlvbn0gW2ZpbHRlcl0gLSBJZiB1bmRlZmluZWQsIGRlbGV0ZXMgZmlsdGVyLlxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgZmlsdGVySW50ZXJmYWNlXG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdsb2JhbEZpbHRlciNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5maWx0ZXI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0OiBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyO1xuICAgIH0sXG5cbiAgICBzb3J0R3JvdXBzOiBmdW5jdGlvbihzb3J0ZXIpe1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc29ydEdyb3Vwcyhzb3J0ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR2xvYmFsRmlsdGVyI1xuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyICYmIHRoaXMuZmlsdGVyLnRlc3QpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRJbmRleCh0aGlzLmZpbHRlclRlc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGVhckluZGV4KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGltcGxlbWVudHMgZmlsdGVyUHJlZGljYXRlXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIjXG4gICAgICovXG4gICAgZmlsdGVyVGVzdDogZnVuY3Rpb24ociwgcm93T2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlci50ZXN0KHJvd09iamVjdCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdsb2JhbEZpbHRlciNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyICYmIHRoaXMuZmlsdGVyLnRlc3QgPyB0aGlzLmluZGV4Lmxlbmd0aCA6IHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpO1xuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVNvdXJjZUdsb2JhbEZpbHRlci5wcm90b3R5cGUsICd0eXBlJywgeyB2YWx1ZTogJ2ZpbHRlcicgfSk7IC8vIHJlYWQtb25seSBwcm9wZXJ0eVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VHbG9iYWxGaWx0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi9CYXNlJyk7XG52YXIgRGF0YVNvdXJjZVNvcnRlciA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlcicpO1xudmFyIERhdGFOb2RlVHJlZSA9IHJlcXVpcmUoJy4vRGF0YU5vZGVUcmVlJyk7XG52YXIgRGF0YU5vZGVHcm91cCA9IHJlcXVpcmUoJy4vRGF0YU5vZGVHcm91cCcpO1xudmFyIERhdGFOb2RlTGVhZiA9IHJlcXVpcmUoJy4vRGF0YU5vZGVMZWFmJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0RhdGFTb3VyY2V9IGRhdGFTb3VyY2VcbiAqL1xudmFyIERhdGFTb3VyY2VHcm91cFZpZXcgPSBCYXNlLmV4dGVuZCgnRGF0YVNvdXJjZUdyb3VwVmlldycsIHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAgICAgKiBAdHlwZSB7RGF0YVNvdXJjZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAgICAgKiBAdHlwZSB7RGF0YU5vZGVUcmVlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmVlID0gbmV3IERhdGFOb2RlVHJlZSgnR3JvdXAnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JvdXBCeXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlldyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQGRlZmF1bHQge31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJlZUNvbHVtbkluZGV4ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBkZWZhdWx0IHt9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvcnRlckluc3RhbmNlID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmVzb3J0R3JvdXBzID0gdHJ1ZTtcblxuICAgIH0sXG5cbiAgICBpc051bGxPYmplY3Q6IGZhbHNlLFxuXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0RmllbGRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZ2V0SGVhZGVycygpLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXR1cm4gZS50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJykuam9pbignXycpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9LFxuXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEhlYWRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMuZGF0YVNvdXJjZS5nZXRIZWFkZXJzKCkuc2xpY2UoMCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzR3JvdXBzKCkpIHtcbiAgICAgICAgICAgIGhlYWRlcnMudW5zaGlmdCgnVHJlZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0gY29sdW1uSW5kZXhBcnJheVxuICAgICAqL1xuICAgIHNldEdyb3VwQnlzOiBmdW5jdGlvbihjb2x1bW5JbmRleEFycmF5KSB7XG4gICAgICAgIHZhciBncm91cEJ5cyA9IHRoaXMuZ3JvdXBCeXM7XG4gICAgICAgIGdyb3VwQnlzLmxlbmd0aCA9IDA7XG4gICAgICAgIGNvbHVtbkluZGV4QXJyYXkuZm9yRWFjaChmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgZ3JvdXBCeXMucHVzaChjb2x1bW5JbmRleCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBhZGRHcm91cEJ5OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB0aGlzLmdyb3VwQnlzLnB1c2goaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdyb3VwQnlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICogQHBhcmFtcyBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBhcHBseTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zICA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy5yb3dDbGljayAmJiAhb3B0aW9ucy5jb2x1bW5Tb3J0KXtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRHcm91cFRyZWUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKi9cbiAgICBjbGVhckdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBCeXMubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VHcm91cFZpZXcjXG4gICAgICovXG4gICAgYnVpbGRHcm91cFRyZWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmV2ZXJzZWRHcm91cEJ5cyA9IHRoaXMuZ3JvdXBCeXMuc2xpY2UoMCkucmV2ZXJzZSgpLFxuICAgICAgICAgICAgbGVhZkRlcHRoID0gdGhpcy5ncm91cEJ5cy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgc291cmNlID0gdGhpcy5kYXRhU291cmNlLFxuICAgICAgICAgICAgcm93Q291bnQgPSBzb3VyY2UuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgICAgIHRyZWUgPSB0aGlzLnRyZWUgPSBuZXcgRGF0YU5vZGVUcmVlKCdHcm91cCcpO1xuXG4gICAgICAgIC8vIGZpcnN0IHNvcnQgZGF0YVxuICAgICAgICBpZiAodGhpcy5wcmVzb3J0R3JvdXBzKSB7XG4gICAgICAgICAgICByZXZlcnNlZEdyb3VwQnlzLmZvckVhY2goZnVuY3Rpb24oZ3JvdXBCeSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IG5ldyBEYXRhU291cmNlU29ydGVyKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgc291cmNlLnNvcnRPbihncm91cEJ5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHRyZWU7XG5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBCeXMuZm9yRWFjaChmdW5jdGlvbihnLCBjKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHNvdXJjZS5nZXRWYWx1ZShnLCByKSxcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yeURhdGFOb2RlID0gKGMgPT09IGxlYWZEZXB0aCkgPyBmYWN0b3J5RGF0YU5vZGVMZWFmIDogZmFjdG9yeURhdGFOb2RlR3JvdXA7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguY2hpbGRyZW4uZ2V0SWZVbmRlZmluZWQoa2V5LCBmYWN0b3J5RGF0YU5vZGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBhdGguaW5kZXgucHVzaChyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc29ydGVySW5zdGFuY2UgPSBuZXcgRGF0YVNvdXJjZVNvcnRlcihzb3VyY2UpO1xuICAgICAgICB0cmVlLnRvQXJyYXkoKTtcbiAgICAgICAgdHJlZS5nZXRSb3dEYXRhKHRoaXMpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlldygpO1xuICAgICAgICAvL3RoaXMuZHVtcCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0gZGF0YU5vZGVcbiAgICAgKi9cbiAgICBhZGRWaWV3OiBmdW5jdGlvbihkYXRhTm9kZSkge1xuICAgICAgICB0aGlzLnZpZXcucHVzaChkYXRhTm9kZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAqL1xuICAgIGJ1aWxkVmlldzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmlldy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnRyZWUuY29tcHV0ZUhlaWdodCgpO1xuICAgICAgICB0aGlzLnRyZWUuYnVpbGRWaWV3KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxuICAgICAqL1xuICAgIHZpZXdNYWtlc1NlbnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzR3JvdXBzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHsqfGJvb2xlYW59XG4gICAgICovXG4gICAgaXNEcmlsbERvd246IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnZpZXdNYWtlc1NlbnNlKCk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgY29sdW1uSW5kZXgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbHVtbkluZGV4ID09PSB0aGlzLnRyZWVDb2x1bW5JbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld01ha2VzU2Vuc2UoKSA/IHkgOiB0aGlzLmRhdGFTb3VyY2UuZ2V0RGF0YUluZGV4KHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0VmFsdWUoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvdyA9IHRoaXMudmlld1t5XTtcbiAgICAgICAgcmV0dXJuIHJvdyA/IHJvdy5nZXRWYWx1ZSh4KSA6IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkZXJzKCkubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5sZW5ndGg7IC8vaGVhZGVyIGNvbHVtblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4cGFuZF0gLSBPbmUgb2Y6XG4gICAgICogKiBgdHJ1ZWAgLSBFeHBhbmQgYWxsIHJvd3MgdGhhdCBhcmUgY3VycmVudGx5IGNvbGxhcHNlZC5cbiAgICAgKiAqIGBmYWxzZWAgLSBDb2xsYXBzZSBhbGwgcm93cyB0aGF0IGFyZSBjdXJyZW50bHkgZXhwYW5kZWQuXG4gICAgICogKiBgdW5kZWZpbmVkYCAob3Igb21pdHRlZCkgLSBFeHBhbmQgYWxsIGN1cnJlbnRseSBjb2xsYXBzZWQgcm93czsgY29sbGFwc2UgYWxsIGN1cnJlbnRseSBleHBhbmRlZCByb3dzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9SW5maW5pdHldIC0gT25lIG9mOlxuICAgICAqICogbnVtYmVyID4gMCAtIEFwcGx5IG9ubHkgaWYgcm93IGRlcHRoIGlzIGFib3ZlIHRoZSBnaXZlbiBkZXB0aC5cbiAgICAgKiAqIG51bWJlciA8PSAwIC0gQXBwbHkgb25seSBpZiByb3cgZGVwdGggaXMgYmVsb3cgdGhlIGdpdmVuIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gT25lIG9mOlxuICAgICAqICogYHVuZGVmaW5lZGAgLSByb3cgd2FzIG5vdCBleHBhbmRhYmxlXG4gICAgICogKiBgdHJ1ZWAgLSByb3cgd2FzIGV4cGFuZGFibGUgX2FuZF8gc3RhdGUgY2hhbmdlZFxuICAgICAqICogYGZhbHNlYCAtIHJvdyB3YXMgZXhwYW5kYWJsZSBfYnV0XyBzdGF0ZSBkaWQgX25vdF8gY2hhbmdlXG4gICAgICovXG4gICAgY2xpY2s6IGZ1bmN0aW9uKHksIGV4cGFuZCwgZGVwdGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuY2xpY2suYXBwbHkodGhpcy5kYXRhU291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMudmlld1t5XSwgZXhwYW5kYWJsZSwgY2hhbmdlZDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZ3JvdXAgJiYgKFxuICAgICAgICAgICAgICAgIGRlcHRoID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICBkZXB0aCA+IDAgJiYgZ3JvdXAuZGVwdGggPCBkZXB0aCB8fFxuICAgICAgICAgICAgICAgIGRlcHRoIDw9IDAgJiYgZ3JvdXAuZGVwdGggPj0gLWRlcHRoXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IGdyb3VwLnRvZ2dsZUV4cGFuc2lvblN0YXRlKHRoaXMsIGV4cGFuZCk7XG4gICAgICAgICAgICBpZiAoKGV4cGFuZGFibGUgPSBncm91cC5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkVmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cGFuZGFibGUgPyBjaGFuZ2VkIDogdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0gaGVhZGVyc1xuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNldEhlYWRlcnMoaGVhZGVycyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAqIEBwYXJhbSBmaWVsZHNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLnNldEZpZWxkcyhmaWVsZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3coeSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy52aWV3W3ldO1xuXG4gICAgICAgIHJldHVybiBncm91cHMgPyBncm91cHMgOiB0aGlzLnRyZWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlR3JvdXBWaWV3I1xuICAgICAqIEBwYXJhbSBhcnJheU9mVW5pZm9ybU9iamVjdHNcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihhcnJheU9mVW5pZm9ybU9iamVjdHMpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNldERhdGEoYXJyYXlPZlVuaWZvcm1PYmplY3RzKTtcbiAgICAgICAgdGhpcy5hcHBseSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdyb3VwVmlldyNcbiAgICAgKi9cbiAgICBnZXRHcmFuZFRvdGFsczogZnVuY3Rpb24gKCl7XG5cbiAgICB9LFxuXG4gICAgc29ydEdyb3VwczogZnVuY3Rpb24oZ3JvdXBTb3J0ZXIpIHtcbiAgICAgICAgdGhpcy50cmVlLmNsZWFyR3JvdXBTb3J0cygpO1xuICAgICAgICB0aGlzLnRyZWUuc29ydFdpdGgoZ3JvdXBTb3J0ZXIpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlldygpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBmYWN0b3J5RGF0YU5vZGVMZWFmKGtleSkge1xuICAgIHJldHVybiBuZXcgRGF0YU5vZGVMZWFmKGtleSk7XG59XG5cbmZ1bmN0aW9uIGZhY3RvcnlEYXRhTm9kZUdyb3VwKGtleSkge1xuICAgIHJldHVybiBuZXcgRGF0YU5vZGVHcm91cChrZXkpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVNvdXJjZUdyb3VwVmlldy5wcm90b3R5cGUsICd0eXBlJywgeyB2YWx1ZTogJ2dyb3Vwdmlld2VyJyB9KTsgLy8gcmVhZC1vbmx5IHByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZUdyb3VwVmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuL0Jhc2UnKTtcblxuLyoqXG4gKiBAcGFyYW0gZGF0YVNvdXJjZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IEJhc2UuZXh0ZW5kKCdEYXRhU291cmNlSW5kZXhlZCcsIHtcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQjXG4gICAgICogQHBhcmFtIGRhdGFTb3VyY2VcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IGRhdGFTb3VyY2U7XG4gICAgICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkI1xuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgdHJhbnNwb3NlWTogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleC5sZW5ndGggPyB0aGlzLmluZGV4W3ldIDogeTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YUluZGV4OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0RGF0YUluZGV4KHRoaXMudHJhbnNwb3NlWSh5KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZCNcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93KHRoaXMudHJhbnNwb3NlWSh5KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlSW5kZXhlZCNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp8TWl4ZWR9XG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRWYWx1ZSh4LCB0aGlzLnRyYW5zcG9zZVkoeSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNldFZhbHVlKHgsIHRoaXMudHJhbnNwb3NlWSh5KSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQjXG4gICAgICogQHJldHVybnMge051bWJlcnwqfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXgubGVuZ3RoIHx8IHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUluZGV4ZWQjXG4gICAgICovXG4gICAgY2xlYXJJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaW5kZXgubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VJbmRleGVkI1xuICAgICAqIEBwYXJhbSB7ZmlsdGVyUHJlZGljYXRlfSBwcmVkaWNhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICovXG4gICAgYnVpbGRJbmRleDogZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpLFxuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuXG4gICAgICAgIHRoaXMuY2xlYXJJbmRleCgpO1xuXG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlLmNhbGwodGhpcywgciwgdGhpcy5kYXRhU291cmNlLmdldFJvdyhyKSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleC5wdXNoKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbn0pO1xuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9ufSBmaWx0ZXJQcmVkaWNhdGVcbiAqIEBzdW1tYXJ5IEFwcGxpZXMgZmlsdGVyIHRvIGdpdmVuIHJvdy5cbiAqIEB0aGlzIHtEYXRhU291cmNlR2xvYmFsRmlsdGVyfVxuICogQHBhcmFtIHtudWJtZXJ9IHIgLSBSb3cgaW5kZXggb2Ygcm93IGRhdGEgd2l0aGluIHJvd3MgYXJyYXkgYHRoaXMuZGF0YVNvdXJjZS5kYXRhW11gLlxuICogQHBhcmFtIHtvYmplY3R9IHJvd09iamVjdCAtIFJvdyBkYXRhOyBlbGVtZW50IG9mIGB0aGlzLmRhdGFTb3VyY2UuZGF0YVtdYC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSb3cgcXVhbGlmaWVzIChwYXNzZXMgdGhyb3VnaCBmaWx0ZXIpLlxuICovXG5cbi8qKlxuICogVXNlZCBieSB0aGUgc29ydGVycyAoYERhdGFTb3VyY2VTb3J0ZXJgIGFuZCBgRGF0YVNvdXJjZVRyZWV2aWV3U29ydGVyYCkuXG4gKiBAdGhpcyB7ZGF0YVJvd09iamVjdH1cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2x1bW5OYW1lXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuRGF0YVNvdXJjZUluZGV4ZWQudmFsT3JGdW5jID0gZnVuY3Rpb24oY29sdW1uTmFtZSwgY2FsY3VsYXRvcikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHRoaXMpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpc1tjb2x1bW5OYW1lXTtcbiAgICAgICAgY2FsY3VsYXRvciA9ICh0eXBlb2YgcmVzdWx0KVswXSA9PT0gJ2YnICYmIHJlc3VsdCB8fCBjYWxjdWxhdG9yO1xuICAgICAgICBpZiAoY2FsY3VsYXRvcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FsY3VsYXRvci5jYWxsKHRoaXMsIGNvbHVtbk5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VJbmRleGVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YVNvdXJjZUluZGV4ZWQgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VJbmRleGVkJyk7XG52YXIgc3RhYmxlU29ydCA9IHJlcXVpcmUoJy4vdXRpbC9zdGFibGVTb3J0Jyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEYXRhU291cmNlSW5kZXhlZFxuICovXG52YXIgRGF0YVNvdXJjZVNvcnRlciA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZVNvcnRlcicsIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlciNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RpcmVjdGlvbj0xXVxuICAgICAqL1xuICAgIHNvcnRPbjogZnVuY3Rpb24oY29sdW1uSW5kZXgsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgZGF0YVNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZSxcbiAgICAgICAgICAgICBjb2x1bW5TY2hlbWEgPSBkYXRhU291cmNlLnNjaGVtYS5maW5kKGZ1bmN0aW9uKGNvbHVtblNjaGVtYSwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpID09PSBjb2x1bW5JbmRleDtcbiAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNvbHVtbk5hbWUgPSBjb2x1bW5TY2hlbWEgJiYgY29sdW1uU2NoZW1hW1wibmFtZVwiXSxcbiAgICAgICAgICAgIGNhbGN1bGF0b3IgPSBkYXRhU291cmNlLnNjaGVtYVtjb2x1bW5JbmRleF0uY2FsY3VsYXRvcjtcblxuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJJbmRleCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgICAgc3RhYmxlU29ydC5zb3J0KHRoaXMuYnVpbGRJbmRleCgpLCBnZXRWYWx1ZSwgZGlyZWN0aW9uLCAgZGF0YVNvdXJjZS5zY2hlbWFbY29sdW1uSW5kZXhdLnR5cGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUocm93SWR4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YVJvdyA9IGRhdGFTb3VyY2UuZ2V0Um93KHJvd0lkeCk7XG4gICAgICAgICAgICByZXR1cm4gRGF0YVNvdXJjZUluZGV4ZWQudmFsT3JGdW5jLmNhbGwoZGF0YVJvdywgY29sdW1uTmFtZSwgY2FsY3VsYXRvcik7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlU29ydGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YVNvdXJjZUluZGV4ZWQgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VJbmRleGVkJyk7XG52YXIgRGF0YVNvdXJjZVNvcnRlciA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGF0YVNvdXJjZUluZGV4ZWRcbiAqL1xudmFyIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUgPSBEYXRhU291cmNlSW5kZXhlZC5leHRlbmQoJ0RhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSNcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhdmVhdHM6XG4gICAgICAgICAqXG4gICAgICAgICAqIDEuIENvbHVtbnMgc2hvdWxkIGJlIHVuaXF1ZWx5IHJlcHJlc2VudGVkIChpLmUuLCBubyByZXBlYXRzIHdpdGggc2FtZSBjb2x1bW5JbmRleClcbiAgICAgICAgICogMi4gQ29sdW1ucyBzaG91bGQgYmUgYWRkZWQgbG93LSB0byBoaWdoLW9yZGVyIChpLmUuLCBtb3N0IGdyb3VwZWQgY29sdW1ucyBjb21lIGxhc3QpXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvcnRzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtEYXRhU291cmNlfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdCA9IHRoaXMuZGF0YVNvdXJjZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0LmdldFJvdyh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUjXG4gICAgICogQHBhcmFtIGNvbHVtbkluZGV4XG4gICAgICogQHBhcmFtIGRpcmVjdGlvblxuICAgICAqL1xuICAgIHNvcnRPbjogZnVuY3Rpb24oY29sdW1uSW5kZXgsIGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLnNvcnRzLnB1c2goeyBjb2x1bW5JbmRleDogY29sdW1uSW5kZXgsIGRpcmVjdGlvbjogZGlyZWN0aW9uIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlI1xuICAgICAqIEBwYXJhbSB7c29ydGVyRnVuY3Rpb259IFtzb3J0ZXJdIC0gSWYgdW5kZWZpbmVkLCBkZWxldGVzIHNvcnRlci5cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHNvcnRlcikge1xuICAgICAgICBpZiAoc29ydGVyKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBpbXBsZW1lbnRzIHNvcnRlckludGVyZmFjZWlcbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlI1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNvcnRlciA9IHNvcnRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNvcnRlcjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlI1xuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVhY2ggPSB0aGlzLmRhdGFTb3VyY2U7XG4gICAgICAgIC8vIGdldCBsaXN0IG9mIHNvcnRzIGZyb20gZWl0aGVyIEFQSSBvciB1c2UgZXhpc3RpbmdcbiAgICAgICAgdGhpcy5zb3J0cyA9ICh0aGlzLnNvcnRlciAmJiB0aGlzLnNvcnRlci5wcm9wKCdzb3J0cycpKSB8fCB0aGlzLnNvcnRzO1xuXG4gICAgICAgIGlmICh0aGlzLnNvcnRzKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRzLmZvckVhY2goZnVuY3Rpb24oc29ydFNwZWMpIHtcbiAgICAgICAgICAgICAgICBlYWNoID0gbmV3IERhdGFTb3VyY2VTb3J0ZXIoZWFjaCk7XG4gICAgICAgICAgICAgICAgZWFjaC5zb3J0T24oc29ydFNwZWMuY29sdW1uSW5kZXgsIHNvcnRTcGVjLmRpcmVjdGlvbiwgc29ydFNwZWMudHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubGFzdCA9IGVhY2g7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUjXG4gICAgICovXG4gICAgY2xlYXJTb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc29ydHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5kYXRhU291cmNlO1xuICAgIH0sXG5cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdC5nZXREYXRhSW5kZXgoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlI1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0LmdldFZhbHVlKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmxhc3Quc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgIH1cbn0pO1xuXG5EYXRhU291cmNlU29ydGVyQ29tcG9zaXRlLnByb3RvdHlwZS5hcHBseVNvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgKGNvbnNvbGUud2FybiB8fCBjb25zb2xlLmxvZykuY2FsbChjb25zb2xlLCAnYXBwbHlTb3J0cyBkZXByZWNhdGVkOyB1c2UgYXBwbHknKTtcbiAgICB0aGlzLmFwcGx5KCk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZS5wcm90b3R5cGUsICd0eXBlJywgeyB2YWx1ZTogJ3NvcnRlcicgfSk7IC8vIHJlYWQtb25seSBwcm9wZXJ0eVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcblxudmFyIGV4cGFuZGVkTWFwID0ge1xuICAgIHRydWU6ICdcXHUyNWJjJywgLy8gQkxBQ0sgRE9XTi1QT0lOVElORyBUUklBTkdMRSBha2EgJ+KWvCdcbiAgICBmYWxzZTogJ1xcdTI1YjYnLCAvLyBCTEFDSyBSSUdIVC1QT0lOVElORyBUUklBTkdMRSBha2EgJ+KWtidcbiAgICB1bmRlZmluZWQ6ICcnIC8vIGZvciBsZWFmIHJvd3Ncbn07XG5cbi8qKiBAdHlwZWRlZiBjb2x1bW5BZGRyZXNzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIGEgY29sdW1uIGxpc3RlZCBpbiB0aGUgZmllbGRzIGFycmF5LiBTZWUgdGhlIHtAbGluayBEYXRhU291cmNlVHJlZXZpZXcjZ2V0RmllbGRzfGdldEZpZWxkcygpfSBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGNvbHVtbiBpbiB0aGUgZmllbGRzIGFycmF5LiBTZWUgdGhlIHtAbGluayBEYXRhU291cmNlVHJlZXZpZXcjZ2V0RmllbGRzfGdldEZpZWxkcygpfSBtZXRob2QuXG4gKi9cblxuXG4vKipcbiAqIEBjbGFzc2Rlc2MgRm9yIHByb3BlciBzb3J0aW5nLCBpbmNsdWRlIGBEYXRhU291cmNlVHJlZXZpZXdTb3J0ZXJgIGluIHlvdXIgZGF0YSBzb3VyY2UgcGlwZWxpbmUsIF9haGVhZCBvZl8gKGNsb3NlciB0byB0aGUgZGF0YSB0aGFuKSB0aGlzIGRhdGEgc291cmNlLlxuICpcbiAqIEZvciBwcm9wZXIgZmlsdGVyaW5nLCBpbmNsdWRlIGBEYXRhU291cmNlVHJlZXZpZXdGaWx0ZXJgIGluIHlvdXIgZGF0YSBzb3VyY2UgcGlwZWxpbmUsIF9haGVhZCBvZl8gYERhdGFTb3VyY2VUcmVldmlld1NvcnRlcmAsIGlmIGluY2x1ZGVkOyBvciBhdCBhbnkgcmF0ZSBhaGVhZCBvZiB0aGlzIGRhdGEgc291cmNlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZGF0YVNvdXJjZVxuICogQGV4dGVuZHMgRGF0YVNvdXJjZUluZGV4ZWRcbiAqL1xudmFyIERhdGFTb3VyY2VUcmVldmlldyA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZVRyZWV2aWV3Jywge1xuXG4gICAgLyoqIEBzdW1tYXJ5IEluaXRpYWxpemUgYSBuZXcgaW5zdGFuY2UuXG4gICAgICogQGRlc2MgU2V0IHVwIHtAbGluayBEYXRhU291cmNlVHJlZXZpZXdTb3J0ZXJ9IGFjY2VzcyB0byB0aGlzIG9iamVjdC4gQWNjZXNzIGlzIHByb3ZpZGVkIHRvIHRoZSB3aG9sZSBvYmplY3QgYWx0aG91Z2ggb25seSBpbnN0YW5jZSB2YXJpYWJsZXMgYGpvaW5lZGAsIGBpZENvbHVtbmAsIGFuZCBgcGFyZW50SWRDb2x1bW5gIGFyZSBuZWVkZWQgYnkgdGhlIHNvcnRlci4gVGhlIHR3byBJRCBjb2x1bW5zIGFyZSBwYXNzZWQgdG8gdGhlIHtAbGluayBEYXRhU291cmNlRGVwdGhTb3J0ZXJ9IGNvbnN0cnVjdG9yLiAoSWYgZGF0YVNvdXJjZSBpcyBub3QgdGhlIHNvcnRlciwgdGhpcyBpcyBub3QgdXNlZCBidXQgaGFybWxlc3MuKVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGFsbCBhbmNlc3RvciBjbGFzc2VzJyBgaW5pdGlhbGl6ZWAgbWV0aG9kcyBhcmUgY2FsbGVkICh0b3AtZG93bikgYmVmb3JlIHRoaXMgb25lLiBTZWUge0BsaW5rIGh0dHA6Ly9ucG1qcy5vcmcvZXh0ZW5kLW1lfSBmb3IgbW9yZSBpbmZvLlxuICAgICAqIEBwYXJhbSBkYXRhU291cmNlXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VUcmVldmlldyNcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhU291cmNlKSB7XG4gICAgICAgIHdoaWxlIChkYXRhU291cmNlKSB7XG4gICAgICAgICAgICBpZiAoL3RyZWV2aWV3L2kudGVzdChkYXRhU291cmNlLiQkQ0xBU1NfTkFNRSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlLnRyZWV2aWV3ID0gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFTb3VyY2UgPSBkYXRhU291cmNlLmRhdGFTb3VyY2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFJlZmVyZW5jZSB0byB0aGUgcHJpbWFyeSBrZXkgY29sdW1uIGFkZHJlc3Mgb2JqZWN0LlxuICAgICAqIEBkZXNjIFRoZSBwcmltYXJ5IGtleSBjb2x1bW4gdW5pcXVlbHkgaWRlbnRpZmllcyBhIGRhdGEgcm93LlxuICAgICAqIFVzZWQgdG8gcmVsYXRlIGEgY2hpbGQgcm93IHRvIGEgcGFyZW50IHJvdy5cbiAgICAgKlxuICAgICAqIFJlZGVmaW5lZCBlYWNoIHRpbWUgdHJlZS12aWV3IGlzIHR1cm5lZCAqT04qIGJ5IGEgY2FsbCB0byB7QGxpbmsgRGF0YVNvdXJjZVRyZWV2aWV3I3NldFJlbGF0aW9ufHNldFJlbGF0aW9uKCl9LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gaW5kZXhPck5hbWVcbiAgICAgKiBAcmV0dXJucyB7Y29sdW1uQWRkcmVzc30gR2V0dGVyIHJldHVybnMgY29sdW1uIGFkZHJlc3Mgb2JqZWN0OyBzZXR0ZXIgaG93ZXZlciBhbHdheXMgcmV0dXJucyBpdHMgaW5wdXQuXG4gICAgICovXG4gICAgc2V0IGlkQ29sdW1uKGluZGV4T3JOYW1lKSB7XG4gICAgICAgIHRoaXMuX2lkQ29sdW1uID0gdGhpcy5nZXRDb2x1bW5JbmZvKGluZGV4T3JOYW1lIHx8ICdJRCcpO1xuICAgIH0sXG4gICAgZ2V0IGlkQ29sdW1uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWRDb2x1bW47XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBSZWZlcmVuY2UgdG8gdGhlIGZvcmVpZ24ga2V5IGNvbHVtbiBhZGRyZXNzIG9iamVjdC5cbiAgICAgKiBAZGVzYyBUaGUgZm9yZWlnbiBrZXkgY29sdW1uIGRlZmluZXMgZ3JvdXBpbmc7IGl0IHJlbGF0ZXMgdGhpcyB0cmVlIG5vZGUgcm93IHRvIGl0cyBwYXJlbnQgdHJlZSBub2RlIHJvdy4gVG9wLWxldmVsIHRyZWUgbm9kZXMgaGF2ZSBubyBwYXJlbnQuIEluIHRoYXQgY2FzZSB0aGUgdmFsdWUgaW4gdGhlIGNvbHVtbiBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBSZWRlZmluZWQgZWFjaCB0aW1lIHRyZWUtdmlldyBpcyB0dXJuZWQgKk9OKiBieSBhIGNhbGwgdG8ge0BsaW5rIERhdGFTb3VyY2VUcmVldmlldyNzZXRSZWxhdGlvbnxzZXRSZWxhdGlvbigpfS5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGluZGV4T3JOYW1lXG4gICAgICogQHJldHVybnMge2NvbHVtbkFkZHJlc3N9IEdldHRlciByZXR1cm5zIGNvbHVtbiBhZGRyZXNzIG9iamVjdDsgc2V0dGVyIGhvd2V2ZXIgYWx3YXlzIHJldHVybnMgaXRzIGlucHV0LlxuICAgICAqL1xuICAgIHNldCBwYXJlbnRJZENvbHVtbihpbmRleE9yTmFtZSkge1xuICAgICAgICB0aGlzLl9wYXJlbnRJZENvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uSW5mbyhpbmRleE9yTmFtZSB8fCAncGFyZW50SUQnKTtcbiAgICB9LFxuICAgIGdldCBwYXJlbnRJZENvbHVtbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudElkQ29sdW1uO1xuICAgIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgUmVmZXJlbmNlIHRvIHRoZSBkcmlsbC1kb3duIGNvbHVtbiBhZGRyZXNzIG9iamVjdC5cbiAgICAgKiBAZGVzYyBUaGUgZHJpbGwtZG93biBjb2x1bW4gaXMgdGhlIGNvbHVtbiB0aGF0IGlzIGluZGVudGVkIGFuZCBkZWNvcmF0ZWQgd2l0aCBkcmlsbC1kb3duIGNvbnRyb2xzICh0cmlhbmdsZXMpLiBBIGNvbHVtbiB3aXRoIHRoZSBnaXZlbiBpbmRleCBvciBuYW1lIG11c3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBSZWRlZmluZWQgZWFjaCB0aW1lIHRyZWUtdmlldyBpcyB0dXJuZWQgKk9OKiBieSBhIGNhbGwgdG8ge0BsaW5rIERhdGFTb3VyY2VUcmVldmlldyNzZXRSZWxhdGlvbnxzZXRSZWxhdGlvbigpfS5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGluZGV4T3JOYW1lXG4gICAgICogQHJldHVybnMge2NvbHVtbkFkZHJlc3N9IEdldHRlciByZXR1cm5zIGNvbHVtbiBhZGRyZXNzIG9iamVjdDsgc2V0dGVyIGhvd2V2ZXIgYWx3YXlzIHJldHVybnMgaXRzIGlucHV0LlxuICAgICAqL1xuICAgIHNldCB0cmVlQ29sdW1uKGluZGV4T3JOYW1lKSB7XG4gICAgICAgIHRoaXMuX3RyZWVDb2x1bW4gPSB0aGlzLmdldENvbHVtbkluZm8oaW5kZXhPck5hbWUgfHwgJ25hbWUnKTtcbiAgICB9LFxuICAgIGdldCB0cmVlQ29sdW1uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJlZUNvbHVtbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgIC8qKiBAc3VtbWFyeSBSZWZlcmVuY2UgdG8gdGhlIGdyb3VwIG5hbWUgY29sdW1uIGFkZHJlc3Mgb2JqZWN0LlxuICAgICAqIEBkZXNjIFRoZSBncm91cCBuYW1lIGNvbHVtbiBpcyB0aGUgY29sdW1uIHdob3NlIGNvbnRlbnQgZGVzY3JpYmVzIHRoZSBncm91cC4gQSBjb2x1bW4gd2l0aCB0aGUgZ2l2ZW4gaW5kZXggb3IgbmFtZSBtdXN0IGV4aXN0LlxuICAgICAqXG4gICAgICogVGhlIHRyZWV2aWV3IHNvcnRlciB0cmVhdHMgdGhlIGdyb3VwIG5hbWUgY29sdW1uIGRpZmZlcmVudGx5IHRoYW4gb3RoZXIgY29sdW1ucyxcbiAgICAgKiBhcHBseSBhIFwiZ3JvdXAgc29ydFwiIHRvIGl0LCB3aGljaCBtZWFucyBvbmx5IHRoZSBncm91cCByb3dzIChyb3dzIHdpdGggY2hpbGRyZW4pXG4gICAgICogYXJlIHNvcnRlZCBhbmQgdGhlIGxlYXZlcyBhcmUgbGVmdCBhbG9uZSAoc3RhYmxlIHNvcnRlZCkuXG4gICAgICpcbiAgICAgKiBOb3JtYWxseSByZWZlcnMgdG8gdGhlIHNhbWUgY29sdW1uIGFzIHtAbGluayBEYXRhU291cmNlVHJlZXZpZXcjdHJlZUNvbHVtbnx0cmVlQ29sdW1ufS5cbiAgICAgKlxuICAgICAqIFJlZGVmaW5lZCBlYWNoIHRpbWUgdHJlZS12aWV3IGlzIHR1cm5lZCAqT04qIGJ5IGEgY2FsbCB0byB7QGxpbmsgRGF0YVNvdXJjZVRyZWV2aWV3I3NldFJlbGF0aW9ufHNldFJlbGF0aW9uKCl9LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gaW5kZXhPck5hbWVcbiAgICAgKiBAcmV0dXJucyB7Y29sdW1uQWRkcmVzc30gR2V0dGVyIHJldHVybnMgY29sdW1uIGFkZHJlc3Mgb2JqZWN0OyBzZXR0ZXIgaG93ZXZlciBhbHdheXMgcmV0dXJucyBpdHMgaW5wdXQuXG4gICAgICovXG4gICAgc2V0IGdyb3VwQ29sdW1uKGluZGV4T3JOYW1lKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwQ29sdW1uID0gdGhpcy5nZXRDb2x1bW5JbmZvKGluZGV4T3JOYW1lIHx8IHRoaXMuX3RyZWVDb2x1bW4ubmFtZSk7XG4gICAgfSxcbiAgICBnZXQgZ3JvdXBDb2x1bW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cENvbHVtbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVEVNUE9SQVJZLiBUaGlzIGZ1bmN0aW9uIGluY2x1ZGVkIGhlcmUgdW50aWwgbmV4dCB2ZXJzaW9uIG9mIGJhc2UgaXMgcHVibGlzaGVkLlxuICAgICAqIFRoZSBjaGFuZ2Ugd2FzIHRvIHVzZSBzY2hlbWEgcmF0aGVyIHRoYW4gZ2V0RmllbGRzKCkuXG4gICAgICogKFRoZSBjdXJyZW50IHZlcnNpb24gaW4gYmFzZSBpcyBub3QgaW4gdXNlIGJlY2F1c2UgaXQncyBvbmx5IHVzZWQgZnJvbSBoZXJlLilcbiAgICAgKlxuICAgICAqIEdldCBuZXcgb2JqZWN0IHdpdGggbmFtZSBhbmQgaW5kZXggZ2l2ZW4gdGhlIG5hbWUgb3IgdGhlIGluZGV4LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY29sdW1uT3JJbmRleCAtIENvbHVtbiBuYW1lIG9yIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHt7bmFtZTogc3RyaW5nLCBpbmRleDogbnVtYmVyfX1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5JbmZvOiBmdW5jdGlvbihjb2x1bW5PckluZGV4KSB7XG4gICAgICAgIHZhciBuYW1lLCBpbmRleCwgcmVzdWx0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29sdW1uT3JJbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGluZGV4ID0gY29sdW1uT3JJbmRleDtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLnNjaGVtYVtpbmRleF0ubmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBjb2x1bW5PckluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLnNjaGVtYS5maW5kSW5kZXgoZnVuY3Rpb24oY29sdW1uU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtblNjaGVtYS5uYW1lID09PSBuYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSAmJiBpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUb2dnbGUgdGhlIHRyZWUtdmlldy5cbiAgICAgKiBAZGVzYyBDYWxjdWxhdGVzIG9yIHJlY2FsY3VsYXRlcyBuZXN0aW5nIGRlcHRoIG9mIGVhY2ggcm93IGFuZCBtYXJrcyBpdCBhcyBcImV4cGFuZGFibGVcIiBpZmYgaXQgaGFzIGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogSWYgcmVzZXR0aW5nIHByZXZpb3VzbHkgc2V0IGRhdGEsIHRoZSBzdGF0ZSBvZiBleHBhbnNpb24gb2YgYWxsIHJvd3MgdGhhdCBzdGlsbCBoYXZlIGNoaWxkcmVuIGlzIHJldGFpbmVkLiAoQWxsIGV4cGFuZGVkIHJvd3Mgd2lsbCBzdGlsbCBiZSBleHBhbmRlZCB3aGVuIHRyZWUtdmlldyBpcyB0dXJuZWQgYmFjayAqT04qLilcbiAgICAgKlxuICAgICAqIEFsbCBvZiB0aGUgY29sdW1ucyByZWZlcmVuY2VkIGJ5IHRoZSBgb3B0aW9uc2AgcHJvcGVydGllcyBgaWRDb2x1bW5gLCBgcGFyZW50SWRDb2x1bW5gLCBgdHJlZUNvbHVtbmAsIGFuZCBgZ3JvdXBDb2x1bW5gIG11c3QgZXhpc3QuIFRoZXNlIGZvdXIgY29sdW1ucyBoYXZlIGRlZmF1bHQgcmVmZXJlbmNlcyAobmFtZXMpIGFzIGxpc3RlZCBiZWxvdy4gVGhlIHJlZmVyZW5jZXMgbWF5IGJlIG92ZXJyaWRkZW4gaW4gYG9wdGlvbnNgIGJ5IHN1cHBseWluZyBhbHRlcm5hdGUgY29sdW1uIG5hbWVzIG9yIGluZGV4ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58b2JqZWN0fSBbb3B0aW9uc10gLSBGYWxzeSB2YWx1ZSAob3Igb21pdHRlZCkgdHVybnMgdHJlZS12aWV3ICoqT0ZGKiouIFRydXRoeSB2YWx1ZSB0dXJucyB0cmVlLXZpZXcgKipPTioqIHVzaW5nIGZvbGxvd2luZyBvcHRpb25zOlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdGlvbnMuaWRDb2x1bW49J0lEJ10gLSBOYW1lIG9yIGluZGV4IG9mIHRoZSBwcmltYXJ5IGtleSBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0aW9ucy5wYXJlbnRJZENvbHVtbj0ncGFyZW50SUQnXSAtIE5hbWUgb3IgaW5kZXggb2YgdGhlIGZvcmVpZ24ga2V5IGNvbHVtbiBmb3IgZ3JvdXBpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0aW9ucy50cmVlQ29sdW1uPSduYW1lJ10gLSBOYW1lIG9yIGluZGV4IG9mIHRoZSBkcmlsbC1kb3duIGNvbHVtbiB0byBkZWNvcmF0ZSB3aXRoIHRyaWFuZ2xlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRpb25zLmdyb3VwQ29sdW1uPXRoaXMuX3RyZWVDb2x1bW4ubmFtZV0gLSBOYW1lIG9yIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCBjb250YWlucyB0aGUgZ3JvdXAgbmFtZXMuIFRoaXMgaXMgbm9ybWFsbHkgdGhlIHNhbWUgYXMgdGhlIGRyaWxsLWRvd24gY29sdW1uLiBZb3Ugb25seSBuZWVkIHRvIHNwZWNpZnkgYSBkaWZmZXJlbnQgdmFsdWUgd2hlbiB5b3Ugd2FudCB0aGUgZHJpbGwgZG93biB0byB0aGlzIGNvbHVtbiwgc3VjaCBhcyB3aGVuIHRoZSBkcmlsbC1kb3duIGlzIGluIGEgY29sdW1uIG9mIGl0cyBvd24uIFNlZSB7QGxpbmsgaHR0cDovL29wZW5maW4uZ2l0aHViLmlvL2Zpbi1oeXBlcmdyaWQvdHJlZS12aWV3LXNlcGFyYXRlLWRyaWxsLWRvd24uaHRtbH0gZm9yIGFuIGV4YW1wbGUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IEpvaW5lZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlVHJlZXZpZXcjXG4gICAgICovXG4gICAgc2V0UmVsYXRpb246IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHIsIHBhcmVudElELCBkZXB0aCwgbGVhZlJvdywgcm93LCBJRDtcblxuICAgICAgICAvLyBzdWNjZXNzZnVsIGpvaW4gcmVxdWlyZXMgdGhhdCBvcHRpb25zIG9iamVjdCBiZSBnaXZlbiBhbmQgdGhhdCBhbGwgY29sdW1ucyBleGlzdFxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5pZENvbHVtbiA9IG9wdGlvbnMuaWRDb2x1bW47XG4gICAgICAgICAgICB0aGlzLnBhcmVudElkQ29sdW1uID0gb3B0aW9ucy5wYXJlbnRJZENvbHVtbjtcbiAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbiA9IG9wdGlvbnMudHJlZUNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBDb2x1bW4gPSBvcHRpb25zLmdyb3VwQ29sdW1uO1xuICAgICAgICAgICAgdGhpcy5qb2luZWQgPSAhISh0aGlzLmlkQ29sdW1uICYmIHRoaXMucGFyZW50SWRDb2x1bW4gJiYgdGhpcy50cmVlQ29sdW1uICYmIHRoaXMuZ3JvdXBDb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5idWlsZEluZGV4KCk7IC8vIG1ha2UgYWxsIHJvd3MgdmlzaWJsZSB0byBnZXRSb3coKVxuXG4gICAgICAgIHIgPSB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgIGlmICh0aGlzLmpvaW5lZCkge1xuICAgICAgICAgICAgLy8gbXV0YXRlIGRhdGEgcm93IHdpdGggX19ERVBUSCAoYWxsIHJvd3MpIGFuZCBfX0VYUEFOREVEIChhbGwgXCJwYXJlbnRcIiByb3dzKVxuICAgICAgICAgICAgdmFyIGlkQ29sdW1uTmFtZSA9IHRoaXMuaWRDb2x1bW4ubmFtZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRJZENvbHVtbk5hbWUgPSB0aGlzLnBhcmVudElkQ29sdW1uLm5hbWU7XG5cbiAgICAgICAgICAgIHRoaXMubWF4RGVwdGggPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSAoci0tKSB7XG4gICAgICAgICAgICAgICAgZGVwdGggPSAwO1xuICAgICAgICAgICAgICAgIGxlYWZSb3cgPSB0aGlzLmdldFJvdyhyKTtcbiAgICAgICAgICAgICAgICByb3cgPSBsZWFmUm93O1xuICAgICAgICAgICAgICAgIElEID0gcm93W2lkQ29sdW1uTmFtZV07XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoKHBhcmVudElEID0gcm93W3BhcmVudElkQ29sdW1uTmFtZV0pICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gdGhpcy5maW5kUm93KGlkQ29sdW1uTmFtZSwgcGFyZW50SUQpO1xuICAgICAgICAgICAgICAgICAgICArK2RlcHRoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heERlcHRoIDwgZGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXhEZXB0aCA9IGRlcHRoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxlYWZSb3cuX19ERVBUSCA9IGRlcHRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbmRSb3cocGFyZW50SWRDb2x1bW5OYW1lLCBJRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxlYWZSb3cuX19FWFBBTkRFRDsgLy8gbm8gbG9uZ2VyIGV4cGFuZGFibGVcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlYWZSb3cuX19FWFBBTkRFRCA9PT0gdW5kZWZpbmVkKSB7IC8vIHJldGFpbiBwcmV2aW91cyBzZXR0aW5nIGZvciBvbGQgcm93c1xuICAgICAgICAgICAgICAgICAgICBsZWFmUm93Ll9fRVhQQU5ERUQgPSBmYWxzZTsgLy8gZGVmYXVsdCBmb3IgbmV3IHJvdyBpcyB1bmV4cGFuZGVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmxhdHRlbiB0aGUgdHJlZSBzbyBncm91cCBzb3J0ZXIgc2VlcyBpdCBhcyBhIHNpbmdsZSBncm91cFxuICAgICAgICAgICAgd2hpbGUgKHItLSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Um93KHIpLl9fREVQVEggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbG9vayBmb3IgRGF0YVNvdXJjZVRyZWV2aWV3RmlsdGVyXG5cbiAgICAgICAgcmV0dXJuIHRoaXMuam9pbmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZWJ1aWxkIHRoZSBpbmRleC5cbiAgICAgKiBAZGVzYyBSZWJ1aWxkIHRoZSBpbmRleCB0byBzaG93IG9ubHkgXCJyZXZlYWxlZFwiIHJvd3MuIChSb3dzIHRoYXQgYXJlIG5vdCBpbnNpZGUgYSBjb2xsYXBzZWQgcGFyZW50IG5vZGUgcm93LilcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVRyZWV2aWV3I1xuICAgICAqL1xuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJJbmRleCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWlsZEluZGV4KHRoaXMuam9pbmVkICYmIHJvd0lzUmV2ZWFsZWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgY2VsbC5cbiAgICAgKiBAZGVzYyBJbnRlcmNlcHRzIHRyZWUgY29sdW1uIHZhbHVlcyBhbmQgaW5kZW50cyBhbmQgZGVjb3JhdGVzIHRoZW0uXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlVHJlZXZpZXcjXG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gRGF0YVNvdXJjZUluZGV4ZWQucHJvdG90eXBlLmdldFZhbHVlLmNhbGwodGhpcywgeCwgeSk7XG5cbiAgICAgICAgaWYgKHRoaXMudmlld01ha2VzU2Vuc2UoKSAmJiB4ID09PSB0aGlzLl90cmVlQ29sdW1uLmluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGhpcy5nZXRSb3coeSk7XG5cbiAgICAgICAgICAgIGlmICghKHZhbHVlID09PSAnJyAmJiByb3cuX19FWFBBTkRFRCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gQXJyYXkocm93Ll9fREVQVEggKyAxKS5qb2luKCcgICAnKSArIGV4cGFuZGVkTWFwW3Jvdy5fX0VYUEFOREVEXSArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICB2aWV3TWFrZXNTZW5zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpvaW5lZDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlVHJlZXZpZXcjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0RyaWxsRG93bjogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudmlld01ha2VzU2Vuc2UoKTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBjb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29sdW1uSW5kZXggPT09IHRoaXMudHJlZUNvbHVtbkluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEhhbmRsZSBhIGNsaWNrIGV2ZW50IGluIHRoZSBkcmlsbC1kb3duIGNvbHVtbi5cbiAgICAgKiBAZGVzYyBPcGVyYXRlcyBvbmx5IG9uIHRoZSBmb2xsb3dpbmcgcm93czpcbiAgICAgKiAqIEV4cGFuZGFibGUgcm93cyAtIFJvd3Mgd2l0aCBhIGRyaWxsLWRvd24gY29udHJvbC5cbiAgICAgKiAqIFJldmVhbGVkIHJvd3MgLSBSb3dzIG5vdCBoaWRkZW4gaW5zaWRlIG9mIGNvbGxhcHNlZCBkcmlsbC1kb3ducy5cbiAgICAgKiBAcGFyYW0geSAtIFJldmVhbGVkIHJvdyBudW1iZXIuIChUaGlzIGlzIG5vdCB0aGUgcm93IElELilcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBhbmRdIC0gT25lIG9mOlxuICAgICAqICogYHRydWVgIC0gRXhwYW5kIGFsbCByb3dzIHRoYXQgYXJlIGN1cnJlbnRseSBjb2xsYXBzZWQuXG4gICAgICogKiBgZmFsc2VgIC0gQ29sbGFwc2UgYWxsIHJvd3MgdGhhdCBhcmUgY3VycmVudGx5IGV4cGFuZGVkLlxuICAgICAqICogYHVuZGVmaW5lZGAgKG9yIG9taXR0ZWQpIC0gRXhwYW5kIGFsbCBjdXJyZW50bHkgY29sbGFwc2VkIHJvd3M7IGNvbGxhcHNlIGFsbCBjdXJyZW50bHkgZXhwYW5kZWQgcm93cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPUluZmluaXR5XSAtIE9uZSBvZjpcbiAgICAgKiAqIG51bWJlciA+IDAgLSBBcHBseSBvbmx5IGlmIHJvdyBkZXB0aCBpcyBhYm92ZSB0aGUgZ2l2ZW4gZGVwdGguXG4gICAgICogKiBudW1iZXIgPD0gMCAtIEFwcGx5IG9ubHkgaWYgcm93IGRlcHRoIGlzIGJlbG93IHRoZSBnaXZlbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IE9uZSBvZjpcbiAgICAgKiAqIGB1bmRlZmluZWRgIC0gUm93IHdhcyBub3QgZXhwYW5kYWJsZS5cbiAgICAgKiAqIGB0cnVlYCAtIFJvdyBoYWQgZHJpbGwtZG93biBfYW5kXyBzdGF0ZSBjaGFuZ2VkLlxuICAgICAqICogYGZhbHNlYCAtIFJvdyBoYWQgZHJpbGwtZG93biBfYnV0XyBzdGF0ZSBkaWQgX25vdF8gY2hhbmdlLlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlVHJlZXZpZXcjXG4gICAgICovXG4gICAgY2xpY2s6IGZ1bmN0aW9uKHksIGV4cGFuZCwgZGVwdGgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuY2xpY2suYXBwbHkodGhpcy5kYXRhU291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYW5nZWQsIHJvdyA9IHRoaXMuZ2V0Um93KHkpO1xuICAgICAgICBpZiAocm93ICYmIHJvdy5fX0VYUEFOREVEICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChkZXB0aCAhPT0gdW5kZWZpbmVkICYmIChcbiAgICAgICAgICAgICAgICBkZXB0aCA+IDAgJiYgcm93Ll9fREVQVEggPj0gZGVwdGggfHxcbiAgICAgICAgICAgICAgICBkZXB0aCA8PSAwICYmIHJvdy5fX0RFUFRIIDwgLWRlcHRoXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwYW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kID0gIXJvdy5fX0VYUEFOREVEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gcm93Ll9fRVhQQU5ERUQgJiYgIWV4cGFuZCB8fCAhcm93Ll9fRVhQQU5ERUQgJiYgZXhwYW5kO1xuICAgICAgICAgICAgICAgIHJvdy5fX0VYUEFOREVEID0gZXhwYW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBFeHBhbmQgbmVzdGVkIGRyaWxsLWRvd25zIGNvbnRhaW5pbmcgdGhpcyByb3cuXG4gICAgICogQHBhcmFtIElEIC0gVGhlIHVuaXF1ZSByb3cgSUQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IElmIGFueSByb3dzIGV4cGFuZGVkLlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlVHJlZXZpZXcjXG4gICAgICovXG4gICAgcmV2ZWFsUm93OiBmdW5jdGlvbihJRCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5yZXZlYWxSb3cuYXBwbHkodGhpcy5kYXRhU291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvdywgcGFyZW50LCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICgocm93ID0gdGhpcy5maW5kUm93KHRoaXMuX2lkQ29sdW1uLm5hbWUsIElEKSkpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcm93Ll9fRVhQQU5ERUQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcm93Ll9fRVhQQU5ERUQgPSBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHRydWU7XG4gICAgICAgICAgICBJRCA9IHJvd1t0aGlzLl9wYXJlbnRJZENvbHVtbi5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gcm93SXNSZXZlYWxlZChyLCByb3cpIHtcbiAgICB2YXIgcGFyZW50SUQ7XG5cbiAgICAvLyBhcmUgYW55IG9mIHRoZSByb3cncyBhbmNlc3RvcnMgY29sbGFwc2VkP1xuICAgIHdoaWxlICgocGFyZW50SUQgPSByb3dbdGhpcy5fcGFyZW50SWRDb2x1bW4ubmFtZV0pICE9IG51bGwpIHtcbiAgICAgICAgLy8gd2FsayB1cCB0aHJvdWdoIGVhY2ggcGFyZW50Li4uXG4gICAgICAgIHJvdyA9IHRoaXMuZmluZFJvdyh0aGlzLl9pZENvbHVtbi5uYW1lLCBwYXJlbnRJRCk7XG4gICAgICAgIGlmIChyb3cuX19FWFBBTkRFRCA9PT0gZmFsc2UpIHsgLy8gYW4gYW5jZXN0b3IgaXMgY29sbGFwc2VkXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGV4Y2x1ZGUgcm93IGZyb20gYnVpbGRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vIGFuY2VzdG9ycyB3ZXJlIGNvbGxhcHNlZFxuICAgIHJldHVybiB0cnVlOyAvLyBpbmNsdWRlIHJvdyBpbiBidWlsZFxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVNvdXJjZVRyZWV2aWV3LnByb3RvdHlwZSwgJ3R5cGUnLCB7IHZhbHVlOiAndHJlZXZpZXdlcicgfSk7IC8vIHJlYWQtb25seSBwcm9wZXJ0eVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VUcmVldmlldztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VHbG9iYWxGaWx0ZXInKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFNob3VsZCBiZSBwb3NpdGlvbmVkIGluIHRoZSBkYXRhIHNvdXJjZSBwaXBlbGluZSBfYWhlYWQgb2ZfIChjbG9zZXIgdG8gdGhlIGRhdGEgdGhhbikgdGhlIG9wdGlvbmFsIGBEYXRhU291cmNlVHJlZXZpZXdTb3J0ZXJgIGFuZCB0aGUgcmVxdWlyZWQgYERhdGFTb3VyY2VUcmVldmlld2AgKHdoaWNoIHNldHMgYHRoaXMudHJlZXZpZXdgKS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGRhdGFTb3VyY2VcbiAqIEBleHRlbmRzIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGVcbiAqIEBleHRlbmRzIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXJcbiAqL1xudmFyIERhdGFTb3VyY2VUcmVldmlld0ZpbHRlciA9IERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIuZXh0ZW5kKCdEYXRhU291cmNlVHJlZXZpZXdGaWx0ZXInLCB7XG5cbiAgICAvKipcbiAgICAgKiBAaW1wbGVtZW50cyBmaWx0ZXJQcmVkaWNhdGVcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZUdsb2JhbEZpbHRlciNcbiAgICAgKi9cbiAgICBmaWx0ZXJUZXN0OiBmdW5jdGlvbihyLCByb3dPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZXZpZXcudmlld01ha2VzU2Vuc2UoKSAmJiByb3dPYmplY3QuX19FWFBBTkRFRCAhPT0gdW5kZWZpbmVkIHx8IHRoaXMuZmlsdGVyLnRlc3Qocm93T2JqZWN0KTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VUcmVldmlld0ZpbHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUnKTtcbnZhciBEYXRhU291cmNlRGVwdGhTb3J0ZXIgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VEZXB0aFNvcnRlcicpO1xudmFyIERhdGFTb3VyY2VTb3J0ZXIgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VTb3J0ZXInKTtcblxuLyoqXG4gKiBAY2xhc3NkZXNjIFNob3VsZCBiZSBwb3NpdGlvbmVkIGluIHRoZSBkYXRhIHNvdXJjZSBwaXBlbGluZSBfYWhlYWQgb2ZfIChjbG9zZXIgdG8gdGhlIGRhdGEgdGhhbikgdGhlIHJlcXVpcmVkIGBEYXRhU291cmNlVHJlZXZpZXdgICh3aGljaCBzZXRzIGB0aGlzLnRyZWV2aWV3YCkgYnV0IF9iZWhpbmRfIHRoZSBvcHRpb25hbCBgRGF0YVNvdXJjZVRyZWV2aWV3RmlsdGVyYC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGRhdGFTb3VyY2VcbiAqIEBleHRlbmRzIERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGVcbiAqL1xudmFyIERhdGFTb3VyY2VUcmVldmlld1NvcnRlciA9IERhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUuZXh0ZW5kKCdEYXRhU291cmNlVHJlZXZpZXdTb3J0ZXInLCB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZWJ1aWxkIHRoZSBpbmRleC5cbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSNcbiAgICAgKi9cbiAgICBhcHBseTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBqb2luZWQgPSB0aGlzLnRyZWV2aWV3LnZpZXdNYWtlc1NlbnNlKCksXG4gICAgICAgICAgICBlYWNoID0gdGhpcy5kYXRhU291cmNlLFxuICAgICAgICAgICAgbGFzdCwgLy8gbGFzdCBzb3J0IHNwZWMgKFwiZmlyc3RcIiBzb3J0KSB3aGVuIGFuZCBvbmx5IHdoZW4gam9pbmVkIEFORCBpdCBpcyB0aGUgZ3JvdXAgY29sdW1uXG4gICAgICAgICAgICBsYXN0SXNHcm91cCwgY29sdW1uSW5kZXgsIGRpcmVjdGlvbjtcbiAgICAgICAgLy8gZ2V0IGxpc3Qgb2Ygc29ydHMgZnJvbSBlaXRoZXIgQVBJIG9yIHVzZSBleGlzdGluZ1xuICAgICAgICB0aGlzLnNvcnRzID0gKHRoaXMuc29ydGVyICYmIHRoaXMuc29ydGVyLnByb3AoJ3NvcnRzJykpIHx8IHRoaXMuc29ydHM7XG5cbiAgICAgICAgaWYgKHRoaXMuc29ydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoam9pbmVkKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IHRoaXMuc29ydHNbdGhpcy5zb3J0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBsYXN0SXNHcm91cCA9IGxhc3QuY29sdW1uSW5kZXggPT09IHRoaXMudHJlZXZpZXcuZ3JvdXBDb2x1bW4uaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc29ydHMuZm9yRWFjaChmdW5jdGlvbihzb3J0U3BlYykge1xuICAgICAgICAgICAgICAgIGlmICghKGxhc3RJc0dyb3VwICYmIHNvcnRTcGVjID09PSBsYXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBlYWNoID0gbmV3IERhdGFTb3VyY2VTb3J0ZXIoZWFjaCk7XG4gICAgICAgICAgICAgICAgICAgIGVhY2guc29ydE9uKHNvcnRTcGVjLmNvbHVtbkluZGV4LCBzb3J0U3BlYy5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGpvaW5lZCkge1xuICAgICAgICAgICAgaWYgKGxhc3RJc0dyb3VwIHx8IHRoaXMuc29ydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uSW5kZXggPSBsYXN0LmNvbHVtbkluZGV4O1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5hbGx5LCBhcHBseSBhIFwiZGVwdGggc29ydFwiIHRvIGVpdGhlciB0aGUgZ3JvdXAgY29sdW1uIChpZiBsYXN0KSBvciB0aGUgSUQgY29sdW1uIHRvIGdyb3VwIGl0IHByb3Blcmx5XG4gICAgICAgICAgICBmb3IgKHZhciBkZXB0aCA9IHRoaXMudHJlZXZpZXcubWF4RGVwdGg7IGRlcHRoID49IDA7IC0tZGVwdGgpIHtcbiAgICAgICAgICAgICAgICBlYWNoID0gbmV3IERhdGFTb3VyY2VEZXB0aFNvcnRlcihlYWNoLCB0aGlzLnRyZWV2aWV3KTtcbiAgICAgICAgICAgICAgICBlYWNoLnNvcnRPbihkZXB0aCwgZGlyZWN0aW9uLCBjb2x1bW5JbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3QgPSBlYWNoO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNvdXJjZVRyZWV2aWV3U29ydGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYXBweSgpIHtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB0aGlzLnZhbHVlcyA9IFtdO1xufVxuXG5NYXBweS5wcm90b3R5cGUgPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogTWFwcHkucHJvdG90eXBlLmNvbnN0cnVjdG9yLCAvLyBwcmVzZXJ2ZSBjb25zdHJ1Y3RvclxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE1hcHB5I1xuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGhhc2hDb2RlID0gaGFzaChrZXkpO1xuICAgICAgICBpZiAoIShoYXNoQ29kZSBpbiB0aGlzLmRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhW2hhc2hDb2RlXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTWFwcHkjXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBoYXNoQ29kZSA9IGhhc2goa2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtoYXNoQ29kZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIE1hcHB5I1xuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpZlVuZGVmaW5lZEZ1bmMgLSBWYWx1ZSBnZXR0ZXIgd2hlbiB2YWx1ZSBpcyBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldElmVW5kZWZpbmVkOiBmdW5jdGlvbihrZXksIGlmVW5kZWZpbmVkRnVuYykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChrZXkpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBpZlVuZGVmaW5lZEZ1bmMoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTWFwcHkjXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmtleXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweSNcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICovXG4gICAgZGVsZXRlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGhhc2hDb2RlID0gaGFzaChrZXkpO1xuICAgICAgICBpZiAodGhpcy5kYXRhW2hhc2hDb2RlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBiZXR0ZXJJbmRleE9mKHRoaXMua2V5cywga2V5KTtcbiAgICAgICAgICAgIHRoaXMua2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFbaGFzaENvZGVdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweSNcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZVxuICAgICAqL1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0ZWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzLFxuICAgICAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlbGYuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZWUodmFsdWUsIGtleSwgc2VsZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgTWFwcHkjXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWVcbiAgICAgKiBAcmV0dXJucyB7TWFwcHl9XG4gICAgICovXG4gICAgbWFwOiBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5cyxcbiAgICAgICAgICAgIG5ld01hcCA9IG5ldyBNYXBweSgpLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCEodHlwZW9mIGl0ZXJhdGVlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgaXRlcmF0ZWUgPSByZWZsZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZi5nZXQoa2V5KSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZCA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIHNlbGYpO1xuICAgICAgICAgICAgbmV3TWFwLnNldChrZXksIHRyYW5zZm9ybWVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdNYXA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBNYXBweSNcbiAgICAgKiBAcmV0dXJucyB7TWFwcHl9XG4gICAgICovXG4gICAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzLFxuICAgICAgICAgICAgbmV3TWFwID0gbmV3IE1hcHB5KCksXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZi5nZXQoa2V5KTtcbiAgICAgICAgICAgIG5ld01hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3TWFwO1xuICAgIH1cblxufTtcblxudmFyIE9JRF9QUkVGSVggPSAnLn4uIyVfJzsgLy90aGlzIHNob3VsZCBiZSBzb21ldGhpbmcgd2UgbmV2ZXIgd2lsbCBzZWUgYXQgdGhlIGJlZ2lubmluZyBvZiBhIHN0cmluZ1xudmFyIGNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBoYXNoKGtleSkge1xuICAgIHZhciB0eXBlT2YgPSB0eXBlb2Yga2V5O1xuXG4gICAgc3dpdGNoICh0eXBlT2YpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICByZXR1cm4gT0lEX1BSRUZJWCArIHR5cGVPZiArICdfJyArIGtleTtcblxuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgcmV0dXJuICdVTkRFRklORUQnO1xuXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOVUxMJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaCB3aGVuIG5vdCBudWxsOlxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gKGtleS5fX19maW5oYXNoID0ga2V5Ll9fX2Zpbmhhc2ggfHwgT0lEX1BSRUZJWCArIGNvdW50ZXIrKyk7XG4gICAgfVxufVxuXG4vLyBPYmplY3QuaXMgcG9seWZpbGwsIGNvdXJ0ZXN5IG9mIEBXZWJSZWZsZWN0aW9uXG52YXIgaXMgPSBPYmplY3QuaXMgfHwgZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhID09PSBiID8gYSAhPT0gMCB8fCAxIC8gYSA9PSAxIC8gYiA6IGEgIT0gYSAmJiBiICE9IGI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG59O1xuXG5mdW5jdGlvbiByZWZsZWN0aW9uKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG59XG5cbi8vIE1vcmUgcmVsaWFibGUgaW5kZXhPZiwgY291cnRlc3kgb2YgQFdlYlJlZmxlY3Rpb25cbmZ1bmN0aW9uIGJldHRlckluZGV4T2YoYXJyLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICB2YXIgaSA9IGFyci5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0gJiYgIWlzKGFycltpXSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpID0gW10uaW5kZXhPZi5jYWxsKGFyciwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNYXBweTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbW9kdWxlIGFnZ3JlZ2F0aW9uc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9ufSBhZ2dyZWdhdGlvbkZ1bmN0aW9uXG4gKiBAc3VtbWFyeSBBIGJvdW5kIGZ1bmN0aW9uLlxuICogQGRlc2MgQW4gYWdncmVnYXRpb24gZnVuY3Rpb24gYm91bmQgdG8gdGhlIGBjb2x1bW5JbmRleGAgdmFsdWUgc3VwcGxpZWQgdG8gb25lIG9mIHRoZSBhYm92ZSBmYWN0b3J5IGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBncm91cFxuICogQHJldHVybnMgeyp9IEFnZ3JlZ2F0ZWQgdmFsdWUuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMge2FnZ3JlZ2F0aW9uRnVuY3Rpb259IEJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNvdW50OiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdW06IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBzdW0uYmluZCh0aGlzLCBjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBtaW46IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBtaW5tYXguYmluZCh0aGlzLCBjb2x1bW5JbmRleCwgTWF0aC5taW4sIEluZmluaXR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMge2FnZ3JlZ2F0aW9uRnVuY3Rpb259IEJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG1heDogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1pbm1heC5iaW5kKHRoaXMsIGNvbHVtbkluZGV4LCBNYXRoLm1heCwgLUluZmluaXR5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMge2FnZ3JlZ2F0aW9uRnVuY3Rpb259IEJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGF2ZzogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGF2Zy5iaW5kKHRoaXMsIGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMge2FnZ3JlZ2F0aW9uRnVuY3Rpb259IEJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZpcnN0OiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gZmlyc3QuYmluZCh0aGlzLCBjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleFxuICAgICAqIEByZXR1cm5zIHthZ2dyZWdhdGlvbkZ1bmN0aW9ufSBCb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBsYXN0OiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gbGFzdC5iaW5kKHRoaXMsIGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4XG4gICAgICogQHJldHVybnMge2FnZ3JlZ2F0aW9uRnVuY3Rpb259IEJvdW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0ZGRldjogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHN0ZGRldi5iaW5kKHRoaXMsIGNvbHVtbkluZGV4KTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjb3VudChncm91cCkge1xuICAgIHJldHVybiBncm91cC5nZXRSb3dDb3VudCgpO1xufVxuXG5mdW5jdGlvbiBzdW0oY29sdW1uSW5kZXgsIGdyb3VwKSB7XG4gICAgdmFyIHIgPSBncm91cC5nZXRSb3dDb3VudCgpLFxuICAgICAgICBuID0gMDtcblxuICAgIHdoaWxlIChyLS0pIHtcbiAgICAgICAgbiArPSBncm91cC5nZXRWYWx1ZShjb2x1bW5JbmRleCwgcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIG1pbm1heChjb2x1bW5JbmRleCwgbWV0aG9kLCBuLCBncm91cCkge1xuICAgIHZhciByID0gZ3JvdXAuZ2V0Um93Q291bnQoKTtcblxuICAgIHdoaWxlIChyLS0pIHtcbiAgICAgICAgbiA9IG1ldGhvZChuLCBncm91cC5nZXRWYWx1ZShjb2x1bW5JbmRleCwgcikpO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBhdmcoY29sdW1uSW5kZXgsIGdyb3VwKSB7XG4gICAgcmV0dXJuIHN1bShjb2x1bW5JbmRleCwgZ3JvdXApIC8gZ3JvdXAuZ2V0Um93Q291bnQoKTtcbn1cblxuZnVuY3Rpb24gZmlyc3QoY29sdW1uSW5kZXgsIGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLmdldFZhbHVlKGNvbHVtbkluZGV4LCAwKTtcbn1cblxuZnVuY3Rpb24gbGFzdChjb2x1bW5JbmRleCwgZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIGdyb3VwLmdldFJvd0NvdW50KCkgLSAxKTtcbn1cblxuZnVuY3Rpb24gc3RkZGV2KGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHZhciByb3dzID0gZ3JvdXAuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgbWVhbiA9IGF2Zyhjb2x1bW5JbmRleCwgZ3JvdXApO1xuXG4gICAgZm9yICh2YXIgZGV2LCByID0gcm93cywgdmFyaWFuY2UgPSAwOyByLS07IHZhcmlhbmNlICs9IGRldiAqIGRldikge1xuICAgICAgICBkZXYgPSBncm91cC5nZXRWYWx1ZShjb2x1bW5JbmRleCwgcikgLSBtZWFuO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLnNxcnQodmFyaWFuY2UgLyByb3dzKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTk9URTogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBgY2FwaXRhbGl6ZWAgaXMgc3RpbGwgYSBmdW5jdGlvbiwgZG91Ymxpbmcgbm93IGFzIHRoZSBBUEkuXG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuICgvW2Etel0vLnRlc3Qoc3RyaW5nKSA/IHN0cmluZyA6IHN0cmluZy50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAucmVwbGFjZSgvW1xcc1xcLV9dKihbXlxcc1xcLV9dKShbXlxcc1xcLV9dKykvZywgcmVwbGFjZXIpXG4gICAgICAgIC5yZXBsYWNlKC9bQS1aXS9nLCAnICQmJylcbiAgICAgICAgLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZXIoYSwgYiwgYykge1xuICAgIHJldHVybiBiLnRvVXBwZXJDYXNlKCkgKyBjO1xufVxuXG5mdW5jdGlvbiBzZXQobWV0aG9kTmFtZSkge1xuICAgIGNhcGl0YWxpemUudHJhbnNmb3JtID0gY2FwaXRhbGl6ZVttZXRob2ROYW1lXTtcbn1cblxuZnVuY3Rpb24gcGFzc3Rocm91Z2goc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZztcbn1cblxuY2FwaXRhbGl6ZS50cmFuc2Zvcm0gPSBwYXNzdGhyb3VnaDtcbmNhcGl0YWxpemUuc2V0ID0gc2V0O1xuY2FwaXRhbGl6ZS5wYXNzdGhyb3VnaCA9IHBhc3N0aHJvdWdoO1xuY2FwaXRhbGl6ZS5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBjYXBpdGFsaXplO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE5vdGUgdGhhdCB7QGxpbmsgbW9kdWxlOnN0YWJsZVNvcnQjc29ydHxzb3J0KCl9IGlzIHRoZSBvbmx5IGV4cG9zZWQgbWV0aG9kLlxuICogQG1vZHVsZSBzdGFibGVTb3J0XG4gKi9cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRlc2NlbmRpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGFycjFcbiAqIEBwYXJhbSB7QXJyYXl9IGFycjJcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gc3RhYmlsaXplKGNvbXBhcmF0b3IsIGRlc2NlbmRpbmcsIGFycjEsIGFycjIpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zaGFkb3dcbiAgICB2YXIgeCA9IGFycjFbMF07XG4gICAgdmFyIHkgPSBhcnIyWzBdO1xuXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgeCA9IGRlc2NlbmRpbmcgPyBhcnIyWzFdIDogYXJyMVsxXTtcbiAgICAgICAgeSA9IGRlc2NlbmRpbmcgPyBhcnIxWzFdIDogYXJyMlsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb21wYXJhdG9yKHgsIHkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gYXNjZW5kaW5nTnVtYmVycyh4LCB5KSB7XG4gICAgcmV0dXJuIHggLSB5O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGVzY2VuZGluZ051bWJlcnMoeCwgeSkge1xuICAgIHJldHVybiB5IC0geDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGFzY2VuZGluZ0FsbE90aGVycyh4LCB5KSB7XG4gICAgcmV0dXJuIHggPCB5ID8gLTEgOiAxO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0geVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZGVzY2VuZGluZ0FsbE90aGVycyh4LCB5KSB7XG4gICAgcmV0dXJuIHkgPCB4ID8gLTEgOiAxO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB0eXBlT2ZEYXRhXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24odGhpczphc2NlbmRpbmcpfVxuICovXG5mdW5jdGlvbiBhc2NlbmRpbmcodHlwZU9mRGF0YSkge1xuICAgIHJldHVybiBzdGFiaWxpemUuYmluZCh0aGlzLCB0eXBlT2ZEYXRhID09PSAnbnVtYmVyJyA/IGFzY2VuZGluZ051bWJlcnMgOiBhc2NlbmRpbmdBbGxPdGhlcnMsIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0gdHlwZU9mRGF0YVxuICogQHJldHVybnMge2Z1bmN0aW9uKHRoaXM6ZGVzY2VuZGluZyl9XG4gKi9cbmZ1bmN0aW9uIGRlc2NlbmRpbmcodHlwZU9mRGF0YSkge1xuICAgIHJldHVybiBzdGFiaWxpemUuYmluZCh0aGlzLCB0eXBlT2ZEYXRhID09PSAnbnVtYmVyJyA/IGRlc2NlbmRpbmdOdW1iZXJzIDogZGVzY2VuZGluZ0FsbE90aGVycywgdHJ1ZSk7XG59XG5cbi8qKlxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldFZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW2RpcmVjdGlvbj0xXVxuICovXG5mdW5jdGlvbiBzb3J0KGluZGV4LCBnZXRWYWx1ZSwgZGlyZWN0aW9uLCB0eXBlKSB7XG5cbiAgICB2YXIgY29tcGFyZSwgaTtcblxuICAgIC8vIGFwcGx5IGRlZmF1bHRzXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4Lmxlbmd0aCkgeyAvLyBzb21ldGhpbmcgdG8gZG9cbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGJhaWw6IG5vdGhpbmcgdG8gc29ydFxuXG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IDE7XG4gICAgICAgICAgICBjYXNlIDE6ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgY29tcGFyZSA9IGFzY2VuZGluZyh0eXBlIHx8IHR5cGVvZiBnZXRWYWx1ZSgwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgICAgY29tcGFyZSA9IGRlc2NlbmRpbmcodHlwZSB8fCB0eXBlb2YgZ2V0VmFsdWUoMCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBzb3J0Li4uLi5cbiAgICAgICAgdmFyIHRtcCA9IG5ldyBBcnJheShpbmRleC5sZW5ndGgpO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgaW5kZXggZm9yIFwic3RhYmlsaXR5XCJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGluZGV4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0bXBbaV0gPSBbZ2V0VmFsdWUoaSksIGldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG8gdGhlIGFjdHVhbCBzb3J0XG4gICAgICAgIHRtcC5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIC8vIGNvcHkgdGhlIHNvcnRlZCB2YWx1ZXMgaW50byBvdXIgaW5kZXggdmVjdG9yXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5kZXhbaV0gPSB0bXBbaV1bMV07XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0cy5zb3J0ID0gc29ydDtcbiIsIi8vIGxpc3QtZHJhZ29uIG5vZGUgbW9kdWxlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L2xpc3QtZHJhZ29uXG5cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjc3NJbmplY3RvciA9IHJlcXVpcmUoJ2Nzcy1pbmplY3RvcicpO1xudmFyIGZvcm1hdCA9IHJlcXVpcmUoJ3RlbXBsZXgnKTtcblxudmFyIFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFID0gbnVsbDsgIC8vIG51bGwgcmVtb3ZlcyB0aGUgc3R5bGVcblxudmFyIHRyYW5zZm9ybSwgdGltZXIsIHNjcm9sbFZlbG9jaXR5LCBjc3NMaXN0RHJhZ29uO1xuXG4vKiBpbmplY3Q6Y3NzICovXG5jc3NMaXN0RHJhZ29uID0gJ2Rpdi5kcmFnb24tbGlzdHtwb3NpdGlvbjpyZWxhdGl2ZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9ZGl2LmRyYWdvbi1saXN0PmRpdixkaXYuZHJhZ29uLWxpc3Q+dWx7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjB9ZGl2LmRyYWdvbi1saXN0PmRpdnt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDc5NmI7Y29sb3I6I2ZmZjtib3gtc2hhZG93OjAgM3B4IDZweCByZ2JhKDAsMCwwLC4xNiksMCAzcHggNnB4IHJnYmEoMCwwLDAsLjIzKTtvdmVyZmxvdzpoaWRkZW47d2hpdGUtc3BhY2U6bm93cmFwfWRpdi5kcmFnb24tbGlzdD51bHtvdmVyZmxvdy15OmF1dG87Ym90dG9tOjA7bWFyZ2luOjA7cGFkZGluZzowO2JveC1zaGFkb3c6MCAxcHggM3B4IHJnYmEoMCwwLDAsLjEyKSwwIDFweCAycHggcmdiYSgwLDAsMCwuMjQpfWRpdi5kcmFnb24tbGlzdD51bD5saSxsaS5kcmFnb24tcG9we3doaXRlLXNwYWNlOm5vd3JhcDtsaXN0LXN0eWxlLXR5cGU6bm9uZTtib3JkZXI6MCBzb2xpZCAjZjRmNGY0O2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlMGUwZTA7Y3Vyc29yOm1vdmU7dHJhbnNpdGlvbjpib3JkZXItdG9wLXdpZHRoIC4yc31kaXYuZHJhZ29uLWxpc3Q+dWw+bGk6bGFzdC1jaGlsZHtoZWlnaHQ6MDtib3JkZXItYm90dG9tOm5vbmV9bGkuZHJhZ29uLXBvcHtwb3NpdGlvbjpmaXhlZDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyOjFweCBzb2xpZCAjZTBlMGUwO2xlZnQ6MDt0b3A6MDtvdmVyZmxvdy14OmhpZGRlbjtib3gtc2hhZG93OnJnYmEoMCwwLDAsLjE4ODIzNSkgMCAxMHB4IDIwcHgscmdiYSgwLDAsMCwuMjI3NDUxKSAwIDZweCA2cHh9Jztcbi8qIGVuZGluamVjdCAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvciBMaXN0RHJhZ29uXG4gKlxuICogQGRlc2MgVGhpcyBvYmplY3Qgc2VydmljZXMgYSBzZXQgb2YgaXRlbSBsaXN0cyB0aGF0IGFsbG93IGRyYWdnaW5nIGFuZCBkcm9wcGluZyBpdGVtcyB3aXRoaW4gYW5kIGJldHdlZW4gbGlzdHMgaW4gYSBzZXQuXG4gKlxuICogVHdvIHN0cmF0ZWdpZXMgYXJlIHN1cHBvcnRlZDpcbiAqXG4gKiAxLiBTdXBwbHkgeW91ciBvd24gSFRNTCBtYXJrdXAgYW5kIGxldCB0aGUgQVBJIGJ1aWxkIHRoZSBpdGVtIG1vZGVscyBmb3IgeW91LlxuICogICAgVG8gdXNlIHRoaXMgc3RyYXRlZ3ksIHNjcmlwdCB5b3VyIEhUTUwgYW5kIHByb3ZpZGUgb25lIG9mIHRoZXNlOlxuICogICAgKiBhbiBhcnJheSBvZiBhbGwgdGhlIGxpc3QgaXRlbSAoYDxsaT5gKSB0YWdzXG4gKiAgICAqIGEgQ1NTIHNlbGVjdG9yIHRoYXQgcG9pbnRzIHRvIGFsbCB0aGUgbGlzdCBpdGVtIHRhZ3NcbiAqIDIuIFN1cHBseSB5b3VyIG93biBpdGVtIG1vZGVscyBhbmQgbGV0IHRoZSBBUEkgYnVpbGQgdGhlIEhUTUwgbWFya3VwIGZvciB5b3UuXG4gKiAgICBUbyB1c2UgdGhpcyBzdHJhdGVneSwgcHJvdmlkZSBhbiBhcnJheSBvZiBtb2RlbCBsaXN0cy5cbiAqXG4gKiBUaGUgbmV3IExpc3REcmFnb24gb2JqZWN0J3MgYG1vZGVsTGlzdHNgIHByb3BlcnR5IHJlZmVyZW5jZXMgdGhlIGFycmF5IG9mIG1vZGVsIGxpc3RzIHRoZSBBUEkgY29uc3RydWN0ZWQgZm9yIHlvdSBpbiBzdHJhdGVneSAjMSBvciB0aGUgYXJyYXkgb2YgbW9kZWwgbGlzdHMgeW91IHN1cHBsaWVkIGZvciBzdHJhdGVneSAjMi5cbiAqXG4gKiBBZnRlciB0aGUgdXNlciBwZXJmb3JtcyBhIHN1Y2Nlc3NmdWwgZHJhZy1hbmQtZHJvcCBvcGVyYXRpb24sIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW9kZWwgcmVmZXJlbmNlcyB3aXRoaW4gdGhlIGBtb2RlbExpc3RzYCBhcnJheSBpcyByZWFycmFuZ2VkLiAoVGhlIG1vZGVscyB0aGVtc2VsdmVzIGFyZSB0aGUgb3JpZ2luYWwgb2JqZWN0cyBhcyBzdXBwbGllZCBpbiB0aGUgbW9kZWwgbGlzdHM7IHRoZXkgYXJlIG5vdCByZWJ1aWx0IG9yIGFsdGVyZWQgaW4gYW55IHdheS4gSnVzdCB0aGUgcmVmZXJlbmNlcyB0byB0aGVtIGFyZSBtb3ZlZCBhcm91bmQuKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnRbXXxtb2RlbExpc3RUeXBlW119IHNlbGVjdG9yT3JNb2RlbExpc3RzIC0gWW91IG11c3Qgc3VwcGx5IG9uZSBvZiB0aGUgaXRlbXMgaW4gKipib2xkKiogYmVsb3c6XG4gKlxuICogMS4gX0ZvciBzdHJhdGVneSAjMSBhYm92ZSAoQVBJIGNyZWF0ZXMgbW9kZWxzIGZyb20gc3VwcGxpZWQgZWxlbWVudHMpOl8gQWxsIHRoZSBsaXN0IGl0ZW0gKGA8bGk+YCkgRE9NIGVsZW1lbnRzIG9mIGFsbCB0aGUgbGlzdHMgeW91IHdhbnQgdGhlIG5ldyBvYmplY3QgdG8gbWFuYWdlLCBhcyBlaXRoZXI6XG4gKiAgICAxLiAqKkEgQ1NTIHNlbGVjdG9yOyoqIF9vcl9cbiAqICAgIDIuICoqQW4gYXJyYXkgb2YgRE9NIGVsZW1lbnRzKipcbiAqIDIuIF9Gb3Igc3RyYXRlZ3kgIzIgYWJvdmUgKEFQSSBjcmVhdGVzIGVsZW1lbnRzIGZyb20gc3VwcGxpZWQgbW9kZWxzKTpfICoqQW4gYXJyYXkgb2YgbW9kZWwgbGlzdHMsKiogZWFjaCBvZiB3aGljaCBpcyBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtczpcbiAqICAgIDEuIEFuIGFycmF5IG9mIGl0ZW0gbW9kZWxzICh3aXRoIHZhcmlvdXMgb3B0aW9uIHByb3BlcnRpZXMgaGFuZ2luZyBvZmYgb2YgaXQpOyBfYW5kL29yX1xuICogICAgMi4gQSB7QGxpbmsgbW9kZWxMaXN0VHlwZX0gb2JqZWN0IHdpdGggdGhvc2Ugc2FtZSB2YXJpb3VzIG9wdGlvbiBwcm9wZXJ0aWVzIGluY2x1ZGluZyB0aGUgcmVxdWlyZWQgYG1vZGVsc2AgcHJvcGVydHkgY29udGFpbmluZyB0aGF0IHNhbWUgYXJyYXkgb2YgaXRlbSBtb2RlbHMuXG4gKlxuICogSW4gZWl0aGVyIGNhc2UgKDIuMSBvciAyLjIpLCBlYWNoIGVsZW1lbnQgb2Ygc3VjaCBhcnJheXMgb2YgaXRlbSBtb2RlbHMgbWF5IHRha2UgdGhlIGZvcm0gb2Y6XG4gKiAqIEEgc3RyaW5nIHByaW1pdGl2ZTsgX29yX1xuICogKiBBIHtAbGluayBpdGVtTW9kZWxUeXBlfSBvYmplY3Qgd2l0aCBhIHZhcmlvdXMgb3B0aW9uIHByb3BlcnRpZXMgaW5jbHVkaW5nIHRoZSByZXF1aXJlZCBgbGFiZWxgIHByb3BlcnR5IGNvbnRhaW5pbmcgYSBzdHJpbmcgcHJpbWl0aXZlLlxuICpcbiAqIFJlZ2FyZGluZyB0aGVzZSBzdHJpbmcgcHJpbWl0aXZlcywgZWFjaCBpcyBlaXRoZXI6XG4gKiAqIEEgc3RyaW5nIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgbGlzdCBpdGVtOyBfb3JfXG4gKiAqIEEgZm9ybWF0IHN0cmluZyB3aXRoIG90aGVyIHByb3BlcnR5IHZhbHVlcyBtZXJnZWQgaW4sIHRoZSByZXN1bHQgb2Ygd2hpY2ggaXMgdG8gYmUgZGlzcGxheWVkIGluIHRoZSBsaXN0IGl0ZW0uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSAtIFlvdSBtYXkgc3VwcGx5IFwiZ2xvYmFsXCIgdGVtcGxhdGUgdmFyaWFibGVzIGhlcmUsIHJlcHJlc2VudGluZyB0aGUgXCJvdXRlciBzY29wZSxcIiBhZnRlciBmaXJzdCBzZWFyY2hpbmcgZWFjaCBtb2RlbCBhbmQgdGhlbiBlYWNoIG1vZGVsIGxpc3QuXG4gKiBAcGFyYW0ge3VuZGVmaW5lZHxudWxsfEVsZW1lbnR8c3RyaW5nfSBbY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnRdIC0gRGV0ZXJtaW5lcyB3aGVyZSB0byBpbnNlcnQgdGhlIHN0eWxlc2hlZXQuIChUaGlzIGlzIHRoZSBvbmx5IGZvcm1hbCBvcHRpb24uKSBQYXNzZWQgdG8gY3NzLWluamVjdG9yLCB0aGUgb3ZlcmxvYWRzIGFyZSAoZnJvbSBjc3MtaW5qZWN0b3IgZG9jcyk6XG4gKiAqIGB1bmRlZmluZWRgIHR5cGUgKG9yIG9taXR0ZWQpOiBpbmplY3RzIHN0eWxlc2hlZXQgYXQgdG9wIG9mIGA8aGVhZD4uLi48L2hlYWQ+YCBlbGVtZW50XG4gKiAqIGBudWxsYCB2YWx1ZTogaW5qZWN0cyBzdHlsZXNoZWV0IGF0IGJvdHRvbSBvZiBgPGhlYWQ+Li4uPC9oZWFkPmAgZWxlbWVudFxuICogKiBgRWxlbWVudGAgdHlwZTogaW5qZWN0cyBzdHlsZXNoZWV0IGltbWVkaWF0ZWx5IGJlZm9yZSBnaXZlbiBlbGVtZW50LCB3aGVyZXZlciBpdCBpcyBmb3VuZC5cbiAqICogYHN0cmluZ2AgdHlwZTogaW5qZWN0cyBzdHlsZXNoZWV0IGltbWVkaWF0ZWx5IGJlZm9yZSBnaXZlbiBmaXJzdCBlbGVtZW50IGZvdW5kIHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gY3NzIHNlbGVjdG9yLlxuICovXG5mdW5jdGlvbiBMaXN0RHJhZ29uKHNlbGVjdG9yT3JNb2RlbExpc3RzLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGlzdERyYWdvbikpIHtcbiAgICAgICAgdGhyb3cgZXJyb3IoJ05vdCBjYWxsZWQgd2l0aCBcIm5ld1wiIGtleXdvcmQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzLCBtb2RlbExpc3RzLCBpdGVtcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBzZWxlY3Rvck9yTW9kZWxMaXN0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaXRlbXMgPSB0b0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JPck1vZGVsTGlzdHMpKTtcbiAgICAgICAgbW9kZWxMaXN0cyA9IGNyZWF0ZU1vZGVsTGlzdHNGcm9tTGlzdEVsZW1lbnRzKGl0ZW1zKTtcbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yT3JNb2RlbExpc3RzWzBdIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICBpdGVtcyA9IHRvQXJyYXkoc2VsZWN0b3JPck1vZGVsTGlzdHMpO1xuICAgICAgICBtb2RlbExpc3RzID0gY3JlYXRlTW9kZWxMaXN0c0Zyb21MaXN0RWxlbWVudHMoaXRlbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhcmFtIGlzIGFycmF5IG9mIG1vZGVsIGxpc3RzXG4gICAgICAgIC8vIGJ1aWxkIG5ldyA8dWw+IGVsZW1lbnQocykgZm9yIGVhY2ggbGlzdCBhbmQgcHV0IGluIGAubW9kZWxMaXN0c2A7XG4gICAgICAgIC8vIGZpbGwgYC5pdGVtc2AgYXJyYXkgd2l0aCA8bGk+IGVsZW1lbnRzIGZyb20gdGhlc2UgbmV3IDx1bD4gZWxlbWVudHNcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgbW9kZWxMaXN0cyA9IGNyZWF0ZUxpc3RFbGVtZW50c0Zyb21Nb2RlbExpc3RzKHNlbGVjdG9yT3JNb2RlbExpc3RzLCBvcHRpb25zKTtcbiAgICAgICAgbW9kZWxMaXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdCh0b0FycmF5KGxpc3QuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaScpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGdyYWIgd2hlZWwgZXZlbnRzIGFuZCBkb24ndCBsZXQgJ2VtIGJ1YmJsZVxuICAgIG1vZGVsTGlzdHMuZm9yRWFjaChmdW5jdGlvbiAobW9kZWxMaXN0KSB7XG4gICAgICAgIG1vZGVsTGlzdC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgY2FwdHVyZUV2ZW50KTtcbiAgICB9KTtcblxuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW1FbGVtZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgaXRlbSA9IChpdGVtRWxlbWVudCAhPT0gaXRlbUVsZW1lbnQucGFyZW50RWxlbWVudC5sYXN0RWxlbWVudENoaWxkKVxuICAgICAgICAgICAgPyBzZWxmLmFkZEV2dChpdGVtRWxlbWVudCwgJ21vdXNlZG93bicsIGl0ZW1FbGVtZW50LCB0cnVlKVxuICAgICAgICAgICAgOiB7IGVsZW1lbnQ6IGl0ZW1FbGVtZW50IH07XG5cbiAgICAgICAgLyogYGl0ZW0ubW9kZWxgIG5vdCBjdXJyZW50bHkgbmVlZGVkIHNvIGNvbW1lbnRlZCBvdXQgaGVyZS5cbiAgICAgICAgICogKE9yaWdpbmFsbHkgdXNlZCBmb3IgcmVidWlsZGluZyBtb2RlbExpc3RzIGZvciBmaW5hbFxuICAgICAgICAgKiByZXBvcnRpbmcsIG1vZGVsTGlzdHMgYXJlIG5vdyBzcGxpY2VkIG9uIGV2ZXJ5IHN1Y2Nlc3NmdWxcbiAgICAgICAgICogZHJhZy1hbmQtZHJvcCBvcGVyYXRpb24gc28gdGhleSdyZSBhbHdheXMgdXAgdG8gZGF0ZS4pXG5cbiAgICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLml0ZW1Db29yZGluYXRlcyhpdGVtRWxlbWVudCk7XG4gICAgICAgICBpdGVtLm1vZGVsID0gdGhpcy5tb2RlbExpc3RzW29yaWdpbi5saXN0XS5tb2RlbHNbb3JpZ2luLml0ZW1dO1xuXG4gICAgICAgICAqL1xuXG4gICAgICAgIGl0ZW1zW2luZGV4XSA9IGl0ZW07XG4gICAgfSk7XG5cbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNmb3JtJyBpbiBpdGVtc1swXS5lbGVtZW50LnN0eWxlXG4gICAgICAgID8gJ3RyYW5zZm9ybScgLy8gQ2hyb21lIDQ1IGFuZCBGaXJlZm94IDQwXG4gICAgICAgIDogJy13ZWJraXQtdHJhbnNmb3JtJzsgLy8gU2FmYXJpIDhcblxuICAgIC8vIHNldCB1cCB0aGUgbmV3IG9iamVjdFxuICAgIHRoaXMubW9kZWxMaXN0cyA9IG1vZGVsTGlzdHM7XG4gICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICB0aGlzLmNhbGxiYWNrID0ge307XG5cbiAgICBjc3NJbmplY3Rvcihjc3NMaXN0RHJhZ29uLCAnbGlzdC1kcmFnb24tYmFzZScsIG9wdGlvbnMuY3NzU3R5bGVzaGVldFJlZmVyZW5jZUVsZW1lbnQpO1xuXG59XG5cbkxpc3REcmFnb24ucHJvdG90eXBlID0ge1xuXG4gICAgYWRkRXZ0OiBmdW5jdGlvbiAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgZG9Ob3RCaW5kKSB7XG4gICAgICAgIHZhciBiaW5kaW5nID0ge1xuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcnNbdHlwZV0uYmluZCh0YXJnZXQsIHRoaXMpLFxuICAgICAgICAgICAgZWxlbWVudDogbGlzdGVuZXIgfHwgd2luZG93XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFkb05vdEJpbmQpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZV0gPSBiaW5kaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgYmluZGluZy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgYmluZGluZy5oYW5kbGVyKTtcblxuICAgICAgICByZXR1cm4gYmluZGluZztcbiAgICB9LFxuXG4gICAgcmVtb3ZlRXZ0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbdHlwZV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW3R5cGVdO1xuICAgICAgICBiaW5kaW5nLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBiaW5kaW5nLmhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICByZW1vdmVBbGxFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZW1vdmUgZHJhZyAmIGRyb3AgZXZlbnRzIChtb3VzZW1vdmUsIG1vdXNldXAsIGFuZCB0cmFuc2l0aW9uZW5kKVxuICAgICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMuYmluZGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nID0gdGhpcy5iaW5kaW5nc1t0eXBlXTtcbiAgICAgICAgICAgIGJpbmRpbmcuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGJpbmRpbmcuaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBtb3VzZWRvd24gZXZlbnRzIGZyb20gYWxsIGxpc3QgaXRlbXNcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5oYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGl0ZW0uaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB3aGVlbCBldmVudHMgb24gdGhlIGxpc3QgZWxlbWVudHNcbiAgICAgICAgdGhpcy5tb2RlbExpc3RzLmZvckVhY2goZnVuY3Rpb24gKG1vZGVsTGlzdCkge1xuICAgICAgICAgICAgbW9kZWxMaXN0LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBjYXB0dXJlRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcG9pbnRJbkxpc3RSZWN0czogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsTGlzdHMuZmluZChmdW5jdGlvbiAobW9kZWxMaXN0KSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IG1vZGVsTGlzdC5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICByZWN0ID0ge1xuICAgICAgICAgICAgICAgIGxlZnQ6ICAgd2luZG93LnNjcm9sbFggKyByZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiAgICB3aW5kb3cuc2Nyb2xsWSArIHJlY3QudG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAgd2luZG93LnNjcm9sbFggKyByZWN0LnJpZ2h0LFxuICAgICAgICAgICAgICAgIGJvdHRvbTogd2luZG93LnNjcm9sbFkgKyByZWN0LmJvdHRvbSxcbiAgICAgICAgICAgICAgICB3aWR0aDogIHJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbW9kZWxMaXN0LnJlY3QgPSByZWN0O1xuXG4gICAgICAgICAgICBpZiAocG9pbnRJblJlY3QocG9pbnQsIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxMaXN0LnJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBmb3VuZFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBwb2ludEluSXRlbVJlY3RzOiBmdW5jdGlvbiAocG9pbnQsIGV4Y2VwdDEsIGV4Y2VwdDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBpdGVtLmVsZW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGVsZW1lbnQgIT09IGV4Y2VwdDEgJiZcbiAgICAgICAgICAgICAgICBlbGVtZW50ICE9PSBleGNlcHQyICYmXG4gICAgICAgICAgICAgICAgcG9pbnRJblJlY3QocG9pbnQsIGl0ZW0ucmVjdClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgcG9zaXRpb25zIG9mIGFsbCBsaXN0IGl0ZW1zIGluIHBhZ2UgY29vcmRzIChub3JtYWxpemVkIGZvciB3aW5kb3cgYW5kIGxpc3Qgc2Nyb2xsaW5nKVxuICAgIGdldEFsbEl0ZW1Cb3VuZGluZ1JlY3RzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtb2RlbExpc3RzID0gdGhpcy5tb2RlbExpc3RzLCBoZWlnaHQ7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIGl0ZW1FbGVtZW50ID0gaXRlbS5lbGVtZW50LFxuICAgICAgICAgICAgICAgIGxpc3RFbGVtZW50ID0gaXRlbUVsZW1lbnQucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBsaXN0ID0gbW9kZWxMaXN0cy5maW5kKGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0LmVsZW1lbnQgPT09IGxpc3RFbGVtZW50OyB9KTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIG9taXR0ZWQ6IGRlZmF1bHQgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgIGxpc3QuaXNEcm9wVGFyZ2V0ID09PSB1bmRlZmluZWQgfHxcblxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uOiB1c2UgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICAgICAgdHlwZW9mIGxpc3QuaXNEcm9wVGFyZ2V0ID09PSAnZnVuY3Rpb24nICYmIGxpc3QuaXNEcm9wVGFyZ2V0KCkgfHxcblxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZTogdXNlIHRydXRoaW5lc3Mgb2YgZ2l2ZW4gdmFsdWVcbiAgICAgICAgICAgICAgICBsaXN0LmlzRHJvcFRhcmdldFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBpdGVtRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gcmVjdC5ib3R0b207XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbUVsZW1lbnQgPT09IGxpc3RFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gbGlzdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tIDwgcmVjdC50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHJlY3QudG9wICsgKGhlaWdodCB8fCA1MCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAgIHdpbmRvdy5zY3JvbGxYICsgcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogIHdpbmRvdy5zY3JvbGxYICsgcmVjdC5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAgICB3aW5kb3cuc2Nyb2xsWSArIHJlY3QudG9wICAgICsgbGlzdEVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHdpbmRvdy5zY3JvbGxZICsgYm90dG9tICsgbGlzdEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGl0ZW0ucmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZWluc2VydDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGU7XG4gICAgICAgIHN0eWxlLndpZHRoID0gc3R5bGVbdHJhbnNmb3JtXSA9IHN0eWxlLnRyYW5zaXRpb24gPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTtcblxuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ29uLXBvcCcpO1xuXG4gICAgICAgIHRoaXMuZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgICAgICB0aGlzLmRyb3Auc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTtcbiAgICAgICAgdGhpcy5kcm9wLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRhcmdldCwgdGhpcy5kcm9wKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5kcm9wO1xuICAgIH0sXG5cbiAgICAvLyByZXR1cm4gYW4gb2JqZWN0IHsgaXRlbTogPGl0ZW0gaW5kZXggd2l0aGluIGxpc3Q+LCBsaXN0OiA8bGlzdCBpbmRleCB3aXRoaW4gbGlzdCBvZiBsaXN0cz4gfVxuICAgIGl0ZW1Db29yZGluYXRlczogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGxpc3RFbGVtZW50ID0gaXRlbS5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgY29vcmRzID0geyBpdGVtOiAwIH07XG5cbiAgICAgICAgd2hpbGUgKChpdGVtID0gaXRlbS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgKytjb29yZHMuaXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9kZWxMaXN0cy5maW5kKGZ1bmN0aW9uIChsaXN0LCBpbmRleCkge1xuICAgICAgICAgICAgY29vcmRzLmxpc3QgPSBpbmRleDtcbiAgICAgICAgICAgIHJldHVybiBsaXN0LmVsZW1lbnQgPT09IGxpc3RFbGVtZW50OyAvLyBzdG9wIHdoZW4gd2UgZmluZCB0aGUgb25lIHdlIGJlbG9uZyB0b1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgIH1cblxufTtcblxudmFyIGhhbmRsZXJzID0ge1xuICAgIG1vdXNlZG93bjogZnVuY3Rpb24gKGRyYWdvbiwgZXZ0KSB7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgIC8vcHJldmVudHMgdXNlciBzZWxlY3Rpb24gb2YgcmVuZGVyZWQgbm9kZXMgZHVyaW5nIGRyYWdcblxuICAgICAgICBpZiAoZHJhZ29uLmRyb3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBkcmFnb24ucmVjdCA9IHJlY3QgPSB7XG4gICAgICAgICAgICBsZWZ0OiAgIE1hdGgucm91bmQocmVjdC5sZWZ0IC0gMSksXG4gICAgICAgICAgICB0b3A6ICAgIE1hdGgucm91bmQocmVjdC50b3AgLSAxKSxcbiAgICAgICAgICAgIHJpZ2h0OiAgTWF0aC5yb3VuZChyZWN0LnJpZ2h0KSxcbiAgICAgICAgICAgIGJvdHRvbTogTWF0aC5yb3VuZChyZWN0LmJvdHRvbSksXG4gICAgICAgICAgICB3aWR0aDogIE1hdGgucm91bmQocmVjdC53aWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQocmVjdC5oZWlnaHQpXG4gICAgICAgIH07XG5cbiAgICAgICAgZHJhZ29uLnBpbiA9IHtcbiAgICAgICAgICAgIHg6IHdpbmRvdy5zY3JvbGxYICsgZXZ0LmNsaWVudFgsXG4gICAgICAgICAgICB5OiB3aW5kb3cuc2Nyb2xsWSArIGV2dC5jbGllbnRZXG4gICAgICAgIH07XG5cbiAgICAgICAgZHJhZ29uLm9yaWdpbiA9IGRyYWdvbi5pdGVtQ29vcmRpbmF0ZXModGhpcyk7XG5cbiAgICAgICAgaWYgKGRyYWdvbi5jYWxsYmFjay5ncmFiYmVkKSB7XG4gICAgICAgICAgICBkcmFnb24uY2FsbGJhY2suZ3JhYmJlZC5jYWxsKHRoaXMsIGRyYWdvbik7XG4gICAgICAgIH1cblxuICAgICAgICBkcmFnb24uZ2V0QWxsSXRlbUJvdW5kaW5nUmVjdHMoKTtcblxuICAgICAgICBkcmFnb24uZHJvcCA9IHRoaXMubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBkcmFnb24uZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgICAgICBkcmFnb24uZHJvcC5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IHJlY3QuaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICB0aGlzLnN0eWxlLndpZHRoID0gcmVjdC53aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgICAgICAgdGhpcy5zdHlsZVt0cmFuc2Zvcm1dID0gdHJhbnNsYXRlKFxuICAgICAgICAgICAgcmVjdC5sZWZ0IC0gd2luZG93LnNjcm9sbFgsXG4gICAgICAgICAgICByZWN0LnRvcCAgLSB3aW5kb3cuc2Nyb2xsWVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2RyYWdvbi1wb3AnKTtcbiAgICAgICAgdGhpcy5zdHlsZS56SW5kZXggPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkcmFnb24ubW9kZWxMaXN0c1swXS5jb250YWluZXIucGFyZW50RWxlbWVudCkuekluZGV4O1xuXG4gICAgICAgIGlmICghZHJhZ29uLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgLy8gd2FsayBiYWNrIHRvIGNsb3Nlc3Qgc2hhZG93IHJvb3QgT1IgYm9keSB0YWcgT1Igcm9vdCB0YWdcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgU2hhZG93Um9vdCAhPT0gJ3VuZGVmaW5lZCcgJiYgY29udGFpbmVyIGluc3RhbmNlb2YgU2hhZG93Um9vdCB8fFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIudGFnTmFtZSA9PT0gJ0JPRFknXG4gICAgICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHJhZ29uLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRyYWdvbi5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcyk7XG5cbiAgICAgICAgcmVjdC5sZWZ0ICAgKz0gd2luZG93LnNjcm9sbFg7XG4gICAgICAgIHJlY3QudG9wICAgICs9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICByZWN0LnJpZ2h0ICArPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgcmVjdC5ib3R0b20gKz0gd2luZG93LnNjcm9sbFk7XG5cbiAgICAgICAgZHJhZ29uLmFkZEV2dCh0aGlzLCAnbW91c2Vtb3ZlJyk7XG4gICAgICAgIGRyYWdvbi5hZGRFdnQodGhpcywgJ21vdXNldXAnKTtcbiAgICB9LFxuXG4gICAgbW91c2Vtb3ZlOiBmdW5jdGlvbiAoZHJhZ29uLCBldnQpIHtcbiAgICAgICAgZHJhZ29uLmRyb3Auc3R5bGUudHJhbnNpdGlvbiA9IFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFO1xuXG4gICAgICAgIHZhciBob3Zlckxpc3QgPSBkcmFnb24ucG9pbnRJbkxpc3RSZWN0cyh7IHg6IGV2dC5jbGllbnRYLCB5OiBldnQuY2xpZW50WSB9KSB8fCBkcmFnb24ubW9zdFJlY2VudEhvdmVyTGlzdDtcblxuICAgICAgICBpZiAoaG92ZXJMaXN0KSB7XG4gICAgICAgICAgICB2YXIgZHggPSBldnQuY2xpZW50WCAtIGRyYWdvbi5waW4ueCxcbiAgICAgICAgICAgICAgICBkeSA9IGV2dC5jbGllbnRZIC0gZHJhZ29uLnBpbi55O1xuXG4gICAgICAgICAgICBkcmFnb24ubW9zdFJlY2VudEhvdmVyTGlzdCA9IGhvdmVyTGlzdDtcblxuICAgICAgICAgICAgdmFyIG1heFNjcm9sbFkgPSBob3Zlckxpc3QuZWxlbWVudC5zY3JvbGxIZWlnaHQgLSBob3Zlckxpc3QucmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgeSA9IGV2dC5jbGllbnRZICsgd2luZG93LnNjcm9sbFksXG4gICAgICAgICAgICAgICAgbWFnbml0dWRlO1xuXG4gICAgICAgICAgICBpZiAobWF4U2Nyb2xsWSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBsaXN0IGlzIHNjcm9sbGFibGUgKGlzIHRhbGxlciB0aGFuIHJlY3QpXG4gICAgICAgICAgICAgICAgaWYgKGhvdmVyTGlzdC5lbGVtZW50LnNjcm9sbFRvcCA+IDAgJiYgKG1hZ25pdHVkZSA9IHkgLSAoaG92ZXJMaXN0LnJlY3QudG9wICsgNSkpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3VzZSBuZWFyIG9yIGFib3ZlIHRvcCBhbmQgbGlzdCBpcyBub3Qgc2Nyb2xsZWQgdG8gdG9wIHlldFxuICAgICAgICAgICAgICAgICAgICByZXNldEF1dG9TY3JvbGxUaW1lcihtYWduaXR1ZGUsIDAsIGhvdmVyTGlzdC5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhvdmVyTGlzdC5lbGVtZW50LnNjcm9sbFRvcCA8IG1heFNjcm9sbFkgJiYgKG1hZ25pdHVkZSA9IHkgLSAoaG92ZXJMaXN0LnJlY3QuYm90dG9tIC0gMSAtIDUpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91c2UgbmVhciBvciBiZWxvdyBib3R0b20gYW5kIGxpc3Qgbm90IHNjcm9sbGVkIHRvIGJvdHRvbSB5ZXRcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRBdXRvU2Nyb2xsVGltZXIobWFnbml0dWRlLCBtYXhTY3JvbGxZLCBob3Zlckxpc3QuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91c2UgaW5zaWRlXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0QXV0b1Njcm9sbFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBkcmFnb24ucG9pbnRJbkl0ZW1SZWN0cyh7XG4gICAgICAgICAgICAgICAgeDogZXZ0LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgeTogZHJhZ29uLnJlY3QuYm90dG9tICsgd2luZG93LnNjcm9sbFkgKyBkeSArIGhvdmVyTGlzdC5lbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgfSwgdGhpcywgZHJhZ29uLmRyb3ApO1xuXG4gICAgICAgICAgICB0aGlzLnN0eWxlW3RyYW5zZm9ybV0gPSB0cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgZHJhZ29uLnJlY3QubGVmdCAtIHdpbmRvdy5zY3JvbGxYICsgZHgsXG4gICAgICAgICAgICAgICAgZHJhZ29uLnJlY3QudG9wIC0gd2luZG93LnNjcm9sbFkgKyBkeVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBvdGhlci5lbGVtZW50O1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbiA9IFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBkcmFnb24uZHJvcC5zdHlsZS5ib3JkZXJUb3BXaWR0aDtcbiAgICAgICAgICAgICAgICBkcmFnb24uZHJvcC5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZHJhZ29uLmRyb3AgPSBlbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vdXNldXA6IGZ1bmN0aW9uIChkcmFnb24sIGV2dCkge1xuICAgICAgICByZXNldEF1dG9TY3JvbGxUaW1lcigpO1xuICAgICAgICBkcmFnb24ucmVtb3ZlRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgZHJhZ29uLnJlbW92ZUV2dCgnbW91c2V1cCcpO1xuXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB2YXIgbmV3UmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgd2luZG93LnNjcm9sbFggKyBuZXdSZWN0LmxlZnQgPT09IGRyYWdvbi5yZWN0LmxlZnQgJiZcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxZICsgbmV3UmVjdC50b3AgPT09IGRyYWdvbi5yZWN0LnRvcFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRyYWdvbi5yZWluc2VydCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkcm9wUmVjdCA9IGRyYWdvbi5kcm9wLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICBkcmFnb24uYWRkRXZ0KHRoaXMsICd0cmFuc2l0aW9uZW5kJywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFOyAvL3JldmVydHMgdG8gMjAwbXNcbiAgICAgICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gdHJhbnNmb3JtO1xuICAgICAgICAgICAgdGhpcy5zdHlsZVt0cmFuc2Zvcm1dID0gdHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgIGRyb3BSZWN0LmxlZnQgLSB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICBkcm9wUmVjdC50b3AgLSB3aW5kb3cuc2Nyb2xsWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFuc2l0aW9uZW5kOiBmdW5jdGlvbiAoZHJhZ29uLCBldnQpIHtcbiAgICAgICAgaWYgKGV2dC5wcm9wZXJ0eU5hbWUgPT09IHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgZHJhZ29uLnJlbW92ZUV2dCgndHJhbnNpdGlvbmVuZCcpO1xuICAgICAgICAgICAgZHJhZ29uLnJlaW5zZXJ0KHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFOyAvL3JldmVydHMgdG8gYm9yZGVyLXRvcC13aWR0aFxuXG4gICAgICAgICAgICB2YXIgb3JpZ2luTGlzdCA9IGRyYWdvbi5tb2RlbExpc3RzW2RyYWdvbi5vcmlnaW4ubGlzdF07XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBvcmlnaW5MaXN0LnNwbGljZShkcmFnb24ub3JpZ2luLml0ZW0sIDEpWzBdO1xuICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gZHJhZ29uLml0ZW1Db29yZGluYXRlcyh0aGlzKTtcbiAgICAgICAgICAgIHZhciBkZXN0aW5hdGlvbkxpc3QgPSBkcmFnb24ubW9kZWxMaXN0c1tkZXN0aW5hdGlvbi5saXN0XTtcbiAgICAgICAgICAgIHZhciBpbnRlckxpc3REcm9wID0gb3JpZ2luTGlzdCAhPT0gZGVzdGluYXRpb25MaXN0O1xuICAgICAgICAgICAgdmFyIGxpc3RDaGFuZ2VkID0gaW50ZXJMaXN0RHJvcCB8fCBkcmFnb24ub3JpZ2luLml0ZW0gIT09IGRlc3RpbmF0aW9uLml0ZW07XG4gICAgICAgICAgICBkZXN0aW5hdGlvbkxpc3Quc3BsaWNlKGRlc3RpbmF0aW9uLml0ZW0sIDAsIG1vZGVsKTtcblxuICAgICAgICAgICAgaWYgKGxpc3RDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luTGlzdC5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdsaXN0Y2hhbmdlZCcpKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJMaXN0RHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkxpc3QuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbGlzdGNoYW5nZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHJhZ29uLmNhbGxiYWNrLmRyb3BwZWQpIHtcbiAgICAgICAgICAgICAgICBkcmFnb24uY2FsbGJhY2suZHJvcHBlZC5jYWxsKHRoaXMsIGRyYWdvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiByZXNldEF1dG9TY3JvbGxUaW1lcihtYWduaXR1ZGUsIGxpbWl0LCBlbGVtZW50KSB7XG4gICAgaWYgKCFtYWduaXR1ZGUpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIHNjcm9sbFZlbG9jaXR5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hhbmdlRGlyZWN0aW9uID1cbiAgICAgICAgICAgIHNjcm9sbFZlbG9jaXR5ICA8ICAwICYmIG1hZ25pdHVkZSAgPj0gMCB8fFxuICAgICAgICAgICAgc2Nyb2xsVmVsb2NpdHkgPT09IDAgJiYgbWFnbml0dWRlICE9PSAwIHx8XG4gICAgICAgICAgICBzY3JvbGxWZWxvY2l0eSAgPiAgMCAmJiBtYWduaXR1ZGUgIDw9IDA7XG4gICAgICAgIHNjcm9sbFZlbG9jaXR5ID0gbWFnbml0dWRlID4gMCA/IE1hdGgubWluKDUwLCBtYWduaXR1ZGUpIDogTWF0aC5tYXgoLTUwLCBtYWduaXR1ZGUpO1xuICAgICAgICBpZiAoY2hhbmdlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wICsgc2Nyb2xsVmVsb2NpdHk7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFZlbG9jaXR5IDwgMCAmJiBzY3JvbGxUb3AgPCBsaW1pdCB8fCBzY3JvbGxWZWxvY2l0eSA+IDAgJiYgc2Nyb2xsVG9wID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBsaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTI1KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2VPYmplY3QpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlT2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gcG9pbnRJblJlY3QocG9pbnQsIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC50b3AgPD0gcG9pbnQueSAmJiBwb2ludC55IDw9IHJlY3QuYm90dG9tXG4gICAgICAgICYmIHJlY3QubGVmdCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gcmVjdC5yaWdodDtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlKGxlZnQsIHRvcCkge1xuICAgIHJldHVybiAndHJhbnNsYXRlKCdcbiAgICAgICAgKyBNYXRoLmZsb29yKGxlZnQgKyB3aW5kb3cuc2Nyb2xsWCkgKyAncHgsJ1xuICAgICAgICArIE1hdGguZmxvb3IodG9wICsgd2luZG93LnNjcm9sbFkpICsgJ3B4KSc7XG59XG5cbmZ1bmN0aW9uIGh0bWxFbmNvZGUoc3RyaW5nKSB7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nKTtcblxuICAgIHJldHVybiBkb2N1bWVudFxuICAgICAgICAuY3JlYXRlRWxlbWVudCgnYScpXG4gICAgICAgIC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSlcbiAgICAgICAgLnBhcmVudE5vZGVcbiAgICAgICAgLmlubmVySFRNTDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGA8dWw+Li4uPC91bD5gIGVsZW1lbnRzIGFuZCBpbnNlcnRzIHRoZW0gaW50byBhbiBgZWxlbWVudGAgcHJvcGVydHkgb24gZWFjaCBtb2RlbC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbExpc3RzXG4gKiBAcmV0dXJucyBgbW9kZWxMaXN0c2BcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGlzdEVsZW1lbnRzRnJvbU1vZGVsTGlzdHMobW9kZWxMaXN0cywgb3B0aW9ucykge1xuICAgIHZhciB0ZW1wbGF0ZUxhYmVsID0gb3B0aW9ucy5sYWJlbCB8fCAne2xhYmVsfSc7XG5cbiAgICBtb2RlbExpc3RzLmZvckVhY2goZnVuY3Rpb24gKG1vZGVsTGlzdCwgbGlzdEluZGV4KSB7XG4gICAgICAgIHZhciBsaXN0TGFiZWwgPSBtb2RlbExpc3QubGFiZWwgfHwgdGVtcGxhdGVMYWJlbCxcbiAgICAgICAgICAgIGxpc3RIdG1sRW5jb2RlID0gbW9kZWxMaXN0Lmh0bWxFbmNvZGUgIT09IHVuZGVmaW5lZCAmJiBtb2RlbExpc3QuaHRtbEVuY29kZSB8fCBvcHRpb25zLmh0bWxFbmNvZGUsXG4gICAgICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIGxpc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcblxuICAgICAgICBpZiAobW9kZWxMaXN0Lm1vZGVscykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobW9kZWxMaXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kZWxzJykge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbExpc3QubW9kZWxzW2tleV0gPSBtb2RlbExpc3Rba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vZGVsTGlzdHNbbGlzdEluZGV4XSA9IG1vZGVsTGlzdCA9IG1vZGVsTGlzdC5tb2RlbHM7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZWxMaXN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIG1vZGVsTGlzdC5tb2RlbHMgPSBtb2RlbExpc3Q7IC8vIHBvaW50IHRvIHNlbGZcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yKCdMaXN0IFt7MX1dIG5vdCBhbiBhcnJheSBvZiBtb2RlbHMgKHdpdGggb3Igd2l0aG91dCBhZGRpdGlvbmFsIHByb3BlcnRpZXMpIE9SICcgK1xuICAgICAgICAgICAgICAgICdhbiBvYmplY3QgKHdpdGggYSBgbW9kZWxzYCBwcm9wZXJ0eSBjb250YWluaW5nIGFuIGFycmF5IG9mIG1vZGVscykuJywgbGlzdEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGVsTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgdmFyIG1vZGVsTGFiZWwgPSBtb2RlbC5sYWJlbCB8fCBsaXN0TGFiZWwsXG4gICAgICAgICAgICAgICAgbW9kZWxIdG1sRW5jb2RlID0gbW9kZWwuaHRtbEVuY29kZSAhPT0gdW5kZWZpbmVkICYmIG1vZGVsLmh0bWxFbmNvZGUgfHwgbGlzdEh0bWxFbmNvZGUsXG4gICAgICAgICAgICAgICAgbW9kZWxPYmplY3QgPSB0eXBlb2YgbW9kZWwgPT09ICdvYmplY3QnID8gbW9kZWwgOiB7IGxhYmVsOiBtb2RlbH0sXG4gICAgICAgICAgICAgICAgbGFiZWwgPSBmb3JtYXQuY2FsbChbbW9kZWxPYmplY3QsIG1vZGVsTGlzdCwgb3B0aW9uc10sIG1vZGVsTGFiZWwpLFxuICAgICAgICAgICAgICAgIGl0ZW1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblxuICAgICAgICAgICAgaXRlbUVsZW1lbnQuaW5uZXJIVE1MID0gbW9kZWxIdG1sRW5jb2RlID8gaHRtbEVuY29kZShsYWJlbCkgOiBsYWJlbDtcblxuICAgICAgICAgICAgbGlzdEVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbUVsZW1lbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhcHBlbmQgdGhlIGZpbmFsIFwiZmVuY2Vwb3N0XCIgaXRlbSAtLSBkcm9wIHRhcmdldCBhdCBib3R0b20gb2YgbGlzdCBhZnRlciBhbGwgaXRlbXNcbiAgICAgICAgdmFyIGl0ZW1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgaXRlbUVsZW1lbnQuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG4gICAgICAgIGxpc3RFbGVtZW50LmFwcGVuZENoaWxkKGl0ZW1FbGVtZW50KTtcblxuICAgICAgICAvLyBhcHBlbmQgaGVhZGVyIHRvIGNvbnRhaW5lclxuICAgICAgICBpZiAobW9kZWxMaXN0LnRpdGxlKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBoZWFkZXIuaW5uZXJIVE1MID0gbGlzdEh0bWxFbmNvZGUgPyBodG1sRW5jb2RlKG1vZGVsTGlzdC50aXRsZSkgOiBtb2RlbExpc3QudGl0bGU7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChsaXN0RWxlbWVudCk7XG4gICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBtb2RlbExpc3QuY3NzQ2xhc3NOYW1lcyB8fCBvcHRpb25zLmNzc0NsYXNzTmFtZXMgfHwgJ2RyYWdvbi1saXN0JztcbiAgICAgICAgbW9kZWxMaXN0LmVsZW1lbnQgPSBsaXN0RWxlbWVudDtcbiAgICAgICAgbW9kZWxMaXN0LmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9KTtcblxuICAgIHJldHVybiBtb2RlbExpc3RzO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGAubW9kZWxMaXN0c2AgYXJyYXkgd2l0aCB0aGVzZSA8bGk+IGVsZW1lbnRzJyBwYXJlbnQgPHVsPiBlbGVtZW50c1xuICogQHBhcmFtIHtFbGVtZW50W119IGxpc3RJdGVtRWxlbWVudHNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kZWxMaXN0c0Zyb21MaXN0RWxlbWVudHMobGlzdEl0ZW1FbGVtZW50cykge1xuICAgIHZhciBtb2RlbExpc3RzID0gW107XG5cbiAgICBsaXN0SXRlbUVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW1FbGVtZW50KSB7XG4gICAgICAgIHZhciBsaXN0RWxlbWVudCA9IGl0ZW1FbGVtZW50LnBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICBjb250YWluZXIgPSBsaXN0RWxlbWVudC5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgbW9kZWxzID0gW107XG4gICAgICAgIGlmICghbW9kZWxMaXN0cy5maW5kKGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0LmVsZW1lbnQgPT09IGxpc3RFbGVtZW50OyB9KSkge1xuICAgICAgICAgICAgdG9BcnJheShsaXN0RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaScpKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtRWxlbWVudCAhPT0gbGlzdEVsZW1lbnQubGFzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbHMucHVzaChpdGVtRWxlbWVudC5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbW9kZWxzLmVsZW1lbnQgPSBsaXN0RWxlbWVudDtcbiAgICAgICAgICAgIG1vZGVscy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgICAgICBtb2RlbExpc3RzLnB1c2gobW9kZWxzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1vZGVsTGlzdHM7XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVFdmVudChldnQpIHtcbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIGVycm9yKCkge1xuICAgIHJldHVybiAnbGlzdC1kcmFnb246ICcgKyBmb3JtYXQuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59XG5cbi8vIHRoaXMgaW50ZXJmYWNlIGNvbnNpc3RzIHNvbGVseSBvZiB0aGUgcHJvdG90eXBhbCBvYmplY3QgY29uc3RydWN0b3Jcbm1vZHVsZS5leHBvcnRzID0gTGlzdERyYWdvbjtcbiIsIjsoZnVuY3Rpb24gKCkgeyAvLyBjbG9zdXJlIGZvciB3ZWIgYnJvd3NlcnNcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbn0gZWxzZSB7XG4gIC8vIGp1c3Qgc2V0IHRoZSBnbG9iYWwgZm9yIG5vbi1ub2RlIHBsYXRmb3Jtcy5cbiAgdGhpcy5MUlVDYWNoZSA9IExSVUNhY2hlXG59XG5cbmZ1bmN0aW9uIGhPUCAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuZnVuY3Rpb24gbmFpdmVMZW5ndGggKCkgeyByZXR1cm4gMSB9XG5cbmZ1bmN0aW9uIExSVUNhY2hlIChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMUlVDYWNoZSkpXG4gICAgcmV0dXJuIG5ldyBMUlVDYWNoZShvcHRpb25zKVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpXG4gICAgb3B0aW9ucyA9IHsgbWF4OiBvcHRpb25zIH1cblxuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9XG5cbiAgdGhpcy5fbWF4ID0gb3B0aW9ucy5tYXhcbiAgLy8gS2luZCBvZiB3ZWlyZCB0byBoYXZlIGEgZGVmYXVsdCBtYXggb2YgSW5maW5pdHksIGJ1dCBvaCB3ZWxsLlxuICBpZiAoIXRoaXMuX21heCB8fCAhKHR5cGVvZiB0aGlzLl9tYXggPT09IFwibnVtYmVyXCIpIHx8IHRoaXMuX21heCA8PSAwIClcbiAgICB0aGlzLl9tYXggPSBJbmZpbml0eVxuXG4gIHRoaXMuX2xlbmd0aENhbGN1bGF0b3IgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aFxuICBpZiAodHlwZW9mIHRoaXMuX2xlbmd0aENhbGN1bGF0b3IgIT09IFwiZnVuY3Rpb25cIilcbiAgICB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yID0gbmFpdmVMZW5ndGhcblxuICB0aGlzLl9hbGxvd1N0YWxlID0gb3B0aW9ucy5zdGFsZSB8fCBmYWxzZVxuICB0aGlzLl9tYXhBZ2UgPSBvcHRpb25zLm1heEFnZSB8fCBudWxsXG4gIHRoaXMuX2Rpc3Bvc2UgPSBvcHRpb25zLmRpc3Bvc2VcbiAgdGhpcy5yZXNldCgpXG59XG5cbi8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcIm1heFwiLFxuICB7IHNldCA6IGZ1bmN0aW9uIChtTCkge1xuICAgICAgaWYgKCFtTCB8fCAhKHR5cGVvZiBtTCA9PT0gXCJudW1iZXJcIikgfHwgbUwgPD0gMCApIG1MID0gSW5maW5pdHlcbiAgICAgIHRoaXMuX21heCA9IG1MXG4gICAgICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KSB0cmltKHRoaXMpXG4gICAgfVxuICAsIGdldCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21heCB9XG4gICwgZW51bWVyYWJsZSA6IHRydWVcbiAgfSlcblxuLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcImxlbmd0aENhbGN1bGF0b3JcIixcbiAgeyBzZXQgOiBmdW5jdGlvbiAobEMpIHtcbiAgICAgIGlmICh0eXBlb2YgbEMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yID0gbmFpdmVMZW5ndGhcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdGhpcy5faXRlbUNvdW50XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9jYWNoZSkge1xuICAgICAgICAgIHRoaXMuX2NhY2hlW2tleV0ubGVuZ3RoID0gMVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yID0gbENcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gMFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICB0aGlzLl9jYWNoZVtrZXldLmxlbmd0aCA9IHRoaXMuX2xlbmd0aENhbGN1bGF0b3IodGhpcy5fY2FjaGVba2V5XS52YWx1ZSlcbiAgICAgICAgICB0aGlzLl9sZW5ndGggKz0gdGhpcy5fY2FjaGVba2V5XS5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KSB0cmltKHRoaXMpXG4gICAgfVxuICAsIGdldCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xlbmd0aENhbGN1bGF0b3IgfVxuICAsIGVudW1lcmFibGUgOiB0cnVlXG4gIH0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsXG4gIHsgZ2V0IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGVuZ3RoIH1cbiAgLCBlbnVtZXJhYmxlIDogdHJ1ZVxuICB9KVxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsIFwiaXRlbUNvdW50XCIsXG4gIHsgZ2V0IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faXRlbUNvdW50IH1cbiAgLCBlbnVtZXJhYmxlIDogdHJ1ZVxuICB9KVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciBpID0gMFxuICB2YXIgaXRlbUNvdW50ID0gdGhpcy5faXRlbUNvdW50XG5cbiAgZm9yICh2YXIgayA9IHRoaXMuX21ydSAtIDE7IGsgPj0gMCAmJiBpIDwgaXRlbUNvdW50OyBrLS0pIGlmICh0aGlzLl9scnVMaXN0W2tdKSB7XG4gICAgaSsrXG4gICAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3Rba11cbiAgICBpZiAoaXNTdGFsZSh0aGlzLCBoaXQpKSB7XG4gICAgICBkZWwodGhpcywgaGl0KVxuICAgICAgaWYgKCF0aGlzLl9hbGxvd1N0YWxlKSBoaXQgPSB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKGhpdCkge1xuICAgICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGtleXMgPSBuZXcgQXJyYXkodGhpcy5faXRlbUNvdW50KVxuICB2YXIgaSA9IDBcbiAgZm9yICh2YXIgayA9IHRoaXMuX21ydSAtIDE7IGsgPj0gMCAmJiBpIDwgdGhpcy5faXRlbUNvdW50OyBrLS0pIGlmICh0aGlzLl9scnVMaXN0W2tdKSB7XG4gICAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3Rba11cbiAgICBrZXlzW2krK10gPSBoaXQua2V5XG4gIH1cbiAgcmV0dXJuIGtleXNcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheSh0aGlzLl9pdGVtQ291bnQpXG4gIHZhciBpID0gMFxuICBmb3IgKHZhciBrID0gdGhpcy5fbXJ1IC0gMTsgayA+PSAwICYmIGkgPCB0aGlzLl9pdGVtQ291bnQ7IGstLSkgaWYgKHRoaXMuX2xydUxpc3Rba10pIHtcbiAgICB2YXIgaGl0ID0gdGhpcy5fbHJ1TGlzdFtrXVxuICAgIHZhbHVlc1tpKytdID0gaGl0LnZhbHVlXG4gIH1cbiAgcmV0dXJuIHZhbHVlc1xufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9kaXNwb3NlICYmIHRoaXMuX2NhY2hlKSB7XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLl9jYWNoZSkge1xuICAgICAgdGhpcy5fZGlzcG9zZShrLCB0aGlzLl9jYWNoZVtrXS52YWx1ZSlcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCkgLy8gaGFzaCBvZiBpdGVtcyBieSBrZXlcbiAgdGhpcy5fbHJ1TGlzdCA9IE9iamVjdC5jcmVhdGUobnVsbCkgLy8gbGlzdCBvZiBpdGVtcyBpbiBvcmRlciBvZiB1c2UgcmVjZW5jeVxuICB0aGlzLl9tcnUgPSAwIC8vIG1vc3QgcmVjZW50bHkgdXNlZFxuICB0aGlzLl9scnUgPSAwIC8vIGxlYXN0IHJlY2VudGx5IHVzZWRcbiAgdGhpcy5fbGVuZ3RoID0gMCAvLyBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGxpc3RcbiAgdGhpcy5faXRlbUNvdW50ID0gMFxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IFtdXG4gIHZhciBpID0gMFxuXG4gIGZvciAodmFyIGsgPSB0aGlzLl9tcnUgLSAxOyBrID49IDAgJiYgaSA8IHRoaXMuX2l0ZW1Db3VudDsgay0tKSBpZiAodGhpcy5fbHJ1TGlzdFtrXSkge1xuICAgIHZhciBoaXQgPSB0aGlzLl9scnVMaXN0W2tdXG4gICAgaWYgKCFpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICAgIC8vRG8gbm90IHN0b3JlIHN0YWxlZCBoaXRzXG4gICAgICArK2lcbiAgICAgIGFyci5wdXNoKHtcbiAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvL2FyciBoYXMgdGhlIG1vc3QgcmVhZCBmaXJzdFxuICByZXR1cm4gYXJyXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kdW1wTHJ1ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fbHJ1TGlzdFxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIG1heEFnZSkge1xuICBtYXhBZ2UgPSBtYXhBZ2UgfHwgdGhpcy5fbWF4QWdlXG4gIHZhciBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvcih2YWx1ZSlcblxuICBpZiAoaE9QKHRoaXMuX2NhY2hlLCBrZXkpKSB7XG4gICAgaWYgKGxlbiA+IHRoaXMuX21heCkge1xuICAgICAgZGVsKHRoaXMsIHRoaXMuX2NhY2hlW2tleV0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICBpZiAodGhpcy5fZGlzcG9zZSlcbiAgICAgIHRoaXMuX2Rpc3Bvc2Uoa2V5LCB0aGlzLl9jYWNoZVtrZXldLnZhbHVlKVxuXG4gICAgdGhpcy5fY2FjaGVba2V5XS5ub3cgPSBub3dcbiAgICB0aGlzLl9jYWNoZVtrZXldLm1heEFnZSA9IG1heEFnZVxuICAgIHRoaXMuX2NhY2hlW2tleV0udmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMuX2xlbmd0aCArPSAobGVuIC0gdGhpcy5fY2FjaGVba2V5XS5sZW5ndGgpXG4gICAgdGhpcy5fY2FjaGVba2V5XS5sZW5ndGggPSBsZW5cbiAgICB0aGlzLmdldChrZXkpXG5cbiAgICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KVxuICAgICAgdHJpbSh0aGlzKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHZhciBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSwgdGhpcy5fbXJ1KyssIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgLy8gb3ZlcnNpemVkIG9iamVjdHMgZmFsbCBvdXQgb2YgY2FjaGUgYXV0b21hdGljYWxseS5cbiAgaWYgKGhpdC5sZW5ndGggPiB0aGlzLl9tYXgpIHtcbiAgICBpZiAodGhpcy5fZGlzcG9zZSkgdGhpcy5fZGlzcG9zZShrZXksIHZhbHVlKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdGhpcy5fbGVuZ3RoICs9IGhpdC5sZW5ndGhcbiAgdGhpcy5fbHJ1TGlzdFtoaXQubHVdID0gdGhpcy5fY2FjaGVba2V5XSA9IGhpdFxuICB0aGlzLl9pdGVtQ291bnQgKytcblxuICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KVxuICAgIHRyaW0odGhpcylcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAoIWhPUCh0aGlzLl9jYWNoZSwga2V5KSkgcmV0dXJuIGZhbHNlXG4gIHZhciBoaXQgPSB0aGlzLl9jYWNoZVtrZXldXG4gIGlmIChpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3RbdGhpcy5fbHJ1XVxuICBkZWwodGhpcywgaGl0KVxuICByZXR1cm4gaGl0IHx8IG51bGxcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgZGVsKHRoaXMsIHRoaXMuX2NhY2hlW2tleV0pXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGFycikge1xuICAvL3Jlc2V0IHRoZSBjYWNoZVxuICB0aGlzLnJlc2V0KCk7XG5cbiAgdmFyIG5vdyA9IERhdGUubm93KClcbiAgLy9BIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICBmb3IgKHZhciBsID0gYXJyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tICkge1xuICAgIHZhciBoaXQgPSBhcnJbbF1cbiAgICB2YXIgZXhwaXJlc0F0ID0gaGl0LmUgfHwgMFxuICAgIGlmIChleHBpcmVzQXQgPT09IDApIHtcbiAgICAgIC8vdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heEFnZSA9IGV4cGlyZXNBdCAtIG5vd1xuICAgICAgLy9kb250IGFkZCBhbHJlYWR5IGV4cGlyZWQgaXRlbXNcbiAgICAgIGlmIChtYXhBZ2UgPiAwKSB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0IChzZWxmLCBrZXksIGRvVXNlKSB7XG4gIHZhciBoaXQgPSBzZWxmLl9jYWNoZVtrZXldXG4gIGlmIChoaXQpIHtcbiAgICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgICBkZWwoc2VsZiwgaGl0KVxuICAgICAgaWYgKCFzZWxmLl9hbGxvd1N0YWxlKSBoaXQgPSB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB1c2Uoc2VsZiwgaGl0KVxuICAgIH1cbiAgICBpZiAoaGl0KSBoaXQgPSBoaXQudmFsdWVcbiAgfVxuICByZXR1cm4gaGl0XG59XG5cbmZ1bmN0aW9uIGlzU3RhbGUoc2VsZiwgaGl0KSB7XG4gIGlmICghaGl0IHx8ICghaGl0Lm1heEFnZSAmJiAhc2VsZi5fbWF4QWdlKSkgcmV0dXJuIGZhbHNlXG4gIHZhciBzdGFsZSA9IGZhbHNlO1xuICB2YXIgZGlmZiA9IERhdGUubm93KCkgLSBoaXQubm93XG4gIGlmIChoaXQubWF4QWdlKSB7XG4gICAgc3RhbGUgPSBkaWZmID4gaGl0Lm1heEFnZVxuICB9IGVsc2Uge1xuICAgIHN0YWxlID0gc2VsZi5fbWF4QWdlICYmIChkaWZmID4gc2VsZi5fbWF4QWdlKVxuICB9XG4gIHJldHVybiBzdGFsZTtcbn1cblxuZnVuY3Rpb24gdXNlIChzZWxmLCBoaXQpIHtcbiAgc2hpZnRMVShzZWxmLCBoaXQpXG4gIGhpdC5sdSA9IHNlbGYuX21ydSArK1xuICBzZWxmLl9scnVMaXN0W2hpdC5sdV0gPSBoaXRcbn1cblxuZnVuY3Rpb24gdHJpbSAoc2VsZikge1xuICB3aGlsZSAoc2VsZi5fbHJ1IDwgc2VsZi5fbXJ1ICYmIHNlbGYuX2xlbmd0aCA+IHNlbGYuX21heClcbiAgICBkZWwoc2VsZiwgc2VsZi5fbHJ1TGlzdFtzZWxmLl9scnVdKVxufVxuXG5mdW5jdGlvbiBzaGlmdExVIChzZWxmLCBoaXQpIHtcbiAgZGVsZXRlIHNlbGYuX2xydUxpc3RbIGhpdC5sdSBdXG4gIHdoaWxlIChzZWxmLl9scnUgPCBzZWxmLl9tcnUgJiYgIXNlbGYuX2xydUxpc3Rbc2VsZi5fbHJ1XSkgc2VsZi5fbHJ1ICsrXG59XG5cbmZ1bmN0aW9uIGRlbCAoc2VsZiwgaGl0KSB7XG4gIGlmIChoaXQpIHtcbiAgICBpZiAoc2VsZi5fZGlzcG9zZSkgc2VsZi5fZGlzcG9zZShoaXQua2V5LCBoaXQudmFsdWUpXG4gICAgc2VsZi5fbGVuZ3RoIC09IGhpdC5sZW5ndGhcbiAgICBzZWxmLl9pdGVtQ291bnQgLS1cbiAgICBkZWxldGUgc2VsZi5fY2FjaGVbIGhpdC5rZXkgXVxuICAgIHNoaWZ0TFUoc2VsZiwgaGl0KVxuICB9XG59XG5cbi8vIGNsYXNzeSwgc2luY2UgVjggcHJlZmVycyBwcmVkaWN0YWJsZSBvYmplY3RzLlxuZnVuY3Rpb24gRW50cnkgKGtleSwgdmFsdWUsIGx1LCBsZW5ndGgsIG5vdywgbWF4QWdlKSB7XG4gIHRoaXMua2V5ID0ga2V5XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB0aGlzLmx1ID0gbHVcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5ub3cgPSBub3dcbiAgaWYgKG1heEFnZSkgdGhpcy5tYXhBZ2UgPSBtYXhBZ2Vcbn1cblxufSkoKVxuIiwiLyohXG4gKiBtdXN0YWNoZS5qcyAtIExvZ2ljLWxlc3Mge3ttdXN0YWNoZX19IHRlbXBsYXRlcyB3aXRoIEphdmFTY3JpcHRcbiAqIGh0dHA6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanNcbiAqL1xuXG4vKmdsb2JhbCBkZWZpbmU6IGZhbHNlIE11c3RhY2hlOiB0cnVlKi9cblxuKGZ1bmN0aW9uIGRlZmluZU11c3RhY2hlIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmIHR5cGVvZiBleHBvcnRzLm5vZGVOYW1lICE9PSAnc3RyaW5nJykge1xuICAgIGZhY3RvcnkoZXhwb3J0cyk7IC8vIENvbW1vbkpTXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTsgLy8gQU1EXG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLk11c3RhY2hlID0ge307XG4gICAgZmFjdG9yeShNdXN0YWNoZSk7IC8vIHNjcmlwdCwgd3NoLCBhc3BcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiBtdXN0YWNoZUZhY3RvcnkgKG11c3RhY2hlKSB7XG5cbiAgdmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXlQb2x5ZmlsbCAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3JlIGNvcnJlY3QgdHlwZW9mIHN0cmluZyBoYW5kbGluZyBhcnJheVxuICAgKiB3aGljaCBub3JtYWxseSByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuICAgKi9cbiAgZnVuY3Rpb24gdHlwZVN0ciAob2JqKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdhcnJheScgOiB0eXBlb2Ygb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gIH1cblxuICAvKipcbiAgICogTnVsbCBzYWZlIHdheSBvZiBjaGVja2luZyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QsXG4gICAqIGluY2x1ZGluZyBpdHMgcHJvdG90eXBlLCBoYXMgYSBnaXZlbiBwcm9wZXJ0eVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzUHJvcGVydHkgKG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKHByb3BOYW1lIGluIG9iaik7XG4gIH1cblxuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2lzc3Vlcy5hcGFjaGUub3JnL2ppcmEvYnJvd3NlL0NPVUNIREItNTc3XG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg5XG4gIHZhciByZWdFeHBUZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xuICBmdW5jdGlvbiB0ZXN0UmVnRXhwIChyZSwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlZ0V4cFRlc3QuY2FsbChyZSwgc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBub25TcGFjZVJlID0gL1xcUy87XG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAoc3RyaW5nKSB7XG4gICAgcmV0dXJuICF0ZXN0UmVnRXhwKG5vblNwYWNlUmUsIHN0cmluZyk7XG4gIH1cblxuICB2YXIgZW50aXR5TWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7JyxcbiAgICAnLyc6ICcmI3gyRjsnXG4gIH07XG5cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoL1smPD5cIidcXC9dL2csIGZ1bmN0aW9uIGZyb21FbnRpdHlNYXAgKHMpIHtcbiAgICAgIHJldHVybiBlbnRpdHlNYXBbc107XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2hpdGVSZSA9IC9cXHMqLztcbiAgdmFyIHNwYWNlUmUgPSAvXFxzKy87XG4gIHZhciBlcXVhbHNSZSA9IC9cXHMqPS87XG4gIHZhciBjdXJseVJlID0gL1xccypcXH0vO1xuICB2YXIgdGFnUmUgPSAvI3xcXF58XFwvfD58XFx7fCZ8PXwhLztcblxuICAvKipcbiAgICogQnJlYWtzIHVwIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHN0cmluZyBpbnRvIGEgdHJlZSBvZiB0b2tlbnMuIElmIHRoZSBgdGFnc2BcbiAgICogYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvIHN0cmluZyB2YWx1ZXM6IHRoZVxuICAgKiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy4gWyBcIjwlXCIsIFwiJT5cIiBdKS4gT2ZcbiAgICogY291cnNlLCB0aGUgZGVmYXVsdCBpcyB0byB1c2UgbXVzdGFjaGVzIChpLmUuIG11c3RhY2hlLnRhZ3MpLlxuICAgKlxuICAgKiBBIHRva2VuIGlzIGFuIGFycmF5IHdpdGggYXQgbGVhc3QgNCBlbGVtZW50cy4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlXG4gICAqIG11c3RhY2hlIHN5bWJvbCB0aGF0IHdhcyB1c2VkIGluc2lkZSB0aGUgdGFnLCBlLmcuIFwiI1wiIG9yIFwiJlwiLiBJZiB0aGUgdGFnXG4gICAqIGRpZCBub3QgY29udGFpbiBhIHN5bWJvbCAoaS5lLiB7e215VmFsdWV9fSkgdGhpcyBlbGVtZW50IGlzIFwibmFtZVwiLiBGb3JcbiAgICogYWxsIHRleHQgdGhhdCBhcHBlYXJzIG91dHNpZGUgYSBzeW1ib2wgdGhpcyBlbGVtZW50IGlzIFwidGV4dFwiLlxuICAgKlxuICAgKiBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgYSB0b2tlbiBpcyBpdHMgXCJ2YWx1ZVwiLiBGb3IgbXVzdGFjaGUgdGFncyB0aGlzIGlzXG4gICAqIHdoYXRldmVyIGVsc2Ugd2FzIGluc2lkZSB0aGUgdGFnIGJlc2lkZXMgdGhlIG9wZW5pbmcgc3ltYm9sLiBGb3IgdGV4dCB0b2tlbnNcbiAgICogdGhpcyBpcyB0aGUgdGV4dCBpdHNlbGYuXG4gICAqXG4gICAqIFRoZSB0aGlyZCBhbmQgZm91cnRoIGVsZW1lbnRzIG9mIHRoZSB0b2tlbiBhcmUgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyxcbiAgICogcmVzcGVjdGl2ZWx5LCBvZiB0aGUgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlLlxuICAgKlxuICAgKiBUb2tlbnMgdGhhdCBhcmUgdGhlIHJvb3Qgbm9kZSBvZiBhIHN1YnRyZWUgY29udGFpbiB0d28gbW9yZSBlbGVtZW50czogMSkgYW5cbiAgICogYXJyYXkgb2YgdG9rZW5zIGluIHRoZSBzdWJ0cmVlIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlIGF0XG4gICAqIHdoaWNoIHRoZSBjbG9zaW5nIHRhZyBmb3IgdGhhdCBzZWN0aW9uIGJlZ2lucy5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgaWYgKCF0ZW1wbGF0ZSlcbiAgICAgIHJldHVybiBbXTtcblxuICAgIHZhciBzZWN0aW9ucyA9IFtdOyAgICAgLy8gU3RhY2sgdG8gaG9sZCBzZWN0aW9uIHRva2Vuc1xuICAgIHZhciB0b2tlbnMgPSBbXTsgICAgICAgLy8gQnVmZmVyIHRvIGhvbGQgdGhlIHRva2Vuc1xuICAgIHZhciBzcGFjZXMgPSBbXTsgICAgICAgLy8gSW5kaWNlcyBvZiB3aGl0ZXNwYWNlIHRva2VucyBvbiB0aGUgY3VycmVudCBsaW5lXG4gICAgdmFyIGhhc1RhZyA9IGZhbHNlOyAgICAvLyBJcyB0aGVyZSBhIHt7dGFnfX0gb24gdGhlIGN1cnJlbnQgbGluZT9cbiAgICB2YXIgbm9uU3BhY2UgPSBmYWxzZTsgIC8vIElzIHRoZXJlIGEgbm9uLXNwYWNlIGNoYXIgb24gdGhlIGN1cnJlbnQgbGluZT9cblxuICAgIC8vIFN0cmlwcyBhbGwgd2hpdGVzcGFjZSB0b2tlbnMgYXJyYXkgZm9yIHRoZSBjdXJyZW50IGxpbmVcbiAgICAvLyBpZiB0aGVyZSB3YXMgYSB7eyN0YWd9fSBvbiBpdCBhbmQgb3RoZXJ3aXNlIG9ubHkgc3BhY2UuXG4gICAgZnVuY3Rpb24gc3RyaXBTcGFjZSAoKSB7XG4gICAgICBpZiAoaGFzVGFnICYmICFub25TcGFjZSkge1xuICAgICAgICB3aGlsZSAoc3BhY2VzLmxlbmd0aClcbiAgICAgICAgICBkZWxldGUgdG9rZW5zW3NwYWNlcy5wb3AoKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGFjZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaGFzVGFnID0gZmFsc2U7XG4gICAgICBub25TcGFjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvcGVuaW5nVGFnUmUsIGNsb3NpbmdUYWdSZSwgY2xvc2luZ0N1cmx5UmU7XG4gICAgZnVuY3Rpb24gY29tcGlsZVRhZ3MgKHRhZ3NUb0NvbXBpbGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnc1RvQ29tcGlsZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHRhZ3NUb0NvbXBpbGUgPSB0YWdzVG9Db21waWxlLnNwbGl0KHNwYWNlUmUsIDIpO1xuXG4gICAgICBpZiAoIWlzQXJyYXkodGFnc1RvQ29tcGlsZSkgfHwgdGFnc1RvQ29tcGlsZS5sZW5ndGggIT09IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWdzOiAnICsgdGFnc1RvQ29tcGlsZSk7XG5cbiAgICAgIG9wZW5pbmdUYWdSZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMF0pICsgJ1xcXFxzKicpO1xuICAgICAgY2xvc2luZ1RhZ1JlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzFdKSk7XG4gICAgICBjbG9zaW5nQ3VybHlSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAoJ30nICsgdGFnc1RvQ29tcGlsZVsxXSkpO1xuICAgIH1cblxuICAgIGNvbXBpbGVUYWdzKHRhZ3MgfHwgbXVzdGFjaGUudGFncyk7XG5cbiAgICB2YXIgc2Nhbm5lciA9IG5ldyBTY2FubmVyKHRlbXBsYXRlKTtcblxuICAgIHZhciBzdGFydCwgdHlwZSwgdmFsdWUsIGNociwgdG9rZW4sIG9wZW5TZWN0aW9uO1xuICAgIHdoaWxlICghc2Nhbm5lci5lb3MoKSkge1xuICAgICAgc3RhcnQgPSBzY2FubmVyLnBvcztcblxuICAgICAgLy8gTWF0Y2ggYW55IHRleHQgYmV0d2VlbiB0YWdzLlxuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChvcGVuaW5nVGFnUmUpO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpIDwgdmFsdWVMZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNociA9IHZhbHVlLmNoYXJBdChpKTtcblxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2hyKSkge1xuICAgICAgICAgICAgc3BhY2VzLnB1c2godG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbnMucHVzaChbICd0ZXh0JywgY2hyLCBzdGFydCwgc3RhcnQgKyAxIF0pO1xuICAgICAgICAgIHN0YXJ0ICs9IDE7XG5cbiAgICAgICAgICAvLyBDaGVjayBmb3Igd2hpdGVzcGFjZSBvbiB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgICAgIGlmIChjaHIgPT09ICdcXG4nKVxuICAgICAgICAgICAgc3RyaXBTcGFjZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1hdGNoIHRoZSBvcGVuaW5nIHRhZy5cbiAgICAgIGlmICghc2Nhbm5lci5zY2FuKG9wZW5pbmdUYWdSZSkpXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBoYXNUYWcgPSB0cnVlO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB0eXBlLlxuICAgICAgdHlwZSA9IHNjYW5uZXIuc2Nhbih0YWdSZSkgfHwgJ25hbWUnO1xuICAgICAgc2Nhbm5lci5zY2FuKHdoaXRlUmUpO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB2YWx1ZS5cbiAgICAgIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhbihlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdDdXJseVJlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuKGN1cmx5UmUpO1xuICAgICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgICB0eXBlID0gJyYnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0aGUgY2xvc2luZyB0YWcuXG4gICAgICBpZiAoIXNjYW5uZXIuc2NhbihjbG9zaW5nVGFnUmUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHRhZyBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gICAgICB0b2tlbiA9IFsgdHlwZSwgdmFsdWUsIHN0YXJ0LCBzY2FubmVyLnBvcyBdO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJyMnIHx8IHR5cGUgPT09ICdeJykge1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJy8nKSB7XG4gICAgICAgIC8vIENoZWNrIHNlY3Rpb24gbmVzdGluZy5cbiAgICAgICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICAgICAgICBpZiAoIW9wZW5TZWN0aW9uKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5vcGVuZWQgc2VjdGlvbiBcIicgKyB2YWx1ZSArICdcIiBhdCAnICsgc3RhcnQpO1xuXG4gICAgICAgIGlmIChvcGVuU2VjdGlvblsxXSAhPT0gdmFsdWUpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICduYW1lJyB8fCB0eXBlID09PSAneycgfHwgdHlwZSA9PT0gJyYnKSB7XG4gICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICAgIC8vIFNldCB0aGUgdGFncyBmb3IgdGhlIG5leHQgdGltZSBhcm91bmQuXG4gICAgICAgIGNvbXBpbGVUYWdzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIG9wZW4gc2VjdGlvbnMgd2hlbiB3ZSdyZSBkb25lLlxuICAgIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgICBpZiAob3BlblNlY3Rpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICAgIHJldHVybiBuZXN0VG9rZW5zKHNxdWFzaFRva2Vucyh0b2tlbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lcyB0aGUgdmFsdWVzIG9mIGNvbnNlY3V0aXZlIHRleHQgdG9rZW5zIGluIHRoZSBnaXZlbiBgdG9rZW5zYCBhcnJheVxuICAgKiB0byBhIHNpbmdsZSB0b2tlbi5cbiAgICovXG4gIGZ1bmN0aW9uIHNxdWFzaFRva2VucyAodG9rZW5zKSB7XG4gICAgdmFyIHNxdWFzaGVkVG9rZW5zID0gW107XG5cbiAgICB2YXIgdG9rZW4sIGxhc3RUb2tlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlblswXSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbiAmJiBsYXN0VG9rZW5bMF0gPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGxhc3RUb2tlblsxXSArPSB0b2tlblsxXTtcbiAgICAgICAgICBsYXN0VG9rZW5bM10gPSB0b2tlblszXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcXVhc2hlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcXVhc2hlZFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtcyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgaW50byBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZSB3aGVyZVxuICAgKiB0b2tlbnMgdGhhdCByZXByZXNlbnQgYSBzZWN0aW9uIGhhdmUgdHdvIGFkZGl0aW9uYWwgaXRlbXM6IDEpIGFuIGFycmF5IG9mXG4gICAqIGFsbCB0b2tlbnMgdGhhdCBhcHBlYXIgaW4gdGhhdCBzZWN0aW9uIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsXG4gICAqIHRlbXBsYXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIHRoYXQgc2VjdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG5lc3RUb2tlbnMgKHRva2Vucykge1xuICAgIHZhciBuZXN0ZWRUb2tlbnMgPSBbXTtcbiAgICB2YXIgY29sbGVjdG9yID0gbmVzdGVkVG9rZW5zO1xuICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuXG4gICAgdmFyIHRva2VuLCBzZWN0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICBjYXNlICcjJzpcbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgICBjb2xsZWN0b3IgPSB0b2tlbls0XSA9IFtdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICBzZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG4gICAgICAgIHNlY3Rpb25bNV0gPSB0b2tlblsyXTtcbiAgICAgICAgY29sbGVjdG9yID0gc2VjdGlvbnMubGVuZ3RoID4gMCA/IHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdWzRdIDogbmVzdGVkVG9rZW5zO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbGxlY3Rvci5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmVzdGVkVG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxlIHN0cmluZyBzY2FubmVyIHRoYXQgaXMgdXNlZCBieSB0aGUgdGVtcGxhdGUgcGFyc2VyIHRvIGZpbmRcbiAgICogdG9rZW5zIGluIHRlbXBsYXRlIHN0cmluZ3MuXG4gICAqL1xuICBmdW5jdGlvbiBTY2FubmVyIChzdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnRhaWwgPSBzdHJpbmc7XG4gICAgdGhpcy5wb3MgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB0YWlsIGlzIGVtcHR5IChlbmQgb2Ygc3RyaW5nKS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLmVvcyA9IGZ1bmN0aW9uIGVvcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFpbCA9PT0gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRyaWVzIHRvIG1hdGNoIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqIFJldHVybnMgdGhlIG1hdGNoZWQgdGV4dCBpZiBpdCBjYW4gbWF0Y2gsIHRoZSBlbXB0eSBzdHJpbmcgb3RoZXJ3aXNlLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuc2NhbiA9IGZ1bmN0aW9uIHNjYW4gKHJlKSB7XG4gICAgdmFyIG1hdGNoID0gdGhpcy50YWlsLm1hdGNoKHJlKTtcblxuICAgIGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggIT09IDApXG4gICAgICByZXR1cm4gJyc7XG5cbiAgICB2YXIgc3RyaW5nID0gbWF0Y2hbMF07XG5cbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpO1xuICAgIHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTa2lwcyBhbGwgdGV4dCB1bnRpbCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGNhbiBiZSBtYXRjaGVkLiBSZXR1cm5zXG4gICAqIHRoZSBza2lwcGVkIHN0cmluZywgd2hpY2ggaXMgdGhlIGVudGlyZSB0YWlsIGlmIG5vIG1hdGNoIGNhbiBiZSBtYWRlLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuc2NhblVudGlsID0gZnVuY3Rpb24gc2NhblVudGlsIChyZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMudGFpbC5zZWFyY2gocmUpLCBtYXRjaDtcblxuICAgIHN3aXRjaCAoaW5kZXgpIHtcbiAgICBjYXNlIC0xOlxuICAgICAgbWF0Y2ggPSB0aGlzLnRhaWw7XG4gICAgICB0aGlzLnRhaWwgPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMDpcbiAgICAgIG1hdGNoID0gJyc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbWF0Y2ggPSB0aGlzLnRhaWwuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIH1cblxuICAgIHRoaXMucG9zICs9IG1hdGNoLmxlbmd0aDtcblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHJlbmRlcmluZyBjb250ZXh0IGJ5IHdyYXBwaW5nIGEgdmlldyBvYmplY3QgYW5kXG4gICAqIG1haW50YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIENvbnRleHQgKHZpZXcsIHBhcmVudENvbnRleHQpIHtcbiAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgIHRoaXMuY2FjaGUgPSB7ICcuJzogdGhpcy52aWV3IH07XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29udGV4dCB1c2luZyB0aGUgZ2l2ZW4gdmlldyB3aXRoIHRoaXMgY29udGV4dFxuICAgKiBhcyB0aGUgcGFyZW50LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKHZpZXcpIHtcbiAgICByZXR1cm4gbmV3IENvbnRleHQodmlldywgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBuYW1lIGluIHRoaXMgY29udGV4dCwgdHJhdmVyc2luZ1xuICAgKiB1cCB0aGUgY29udGV4dCBoaWVyYXJjaHkgaWYgdGhlIHZhbHVlIGlzIGFic2VudCBpbiB0aGlzIGNvbnRleHQncyB2aWV3LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gbG9va3VwIChuYW1lKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcblxuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHZhbHVlID0gY2FjaGVbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgbmFtZXMsIGluZGV4LCBsb29rdXBIaXQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignLicpID4gMCkge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dC52aWV3O1xuICAgICAgICAgIG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgIGluZGV4ID0gMDtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzaW5nIHRoZSBkb3Qgbm90aW9uIHBhdGggaW4gYG5hbWVgLCB3ZSBkZXNjZW5kIHRocm91Z2ggdGhlXG4gICAgICAgICAgICogbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUbyBiZSBjZXJ0YWluIHRoYXQgdGhlIGxvb2t1cCBoYXMgYmVlbiBzdWNjZXNzZnVsLCB3ZSBoYXZlIHRvXG4gICAgICAgICAgICogY2hlY2sgaWYgdGhlIGxhc3Qgb2JqZWN0IGluIHRoZSBwYXRoIGFjdHVhbGx5IGhhcyB0aGUgcHJvcGVydHlcbiAgICAgICAgICAgKiB3ZSBhcmUgbG9va2luZyBmb3IuIFdlIHN0b3JlIHRoZSByZXN1bHQgaW4gYGxvb2t1cEhpdGAuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUaGlzIGlzIHNwZWNpYWxseSBuZWNlc3NhcnkgZm9yIHdoZW4gdGhlIHZhbHVlIGhhcyBiZWVuIHNldCB0b1xuICAgICAgICAgICAqIGB1bmRlZmluZWRgIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGxvb2tpbmcgdXAgcGFyZW50IGNvbnRleHRzLlxuICAgICAgICAgICAqKi9cbiAgICAgICAgICB3aGlsZSAodmFsdWUgIT0gbnVsbCAmJiBpbmRleCA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBuYW1lcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICBsb29rdXBIaXQgPSBoYXNQcm9wZXJ0eSh2YWx1ZSwgbmFtZXNbaW5kZXhdKTtcblxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtuYW1lc1tpbmRleCsrXV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dC52aWV3W25hbWVdO1xuICAgICAgICAgIGxvb2t1cEhpdCA9IGhhc1Byb3BlcnR5KGNvbnRleHQudmlldywgbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9va3VwSGl0KVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgY2FjaGVbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpXG4gICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwodGhpcy52aWV3KTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQSBXcml0ZXIga25vd3MgaG93IHRvIHRha2UgYSBzdHJlYW0gb2YgdG9rZW5zIGFuZCByZW5kZXIgdGhlbSB0byBhXG4gICAqIHN0cmluZywgZ2l2ZW4gYSBjb250ZXh0LiBJdCBhbHNvIG1haW50YWlucyBhIGNhY2hlIG9mIHRlbXBsYXRlcyB0b1xuICAgKiBhdm9pZCB0aGUgbmVlZCB0byBwYXJzZSB0aGUgc2FtZSB0ZW1wbGF0ZSB0d2ljZS5cbiAgICovXG4gIGZ1bmN0aW9uIFdyaXRlciAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGlzIHdyaXRlci5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgYW5kIHJldHVybnMgdGhlIGFycmF5IG9mIHRva2Vuc1xuICAgKiB0aGF0IGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBwYXJzZS5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgIHZhciB0b2tlbnMgPSBjYWNoZVt0ZW1wbGF0ZV07XG5cbiAgICBpZiAodG9rZW5zID09IG51bGwpXG4gICAgICB0b2tlbnMgPSBjYWNoZVt0ZW1wbGF0ZV0gPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0YWdzKTtcblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZ2gtbGV2ZWwgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byByZW5kZXIgdGhlIGdpdmVuIGB0ZW1wbGF0ZWAgd2l0aFxuICAgKiB0aGUgZ2l2ZW4gYHZpZXdgLlxuICAgKlxuICAgKiBUaGUgb3B0aW9uYWwgYHBhcnRpYWxzYCBhcmd1bWVudCBtYXkgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlXG4gICAqIG5hbWVzIGFuZCB0ZW1wbGF0ZXMgb2YgcGFydGlhbHMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGVtcGxhdGUuIEl0IG1heVxuICAgKiBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGxvYWQgcGFydGlhbCB0ZW1wbGF0ZXMgb24gdGhlIGZseVxuICAgKiB0aGF0IHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50OiB0aGUgbmFtZSBvZiB0aGUgcGFydGlhbC5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpIHtcbiAgICB2YXIgdG9rZW5zID0gdGhpcy5wYXJzZSh0ZW1wbGF0ZSk7XG4gICAgdmFyIGNvbnRleHQgPSAodmlldyBpbnN0YW5jZW9mIENvbnRleHQpID8gdmlldyA6IG5ldyBDb250ZXh0KHZpZXcpO1xuICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCB0ZW1wbGF0ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvdy1sZXZlbCBtZXRob2QgdGhhdCByZW5kZXJzIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCB1c2luZ1xuICAgKiB0aGUgZ2l2ZW4gYGNvbnRleHRgIGFuZCBgcGFydGlhbHNgLlxuICAgKlxuICAgKiBOb3RlOiBUaGUgYG9yaWdpbmFsVGVtcGxhdGVgIGlzIG9ubHkgZXZlciB1c2VkIHRvIGV4dHJhY3QgdGhlIHBvcnRpb25cbiAgICogb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgd2FzIGNvbnRhaW5lZCBpbiBhIGhpZ2hlci1vcmRlciBzZWN0aW9uLlxuICAgKiBJZiB0aGUgdGVtcGxhdGUgZG9lc24ndCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLCB0aGlzIGFyZ3VtZW50IG1heVxuICAgKiBiZSBvbWl0dGVkLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbnMgPSBmdW5jdGlvbiByZW5kZXJUb2tlbnMgKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgYnVmZmVyID0gJyc7XG5cbiAgICB2YXIgdG9rZW4sIHN5bWJvbCwgdmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIHN5bWJvbCA9IHRva2VuWzBdO1xuXG4gICAgICBpZiAoc3ltYm9sID09PSAnIycpIHZhbHVlID0gdGhpcy5yZW5kZXJTZWN0aW9uKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICdeJykgdmFsdWUgPSB0aGlzLnJlbmRlckludmVydGVkKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICc+JykgdmFsdWUgPSB0aGlzLnJlbmRlclBhcnRpYWwodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJyYnKSB2YWx1ZSA9IHRoaXMudW5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnbmFtZScpIHZhbHVlID0gdGhpcy5lc2NhcGVkVmFsdWUodG9rZW4sIGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAndGV4dCcpIHZhbHVlID0gdGhpcy5yYXdWYWx1ZSh0b2tlbik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBidWZmZXIgKz0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiByZW5kZXJTZWN0aW9uICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZW5kZXIgYW4gYXJiaXRyYXJ5IHRlbXBsYXRlXG4gICAgLy8gaW4gdGhlIGN1cnJlbnQgY29udGV4dCBieSBoaWdoZXItb3JkZXIgc2VjdGlvbnMuXG4gICAgZnVuY3Rpb24gc3ViUmVuZGVyICh0ZW1wbGF0ZSkge1xuICAgICAgcmV0dXJuIHNlbGYucmVuZGVyKHRlbXBsYXRlLCBjb250ZXh0LCBwYXJ0aWFscyk7XG4gICAgfVxuXG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuO1xuXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgdmFsdWVMZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGogPCB2YWx1ZUxlbmd0aDsgKytqKSB7XG4gICAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlW2pdKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUZW1wbGF0ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMgd2l0aG91dCB0aGUgb3JpZ2luYWwgdGVtcGxhdGUnKTtcblxuICAgICAgLy8gRXh0cmFjdCB0aGUgcG9ydGlvbiBvZiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgdGhhdCB0aGUgc2VjdGlvbiBjb250YWlucy5cbiAgICAgIHZhbHVlID0gdmFsdWUuY2FsbChjb250ZXh0LnZpZXcsIG9yaWdpbmFsVGVtcGxhdGUuc2xpY2UodG9rZW5bM10sIHRva2VuWzVdKSwgc3ViUmVuZGVyKTtcblxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJJbnZlcnRlZCA9IGZ1bmN0aW9uIHJlbmRlckludmVydGVkICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgICAvLyBVc2UgSmF2YVNjcmlwdCdzIGRlZmluaXRpb24gb2YgZmFsc3kuIEluY2x1ZGUgZW1wdHkgYXJyYXlzLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg2XG4gICAgaWYgKCF2YWx1ZSB8fCAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSlcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyUGFydGlhbCA9IGZ1bmN0aW9uIHJlbmRlclBhcnRpYWwgKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscykge1xuICAgIGlmICghcGFydGlhbHMpIHJldHVybjtcblxuICAgIHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24ocGFydGlhbHMpID8gcGFydGlhbHModG9rZW5bMV0pIDogcGFydGlhbHNbdG9rZW5bMV1dO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVG9rZW5zKHRoaXMucGFyc2UodmFsdWUpLCBjb250ZXh0LCBwYXJ0aWFscywgdmFsdWUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUudW5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiB1bmVzY2FwZWRWYWx1ZSAodG9rZW4sIGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5lc2NhcGVkVmFsdWUgPSBmdW5jdGlvbiBlc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIG11c3RhY2hlLmVzY2FwZSh2YWx1ZSk7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yYXdWYWx1ZSA9IGZ1bmN0aW9uIHJhd1ZhbHVlICh0b2tlbikge1xuICAgIHJldHVybiB0b2tlblsxXTtcbiAgfTtcblxuICBtdXN0YWNoZS5uYW1lID0gJ211c3RhY2hlLmpzJztcbiAgbXVzdGFjaGUudmVyc2lvbiA9ICcyLjIuMCc7XG4gIG11c3RhY2hlLnRhZ3MgPSBbICd7eycsICd9fScgXTtcblxuICAvLyBBbGwgaGlnaC1sZXZlbCBtdXN0YWNoZS4qIGZ1bmN0aW9ucyB1c2UgdGhpcyB3cml0ZXIuXG4gIHZhciBkZWZhdWx0V3JpdGVyID0gbmV3IFdyaXRlcigpO1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhlIGRlZmF1bHQgd3JpdGVyLlxuICAgKi9cbiAgbXVzdGFjaGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUgKCkge1xuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLmNsZWFyQ2FjaGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIHRlbXBsYXRlIGluIHRoZSBkZWZhdWx0IHdyaXRlciBhbmQgcmV0dXJucyB0aGVcbiAgICogYXJyYXkgb2YgdG9rZW5zIGl0IGNvbnRhaW5zLiBEb2luZyB0aGlzIGFoZWFkIG9mIHRpbWUgYXZvaWRzIHRoZSBuZWVkIHRvXG4gICAqIHBhcnNlIHRlbXBsYXRlcyBvbiB0aGUgZmx5IGFzIHRoZXkgYXJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVzdGFjaGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGB0ZW1wbGF0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHZpZXdgIGFuZCBgcGFydGlhbHNgIHVzaW5nIHRoZVxuICAgKiBkZWZhdWx0IHdyaXRlci5cbiAgICovXG4gIG11c3RhY2hlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdGVtcGxhdGUhIFRlbXBsYXRlIHNob3VsZCBiZSBhIFwic3RyaW5nXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdidXQgXCInICsgdHlwZVN0cih0ZW1wbGF0ZSkgKyAnXCIgd2FzIGdpdmVuIGFzIHRoZSBmaXJzdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FyZ3VtZW50IGZvciBtdXN0YWNoZSNyZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKScpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLnJlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAwLjQueC4sXG4gIC8qZXNsaW50LWRpc2FibGUgKi8gLy8gZXNsaW50IHdhbnRzIGNhbWVsIGNhc2VkIGZ1bmN0aW9uIG5hbWVcbiAgbXVzdGFjaGUudG9faHRtbCA9IGZ1bmN0aW9uIHRvX2h0bWwgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscywgc2VuZCkge1xuICAgIC8qZXNsaW50LWVuYWJsZSovXG5cbiAgICB2YXIgcmVzdWx0ID0gbXVzdGFjaGUucmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyk7XG5cbiAgICBpZiAoaXNGdW5jdGlvbihzZW5kKSkge1xuICAgICAgc2VuZChyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIGVzY2FwaW5nIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIHVzZXIgbWF5IG92ZXJyaWRlIGl0LlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzI0NFxuICBtdXN0YWNoZS5lc2NhcGUgPSBlc2NhcGVIdG1sO1xuXG4gIC8vIEV4cG9ydCB0aGVzZSBtYWlubHkgZm9yIHRlc3RpbmcsIGJ1dCBhbHNvIGZvciBhZHZhbmNlZCB1c2FnZS5cbiAgbXVzdGFjaGUuU2Nhbm5lciA9IFNjYW5uZXI7XG4gIG11c3RhY2hlLkNvbnRleHQgPSBDb250ZXh0O1xuICBtdXN0YWNoZS5Xcml0ZXIgPSBXcml0ZXI7XG5cbn0pKTtcbiIsIi8qIG9iamVjdC1pdGVyYXRvcnMuanMgLSBNaW5pIFVuZGVyc2NvcmUgbGlicmFyeVxuICogYnkgSm9uYXRoYW4gRWl0ZW5cbiAqXG4gKiBUaGUgbWV0aG9kcyBiZWxvdyBvcGVyYXRlIG9uIG9iamVjdHMgKGJ1dCBub3QgYXJyYXlzKSBzaW1pbGFybHlcbiAqIHRvIFVuZGVyc2NvcmUgKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNjb2xsZWN0aW9ucykuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L29iamVjdC1pdGVyYXRvcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3VtbWFyeSBXcmFwIGFuIG9iamVjdCBmb3Igb25lIG1ldGhvZCBjYWxsLlxuICogQERlc2MgTm90ZSB0aGF0IHRoZSBgbmV3YCBrZXl3b3JkIGlzIG5vdCBuZWNlc3NhcnkuXG4gKiBAcGFyYW0ge29iamVjdHxudWxsfHVuZGVmaW5lZH0gb2JqZWN0IC0gYG51bGxgIG9yIGB1bmRlZmluZWRgIGlzIHRyZWF0ZWQgYXMgYW4gZW1wdHkgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybiB7V3JhcHBlcn0gVGhlIHdyYXBwZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBXcmFwcGVyKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcmFwcGVyKSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyYXBwZXIob2JqZWN0KTtcbiAgICB9XG4gICAgdGhpcy5vcmlnaW5hbFZhbHVlID0gb2JqZWN0O1xuICAgIHRoaXMubyA9IG9iamVjdCB8fCB7fTtcbn1cblxuLyoqXG4gKiBAbmFtZSBXcmFwcGVyLmNoYWluXG4gKiBAc3VtbWFyeSBXcmFwIGFuIG9iamVjdCBmb3IgYSBjaGFpbiBvZiBtZXRob2QgY2FsbHMuXG4gKiBARGVzYyBDYWxscyB0aGUgY29uc3RydWN0b3IgYFdyYXBwZXIoKWAgYW5kIG1vZGlmaWVzIHRoZSB3cmFwcGVyIGZvciBjaGFpbmluZy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge1dyYXBwZXJ9IFRoZSB3cmFwcGVkIG9iamVjdC5cbiAqL1xuV3JhcHBlci5jaGFpbiA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIgd3JhcHBlZCA9IFdyYXBwZXIob2JqZWN0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgd3JhcHBlZC5jaGFpbmluZyA9IHRydWU7XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG59O1xuXG5XcmFwcGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBVbndyYXAgYW4gb2JqZWN0IHdyYXBwZWQgd2l0aCB7QGxpbmsgV3JhcHBlci5jaGFpbnxXcmFwcGVyLmNoYWluKCl9LlxuICAgICAqIEByZXR1cm4ge29iamVjdHxudWxsfHVuZGVmaW5lZH0gVGhlIHZhbHVlIG9yaWdpbmFsbHkgd3JhcHBlZCBieSB0aGUgY29uc3RydWN0b3IuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbZWFjaF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI2VhY2gpIG1ldGhvZDogSXRlcmF0ZSBvdmVyIHRoZSBtZW1iZXJzIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgY2FsbGluZyBgaXRlcmF0ZWUoKWAgd2l0aCBlYWNoLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6IGAodmFsdWUsIGtleSwgb2JqZWN0KWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBpcyB1bmRlZmluZWQ7IGFuIGAuZWFjaGAgbG9vcCBjYW5ub3QgYmUgYnJva2VuIG91dCBvZiAodXNlIHtAbGluayBXcmFwcGVyI2ZpbmR8LmZpbmR9IGluc3RlYWQpLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYGl0ZXJhdGVlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHtXcmFwcGVyfSBUaGUgd3JhcHBlZCBvYmplY3QgZm9yIGNoYWluaW5nLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uIChpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubztcbiAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpdGVyYXRlZS5jYWxsKHRoaXMsIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgfSwgY29udGV4dCB8fCBvKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW2ZpbmRdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNmaW5kKSBtZXRob2Q6IExvb2sgdGhyb3VnaCBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHJldHVybmluZyB0aGUgZmlyc3Qgb25lIHRoYXQgcGFzc2VzIGEgdHJ1dGggdGVzdCAoYHByZWRpY2F0ZWApLCBvciBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBwYXNzZXMgdGhlIHRlc3QuIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgYWNjZXB0YWJsZSBtZW1iZXIsIGFuZCBkb2Vzbid0IG5lY2Vzc2FyaWx5IHRyYXZlcnNlIHRoZSBlbnRpcmUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBgKHZhbHVlLCBrZXksIG9iamVjdClgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHRydXRoeSBpZiB0aGUgbWVtYmVyIHBhc3NlcyB0aGUgdGVzdCBhbmQgZmFsc3kgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYHByZWRpY2F0ZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBwcmVkaWNhdGVgLiAoT3RoZXJ3aXNlLCB0aGUgYHRoaXNgIHZhbHVlIHdpbGwgYmUgdGhlIHVud3JhcHBlZCBvYmplY3QuKVxuICAgICAqIEByZXR1cm4geyp9IFRoZSBmb3VuZCBwcm9wZXJ0eSdzIHZhbHVlLCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGZpbmQ6IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBPYmplY3Qua2V5cyhvKS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLmNhbGwodGhpcywgb1trZXldLCBrZXksIG8pO1xuICAgICAgICAgICAgfSwgY29udGV4dCB8fCBvKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9bcmVzdWx0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtmaWx0ZXJdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNmaWx0ZXIpIG1ldGhvZDogTG9vayB0aHJvdWdoIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgcmV0dXJuaW5nIHRoZSB2YWx1ZXMgb2YgYWxsIG1lbWJlcnMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdCAoYHByZWRpY2F0ZWApLCBvciBlbXB0eSBhcnJheSBpZiBubyB2YWx1ZSBwYXNzZXMgdGhlIHRlc3QuIFRoZSBmdW5jdGlvbiBhbHdheXMgdHJhdmVyc2VzIHRoZSBlbnRpcmUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBgKHZhbHVlLCBrZXksIG9iamVjdClgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHRydXRoeSBpZiB0aGUgbWVtYmVyIHBhc3NlcyB0aGUgdGVzdCBhbmQgZmFsc3kgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYHByZWRpY2F0ZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBwcmVkaWNhdGVgLiAoT3RoZXJ3aXNlLCB0aGUgYHRoaXNgIHZhbHVlIHdpbGwgYmUgdGhlIHVud3JhcHBlZCBvYmplY3QuKVxuICAgICAqIEByZXR1cm4geyp9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbCh0aGlzLCBvW2tleV0sIGtleSwgbykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjb250ZXh0IHx8IG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW21hcF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI21hcCkgbWV0aG9kOiBQcm9kdWNlcyBhIG5ldyBhcnJheSBvZiB2YWx1ZXMgYnkgbWFwcGluZyBlYWNoIHZhbHVlIGluIGxpc3QgdGhyb3VnaCBhIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIChgaXRlcmF0ZWVgKS4gVGhlIGZ1bmN0aW9uIGFsd2F5cyB0cmF2ZXJzZXMgdGhlIGVudGlyZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWUgLSBGb3IgZWFjaCBtZW1iZXIgb2YgdGhlIHdyYXBwZWQgb2JqZWN0LCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogYCh2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIGNvbmNhdGVuYXRlZCB0byB0aGUgZW5kIG9mIHRoZSBuZXcgYXJyYXkuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIElmIGdpdmVuLCBgaXRlcmF0ZWVgIGlzIGJvdW5kIHRvIHRoaXMgb2JqZWN0LiBJbiBvdGhlciB3b3JkcywgdGhpcyBvYmplY3QgYmVjb21lcyB0aGUgYHRoaXNgIHZhbHVlIGluIHRoZSBjYWxscyB0byBgcHJlZGljYXRlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQG1lbWJlck9mIFdyYXBwZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgbWFwOiBmdW5jdGlvbiAoaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZXJhdGVlLmNhbGwodGhpcywgb1trZXldLCBrZXksIG8pKTtcbiAgICAgICAgICAgIH0sIGNvbnRleHQgfHwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbcmVkdWNlXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jcmVkdWNlKSBtZXRob2Q6IEJvaWwgZG93biB0aGUgdmFsdWVzIG9mIGFsbCB0aGUgbWVtYmVycyBvZiB0aGUgd3JhcHBlZCBvYmplY3QgaW50byBhIHNpbmdsZSB2YWx1ZS4gYG1lbW9gIGlzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24sIGFuZCBlYWNoIHN1Y2Nlc3NpdmUgc3RlcCBvZiBpdCBzaG91bGQgYmUgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlKClgLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlIC0gRm9yIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogYChtZW1vLCB2YWx1ZSwga2V5LCBvYmplY3QpYC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgdGhlIG5ldyB2YWx1ZSBvZiBgbWVtb2AgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFttZW1vXSAtIElmIG5vIG1lbW8gaXMgcGFzc2VkIHRvIHRoZSBpbml0aWFsIGludm9jYXRpb24gb2YgcmVkdWNlLCB0aGUgaXRlcmF0ZWUgaXMgbm90IGludm9rZWQgb24gdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3QuIFRoZSBmaXJzdCBlbGVtZW50IGlzIGluc3RlYWQgcGFzc2VkIGFzIHRoZSBtZW1vIGluIHRoZSBpbnZvY2F0aW9uIG9mIHRoZSBpdGVyYXRlZSBvbiB0aGUgbmV4dCBlbGVtZW50IGluIHRoZSBsaXN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYGl0ZXJhdGVlYCBpcyBib3VuZCB0byB0aGlzIG9iamVjdC4gSW4gb3RoZXIgd29yZHMsIHRoaXMgb2JqZWN0IGJlY29tZXMgdGhlIGB0aGlzYCB2YWx1ZSBpbiB0aGUgY2FsbHMgdG8gYGl0ZXJhdGVlYC4gKE90aGVyd2lzZSwgdGhlIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIHRoZSB1bndyYXBwZWQgb2JqZWN0LilcbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgb2YgYG1lbW9gIFwicmVkdWNlZFwiIGFzIHBlciBgaXRlcmF0ZWVgLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlZHVjZTogZnVuY3Rpb24gKGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vO1xuICAgICAgICBpZiAobykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpZHgpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gKCFpZHggJiYgbWVtbyA9PT0gdW5kZWZpbmVkKSA/IG9ba2V5XSA6IGl0ZXJhdGVlKG1lbW8sIG9ba2V5XSwga2V5LCBvKTtcbiAgICAgICAgICAgIH0sIGNvbnRleHQgfHwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW2V4dGVuZF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI2V4dGVuZCkgbWV0aG9kOiBDb3B5IGFsbCBvZiB0aGUgcHJvcGVydGllcyBpbiBlYWNoIG9mIHRoZSBgc291cmNlYCBvYmplY3QgcGFyYW1ldGVyKHMpIG92ZXIgdG8gdGhlICh3cmFwcGVkKSBkZXN0aW5hdGlvbiBvYmplY3QgKHRodXMgbXV0YXRpbmcgaXQpLiBJdCdzIGluLW9yZGVyLCBzbyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbGFzdCBgc291cmNlYCBvYmplY3Qgd2lsbCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdpdGggdGhlIHNhbWUgbmFtZSBpbiBwcmV2aW91cyBhcmd1bWVudHMgb3IgaW4gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiA+IFRoaXMgbWV0aG9kIGNvcGllcyBvd24gbWVtYmVycyBhcyB3ZWxsIGFzIG1lbWJlcnMgaW5oZXJpdGVkIGZyb20gcHJvdG90eXBlIGNoYWluLlxuICAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzb3VyY2UgLSBWYWx1ZXMgb2YgYG51bGxgIG9yIGB1bmRlZmluZWRgIGFyZSB0cmVhdGVkIGFzIGVtcHR5IHBsYWluIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7V3JhcHBlcnxvYmplY3R9IFRoZSB3cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdCBpZiBjaGFpbmluZyBpcyBpbiBlZmZlY3Q7IG90aGVyd2lzZSB0aGUgdW53cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBleHRlbmQ6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBvW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbmluZyA/IHRoaXMgOiBvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBNaW1pY3MgVW5kZXJzY29yZSdzIFtleHRlbmRPd25dKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNleHRlbmRPd24pIG1ldGhvZDogTGlrZSB7QGxpbmsgV3JhcHBlciNleHRlbmR8ZXh0ZW5kfSwgYnV0IG9ubHkgY29waWVzIGl0cyBcIm93blwiIHByb3BlcnRpZXMgb3ZlciB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzb3VyY2UgLSBWYWx1ZXMgb2YgYG51bGxgIG9yIGB1bmRlZmluZWRgIGFyZSB0cmVhdGVkIGFzIGVtcHR5IHBsYWluIG9iamVjdHMuXG4gICAgICogQHJldHVybiB7V3JhcHBlcnxvYmplY3R9IFRoZSB3cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdCBpZiBjaGFpbmluZyBpcyBpbiBlZmZlY3Q7IG90aGVyd2lzZSB0aGUgdW53cmFwcGVkIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBleHRlbmRPd246IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBXcmFwcGVyKG9iamVjdCkuZWFjaChmdW5jdGlvbiAodmFsLCBrZXkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICAgICAgICAgICAgb1trZXldID0gdmFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFpbmluZyA/IHRoaXMgOiBvO1xuICAgIH1cbn07XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmRcbmlmICghQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRlbmQtbmF0aXZlXG4gICAgICAgIGlmICh0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGggPj4+IDA7XG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV3JhcHBlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEBtb2R1bGUgb3ZlcnJpZGVyICovXG5cbi8qKlxuICogTWl4ZXMgbWVtYmVycyBvZiBhbGwgYHNvdXJjZXNgIGludG8gYHRhcmdldGAsIGhhbmRsaW5nIGdldHRlcnMgYW5kIHNldHRlcnMgcHJvcGVybHkuXG4gKlxuICogQW55IG51bWJlciBvZiBgc291cmNlc2Agb2JqZWN0cyBtYXkgYmUgZ2l2ZW4gYW5kIGVhY2ggaXMgY29waWVkIGluIHR1cm4uXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBvdmVycmlkZXIgPSByZXF1aXJlKCdvdmVycmlkZXInKTtcbiAqIHZhciB0YXJnZXQgPSB7IGE6IDEgfSwgc291cmNlMSA9IHsgYjogMiB9LCBzb3VyY2UyID0geyBjOiAzIH07XG4gKiB0YXJnZXQgPT09IG92ZXJyaWRlcih0YXJnZXQsIHNvdXJjZTEsIHNvdXJjZTIpOyAvLyB0cnVlXG4gKiAvLyB0YXJnZXQgb2JqZWN0IG5vdyBoYXMgYSwgYiwgYW5kIGM7IHNvdXJjZSBvYmplY3RzIHVudG91Y2hlZFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgLSBUaGUgdGFyZ2V0IG9iamVjdCB0byByZWNlaXZlIHNvdXJjZXMuXG4gKiBAcGFyYW0gey4uLm9iamVjdH0gW3NvdXJjZXNdIC0gT2JqZWN0KHMpIGNvbnRhaW5pbmcgbWVtYmVycyB0byBjb3B5IHRvIGB0YXJnZXRgLiAoT21pdHRpbmcgaXMgYSBuby1vcC4pXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgdGFyZ2V0IG9iamVjdCAoYHRhcmdldGApXG4gKi9cbmZ1bmN0aW9uIG92ZXJyaWRlcih0YXJnZXQsIHNvdXJjZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG1peEluLmNhbGwodGFyZ2V0LCBhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWl4IGB0aGlzYCBtZW1iZXJzIGludG8gYHRhcmdldGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEEuIFNpbXBsZSB1c2FnZSAodXNpbmcgLmNhbGwpOlxuICogdmFyIG1peEluVG8gPSByZXF1aXJlKCdvdmVycmlkZXInKS5taXhJblRvO1xuICogdmFyIHRhcmdldCA9IHsgYTogMSB9LCBzb3VyY2UgPSB7IGI6IDIgfTtcbiAqIHRhcmdldCA9PT0gb3ZlcnJpZGVyLm1peEluVG8uY2FsbChzb3VyY2UsIHRhcmdldCk7IC8vIHRydWVcbiAqIC8vIHRhcmdldCBvYmplY3Qgbm93IGhhcyBib3RoIGEgYW5kIGI7IHNvdXJjZSBvYmplY3QgdW50b3VjaGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEIuIFNlbWFudGljIHVzYWdlICh3aGVuIHRoZSBzb3VyY2UgaG9zdHMgdGhlIG1ldGhvZCk6XG4gKiB2YXIgbWl4SW5UbyA9IHJlcXVpcmUoJ292ZXJyaWRlcicpLm1peEluVG87XG4gKiB2YXIgdGFyZ2V0ID0geyBhOiAxIH0sIHNvdXJjZSA9IHsgYjogMiwgbWl4SW5UbzogbWl4SW5UbyB9O1xuICogdGFyZ2V0ID09PSBzb3VyY2UubWl4SW5Ubyh0YXJnZXQpOyAvLyB0cnVlXG4gKiAvLyB0YXJnZXQgb2JqZWN0IG5vdyBoYXMgYm90aCBhIGFuZCBiOyBzb3VyY2Ugb2JqZWN0IHVudG91Y2hlZFxuICpcbiAqIEB0aGlzIHtvYmplY3R9IFRhcmdldC5cbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSB0YXJnZXQgb2JqZWN0IChgdGFyZ2V0YClcbiAqIEBtZW1iZXJPZiBtb2R1bGU6b3ZlcnJpZGVyXG4gKi9cbmZ1bmN0aW9uIG1peEluVG8odGFyZ2V0KSB7XG4gICAgdmFyIGRlc2NyaXB0b3I7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgICAgaWYgKChkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBrZXkpKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIE1peCBgc291cmNlYCBtZW1iZXJzIGludG8gYHRoaXNgLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBLiBTaW1wbGUgdXNhZ2UgKHVzaW5nIC5jYWxsKTpcbiAqIHZhciBtaXhJbiA9IHJlcXVpcmUoJ292ZXJyaWRlcicpLm1peEluO1xuICogdmFyIHRhcmdldCA9IHsgYTogMSB9LCBzb3VyY2UgPSB7IGI6IDIgfTtcbiAqIHRhcmdldCA9PT0gb3ZlcnJpZGVyLm1peEluLmNhbGwodGFyZ2V0LCBzb3VyY2UpIC8vIHRydWVcbiAqIC8vIHRhcmdldCBvYmplY3Qgbm93IGhhcyBib3RoIGEgYW5kIGI7IHNvdXJjZSBvYmplY3QgdW50b3VjaGVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEIuIFNlbWFudGljIHVzYWdlICh3aGVuIHRoZSB0YXJnZXQgaG9zdHMgdGhlIG1ldGhvZCk6XG4gKiB2YXIgbWl4SW4gPSByZXF1aXJlKCdvdmVycmlkZXInKS5taXhJbjtcbiAqIHZhciB0YXJnZXQgPSB7IGE6IDEsIG1peEluOiBtaXhJbiB9LCBzb3VyY2UgPSB7IGI6IDIgfTtcbiAqIHRhcmdldCA9PT0gdGFyZ2V0Lm1peEluKHNvdXJjZSkgLy8gdHJ1ZVxuICogLy8gdGFyZ2V0IG5vdyBoYXMgYm90aCBhIGFuZCBiIChhbmQgbWl4SW4pOyBzb3VyY2UgdW50b3VjaGVkXG4gKlxuICogQHBhcmFtIHNvdXJjZVxuICogQHJldHVybnMge29iamVjdH0gVGhlIHRhcmdldCBvYmplY3QgKGB0aGlzYClcbiAqIEBtZW1iZXJPZiBvdmVycmlkZXJcbiAqIEBtZW1iZXJPZiBtb2R1bGU6b3ZlcnJpZGVyXG4gKi9cbmZ1bmN0aW9uIG1peEluKHNvdXJjZSkge1xuICAgIHZhciBkZXNjcmlwdG9yO1xuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKChkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxub3ZlcnJpZGVyLm1peEluVG8gPSBtaXhJblRvO1xub3ZlcnJpZGVyLm1peEluID0gbWl4SW47XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlcnJpZGVyO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJFR0VYUF9JTkRJUkVDVElPTiA9IC9eKFxcdyspXFwoKFxcdyspXFwpJC87ICAvLyBmaW5kcyBjb21wbGV0ZSBwYXR0ZXJuIGEoYikgd2hlcmUgYm90aCBhIGFuZCBiIGFyZSByZWdleCBcIndvcmRzXCJcblxuLyoqIEB0eXBlZGVmIHtvYmplY3R9IHZhbHVlSXRlbVxuICogWW91IHNob3VsZCBzdXBwbHkgYm90aCBgbmFtZWAgYW5kIGBhbGlhc2AgYnV0IHlvdSBjb3VsZCBvbWl0IG9uZSBvciB0aGUgb3RoZXIgYW5kIHdoaWNoZXZlciB5b3UgcHJvdmlkZSB3aWxsIGJlIHVzZWQgZm9yIGJvdGguXG4gKiA+IElmIHlvdSBvbmx5IGdpdmUgdGhlIGBuYW1lYCBwcm9wZXJ0eSwgeW91IG1pZ2h0IGFzIHdlbGwganVzdCBnaXZlIGEgc3RyaW5nIGZvciB7QGxpbmsgbWVudUl0ZW19IHJhdGhlciB0aGFuIHRoaXMgb2JqZWN0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lPWFsaWFzXSAtIFZhbHVlIG9mIGB2YWx1ZWAgYXR0cmlidXRlIG9mIGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYWxpYXM9bmFtZV0gLSBUZXh0IG9mIGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZV0gT25lIG9mIHRoZSBrZXlzIG9mIGB0aGlzLmNvbnZlcnRlcnNgLiBJZiBub3Qgb25lIG9mIHRoZXNlIChpbmNsdWRpbmcgYHVuZGVmaW5lZGApLCBmaWVsZCB2YWx1ZXMgd2lsbCBiZSB0ZXN0ZWQgd2l0aCBhIHN0cmluZyBjb21wYXJpc29uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaGlkZGVuPWZhbHNlXVxuICovXG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fG1lbnVJdGVtW119IHN1Ym1lbnVJdGVtXG4gKiBAc3VtbWFyeSBIaWVyYXJjaGljYWwgYXJyYXkgb2Ygc2VsZWN0IGxpc3QgaXRlbXMuXG4gKiBAZGVzYyBEYXRhIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgdGhlIGxpc3Qgb2YgYDxvcHRpb24+Li4uPC9vcHRpb24+YCBhbmQgYDxvcHRncm91cD4uLi48L29wdGdyb3VwPmAgZWxlbWVudHMgdGhhdCBtYWtlIHVwIGEgYDxzZWxlY3Q+Li4uPC9zZWxlY3Q+YCBlbGVtZW50LlxuICpcbiAqID4gQWx0ZXJuYXRlIGZvcm06IEluc3RlYWQgb2YgYW4gb2JqZWN0IHdpdGggYSBgbWVudWAgcHJvcGVydHkgY29udGFpbmluZyBhbiBhcnJheSwgbWF5IGl0c2VsZiBiZSB0aGF0IGFycmF5LiBCb3RoIGZvcm1zIGhhdmUgdGhlIG9wdGlvbmFsIGBsYWJlbGAgcHJvcGVydHkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xhYmVsXSAtIERlZmF1bHRzIHRvIGEgZ2VuZXJhdGVkIHN0cmluZyBvZiB0aGUgZm9ybSBcIkdyb3VwIG5bLm1dLi4uXCIgd2hlcmUgZWFjaCBkZWNpbWFsIHBvc2l0aW9uIHJlcHJlc2VudHMgYSBsZXZlbCBvZiB0aGUgb3B0Z3JvdXAgaGllcmFyY2h5LlxuICogQHByb3BlcnR5IHttZW51SXRlbVtdfSBzdWJtZW51XG4gKi9cblxuLyoqIEB0eXBlZGVmIHtzdHJpbmd8dmFsdWVJdGVtfHN1Ym1lbnVJdGVtfSBtZW51SXRlbVxuICogTWF5IGJlIG9uZSBvZiB0aHJlZSBwb3NzaWJsZSB0eXBlcyB0aGF0IHNwZWNpZnkgZWl0aGVyIGFuIGA8b3B0aW9uPi4uLi48L29wdGlvbj5gIGVsZW1lbnQgb3IgYW4gYDxvcHRncm91cD4uLi4uPC9vcHRncm91cD5gIGVsZW1lbnQgYXMgZm9sbG93czpcbiAqICogSWYgYSBgc3RyaW5nYCwgc3BlY2lmaWVzIHRoZSB0ZXh0IG9mIGFuIGA8b3B0aW9uPi4uLi48L29wdGlvbj5gIGVsZW1lbnQgd2l0aCBubyBgdmFsdWVgIGF0dHJpYnV0ZS4gKEluIHRoZSBhYnNlbmNlIG9mIGEgYHZhbHVlYCBhdHRyaWJ1dGUsIHRoZSBgdmFsdWVgIHByb3BlcnR5IG9mIHRoZSBlbGVtZW50IGRlZmF1bHRzIHRvIHRoZSB0ZXh0LilcbiAqICogSWYgc2hhcGVkIGxpa2UgYSB7QGxpbmsgdmFsdWVJdGVtfSBvYmplY3QsIHNwZWNpZmllcyBib3RoIHRoZSB0ZXh0IGFuZCB2YWx1ZSBvZiBhbiBgPG9wdGlvbi4uLi48L29wdGlvbj5gIGVsZW1lbnQuXG4gKiAqIElmIHNoYXBlZCBsaWtlIGEge0BsaW5rIHN1Ym1lbnVJdGVtfSBvYmplY3QgKG9yIGl0cyBhbHRlcm5hdGUgYXJyYXkgZm9ybSksIHNwZWNpZmllcyBhbiBgPG9wdGdyb3VwPi4uLi48L29wdGdyb3VwPmAgZWxlbWVudC5cbiAqL1xuXG4vKipcbiAqIEBzdW1tYXJ5IEJ1aWxkcyBhIG5ldyBtZW51IHByZS1wb3B1bGF0ZWQgd2l0aCBpdGVtcyBhbmQgZ3JvdXBzLlxuICogQGRlc2MgVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgbmV3IHBvcC11cCBtZW51IChhLmsuYS4gXCJkcm9wLWRvd25cIikuIFRoaXMgaXMgYSBgPHNlbGVjdD4uLi48L3NlbGVjdD5gIGVsZW1lbnQsIHByZS1wb3B1bGF0ZWQgd2l0aCBpdGVtcyAoYDxvcHRpb24+Li4uPC9vcHRpb24+YCBlbGVtZW50cykgYW5kIGdyb3VwcyAoYDxvcHRncm91cD4uLi48L29wdGdyb3VwPmAgZWxlbWVudHMpLlxuICogPiBCb251czogVGhpcyBmdW5jdGlvbiBhbHNvIGJ1aWxkcyBgaW5wdXQgdHlwZT10ZXh0YCBlbGVtZW50cy5cbiAqID4gTk9URTogVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgT1BUR1JPVVAgZWxlbWVudHMgZm9yIHN1YnRyZWVzLiBIb3dldmVyLCBub3RlIHRoYXQgSFRNTDUgc3BlY2lmaWVzIHRoYXQgT1BUR1JPVVAgZWxlbW5lbnRzIG1hZGUgbm90IG5lc3QhIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIHRoZSBtYXJrdXAgZm9yIHRoZW0gYnV0IHRoZXkgYXJlIG5vdCByZW5kZXJlZCBieSBtb3N0IGJyb3dzZXJzLCBvciBub3QgY29tcGxldGVseS4gVGhlcmVmb3JlLCBmb3Igbm93LCBkbyBub3Qgc3BlY2lmeSBtb3JlIHRoYW4gb25lIGxldmVsIHN1YnRyZWVzLiBGdXR1cmUgdmVyc2lvbnMgb2YgSFRNTCBtYXkgc3VwcG9ydCBpdC4gSSBhbHNvIHBsYW4gdG8gYWRkIGhlcmUgb3B0aW9ucyB0byBhdm9pZCBPUFRHUk9VUFMgZW50aXJlbHkgZWl0aGVyIGJ5IGluZGVudGluZyBvcHRpb24gdGV4dCwgb3IgYnkgY3JlYXRpbmcgYWx0ZXJuYXRlIERPTSBub2RlcyB1c2luZyBgPGxpPmAgaW5zdGVhZCBvZiBgPHNlbGVjdD5gLCBvciBib3RoLlxuICogQG1lbWJlck9mIHBvcE1lbnVcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSBlbCAtIE11c3QgYmUgb25lIG9mIChjYXNlLXNlbnNpdGl2ZSk6XG4gKiAqIHRleHQgYm94IC0gYW4gYEhUTUxJbnB1dEVsZW1lbnRgIHRvIHVzZSBhbiBleGlzdGluZyBlbGVtZW50IG9yIGAnSU5QVVQnYCB0byBjcmVhdGUgYSBuZXcgb25lXG4gKiAqIGRyb3AtZG93biAtIGFuIGBIVE1MU2VsZWN0RWxlbWVudGAgdG8gdXNlIGFuIGV4aXN0aW5nIGVsZW1lbnQgb3IgYCdTRUxFQ1QnYCB0byBjcmVhdGUgYSBuZXcgb25lXG4gKiAqIHN1Ym1lbnUgLSBhbiBgSFRNTE9wdEdyb3VwRWxlbWVudGAgdG8gdXNlIGFuIGV4aXN0aW5nIGVsZW1lbnQgb3IgYCdPUFRHUk9VUCdgIHRvIGNyZWF0ZSBhIG5ldyBvbmUgKG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seSlcbiAqXG4gKiBAcGFyYW0ge21lbnVJdGVtW119IFttZW51XSAtIEhpZXJhcmNoaWNhbCBsaXN0IG9mIHN0cmluZ3MgdG8gYWRkIGFzIGA8b3B0aW9uPi4uLjwvb3B0aW9uPmAgb3IgYDxvcHRncm91cD4uLi4uPC9vcHRncm91cD5gIGVsZW1lbnRzLiBPbWl0dGluZyBjcmVhdGVzIGEgdGV4dCBib3guXG4gKlxuICogQHBhcmFtIHtudWxsfHN0cmluZ30gW29wdGlvbnMucHJvbXB0PScnXSAtIEFkZHMgYW4gaW5pdGlhbCBgPG9wdGlvbj4uLi48L29wdGlvbj5gIGVsZW1lbnQgdG8gdGhlIGRyb3AtZG93biB3aXRoIHRoaXMgdmFsdWUgaW4gcGFyZW50aGVzZXMgYXMgaXRzIGB0ZXh0YDsgYW5kIGVtcHR5IHN0cmluZyBhcyBpdHMgYHZhbHVlYC4gRGVmYXVsdCBpcyBlbXB0eSBzdHJpbmcsIHdoaWNoIGNyZWF0ZXMgYSBibGFuayBwcm9tcHQ7IGBudWxsYCBzdXBwcmVzc2VzIHByb21wdCBhbHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc29ydF0gLSBXaGV0aGVyIHRvIGFscGhhIHNvcnQgb3Igbm90LiBJZiB0cnV0aHksIHNvcnRzIGVhY2ggb3B0Z3JvdXAgb24gaXRzIGBsYWJlbGA7IGFuZCBlYWNoIHNlbGVjdCBvcHRpb24gb24gaXRzIHRleHQgKGl0cyBgYWxpYXNgIGlmIGdpdmVuOyBvciBpdHMgYG5hbWVgIGlmIG5vdCkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnMuYmxhY2tsaXN0XSAtIE9wdGlvbmFsIGxpc3Qgb2YgbWVudSBpdGVtIG5hbWVzIHRvIGJlIGlnbm9yZWQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gW29wdGlvbnMuYnJlYWRjcnVtYnNdIC0gTGlzdCBvZiBvcHRpb24gZ3JvdXAgc2VjdGlvbiBudW1iZXJzIChyb290IGlzIHNlY3Rpb24gMCkuIChGb3IgaW50ZXJuYWwgdXNlLilcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFwcGVuZD1mYWxzZV0gLSBXaGVuIGBlbGAgaXMgYW4gZXhpc3RpbmcgYDxzZWxlY3Q+YCBFbGVtZW50LCBnaXZpbmcgdHJ1dGh5IHZhbHVlIGFkZHMgdGhlIG5ldyBjaGlsZHJlbiB3aXRob3V0IGZpcnN0IHJlbW92aW5nIGV4aXN0aW5nIGNoaWxkcmVuLlxuICpcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBFaXRoZXIgYSBgPHNlbGVjdD5gIG9yIGA8b3B0Z3JvdXA+YCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBidWlsZChlbCwgbWVudSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIHByb21wdCA9IG9wdGlvbnMucHJvbXB0LFxuICAgICAgICBibGFja2xpc3QgPSBvcHRpb25zLmJsYWNrbGlzdCxcbiAgICAgICAgc29ydCA9IG9wdGlvbnMuc29ydCxcbiAgICAgICAgYnJlYWRjcnVtYnMgPSBvcHRpb25zLmJyZWFkY3J1bWJzIHx8IFtdLFxuICAgICAgICBwYXRoID0gYnJlYWRjcnVtYnMubGVuZ3RoID8gYnJlYWRjcnVtYnMuam9pbignLicpICsgJy4nIDogJycsXG4gICAgICAgIHN1YnRyZWVOYW1lID0gcG9wTWVudS5zdWJ0cmVlLFxuICAgICAgICBncm91cEluZGV4ID0gMCxcbiAgICAgICAgdGFnTmFtZTtcblxuICAgIGlmIChlbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgdGFnTmFtZSA9IGVsLnRhZ05hbWU7XG4gICAgICAgIGlmICghb3B0aW9ucy5hcHBlbmQpIHtcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9ICcnOyAvLyByZW1vdmUgYWxsIDxvcHRpb24+IGFuZCA8b3B0Z3JvdXA+IGVsZW1lbnRzXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0YWdOYW1lID0gZWw7XG4gICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAobWVudSkge1xuICAgICAgICB2YXIgYWRkLCBuZXdPcHRpb247XG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICAgICAgYWRkID0gZWwuYWRkO1xuICAgICAgICAgICAgaWYgKHByb21wdCkge1xuICAgICAgICAgICAgICAgIG5ld09wdGlvbiA9IG5ldyBPcHRpb24ocHJvbXB0LCAnJyk7XG4gICAgICAgICAgICAgICAgbmV3T3B0aW9uLmlubmVySFRNTCArPSAnJmhlbGxpcDsnO1xuICAgICAgICAgICAgICAgIGVsLmFkZChuZXdPcHRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9tcHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbC5hZGQobmV3IE9wdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZCA9IGVsLmFwcGVuZENoaWxkO1xuICAgICAgICAgICAgZWwubGFiZWwgPSBwcm9tcHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc29ydCkge1xuICAgICAgICAgICAgbWVudSA9IG1lbnUuc2xpY2UoKS5zb3J0KGl0ZW1Db21wYXJhdG9yKTsgLy8gc29ydGVkIGNsb25lXG4gICAgICAgIH1cblxuICAgICAgICBtZW51LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgLy8gaWYgaXRlbSBpcyBvZiBmb3JtIGEoYikgYW5kIHRoZXJlIGlzIGFuIGZ1bmN0aW9uIGEgaW4gb3B0aW9ucywgdGhlbiBpdGVtID0gb3B0aW9ucy5hKGIpXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kaXJlY3Rpb24gPSBpdGVtLm1hdGNoKFJFR0VYUF9JTkRJUkVDVElPTik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gaW5kaXJlY3Rpb25bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gaW5kaXJlY3Rpb25bMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmID0gb3B0aW9uc1thXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gZihiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdidWlsZDogRXhwZWN0ZWQgb3B0aW9ucy4nICsgYSArICcgdG8gYmUgYSBmdW5jdGlvbi4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3VidHJlZSA9IGl0ZW1bc3VidHJlZU5hbWVdIHx8IGl0ZW07XG4gICAgICAgICAgICBpZiAoc3VidHJlZSBpbnN0YW5jZW9mIEFycmF5KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBicmVhZGNydW1iczogYnJlYWRjcnVtYnMuY29uY2F0KCsrZ3JvdXBJbmRleCksXG4gICAgICAgICAgICAgICAgICAgIHByb21wdDogaXRlbS5sYWJlbCB8fCAnR3JvdXAgJyArIHBhdGggKyBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBzb3J0LFxuICAgICAgICAgICAgICAgICAgICBibGFja2xpc3Q6IGJsYWNrbGlzdFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgb3B0Z3JvdXAgPSBidWlsZCgnT1BUR1JPVVAnLCBzdWJ0cmVlLCBncm91cE9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGdyb3VwLmNoaWxkRWxlbWVudENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG9wdGdyb3VwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShibGFja2xpc3QgJiYgYmxhY2tsaXN0LmluZGV4T2YoaXRlbSkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkLmNhbGwoZWwsIG5ldyBPcHRpb24oaXRlbSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5oaWRkZW4pIHtcblxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gaXRlbS5uYW1lIHx8IGl0ZW0uYWxpYXM7XG4gICAgICAgICAgICAgICAgaWYgKCEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdC5pbmRleE9mKG5hbWUpID49IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZC5jYWxsKGVsLCBuZXcgT3B0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hbGlhcyB8fCBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbC50eXBlID0gJ3RleHQnO1xuICAgIH1cblxuICAgIHJldHVybiBlbDtcbn1cblxuZnVuY3Rpb24gaXRlbUNvbXBhcmF0b3IoYSwgYikge1xuICAgIGEgPSBhLmFsaWFzIHx8IGEubmFtZSB8fCBhLmxhYmVsIHx8IGE7XG4gICAgYiA9IGIuYWxpYXMgfHwgYi5uYW1lIHx8IGIubGFiZWwgfHwgYjtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgUmVjdXJzaXZlbHkgc2VhcmNoZXMgdGhlIGNvbnRleHQgYXJyYXkgb2YgYG1lbnVJdGVtYHMgZm9yIGEgbmFtZWQgYGl0ZW1gLlxuICogQG1lbWJlck9mIHBvcE1lbnVcbiAqIEB0aGlzIEFycmF5XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2V5cz1bcG9wTWVudS5kZWZhdWx0S2V5XV0gLSBQcm9wZXJ0aWVzIHRvIHNlYXJjaCBlYWNoIG1lbnVJdGVtIHdoZW4gaXQgaXMgYW4gb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jYXNlU2Vuc2l0aXZlPWZhbHNlXSAtIElnbm9yZSBjYXNlIHdoaWxlIHNlYXJjaGluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIFZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfG1lbnVJdGVtfSBUaGUgZm91bmQgaXRlbSBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGxvb2t1cChvcHRpb25zLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhbHVlID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgc2hhbGxvdywgZGVlcCwgaXRlbSwgcHJvcCxcbiAgICAgICAga2V5cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5rZXlzIHx8IFtwb3BNZW51LmRlZmF1bHRLZXldLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlID0gb3B0aW9ucyAmJiBvcHRpb25zLmNhc2VTZW5zaXRpdmU7XG5cbiAgICB2YWx1ZSA9IHRvU3RyaW5nKHZhbHVlLCBjYXNlU2Vuc2l0aXZlKTtcblxuICAgIHNoYWxsb3cgPSB0aGlzLmZpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgc3VidHJlZSA9IGl0ZW1bcG9wTWVudS5zdWJ0cmVlXSB8fCBpdGVtO1xuXG4gICAgICAgIGlmIChzdWJ0cmVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiAoZGVlcCA9IGxvb2t1cC5jYWxsKHN1YnRyZWUsIG9wdGlvbnMsIHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9TdHJpbmcoaXRlbSwgY2FzZVNlbnNpdGl2ZSkgPT09IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGl0ZW1ba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgJiYgdG9TdHJpbmcocHJvcCwgY2FzZVNlbnNpdGl2ZSkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXRlbSA9IGRlZXAgfHwgc2hhbGxvdztcblxuICAgIHJldHVybiBpdGVtICYmIChpdGVtLm5hbWUgPyBpdGVtIDogeyBuYW1lOiBpdGVtIH0pO1xufVxuXG5mdW5jdGlvbiB0b1N0cmluZyhzLCBjYXNlU2Vuc2l0aXZlKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIGlmIChzKSB7XG4gICAgICAgIHJlc3VsdCArPSBzOyAvLyBjb252ZXJ0IHMgdG8gc3RyaW5nXG4gICAgICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBSZWN1cnNpdmVseSB3YWxrcyB0aGUgY29udGV4dCBhcnJheSBvZiBgbWVudUl0ZW1gcyBhbmQgY2FsbHMgYGl0ZXJhdGVlYCBvbiBlYWNoIGl0ZW0gdGhlcmVpbi5cbiAqIEBkZXNjIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggZWFjaCBpdGVtICh0ZXJtaW5hbCBub2RlKSBpbiB0aGUgbWVudSB0cmVlIGFuZCBhIGZsYXQgMC1iYXNlZCBpbmRleC4gUmVjdXJzZXMgb24gbWVtYmVyIHdpdGggbmFtZSBvZiBgcG9wTWVudS5zdWJ0cmVlYC5cbiAqXG4gKiBUaGUgbm9kZSB3aWxsIGFsd2F5cyBiZSBhIHtAbGluayB2YWx1ZUl0ZW19IG9iamVjdDsgd2hlbiBhIGBzdHJpbmdgLCBpdCBpcyBib3hlZCBmb3IgeW91LlxuICpcbiAqIEBtZW1iZXJPZiBwb3BNZW51XG4gKlxuICogQHRoaXMgQXJyYXlcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIEZvciBlYWNoIGl0ZW0gaW4gdGhlIG1lbnUsIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGg6XG4gKiAqIHRoZSBgdmFsdWVJdGVtYCAoaWYgdGhlIGl0ZW0gaXMgYSBwcmltYXRpdmUgc3RyaW5nLCBpdCBpcyB3cmFwcGVkIHVwIGZvciB5b3UpXG4gKiAqIGEgMC1iYXNlZCBgb3JkaW5hbGBcbiAqXG4gKiBUaGUgYGl0ZXJhdGVlYCByZXR1cm4gdmFsdWUgY2FuIGJlIHVzZWQgdG8gcmVwbGFjZSB0aGUgaXRlbSwgYXMgZm9sbG93czpcbiAqICogYHVuZGVmaW5lZGAgLSBkbyBub3RoaW5nXG4gKiAqIGBudWxsYCAtIHNwbGljZSBvdXQgdGhlIGl0ZW07IHJlc3VsdGluZyBlbXB0eSBzdWJtZW51cyBhcmUgYWxzbyBzcGxpY2VkIG91dCAoc2VlIG5vdGUpXG4gKiAqIGFueXRoaW5nIGVsc2UgLSByZXBsYWNlIHRoZSBpdGVtIHdpdGggdGhpcyB2YWx1ZTsgaWYgdmFsdWUgaXMgYSBzdWJ0cmVlIChpLmUuLCBhbiBhcnJheSkgYGl0ZXJhdGVlYCB3aWxsIHRoZW4gYmUgY2FsbGVkIHRvIHdhbGsgaXQgYXMgd2VsbCAoc2VlIG5vdGUpXG4gKlxuICogPiBOb3RlOiBSZXR1cm5pbmcgYW55dGhpbmcgKG90aGVyIHRoYW4gYHVuZGVmaW5lZGApIGZyb20gYGl0ZXJhdGVlYCB3aWxsIChkZWVwbHkpIG11dGF0ZSB0aGUgb3JpZ2luYWwgYG1lbnVgIHNvIHlvdSBtYXkgd2FudCB0byBjb3B5IGl0IGZpcnN0IChkZWVwbHksIGluY2x1ZGluZyBhbGwgbGV2ZWxzIG9mIGFycmF5IG5lc3RpbmcgYnV0IG5vdCB0aGUgdGVybWluYWwgbm9kZSBvYmplY3RzKS5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgaXRlbXMgKHRlcm1pbmFsIG5vZGVzKSBpbiB0aGUgbWVudSB0cmVlLlxuICovXG5mdW5jdGlvbiB3YWxrKGl0ZXJhdGVlKSB7XG4gICAgdmFyIG1lbnUgPSB0aGlzLFxuICAgICAgICBvcmRpbmFsID0gMCxcbiAgICAgICAgc3VidHJlZU5hbWUgPSBwb3BNZW51LnN1YnRyZWUsXG4gICAgICAgIGksIGl0ZW0sIHN1YnRyZWUsIG5ld1ZhbDtcblxuICAgIGZvciAoaSA9IG1lbnUubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IG1lbnVbaV07XG4gICAgICAgIHN1YnRyZWUgPSBpdGVtW3N1YnRyZWVOYW1lXSB8fCBpdGVtO1xuXG4gICAgICAgIGlmICghKHN1YnRyZWUgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgIHN1YnRyZWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN1YnRyZWUpIHtcbiAgICAgICAgICAgIG5ld1ZhbCA9IGl0ZXJhdGVlKGl0ZW0ubmFtZSA/IGl0ZW0gOiB7IG5hbWU6IGl0ZW0gfSwgb3JkaW5hbCk7XG4gICAgICAgICAgICBvcmRpbmFsICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChuZXdWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVudS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIG9yZGluYWwgLT0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZW51W2ldID0gaXRlbSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgc3VidHJlZSA9IGl0ZW1bc3VidHJlZU5hbWVdIHx8IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHN1YnRyZWUgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRyZWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VidHJlZSkge1xuICAgICAgICAgICAgb3JkaW5hbCArPSB3YWxrLmNhbGwoc3VidHJlZSwgaXRlcmF0ZWUpO1xuICAgICAgICAgICAgaWYgKHN1YnRyZWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbWVudS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgb3JkaW5hbCAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yZGluYWw7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgRm9ybWF0IGl0ZW0gbmFtZSB3aXRoIGl0J3MgYWxpYXMgd2hlbiBhdmFpbGFibGUuXG4gKiBAbWVtYmVyT2YgcG9wTWVudVxuICogQHBhcmFtIHtzdHJpbmd8dmFsdWVJdGVtfSBpdGVtXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIG5hbWUgYW5kIGFsaWFzLlxuICovXG5mdW5jdGlvbiBmb3JtYXRJdGVtKGl0ZW0pIHtcbiAgICB2YXIgcmVzdWx0ID0gaXRlbS5uYW1lIHx8IGl0ZW07XG4gICAgaWYgKGl0ZW0uYWxpYXMpIHtcbiAgICAgICAgcmVzdWx0ID0gJ1wiJyArIGl0ZW0uYWxpYXMgKyAnXCIgKCcgKyByZXN1bHQgKyAnKSc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gaXNHcm91cFByb3h5KHMpIHtcbiAgICByZXR1cm4gUkVHRVhQX0lORElSRUNUSU9OLnRlc3Qocyk7XG59XG5cbi8qKlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgcG9wTWVudSA9IHtcbiAgICBidWlsZDogYnVpbGQsXG4gICAgd2Fsazogd2FsayxcbiAgICBsb29rdXA6IGxvb2t1cCxcbiAgICBmb3JtYXRJdGVtOiBmb3JtYXRJdGVtLFxuICAgIGlzR3JvdXBQcm94eTogaXNHcm91cFByb3h5LFxuICAgIHN1YnRyZWU6ICdzdWJtZW51JyxcbiAgICBkZWZhdWx0S2V5OiAnbmFtZSdcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcG9wTWVudTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBub2RlLCBicm93c2VyICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWFkLW9ubHkgcHJvcGVydHkgYW5kIGF0dGFjaGVzIGl0IHRvIHRoZSBwcm92aWRlZCBjb250ZXh0LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBmb3IgbmV3IHByb3BlcnR5LlxuICogQHBhcmFtIHsqfSBbdmFsdWVdIC0gVmFsdWUgb2YgbmV3IHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBhZGRSZWFkT25seVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3IgUG9pbnRcbiAqXG4gKiBAZGVzYyBUaGlzIG9iamVjdCByZXByZXNlbnRzIGEgc2luZ2xlIHBvaW50IGluIGFuIGFic3RyYWN0IDItZGltZW5zaW9uYWwgbWF0cml4LlxuICpcbiAqIFRoZSB1bml0IG9mIG1lYXN1cmUgaXMgdHlwaWNhbGx5IHBpeGVscy5cbiAqIChJZiB1c2VkIHRvIG1vZGVsIGNvbXB1dGVyIGdyYXBoaWNzLCB2ZXJ0aWNhbCBjb29yZGluYXRlcyBhcmUgdHlwaWNhbGx5IG1lYXN1cmVkIGRvd253YXJkc1xuICogZnJvbSB0aGUgdG9wIG9mIHRoZSB3aW5kb3cuIFRoaXMgY29udmVudGlvbiBob3dldmVyIGlzIG5vdCBpbmhlcmVudCBpbiB0aGlzIG9iamVjdC4pXG4gKlxuICogTm90ZTogVGhpcyBvYmplY3Qgc2hvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIG5ldyBwb2ludCdzIGB4YCBwcm9wZXJ0eVxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgbmV3IHBvaW50J3MgYHlgIHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHhcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBzdW1tYXJ5IFRoaXMgcG9pbnQncyBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBQb2ludHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAneCcsIE51bWJlcih4KSB8fCAwKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHlcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBzdW1tYXJ5IFRoaXMgcG9pbnQncyB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgUG9pbnR8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ3knLCBOdW1iZXIoeSkgfHwgMCk7XG5cbn1cblxuUG9pbnQucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBwb2ludCB3aGljaCBpcyB0aGlzIHBvaW50J3MgcG9zaXRpb24gaW5jcmVhc2VkIGJ5IGNvb3JkaW5hdGVzIG9mIGdpdmVuIGBvZmZzZXRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IG9mZnNldCAtIEhvcml6b250YWwgYW5kIHZlcnRpY2FsIHZhbHVlcyB0byBhZGQgdG8gdGhpcyBwb2ludCdzIGNvb3JkaW5hdGVzLlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwbHVzOiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIHRoaXMueCArIG9mZnNldC54LFxuICAgICAgICAgICAgdGhpcy55ICsgb2Zmc2V0LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBwb2ludCB3aGljaCBpcyB0aGlzIHBvaW50J3MgcG9zaXRpb24gaW5jcmVhc2VkIGJ5IGdpdmVuIG9mZnNldHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRYPTBdIC0gVmFsdWUgdG8gYWRkIHRvIHRoaXMgcG9pbnQncyBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXRZPTBdIC0gVmFsdWUgdG8gYWRkIHRvIHRoaXMgcG9pbnQncyBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBsdXNYWTogZnVuY3Rpb24ob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgdGhpcy54ICsgKG9mZnNldFggfHwgMCksXG4gICAgICAgICAgICB0aGlzLnkgKyAob2Zmc2V0WSB8fCAwKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IHBvaW50IHdoaWNoIGlzIHRoaXMgcG9pbnQncyBwb3NpdGlvbiBkZWNyZWFzZWQgYnkgY29vcmRpbmF0ZXMgb2YgZ2l2ZW4gYG9mZnNldGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gb2Zmc2V0IC0gSG9yaXpvbnRhbCBhbmQgdmVydGljYWwgdmFsdWVzIHRvIHN1YnRyYWN0IGZyb20gdGhpcyBwb2ludCdzIGNvb3JkaW5hdGVzLlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtaW51czogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICB0aGlzLnggLSBvZmZzZXQueCxcbiAgICAgICAgICAgIHRoaXMueSAtIG9mZnNldC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtQb2ludH0gQSBuZXcgYFBvaW50YCBwb3NpdGlvbmVkIHRvIGxlYXN0IHggYW5kIGxlYXN0IHkgb2YgdGhpcyBwb2ludCBhbmQgZ2l2ZW4gYG9mZnNldGAuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludC5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgbWluOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgTWF0aC5taW4odGhpcy54LCBwb2ludC54KSxcbiAgICAgICAgICAgIE1hdGgubWluKHRoaXMueSwgcG9pbnQueSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBgUG9pbnRgIHBvc2l0aW9uZWQgdG8gZ3JlYXRlc3QgeCBhbmQgZ3JlYXRlc3QgeSBvZiB0aGlzIHBvaW50IGFuZCBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIG1heDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgIE1hdGgubWF4KHRoaXMueCwgcG9pbnQueCksXG4gICAgICAgICAgICBNYXRoLm1heCh0aGlzLnksIHBvaW50LnkpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IERpc3RhbmNlIGJldHdlZW4gZ2l2ZW4gYHBvaW50YCBhbmQgdGhpcyBwb2ludCB1c2luZyBQeXRoYWdvcmVhbiBUaGVvcmVtIGZvcm11bGEuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IGZyb20gd2hpY2ggdG8gY29tcHV0ZSB0aGUgZGlzdGFuY2UgdG8gdGhpcyBwb2ludC5cbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciBkZWx0YVggPSBwb2ludC54IC0gdGhpcy54LFxuICAgICAgICAgICAgZGVsdGFZID0gcG9pbnQueSAtIHRoaXMueTtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgZGVsdGFYICogZGVsdGFYICtcbiAgICAgICAgICAgIGRlbHRhWSAqIGRlbHRhWVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5OiBgZXF1YWxgLilfXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGV4YWN0bHkgZXF1YWwgdG8gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgdGhpcy54ID09PSBwb2ludC54ICYmXG4gICAgICAgICAgICAgICAgdGhpcy55ID09PSBwb2ludC55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGdyZWF0ZXIgdGhhbiB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnRcbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ3JlYXRlclRoYW46IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnggPiBwb2ludC54ICYmXG4gICAgICAgICAgICB0aGlzLnkgPiBwb2ludC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBsZXNzIHRoYW4gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50XG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGxlc3NUaGFuOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy54IDwgcG9pbnQueCAmJlxuICAgICAgICAgICAgdGhpcy55IDwgcG9pbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5IGBncmVhdGVyVGhhbkVxdWFsVG9gLilfXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aG9zZSBvZiBnaXZlbiBgcG9pbnRgLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnRcbiAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ3JlYXRlclRoYW5PckVxdWFsVG86IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnggPj0gcG9pbnQueCAmJlxuICAgICAgICAgICAgdGhpcy55ID49IHBvaW50LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogXyhGb3JtZXJseSBgbGVzc1RoYW5FcXVhbFRvYC4pX1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgdG8gY29tcGFyZSB0byB0aGlzIHBvaW50LlxuICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBsZXNzVGhhbk9yRXF1YWxUbzogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMueCA8PSBwb2ludC54ICYmXG4gICAgICAgICAgICB0aGlzLnkgPD0gcG9pbnQueVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfKEZvcm1lcmx5IGBpc0NvbnRhaW5lZFdpdGhpblJlY3RhbmdsZWAuKV9cbiAgICAgKiBAcGFyYW0gcmVjdCB7UmVjdGFuZ2xlfSAtIFJlY3RhbmdsZSB0byB0ZXN0IHRoaXMgcG9pbnQgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiB0aGlzIHBvaW50IGlzIHdpdGhpbiBnaXZlbiBgcmVjdGAuXG4gICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAqL1xuICAgIHdpdGhpbjogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICB2YXIgbWluWCA9IHJlY3Qub3JpZ2luLngsXG4gICAgICAgICAgICBtYXhYID0gbWluWCArIHJlY3QuZXh0ZW50Lng7XG4gICAgICAgIHZhciBtaW5ZID0gcmVjdC5vcmlnaW4ueSxcbiAgICAgICAgICAgIG1heFkgPSBtaW5ZICsgcmVjdC5leHRlbnQueTtcblxuICAgICAgICBpZiAocmVjdC5leHRlbnQueCA8IDApIHtcbiAgICAgICAgICAgIG1pblggPSBtYXhYO1xuICAgICAgICAgICAgbWF4WCA9IHJlY3Qub3JpZ2luLng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjdC5leHRlbnQueSA8IDApIHtcbiAgICAgICAgICAgIG1pblkgPSBtYXhZO1xuICAgICAgICAgICAgbWF4WSA9IHJlY3Qub3JpZ2luLnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbWluWCA8PSB0aGlzLnggJiYgdGhpcy54IDwgbWF4WCAmJlxuICAgICAgICAgICAgbWluWSA8PSB0aGlzLnkgJiYgdGhpcy55IDwgbWF4WVxuICAgICAgICApO1xuICAgIH1cbn07XG5cblBvaW50LnByb3RvdHlwZS5FUSA9IFBvaW50LnByb3RvdHlwZS5lcXVhbHM7XG5Qb2ludC5wcm90b3R5cGUuR1QgPSBQb2ludC5wcm90b3R5cGUuZ3JlYXRlclRoYW47XG5Qb2ludC5wcm90b3R5cGUuTFQgPSBQb2ludC5wcm90b3R5cGUubGVzc1RoYW47XG5Qb2ludC5wcm90b3R5cGUuR0UgPSBQb2ludC5wcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsVG87XG5Qb2ludC5wcm90b3R5cGUuTEUgPSBQb2ludC5wcm90b3R5cGUubGVzc1RoYW5PckVxdWFsVG87XG5cblxuLyoqXG4gKiBAY29uc3RydWN0b3IgUmVjdGFuZ2xlXG4gKlxuICogQGRlc2MgVGhpcyBvYmplY3QgcmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgd2l0aGluIGFuIGFic3RyYWN0IDItZGltZW5zaW9uYWwgbWF0cml4LlxuICpcbiAqIFRoZSB1bml0IG9mIG1lYXN1cmUgaXMgdHlwaWNhbGx5IHBpeGVscy5cbiAqIChJZiB1c2VkIHRvIG1vZGVsIGNvbXB1dGVyIGdyYXBoaWNzLCB2ZXJ0aWNhbCBjb29yZGluYXRlcyBhcmUgdHlwaWNhbGx5IG1lYXN1cmVkIGRvd253YXJkc1xuICogZnJvbSB0aGUgdG9wIG9mIHRoZSB3aW5kb3cuIFRoaXMgY29udmVudGlvbiBob3dldmVyIGlzIG5vdCBpbmhlcmVudCBpbiB0aGlzIG9iamVjdC4pXG4gKlxuICogTm9ybWFsbHksIHRoZSBgeGAgYW5kIGB5YCBwYXJhbWV0ZXJzIHRvIHRoZSBjb25zdHJ1Y3RvciBkZXNjcmliZSB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlIHJlY3QuXG4gKiBIb3dldmVyLCBuZWdhdGl2ZSB2YWx1ZXMgb2YgYHdpZHRoYCBhbmQgYGhlaWdodGAgd2lsbCBiZSBhZGRlZCB0byB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAuIFRoYXQgaXMsXG4gKiBhIG5lZ2F0aXZlIHZhbHVlIG9mIHRoZSBgd2lkdGhgIHBhcmFtZXRlciB3aWxsIGV4dGVuZCB0aGUgcmVjdCB0byB0aGUgbGVmdCBvZiB0aGUgZ2l2ZW4gYHhgIGFuZFxuICogYSBuZWdhdGl2ZSB2YWx1ZSBvZiB0aGUgYGhlaWdodGAgcGFyYW1ldGVyIHdpbGwgZXh0ZW5kIHRoZSByZWN0IGFib3ZlIHRoZSBnaXZlbiBgeWAuXG4gKiBJbiBhbnkgY2FzZSwgYWZ0ZXIgaW5zdGFudGlhdGlvbiB0aGUgZm9sbG93aW5nIGFyZSBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSB0cnVlOlxuICogKiBUaGUgYGV4dGVudGAsIGB3aWR0aGAsIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzIF9hbHdheXNfIGdpdmUgcG9zaXRpdmUgdmFsdWVzLlxuICogKiBUaGUgYG9yaWdpbmAsIGB0b3BgLCBhbmQgYGxlZnRgIHByb3BlcnRpZXMgX2Fsd2F5c18gcmVmbGVjdCB0aGUgdXBwZXIgbGVmdCBjb3JuZXIuXG4gKiAqIFRoZSBgY29ybmVyYCwgYGJvdHRvbWAsIGFuZCBgcmlnaHRgIHByb3BlcnRpZXMgX2Fsd2F5c18gcmVmbGVjdCB0aGUgbG93ZXIgcmlnaHQgY29ybmVyLlxuICpcbiAqIE5vdGU6IFRoaXMgb2JqZWN0IHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIGNvb3JkaW5hdGUgb2Ygc29tZSBjb3JuZXIgb2YgdGhlIHJlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBjb29yZGluYXRlIG9mIHNvbWUgY29ybmVyIG9mIHRoZSByZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0wXSAtIFdpZHRoIG9mIHRoZSBuZXcgcmVjdC4gTWF5IGJlIG5lZ2F0aXZlIChzZWUgYWJvdmUpLlxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9MF0gLSBIZWlnaHQgb2YgdGhlIG5ldyByZWN0LiBNYXkgYmUgbmVnYXRpdmUgKHNlZSBhYm92ZSkuXG4gKi9cbmZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICB4ID0gTnVtYmVyKHgpIHx8IDA7XG4gICAgeSA9IE51bWJlcih5KSB8fCAwO1xuICAgIHdpZHRoID0gTnVtYmVyKHdpZHRoKSB8fCAwO1xuICAgIGhlaWdodCA9IE51bWJlcihoZWlnaHQpIHx8IDA7XG5cbiAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgIHggKz0gd2lkdGg7XG4gICAgICAgIHdpZHRoID0gLXdpZHRoO1xuICAgIH1cblxuICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgIHkgKz0gaGVpZ2h0O1xuICAgICAgICBoZWlnaHQgPSAtaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIG9yaWdpblxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAc3VtbWFyeSBVcHBlciBsZWZ0IGNvcm5lciBvZiB0aGlzIHJlY3QuXG4gICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGlua3BsYWluIFJlY3RhbmdsZXxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ29yaWdpbicsIG5ldyBQb2ludCh4LCB5KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBleHRlbnRcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQHN1bW1hcnkgdGhpcyByZWN0J3Mgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgKiBAZGVzYyBVbmxpa2UgdGhlIG90aGVyIGBQb2ludGAgcHJvcGVydGllcywgYGV4dGVudGAgaXMgbm90IGEgZ2xvYmFsIGNvb3JkaW5hdGUgcGFpcjsgcmF0aGVyIGl0IGNvbnNpc3RzIG9mIGEgX3dpZHRoXyAoYHhgLCBhbHdheXMgcG9zaXRpdmUpIGFuZCBhIF9oZWlnaHRfIChgeWAsIGFsd2F5cyBwb3NpdGl2ZSkuXG4gICAgICpcbiAgICAgKiBUaGlzIG9iamVjdCBtaWdodCBiZSBtb3JlIGxlZ2l0aW1hdGVseSB0eXBlZCBhcyBzb21ldGhpbmcgbGlrZSBgQXJlYWAgd2l0aCBwcm9wZXJ0aWVzIGB3aWR0aGAgYW5kIGBoZWlnaHRgOyBob3dldmVyIHdlIHdhbnRlZCBpdCB0byBiZSBhYmxlIHRvIHVzZSBpdCBlZmZpY2llbnRseSB3aXRoIGEgcG9pbnQncyBgcGx1c2AgYW5kIGBtaW51c2AgbWV0aG9kcyAodGhhdCBpcywgd2l0aG91dCB0aG9zZSBtZXRob2RzIGhhdmluZyB0byBjaGVjayBhbmQgYnJhbmNoIG9uIHRoZSB0eXBlIG9mIGl0cyBwYXJhbWV0ZXIpLlxuICAgICAqXG4gICAgICogQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGlua3BsYWluIFJlY3RhbmdsZXxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQHNlZSBUaGUge0BsaW5rIFJlY3RhbmdsZSNjb3JuZXJ8Y29ybmVyfSBtZXRob2QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ2V4dGVudCcsIG5ldyBQb2ludCh3aWR0aCwgaGVpZ2h0KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBjb3JuZXJcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQHN1bW1hcnkgTG93ZXIgcmlnaHQgY29ybmVyIG9mIHRoaXMgcmVjdC5cbiAgICAgKiBAZGVzYyBUaGlzIGlzIGEgY2FsY3VsYXRlZCB2YWx1ZSBjcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rcGxhaW4gUmVjdGFuZ2xlfGNvbnN0cnVjdG9yfS4gSXQgaXMgYG9yaWdpbmAgb2Zmc2V0IGJ5IGBleHRlbnRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZXNlIGNvb3JkaW5hdGVzIGFjdHVhbGx5IHBvaW50IHRvIHRoZSBwaXhlbCBvbmUgYmVsb3cgYW5kIG9uZSB0byB0aGUgcmlnaHQgb2YgdGhlIHJlY3QncyBhY3R1YWwgbG93ZXIgcmlnaHQgcGl4ZWwuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ2Nvcm5lcicsIG5ldyBQb2ludCh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGNlbnRlclxuICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgKiBAc3VtbWFyeSBDZW50ZXIgb2YgdGhpcyByZWN0LlxuICAgICAqIEBkZXNjIENyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmtwbGFpbiBSZWN0YW5nbGV8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICdjZW50ZXInLCBuZXcgUG9pbnQoeCArICh3aWR0aCAvIDIpLCB5ICsgKGhlaWdodCAvIDIpKSk7XG5cbn1cblxuUmVjdGFuZ2xlLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBNaW5pbXVtIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBNaW5pbXVtIGhvcml6b250YWwgY29vcmRpbmF0ZSBvZiB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBNYXhpbXVtIHZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0ICsgMS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCBib3R0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcm5lci55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgTWF4aW11bSBob3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0ICsgMS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ybmVyLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgKiBAc3VtbWFyeSBXaWR0aCBvZiB0aGlzIHJlY3QgKGFsd2F5cyBwb3NpdGl2ZSkuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVudC54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgSGVpZ2h0IG9mIHRoaXMgcmVjdCAoYWx3YXlzIHBvc2l0aXZlKS5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVudC55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICogQHN1bW1hcnkgQXJlYSBvZiB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgYXJlYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQSBjb3B5IG9mIHRoaXMgcmVjdCBidXQgd2l0aCBob3Jpem9udGFsIHBvc2l0aW9uIHJlc2V0IHRvIGdpdmVuIGB4YCBhbmQgbm8gd2lkdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBIb3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhlIG5ldyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZmxhdHRlblhBdDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB0aGlzLm9yaWdpbi55LCAwLCB0aGlzLmV4dGVudC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQSBjb3B5IG9mIHRoaXMgcmVjdCBidXQgd2l0aCB2ZXJ0aWNhbCBwb3NpdGlvbiByZXNldCB0byBnaXZlbiBgeWAgYW5kIG5vIGhlaWdodC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFZlcnRpY2FsIGNvb3JkaW5hdGUgb2YgdGhlIG5ldyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZmxhdHRlbllBdDogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLm9yaWdpbi54LCB5LCB0aGlzLmV4dGVudC54LCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgZ2l2ZW4gYHBvaW50YCBlbnRpcmVseSBjb250YWluZWQgd2l0aGluIHRoaXMgcmVjdC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludE9yUmVjdCAtIFRoZSBwb2ludCBvciByZWN0IHRvIHRlc3QgZm9yIGNvbnRhaW5tZW50LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50T3JSZWN0KSB7XG4gICAgICAgIHJldHVybiBwb2ludE9yUmVjdC53aXRoaW4odGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHkgYGlzQ29udGFpbmVkV2l0aGluUmVjdGFuZ2xlYC4pX1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIGB0aGlzYCByZWN0IGlzIGVudGlyZWx5IGNvbnRhaW5lZCB3aXRoaW4gZ2l2ZW4gYHJlY3RgLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gUmVjdGFuZ2xlIHRvIHRlc3QgYWdhaW5zdCB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB3aXRoaW46IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY3Qub3JpZ2luLmxlc3NUaGFuT3JFcXVhbFRvKHRoaXMub3JpZ2luKSAmJlxuICAgICAgICAgICAgcmVjdC5jb3JuZXIuZ3JlYXRlclRoYW5PckVxdWFsVG8odGhpcy5jb3JuZXIpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF8oRm9ybWVybHk6IGBpbnNldEJ5YC4pX1xuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoYXQgaXMgZW5sYXJnZWQvc2hydW5rIGJ5IGdpdmVuIGBwYWRkaW5nYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyAtIEFtb3VudCBieSB3aGljaCB0byBpbmNyZWFzZSAoKykgb3IgZGVjcmVhc2UgKC0pIHRoaXMgcmVjdFxuICAgICAqIEBzZWUgVGhlIHtAbGluayBSZWN0YW5nbGUjc2hyaW5rQnl8c2hyaW5rQnl9IG1ldGhvZC5cbiAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdyb3dCeTogZnVuY3Rpb24ocGFkZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgIHRoaXMub3JpZ2luLnggKyBwYWRkaW5nLFxuICAgICAgICAgICAgdGhpcy5vcmlnaW4ueSArIHBhZGRpbmcsXG4gICAgICAgICAgICB0aGlzLmV4dGVudC54IC0gcGFkZGluZyAtIHBhZGRpbmcsXG4gICAgICAgICAgICB0aGlzLmV4dGVudC55IC0gcGFkZGluZyAtIHBhZGRpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBUaGF0IGlzIGVubGFyZ2VkL3NocnVuayBieSBnaXZlbiBgcGFkZGluZ2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmcgLSBBbW91bnQgYnkgd2hpY2ggdG8gZGVjcmVhc2UgKCspIG9yIGluY3JlYXNlICgtKSB0aGlzIHJlY3QuXG4gICAgICogQHNlZSBUaGUge0BsaW5rIFJlY3RhbmdsZSNncm93Qnl8Z3Jvd0J5fSBtZXRob2QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzaHJpbmtCeTogZnVuY3Rpb24ocGFkZGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm93QnkoLXBhZGRpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBCb3VuZGluZyByZWN0IHRoYXQgY29udGFpbnMgYm90aCB0aGlzIHJlY3QgYW5kIHRoZSBnaXZlbiBgcmVjdGAuXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBUaGUgcmVjdGFuZ2xlIHRvIHVuaW9uIHdpdGggdGhpcyByZWN0LlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgdW5pb246IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luLm1pbihyZWN0Lm9yaWdpbiksXG4gICAgICAgICAgICBjb3JuZXIgPSB0aGlzLmNvcm5lci5tYXgocmVjdC5jb3JuZXIpLFxuICAgICAgICAgICAgZXh0ZW50ID0gY29ybmVyLm1pbnVzKG9yaWdpbik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICBvcmlnaW4ueCwgb3JpZ2luLnksXG4gICAgICAgICAgICBleHRlbnQueCwgZXh0ZW50LnlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaXRlcmF0ZSBvdmVyIGFsbCBwb2ludHMgd2l0aGluIHRoaXMgcmVjdCwgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3IgZWFjaC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcixudW1iZXIpfSBpdGVyYXRlZSAtIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggcG9pbnQuXG4gICAgICogQm91bmQgdG8gYGNvbnRleHRgIHdoZW4gZ2l2ZW47IG90aGVyd2lzZSBpdCBpcyBib3VuZCB0byB0aGlzIHJlY3QuXG4gICAgICogRWFjaCBpbnZvY2F0aW9uIG9mIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiAgICAgKiB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dD10aGlzXSAtIENvbnRleHQgdG8gYmluZCB0byBgaXRlcmF0ZWVgICh3aGVuIG5vdCBgdGhpc2ApLlxuICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICAgICAgZm9yICh2YXIgeCA9IHRoaXMub3JpZ2luLngsIHgyID0gdGhpcy5jb3JuZXIueDsgeCA8IHgyOyB4KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSB0aGlzLm9yaWdpbi55LCB5MiA9IHRoaXMuY29ybmVyLnk7IHkgPCB5MjsgeSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0ZWUuY2FsbChjb250ZXh0LCB4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBPbmUgb2Y6XG4gICAgICogKiBfSWYgdGhpcyByZWN0IGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gYHJlY3RgOl9cbiAgICAgKiAgICAgIGEgbmV3IHJlY3QgcmVwcmVzZW50aW5nIHRoYXQgaW50ZXJzZWN0aW9uLlxuICAgICAqICogX0lmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IGFuZCBgaWZOb25lQWN0aW9uYCBkZWZpbmVkOl9cbiAgICAgKiAgICAgIHJlc3VsdCBvZiBjYWxsaW5nIGBpZk5vbmVBY3Rpb25gLlxuICAgICAqICogX0lmIGl0IGRvZXNuJ3QgaW50ZXJzZWN0IGFuZCBgaWZOb25lQWN0aW9uYCB1bmRlZmluZWQ6X1xuICAgICAqICAgICAgYG51bGxgLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBpbnRlcnNlY3Qgd2l0aCB0aGlzIHJlY3QuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihSZWN0YW5nbGUpfSBbaWZOb25lQWN0aW9uXSAtIFdoZW4gbm8gaW50ZXJzZWN0aW9uLCBpbnZva2UgYW5kIHJldHVybiByZXN1bHQuXG4gICAgICogQm91bmQgdG8gYGNvbnRleHRgIHdoZW4gZ2l2ZW47IG90aGVyd2lzZSBib3VuZCB0byB0aGlzIHJlY3QuXG4gICAgICogSW52b2tlZCB3aXRoIGByZWN0YCBhcyBzb2xlIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHQ9dGhpc10gLSBDb250ZXh0IHRvIGJpbmQgdG8gYGlmTm9uZUFjdGlvbmAgKHdoZW4gbm90IGB0aGlzYCkuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKHJlY3QsIGlmTm9uZUFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbCxcbiAgICAgICAgICAgIG9yaWdpbiA9IHRoaXMub3JpZ2luLm1heChyZWN0Lm9yaWdpbiksXG4gICAgICAgICAgICBjb3JuZXIgPSB0aGlzLmNvcm5lci5taW4ocmVjdC5jb3JuZXIpLFxuICAgICAgICAgICAgZXh0ZW50ID0gY29ybmVyLm1pbnVzKG9yaWdpbik7XG5cbiAgICAgICAgaWYgKGV4dGVudC54ID4gMCAmJiBleHRlbnQueSA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55LFxuICAgICAgICAgICAgICAgIGV4dGVudC54LCBleHRlbnQueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaWZOb25lQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpZk5vbmVBY3Rpb24uY2FsbChjb250ZXh0IHx8IHRoaXMsIHJlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgdGhpcyByZWN0IG92ZXJsYXBzIHdpdGggZ2l2ZW4gYHJlY3RgLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBpbnRlcnNlY3Qgd2l0aCB0aGlzIHJlY3QuXG4gICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICByZWN0LmNvcm5lci54ID4gdGhpcy5vcmlnaW4ueCAmJlxuICAgICAgICAgICAgcmVjdC5jb3JuZXIueSA+IHRoaXMub3JpZ2luLnkgJiZcbiAgICAgICAgICAgIHJlY3Qub3JpZ2luLnggPCB0aGlzLmNvcm5lci54ICYmXG4gICAgICAgICAgICByZWN0Lm9yaWdpbi55IDwgdGhpcy5jb3JuZXIueVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbi8vIEludGVyZmFjZVxuZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xuZXhwb3J0cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblxuICAgIC8vIFRoaXMgY2xvc3VyZSBzdXBwb3J0cyBOb2RlSlMtbGVzcyBjbGllbnQgc2lkZSBpbmNsdWRlcyB3aXRoIDxzY3JpcHQ+IHRhZ3MuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L21ubS5cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvciBSYW5nZVNlbGVjdGlvbk1vZGVsXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIG9iamVjdCBtb2RlbHMgc2VsZWN0aW9uIG9mIFwiY2VsbHNcIiB3aXRoaW4gYW4gYWJzdHJhY3Qgc2luZ2xlLWRpbWVuc2lvbmFsIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIERpc2pvaW50IHNlbGVjdGlvbnMgY2FuIGJlIGJ1aWx0IHdpdGggY2FsbHMgdG8gdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICAgICAqICoge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjc2VsZWN0fHNlbGVjdChzdGFydCwgc3RvcCl9IC0gQWRkIGEgcmFuZ2UgdG8gdGhlIG1hdHJpeC5cbiAgICAgKiAqIHtAbGluayBSYW5nZVNlbGVjdGlvbk1vZGVsI2Rlc2VsZWN0fGRlc2VsZWN0KHN0YXJ0LCBzdG9wKX0gLSBSZW1vdmUgYSByYW5nZSBmcm9tIHRoZSBtYXRyaXguXG4gICAgICpcbiAgICAgKiBUd28gbW9yZSBtZXRob2RzIGFyZSBhdmFpbGFibGU6XG4gICAgICogKiBUZXN0IGEgY2VsbCB0byBzZWUgaWYgaXQge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjaXNTZWxlY3RlZHxpc1NlbGVjdGVkKGNlbGwpfVxuICAgICAqICoge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjY2xlYXJ8Y2xlYXIoKX0gdGhlIG1hdHJpeFxuICAgICAqXG4gICAgICogSW50ZXJuYWxseSwgdGhlIHNlbGVjdGlvbiBpcyBydW4tbGVuZ3RoLWVuY29kZWQuIEl0IGlzIHRoZXJlZm9yZSBhIFwic3BhcnNlXCIgbWF0cml4XG4gICAgICogd2l0aCB1bmRlZmluZWQgYm91bmRzLiBBIHNpbmdsZSBkYXRhIHByb3BlcnR5IGNhbGxlZCBgc2VsZWN0aW9uYCBpcyBhbiBhcnJheSB0aGF0XG4gICAgICogY29udGFpbnMgYWxsIHRoZSBcInJ1bnNcIiAocmFuZ2VzKSBvZiBzZWxlY3RlZCBjZWxscyBhbGJlaXQgaW4gbm8gcGFydGljdWxhciBvcmRlci5cbiAgICAgKiBUaGlzIHByb3BlcnR5IHNob3VsZCBub3Qgbm9ybWFsbHkgbmVlZCB0byBiZSBhY2Nlc3NlZCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb2JqZWN0IHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2Agb2JqZWN0KS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSYW5nZVNlbGVjdGlvbk1vZGVsKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgc2VsZWN0aW9uXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS5BcnJheS5udW1iZXJ9XG4gICAgICAgICAqIEBzdW1tYXJ5IFVub3JkZXJlZCBsaXN0IG9mIHJ1bnMuXG4gICAgICAgICAqIEBkZXNjIEEgXCJydW5cIiBpcyBkZWZpbmVkIGFzIGFuIEFycmF5KDIpIHdoZXJlOlxuICAgICAgICAgKiAqIGVsZW1lbnQgWzBdIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJ1blxuICAgICAgICAgKiAqIGVsZW1lbnQgWzFdIGlzIHRoZSBlbmQgb2YgdGhlIHJ1biAoaW5jbHVzaXZlKSBhbmQgaXMgYWx3YXlzID49IGVsZW1lbnQgWzBdXG4gICAgICAgICAqIFRoZSBvcmRlciBvZiB0aGUgcnVucyB3aXRoaW4gaXMgdW5kZWZpbmVkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IFtdO1xuXG4gICAgICAgIC8vd2UgbmVlZCB0byBiZSBhYmxlIHRvIGdvIGJhY2sgaW4gdGltZVxuICAgICAgICAvL3RoZSBzdGF0ZXMgZmllbGRcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcblxuICAgICAgICAvL2Nsb25lIGFuZCBzdG9yZSBteSBjdXJyZW50IHN0YXRlXG4gICAgICAgIC8vc28gd2UgY2FuIHVud2luZCBjaGFuZ2VzIGlmIG5lZWQgYmVcbiAgICAgICAgdGhpcy5zdG9yZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbHMgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvcHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3B5ID0gW10uY29uY2F0KHNlbHNbaV0pO1xuICAgICAgICAgICAgICAgIHN0YXRlLnB1c2goY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgQWRkIGEgY29udGlndW91cyBydW4gb2YgcG9pbnRzIHRvIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAqIEBkZXNjIEluc2VydCBhIG5ldyBydW4gaW50byBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBUaGUgbmV3IHJ1biB3aWxsIGJlIG1lcmdlZCB3aXRoIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBydW5zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgdHdvIHBhcmFtZXRlcnMgbWF5IGJlIGdpdmVuIGluIGVpdGhlciBvcmRlci5cbiAgICAgICAgICogVGhlIHN0YXJ0IGFuZCBzdG9wIGVsZW1lbnRzIGluIHRoZSByZXN1bHRpbmcgcnVuIHdpbGwgaG93ZXZlciBhbHdheXMgYmUgb3JkZXJlZC5cbiAgICAgICAgICogKEhvd2V2ZXIsIG5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIHJ1bnMgd2l0aGluIGB0aGlzLnNlbGVjdGlvbmAgaXMgaXRzZWxmIGFsd2F5cyB1bm9yZGVyZWQuKVxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYHRoaXMuc2VsZWN0aW9uYCBpcyB1cGRhdGVkIGluIHBsYWNlLCBwcmVzZXJ2aW5nIHZhbGlkaXR5IG9mIGFueSBleHRlcm5hbCByZWZlcmVuY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBTdGFydCBvZiBydW4uIE1heSBiZSBncmVhdGVyIHRoYW4gYHN0b3BgLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0b3A9c3RvcF0gLSBFbmQgb2YgcnVuIChpbmNsdXNpdmUpLiBNYXkgYmUgbGVzcyB0aGFuIGBzdGFydGAuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0OiBmdW5jdGlvbiAoc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVTdGF0ZSgpO1xuICAgICAgICAgICAgdmFyIHJ1biA9IG1ha2VSdW4oc3RhcnQsIHN0b3ApO1xuICAgICAgICAgICAgdmFyIHNwbGljZXIgPSBbMCwgMV07XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBzKGVhY2gsIHJ1bikgfHwgYWJ1dHMoZWFjaCwgcnVuKSkge1xuICAgICAgICAgICAgICAgICAgICBydW4gPSBtZXJnZShlYWNoLCBydW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIucHVzaChlYWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwbGljZXIucHVzaChydW4pO1xuICAgICAgICAgICAgc3BsaWNlclsxXSA9IHRoaXMuc2VsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNwbGljZS5hcHBseSh0aGlzLnNlbGVjdGlvbiwgc3BsaWNlcik7IC8vIHVwZGF0ZSBpbiBwbGFjZSB0byBwcmVzZXJ2ZSBleHRlcm5hbCByZWZlcmVuY2VzXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgUmVtb3ZlIGEgY29udGlndW91cyBydW4gb2YgcG9pbnRzIGZyb20gdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICogQGRlc2MgVHJ1bmNhdGUgYW5kL29yIHJlbW92ZSBydW4ocykgZnJvbSBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBSZW1vdmluZyBwYXJ0IG9mIGV4aXN0aW5nIHJ1bnMgd2lsbCAoY29ycmVjdGx5KSBzaG9ydGVuIHRoZW0gb3IgYnJlYWsgdGhlbSBpbnRvIHR3byBmcmFnbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB0d28gcGFyYW1ldGVycyBtYXkgYmUgZ2l2ZW4gaW4gZWl0aGVyIG9yZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYHRoaXMuc2VsZWN0aW9uYCBpcyB1cGRhdGVkIGluIHBsYWNlLCBwcmVzZXJ2aW5nIHZhbGlkaXR5IG9mIGFueSBleHRlcm5hbCByZWZlcmVuY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBTdGFydCBvZiBydW4uIE1heSBiZSBncmVhdGVyIHRoYW4gYHN0b3BgLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0b3A9c3RvcF0gLSBFbmQgb2YgcnVuIChpbmNsdXNpdmUpLiBNYXkgYmUgbGVzcyB0aGFuIGBzdGFydGAuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIChzdGFydCwgc3RvcCkge1xuICAgICAgICAgICAgdmFyIHJ1biA9IG1ha2VSdW4oc3RhcnQsIHN0b3ApO1xuICAgICAgICAgICAgdmFyIHNwbGljZXIgPSBbMCwgMF07XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBzKGVhY2gsIHJ1bikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpZWNlcyA9IHN1YnRyYWN0KGVhY2gsIHJ1bik7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIgPSBzcGxpY2VyLmNvbmNhdChwaWVjZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIucHVzaChlYWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwbGljZXJbMV0gPSB0aGlzLnNlbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zcGxpY2UuYXBwbHkodGhpcy5zZWxlY3Rpb24sIHNwbGljZXIpOyAvLyB1cGRhdGUgaW4gcGxhY2UgdG8gcHJlc2VydmUgZXh0ZXJuYWwgcmVmZXJlbmNlc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IEVtcHRpZXMgYHRoaXMuc2VsZWN0aW9uYCwgZWZmZWN0aXZlbHkgcmVtb3ZpbmcgYWxsIHJ1bnMuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gYGNlbGxgIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBnaXZlbiBgY2VsbGAgaXMgd2l0aGluIGFueSBvZiB0aGUgcnVucyBpbiBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY2VsbCAtIFRoZSBjZWxsIHRvIHRlc3QgZm9yIGluY2x1c2lvbiBpbiB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uc29tZShmdW5jdGlvbiAoZWFjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYWNoWzBdIDw9IGNlbGwgJiYgY2VsbCA8PSBlYWNoWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24ubGVuZ3RoID09PSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGluZGV4ZXMgdGhhdCBhcmUgc2VsZWN0ZWQuXG4gICAgICAgICAqIEBkZXNjIFJldHVybiB0aGUgaW5kZXhlcyB0aGF0IGFyZSBzZWxlY3RlZC5cbiAgICAgICAgICogQHJldHVybnMge0FycmF5LkFycmF5Lm51bWJlcn1cbiAgICAgICAgICogQG1lbWJlck9mIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGVhY2gpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZWFjaFswXTsgaSA8PSBlYWNoWzFdOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQuc29ydChmdW5jdGlvbiAoYSwgYil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSBQcmVwcyBgc3RhcnRgIGFuZCBgc3RvcGAgcGFyYW1zIGludG8gb3JkZXIgYXJyYXlcbiAgICAgKiBAZnVuY3Rpb24gbWFrZVJ1blxuICAgICAqIEBkZXNjIFV0aWxpdHkgZnVuY3Rpb24gY2FsbGVkIGJ5IGJvdGggYHNlbGVjdCgpYCBhbmQgYGRlc2VsZWN0KClgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBzdGFydCAtIFN0YXJ0IG9mIHJ1bi4gaWYgYXJyYXksIGBzdGFydGAgYW5kIGBzdG9wYCBhcmUgdGFrZW4gZnJvbSBmaXJzdCB0d28gZWxlbWVudHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wPXN0YXJ0XSAtIEVuZCBvZiBydW4gKGluY2x1c2l2ZSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZVJ1bihzdGFydCwgc3RvcCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgc3RhcnQgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgID8gbWFrZVJ1bi5hcHBseSh0aGlzLCBzdGFydCkgLy8gZXh0cmFjdCBwYXJhbXMgZnJvbSBnaXZlbiBhcnJheVxuICAgICAgICAgICAgICAgIDogc3RvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBbIHN0YXJ0LCBzdGFydCBdIC8vIHNpbmdsZSBwYXJhbSBpcyBhIHJ1biB0aGF0IHN0b3BzIHdoZXJlIGl0IHN0YXJ0c1xuICAgICAgICAgICAgICAgIDogc3RhcnQgPD0gc3RvcFxuICAgICAgICAgICAgICAgID8gWyBzdGFydCwgc3RvcCBdXG4gICAgICAgICAgICAgICAgOiBbIHN0b3AsIHN0YXJ0IF0gLy8gcmV2ZXJzZSBkZXNjZW5kaW5nIHBhcmFtcyBpbnRvIGFzY2VuZGluZyBvcmRlclxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIG92ZXJsYXBzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHJ1bjFgIG92ZXJsYXBzIGBydW4yYFxuICAgICAqIEBzdW1tYXJ5IENvbXBhcmlzb24gb3BlcmF0b3IgdGhhdCBkZXRlcm1pbmVzIGlmIGdpdmVuIHJ1bnMgb3ZlcmxhcCB3aXRoIG9uZSBhbm90aGVyLlxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogT3ZlcmxhcCBpcyBkZWZpbmVkIHRvIGluY2x1ZGUgdGhlIGNhc2Ugd2hlcmUgb25lIHJ1biBjb21wbGV0ZWx5IGNvbnRhaW5zIHRoZSBvdGhlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb3BlcmF0b3IgaXMgY29tbXV0YXRpdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcnVuMSAtIGZpcnN0IHJ1blxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjIgLSBzZWNvbmQgcnVuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlcmxhcHMocnVuMSwgcnVuMikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcnVuMVswXSA8PSBydW4yWzBdICYmIHJ1bjJbMF0gPD0gcnVuMVsxXSB8fCAvLyBydW4yJ3Mgc3RhcnQgaXMgd2l0aGluIHJ1bjEgT1IuLi5cbiAgICAgICAgICAgIHJ1bjFbMF0gPD0gcnVuMlsxXSAmJiBydW4yWzFdIDw9IHJ1bjFbMV0gfHwgLy8gcnVuMidzIHN0b3AgaXMgd2l0aGluIHJ1bjEgT1IuLi5cbiAgICAgICAgICAgIHJ1bjJbMF0gPCAgcnVuMVswXSAmJiBydW4xWzFdIDwgIHJ1bjJbMV0gICAgLy8gcnVuMiBjb21wbGV0ZWx5IGNvbnRhaW5zIHJ1bjFcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBhYnV0c1xuICAgICAqIEBzdW1tYXJ5IENvbXBhcmlzb24gb3BlcmF0b3IgdGhhdCBkZXRlcm1pbmVzIGlmIGdpdmVuIHJ1bnMgYXJlIGNvbnNlY3V0aXZlIHdpdGggb25lIGFub3RoZXIuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHJ1bjFgIGlzIGNvbnNlY3V0aXZlIHdpdGggYHJ1bjJgXG4gICAgICogQGRlc2MgQm90aCBwYXJhbWV0ZXJzIGFyZSBhc3N1bWVkIHRvIGJlIF9vcmRlcmVkXyBhcnJheXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdG9yIGlzIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjEgLSBmaXJzdCBydW5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4yIC0gc2Vjb25kIHJ1blxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFidXRzKHJ1bjEsIHJ1bjIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJ1bjFbMV0gPT09IHJ1bjJbMF0gLSAxIHx8IC8vIHJ1bjEncyB0b3AgaW1tZWRpYXRlbHkgcHJlY2VkZXMgcnVuMidzIHN0YXJ0IE9SLi4uXG4gICAgICAgICAgICBydW4yWzFdID09PSBydW4xWzBdIC0gMSAgICAvLyBydW4yJ3MgdG9wIGltbWVkaWF0ZWx5IHByZWNlZGVzIHJ1bjEncyBzdGFydFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIHN1YnRyYWN0XG4gICAgICogQHN1bW1hcnkgT3BlcmF0b3IgdGhhdCBzdWJ0cmFjdHMgb25lIHJ1biBmcm9tIGFub3RoZXIuXG4gICAgICogQHJldHVybnMge0FycmF5LkFycmF5Lm51bWJlcn0gVGhlIHJlbWFpbmluZyBwaWVjZXMgb2YgYG1pbnVlbmRgIGFmdGVyIHJlbW92aW5nIGBzdWJ0cmFoZW5kYC5cbiAgICAgKiBAZGVzYyBCb3RoIHBhcmFtZXRlcnMgYXJlIGFzc3VtZWQgdG8gYmUgX29yZGVyZWRfIGFycmF5cy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gX2RvZXMgbm90IGFzc3VtZXNfIHRoYXQgYG92ZXJsYXAoKWAgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgd2l0aCB0aGUgc2FtZSBydW5zIGFuZCBoYXMgcmV0dXJuZWQgYHRydWVgLlxuICAgICAqXG4gICAgICogUmV0dXJuZWQgYXJyYXkgY29udGFpbnMgMCwgMSwgb3IgMiBydW5zIHdoaWNoIGFyZSB0aGUgcG9ydGlvbihzKSBvZiBgbWludWVuZGAgdGhhdCBkbyBfbm90XyBpbmNsdWRlIGBzdWJ0cmFoZW5kYC5cbiAgICAgKlxuICAgICAqIENhdmVhdDogVGhpcyBvcGVyYXRvciBpcyAqbm90KiBjb21tdXRhdGl2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBtaW51ZW5kIC0gYSBydW4gZnJvbSB3aGljaCB0byBcInN1YnRyYWN0XCIgYHN1YnRyYWhlbmRgXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gc3VidHJhaGVuZCAtIGEgcnVuIHRvIFwic3VidHJhY3RlZFwiIGZyb20gYG1pbnVlbmRgXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VidHJhY3QobWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgICB2YXIgbTAgPSBtaW51ZW5kWzBdO1xuICAgICAgICB2YXIgbTEgPSBtaW51ZW5kWzFdO1xuICAgICAgICB2YXIgczAgPSBzdWJ0cmFoZW5kWzBdO1xuICAgICAgICB2YXIgczEgPSBzdWJ0cmFoZW5kWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKHMwIDw9IG0wICYmIHMxIDwgbTEpIHtcbiAgICAgICAgICAgIC8vc3VidHJhaGVuZCBleHRlbmRzIGJlZm9yZSBtaW51ZW5kOiByZXR1cm4gcmVtYWluaW5nIHBpZWNlIG9mIGBtaW51ZW5kYFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3MxICsgMSwgbTFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzMCA+IG0wICYmIHMxID49IG0xKSB7XG4gICAgICAgICAgICAvL3N1YnRyYWhlbmQgZXh0ZW5kcyBhZnRlciBtaW51ZW5kOiByZXR1cm4gcmVtYWluaW5nIHBpZWNlIG9mIGBtaW51ZW5kYFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goW20wLCBzMCAtIDFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChtMCA8IHMwICYmIHMxIDwgbTEpIHtcbiAgICAgICAgICAgIC8vY29tcGxldGVseSBpbnNpZGU6IHJldHVybiAyIHNtYWxsZXIgcGllY2VzIHJlc3VsdGluZyBmcm9tIHRoZSBob2xlXG4gICAgICAgICAgICByZXN1bHQucHVzaChbbTAsIHMwIC0gMV0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3MxICsgMSwgbTFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzMSA8IG0wIHx8IHMwID4gbTEpIHtcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgb3V0c2lkZTogcmV0dXJuIGBtaW51ZW5kYCB1bnRvdWNoZWRcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1pbnVlbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lbHNlIHN1YnRyYWhlbmQgbXVzdCBjb21wbGV0ZWx5IG92ZXJsYXAgbWludWVuZCBzbyByZXR1cm4gbm8gcGllY2VzXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cblxuICAgIC8vIExvY2FsIHV0aWxpdHkgZnVuY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBtZXJnZVxuICAgICAqIEBzdW1tYXJ5IE9wZXJhdG9yIHRoYXQgbWVyZ2VzIGdpdmVuIHJ1bnMuXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBBIHNpbmdsZSBtZXJnZWQgcnVuLlxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogVGhlIHJ1bnMgYXJlIGFzc3VtZWQgdG8gYmUgb3ZlcmxhcHBpbmcgb3IgYWRqYWNlbnQgdG8gb25lIGFub3RoZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdG9yIGlzIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjEgLSBhIHJ1biB0byBtZXJnZSB3aXRoIGBydW4yYFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjIgLSBhIHJ1biB0byBtZXJnZSB3aXRoIGBydW4xYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKHJ1bjEsIHJ1bjIpIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKE1hdGgubWluLmFwcGx5KE1hdGgsIHJ1bjEpLCBNYXRoLm1pbi5hcHBseShNYXRoLCBydW4yKSk7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChNYXRoLm1heC5hcHBseShNYXRoLCBydW4xKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgcnVuMikpO1xuICAgICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcmZhY2VcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJhbmdlU2VsZWN0aW9uTW9kZWw7XG59KShcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUgfHwgKHdpbmRvdy5SYW5nZVNlbGVjdGlvbk1vZGVsID0ge30pLFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzIHx8ICh3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbC5leHBvcnRzID0ge30pXG4pIHx8IChcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyB8fCAod2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWwgPSB3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbC5leHBvcnRzKVxuKTtcblxuLyogQWJvdXQgdGhlIGFib3ZlIElJRkU6XG4gKiBUaGlzIGZpbGUgaXMgYSBcIm1vZGlmaWVkIG5vZGUgbW9kdWxlLlwiIEl0IGZ1bmN0aW9ucyBhcyB1c3VhbCBpbiBOb2RlLmpzICphbmQqIGlzIGFsc28gdXNhYmxlIGRpcmVjdGx5IGluIHRoZSBicm93c2VyLlxuICogMS4gTm9kZS5qczogVGhlIElJRkUgaXMgc3VwZXJmbHVvdXMgYnV0IGlubm9jdW91cy5cbiAqIDIuIEluIHRoZSBicm93c2VyOiBUaGUgSUlGRSBjbG9zdXJlIHNlcnZlcyB0byBrZWVwIGludGVybmFsIGRlY2xhcmF0aW9ucyBwcml2YXRlLlxuICogMi5hLiBJbiB0aGUgYnJvd3NlciBhcyBhIGdsb2JhbDogVGhlIGxvZ2ljIGluIHRoZSBhY3R1YWwgcGFyYW1ldGVyIGV4cHJlc3Npb25zICsgdGhlIHBvc3QtaW52b2NhdGlvbiBleHByZXNzaW9uXG4gKiB3aWxsIHB1dCB5b3VyIEFQSSBpbiBgd2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWxgLlxuICogMi5iLiBJbiB0aGUgYnJvd3NlciBhcyBhIG1vZHVsZTogSWYgeW91IHByZWRlZmluZSBhIGB3aW5kb3cubW9kdWxlYCBvYmplY3QsIHRoZSByZXN1bHRzIHdpbGwgYmUgaW4gYG1vZHVsZS5leHBvcnRzYC5cbiAqIFRoZSBib3dlciBjb21wb25lbnQgYG1ubWAgbWFrZXMgdGhpcyBlYXN5IGFuZCBhbHNvIHByb3ZpZGVzIGEgZ2xvYmFsIGByZXF1aXJlKClgIGZ1bmN0aW9uIGZvciByZWZlcmVuY2luZyB5b3VyIG1vZHVsZVxuICogZnJvbSBvdGhlciBjbG9zdXJlcy4gSW4gZWl0aGVyIGNhc2UsIHRoaXMgd29ya3Mgd2l0aCBib3RoIE5vZGVKcy1zdHlsZSBleHBvcnQgbWVjaGFuaXNtcyAtLSBhIHNpbmdsZSBBUEkgYXNzaWdubWVudCxcbiAqIGBtb2R1bGUuZXhwb3J0cyA9IHlvdXJBUElgICpvciogYSBzZXJpZXMgb2YgaW5kaXZpZHVhbCBwcm9wZXJ0eSBhc3NpZ25tZW50cywgYG1vZHVsZS5leHBvcnRzLnByb3BlcnR5ID0gcHJvcGVydHlgLlxuICpcbiAqIEJlZm9yZSB0aGUgSUlGRSBydW5zLCB0aGUgYWN0dWFsIHBhcmFtZXRlciBleHByZXNzaW9ucyBhcmUgZXhlY3V0ZWQ6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB3ZSdyZSBpbiBOb2RlSnMgc28gYXNzdW1lIHRoZXJlIGlzIGEgYG1vZHVsZWAgb2JqZWN0IHdpdGggYW4gYGV4cG9ydHNgIHByb3BlcnR5XG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgd2UncmUgaW4gYnJvd3NlclxuICogMi5hLiBJZiBgbW9kdWxlYCBvYmplY3QgcHJlZGVmaW5lZCwgdXNlIGl0XG4gKiAyLmIuIElmIGBtb2R1bGVgIG9iamVjdCB1bmRlZmluZWQsIGNyZWF0ZSBhIGBSYW5nZVNlbGVjdGlvbk1vZGVsYCBvYmplY3RcbiAqXG4gKiBBZnRlciB0aGUgSUlGRSByZXR1cm5zOlxuICogQmVjYXVzZSBpdCBhbHdheXMgcmV0dXJucyB1bmRlZmluZWQsIHRoZSBleHByZXNzaW9uIGFmdGVyIHRoZSB8fCB3aWxsIGV4ZWN1dGU6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB0aGVuIHdlJ3JlIGluIE5vZGVKcyBzbyB3ZSdyZSBkb25lXG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBicm93c2VyXG4gKiAyLmEuIElmIGBtb2R1bGVgIG9iamVjdCBwcmVkZWZpbmVkLCB3ZSdyZSBkb25lOyByZXN1bHRzIGFyZSBpbiBgbW91ZHVsZS5leHBvcnRzYFxuICogMi5iLiBJZiBgbW9kdWxlYCBvYmplY3QgdW5kZWZpbmVkLCByZWRlZmluZWBSYW5nZVNlbGVjdGlvbk1vZGVsYCB0byBiZSB0aGUgYFJhbmdlU2VsZWN0aW9uTW9kZWwuZXhwb3J0c2Agb2JqZWN0XG4gKi9cbiIsIi8vIHRhYnogbm9kZSBtb2R1bGVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25laXQvdGFielxuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3NzSW5qZWN0b3IgPSByZXF1aXJlKCdjc3MtaW5qZWN0b3InKTtcblxuLyoqXG4gKiBSZWdpc3Rlci9kZXJlZ2lzdGVyIGNsaWNrIGhhbmRsZXIgb24gYWxsIHRhYiBjb2xsZWN0aW9ucy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gW29wdGlvbnMucm9vdD1kb2N1bWVudF0gLSBXaGVyZSB0byBsb29rIGZvciB0YWIgcGFuZWxzIChgLnRhYnpgIGVsZW1lbnRzKSBjb250YWluaW5nIHRhYnMgYW5kIGZvbGRlcnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVuaG9vaz1mYWxzZV0gLSBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbSB0YWIgcGFuZWxzIChgLnRhYnpgIGVsZW1lbnRzKS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gW29wdGlvbnMucmVmZXJlbmNlRWxlbWVudF0gLSBQYXNzZWQgdG8gY3NzSW5qZWN0b3IncyBpbnNlcnRCZWZvcmUoKSBjYWxsLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlZmF1bHRUYWJTZWxlY3Rvcj0nLmRlZmF1bHQtdGFiJ10gLSAuY2xhc3NuYW1lIG9yICNpZCBvZiB0aGUgdGFiIHRvIHNlbGVjdCBieSBkZWZhdWx0XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMub25FbmFibGVdIC0gSGFuZGxlciBpbXBsZW1lbnRhdGlvbi4gU2VlIHtAbGluayBUYWJ6I29uRW5hYmxlfG9uRW5hYmxlfS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5vbkRpc2FibGVdIC0gSGFuZGxlciBpbXBsZW1lbnRhdGlvbi4gU2VlIHtAbGluayBUYWJ6I29uRGlzYWJsZXxvbkVuYWJsZX0uXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMub25FbmFibGVkXSAtIEhhbmRsZXIgaW1wbGVtZW50YXRpb24uIFNlZSB7QGxpbmsgVGFieiNvbkVuYWJsZWR8b25FbmFibGV9LlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm9uRGlzYWJsZWRdIC0gSGFuZGxlciBpbXBsZW1lbnRhdGlvbi4gU2VlIHtAbGluayBUYWJ6I29uRGlzYWJsZWR8b25FbmFibGV9LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRhYnoob3B0aW9ucykge1xuICAgIHZhciBpLCBlbDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciByb290ID0gb3B0aW9ucy5yb290IHx8IGRvY3VtZW50LFxuICAgICAgICB1bmhvb2sgPSBvcHRpb25zLnVuaG9vayxcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IG9wdGlvbnMucmVmZXJlbmNlRWxlbWVudCxcbiAgICAgICAgZGVmYXVsdFRhYlNlbGVjdG9yID0gb3B0aW9ucy5kZWZhdWx0VGFiU2VsZWN0b3IgfHwgJy5kZWZhdWx0LXRhYic7XG5cbiAgICBpZiAoIXVuaG9vaykge1xuICAgICAgICB2YXIgY3NzO1xuICAgICAgICAvKiBpbmplY3Q6Y3NzICovXG4gICAgICAgIGNzcyA9ICcudGFientwb3NpdGlvbjpyZWxhdGl2ZTt2aXNpYmlsaXR5OmhpZGRlbjtoZWlnaHQ6MTAwJX0udGFiej5oZWFkZXJ7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7YmFja2dyb3VuZC1jb2xvcjojZmZmO21hcmdpbi1sZWZ0OjFlbTtwYWRkaW5nOjVweCAuNmVtO2JvcmRlcjoxcHggc29saWQgIzY2Njtib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6NnB4IDZweCAwIDA7Y3Vyc29yOmRlZmF1bHQ7dXNlci1zZWxlY3Q6bm9uZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lfS50YWJ6PmhlYWRlcitzZWN0aW9ue3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7bWFyZ2luLXRvcDotMXB4O3BhZGRpbmc6OHB4O2JvcmRlcjoxcHggc29saWQgIzY2Njtib3JkZXItcmFkaXVzOjZweDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDt0b3A6MDt6LWluZGV4OjB9LnRhYno+aGVhZGVyK3NlY3Rpb24udGFiei1lbmFibGV7ei1pbmRleDoxfS50YWJ6PmhlYWRlci50YWJ6LWVuYWJsZXt6LWluZGV4OjJ9LnRhYnotYmcwe2JhY2tncm91bmQtY29sb3I6I2VlZSFpbXBvcnRhbnR9LnRhYnotYmcxe2JhY2tncm91bmQtY29sb3I6I2VlZiFpbXBvcnRhbnR9LnRhYnotYmcye2JhY2tncm91bmQtY29sb3I6I2VmZSFpbXBvcnRhbnR9LnRhYnotYmcze2JhY2tncm91bmQtY29sb3I6I2VmZiFpbXBvcnRhbnR9LnRhYnotYmc0e2JhY2tncm91bmQtY29sb3I6I2ZlZSFpbXBvcnRhbnR9LnRhYnotYmc1e2JhY2tncm91bmQtY29sb3I6I2ZlZiFpbXBvcnRhbnR9LnRhYnotYmc2e2JhY2tncm91bmQtY29sb3I6I2ZmZSFpbXBvcnRhbnR9JztcbiAgICAgICAgLyogZW5kaW5qZWN0ICovXG5cbiAgICAgICAgaWYgKCFyZWZlcmVuY2VFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBmaW5kIGZpcnN0IDxsaW5rPiBvciA8c3R5bGU+IGluIDxoZWFkPlxuICAgICAgICAgICAgdmFyIGhlYWRTdHVmZiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKS5jaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7ICFyZWZlcmVuY2VFbGVtZW50ICYmIGkgPCBoZWFkU3R1ZmYubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBlbCA9IGhlYWRTdHVmZltpXTtcbiAgICAgICAgICAgICAgICBpZiAoZWwudGFnTmFtZSA9PT0gJ1NUWUxFJyB8fCBlbC50YWdOYW1lID09PSAnTElOSycgJiYgZWwucmVsID09PSAnc3R5bGVzaGVldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjc3NJbmplY3Rvcihjc3MsICd0YWJ6LWNzcy1iYXNlJywgcmVmZXJlbmNlRWxlbWVudCk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2tleV0gPT09IG5vb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgVGhlIGNvbnRleHQgb2YgdGhpcyB0YWIgb2JqZWN0LlxuICAgICAgICAgKiBAZGVzYyBUaGUgY29udGV4dCBtYXkgZW5jb21wYXNzIGFueSBudW1iZXIgb2YgdGFiIHBhbmVscyAoYC50YWJ6YCBlbGVtZW50cykuXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRG9jdW1lbnxIVE1MRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG5cbiAgICAgICAgLy8gZW5hYmxlIGZpcnN0IHRhYiBvbiBlYWNoIHRhYiBwYW5lbCAoYC50YWJ6YCBlbGVtZW50KVxuICAgICAgICBmb3JFYWNoRWwoJy50YWJ6PmhlYWRlcjpmaXJzdC1vZi10eXBlLC50YWJ6PnNlY3Rpb246Zmlyc3Qtb2YtdHlwZScsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCd0YWJ6LWVuYWJsZScpO1xuICAgICAgICB9LCByb290KTtcblxuICAgICAgICAvLyBlbmFibGUgZGVmYXVsdCB0YWIgYW5kIGFsbCBpdHMgcGFyZW50cyAobXVzdCBiZSBhIHRhYilcbiAgICAgICAgdGhpcy50YWJUbyhyb290LnF1ZXJ5U2VsZWN0b3IoJy50YWJ6ID4gaGVhZGVyJyArIGRlZmF1bHRUYWJTZWxlY3RvcikpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3JFYWNoRWwoJy50YWJ6ID4gc2VjdGlvbicsIGZ1bmN0aW9uKGVsKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBTdGVwIDE6IEEgYnVnIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSAobGlrZSB2NDApIHRoYXQgaW5zZXJ0ZWQgYSBicmVhayBhdCBtYXJrLXVwIGxvY2F0aW9uIG9mIGFuIGFic29sdXRlIHBvc2l0aW9uZWQgYmxvY2suIFRoZSB3b3JrLWFyb3VuZCBpcyB0byBoaWRlIHRob3NlIGJsb2NrcyB1bnRpbCBhZnRlciBmaXJzdCByZW5kZXI7IHRoZW4gc2hvdyB0aGVtLiBJIGRvbid0IGtub3cgd2h5IHRoaXMgd29ya3MgYnV0IGl0IGRvZXMuIFNlZW1zIHRvIGJlIGR1cmFibGUuXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgICAgICAgICAvLyBTdGVwIDI6IEFkanVzdCBhYnNvbHV0ZSB0b3Agb2YgZWFjaCByZW5kZXJlZCBmb2xkZXIgdG8gdGhlIGJvdHRvbSBvZiBpdHMgdGFiXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUudG9wID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBlbC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArICdweCc7XG5cbiAgICAgICAgICAgIH0sIHJvb3QpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICB2YXIgbWV0aG9kID0gdW5ob29rID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2FkZEV2ZW50TGlzdGVuZXInO1xuICAgIHZhciBib3VuZENsaWNrSGFuZGxlciA9IG9uY2xpY2suYmluZCh0aGlzKTtcbiAgICBmb3JFYWNoRWwoJy50YWJ6JywgZnVuY3Rpb24odGFiQmFyKSB7XG4gICAgICAgIHRhYkJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICB0YWJCYXJbbWV0aG9kXSgnY2xpY2snLCBib3VuZENsaWNrSGFuZGxlcik7XG4gICAgfSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIG9uY2xpY2soZXZ0KSB7XG4gICAgY2xpY2suY2FsbCh0aGlzLCBldnQuY3VycmVudFRhcmdldCwgZXZ0LnRhcmdldCk7XG59XG5cbi8qKlxuICogQHN1bW1hcnkgU2VsZWN0cyB0aGUgZ2l2ZW4gdGFiLlxuICogQGRlc2MgSWYgaXQgaXMgYSBuZXN0ZWQgdGFiLCBhbHNvIHJldmVhbHMgYWxsIGl0cyBhbmNlc3RvciB0YWJzLlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR9IFtlbF0gLSBNYXkgYmUgb25lIG9mOlxuICogKiBgSFRNTEVsZW1lbnRgXG4gKiAgICogYDxoZWFkZXI+YCAtIHRhYiBlbGVtZW50XG4gKiAgICogYDxzZWN0aW9uPmAgLSBmb2xkZXIgZWxlbWVudFxuICogKiBgc3RyaW5nYCAtIENTUyBzZWxlY3RvciB0byBvbmUgb2YgdGhlIGFib3ZlXG4gKiAqIGZhbHN5IC0gZmFpbHMgc2lsZW50bHlcbiAqIEBtZW1iZXJPZiBUYWJ6LnByb3RvdHlwZVxuICovXG5UYWJ6LnByb3RvdHlwZS50YWJUbyA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgd2hpbGUgKChlbCA9IHRoaXMudGFiKGVsKSkpIHtcbiAgICAgICAgY2xpY2suY2FsbCh0aGlzLCBlbC5wYXJlbnRFbGVtZW50LCBlbCk7XG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50OyAvLyBsb29wIHRvIGNsaWNrIG9uIGVhY2ggY29udGFpbmluZyB0YWIuLi5cbiAgICB9XG59O1xuXG4vKipcbiAqIEN1cnJlbnQgc2VsZWN0ZWQgdGFiLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxudW1iZXJ9IGVsIC0gQW4gZWxlbWVudCB0aGF0IGlzIChvciBpcyB3aXRoaW4pIHRoZSB0YWIgcGFuZWwgKGAudGFiemAgZWxlbWVudCkgdG8gbG9vayBpbi5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8SFRNTEVsZW1lbnR9IFJldHVybnMgdGFiIChgPGhlYWRlcj5gKSBlbGVtZW50LiAgUmV0dXJucyBgdW5kZWZpbmVkYCBpZiBgZWxgIGlzIG5laXRoZXIgb2YgdGhlIGFib3ZlIG9yIGFuIG91dCBvZiByYW5nZSBpbmRleC5cbiAqL1xuVGFiei5wcm90b3R5cGUuZW5hYmxlZFRhYiA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgZWwgPSB0aGlzLnBhbmVsKGVsKTtcbiAgICByZXR1cm4gZWwgJiYgZWwucXVlcnlTZWxlY3RvcignOnNjb3BlPmhlYWRlci50YWJ6LWVuYWJsZScpO1xufTtcblxuLyoqXG4gKiBAc3VtbWFyeSBHZXQgdGFiIGVsZW1lbnQuXG4gKiBAZGVzYyBHZXQgdGFiIGVsZW1lbnQgaWYgZ2l2ZW4gdGFiIG9yIGZvbGRlciBlbGVtZW50OyBvciBhbiBlbGVtZW50IHdpdGhpbiBzdWNoOyBvciBmaW5kIHRhYi5cbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IFtlbF0gLSBNYXkgYmUgb25lIG9mOlxuICogKiBhIHRhYiAoYSBgPGhlYWRlcj5gIGVsZW1lbnQpXG4gKiAqIGEgZm9sZGVyIChhIGA8c2VjdGlvbj5gIGVsZW1lbnQpXG4gKiAqIGFuIGVsZW1lbnQgd2l0aGluIG9uZSBvZiB0aGUgYWJvdmVcbiAqICogYHN0cmluZ2AgLSBDU1Mgc2VsZWN0b3IgdG8gb25lIG9mIHRoZSBhYm92ZSwgc2VhcmNoaW5nIHdpdGhpbiB0aGUgcm9vdCBvciBkb2N1bWVudFxuICogQHJldHVybnMge251bGx8RWxlbWVudH0gdGFiIChgPGhlYWRlcj4uLi48L2hlYWRlcj5gKSBlbGVtZW50IG9yIGBudWxsYCBpZiBub3QgZm91bmRcbiAqIEBtZW1iZXJPZiBUYWJ6LnByb3RvdHlwZVxuICovXG5UYWJ6LnByb3RvdHlwZS50YWIgPSBmdW5jdGlvbihlbCkge1xuICAgIGVsID0gbG9va0ZvckVsLmNhbGwodGhpcywgZWwpO1xuICAgIHJldHVybiAhKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpID8gbnVsbCA6IGVsLnRhZ05hbWUgPT09ICdIRUFERVInID8gZWwgOiBlbC50YWdOYW1lID09PSAnU0VDVElPTicgPyBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIDogbnVsbDtcbn07XG5cbi8qKlxuICogQHN1bW1hcnkgR2V0IGZvbGRlciBlbGVtZW50LlxuICogQGRlc2MgR2V0IGZvbGRlciBlbGVtZW50IGlmIGdpdmVuIHRhYiBvciBmb2xkZXIgZWxlbWVudDsgb3IgYW4gZWxlbWVudCB3aXRoaW4gc3VjaDsgb3IgZmluZCBmb2xkZXIuXG4gKiBAcGFyYW0ge3N0cmluZ3xFbGVtZW50fSBbZWxdIC0gTWF5IGJlIG9uZSBvZjpcbiAqICogYSB0YWIgKGEgYDxoZWFkZXI+YCBlbGVtZW50KVxuICogKiBhIGZvbGRlciAoYSBgPHNlY3Rpb24+YCBlbGVtZW50KVxuICogKiBhbiBlbGVtZW50IHdpdGhpbiBvbmUgb2YgdGhlIGFib3ZlXG4gKiAqIGBzdHJpbmdgIC0gQ1NTIHNlbGVjdG9yIHRvIG9uZSBvZiB0aGUgYWJvdmUsIHNlYXJjaGluZyB3aXRoaW4gdGhlIHJvb3Qgb3IgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtudWxsfEVsZW1lbnR9IHRhYiAoYDxoZWFkZXI+Li4uPC9oZWFkZXI+YCkgZWxlbWVudCBvciBgbnVsbGAgaWYgbm90IGZvdW5kXG4gKiBAbWVtYmVyT2YgVGFiei5wcm90b3R5cGVcbiAqL1xuVGFiei5wcm90b3R5cGUuZm9sZGVyID0gZnVuY3Rpb24oZWwpIHtcbiAgICBlbCA9IGxvb2tGb3JFbC5jYWxsKHRoaXMsIGVsKTtcbiAgICByZXR1cm4gIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSA/IG51bGwgOiBlbC50YWdOYW1lID09PSAnU0VDVElPTicgPyBlbCA6IGVsLnRhZ05hbWUgPT09ICdIRUFERVInID8gZWwubmV4dEVsZW1lbnRTaWJsaW5nIDogbnVsbDtcbn07XG5cbi8qKlxuICogQHN1bW1hcnkgR2V0IHRhYiBwYW5lbCBlbGVtZW50LlxuICogQGRlc2MgR2V0IHBhbmVsIGVsZW1lbnQgaWYgZ2l2ZW4gdGFiIHBhbmVsIGVsZW1lbnQ7IG9yIGFuIGVsZW1lbnQgd2l0aGluIGEgdGFiIHBhbmVsOyBvciBmaW5kIHRhYiBwYW5lbC5cbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IFtlbF0gLSBNYXkgYmUgb25lIG9mOlxuICogKiBhIHRhYiBwYW5lbCAoYW4gYEhUTUxFbGVtZW50YCB3aXRoIGNsYXNzIGB0YWJ6YClcbiAqICogYW4gZWxlbWVudCB3aXRoaW4gYSB0YWIgcGFuZWxcbiAqICogYHN0cmluZ2AgLSBDU1Mgc2VsZWN0b3IgdG8gb25lIGEgdGFiIHBhbmVsLCBzZWFyY2hpbmcgd2l0aGluIHRoZSByb290IG9yIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7bnVsbHxFbGVtZW50fSB0YWIgcGFuZWwgZWxlbWVudCBvciBgbnVsbGAgaWYgbm90IGZvdW5kXG4gKiBAbWVtYmVyT2YgVGFiei5wcm90b3R5cGVcbiAqL1xuVGFiei5wcm90b3R5cGUucGFuZWwgPSBmdW5jdGlvbihlbCkge1xuICAgIHdoaWxlIChlbCAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCd0YWJ6JykpIHtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSA/IG51bGwgOiBlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3RhYnonKSA/IGVsIDogbnVsbDtcbn07XG5cbmZ1bmN0aW9uIGxvb2tGb3JFbChlbCkge1xuICAgIGlmIChlbCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsLnRhZ05hbWUgIT09ICdIRUFERVInICYmIGVsLnRhZ05hbWUgIT09ICdTRUNUSU9OJykge1xuICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWwgPSB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cblxuLyoqIEVuYWJsZXMgdGhlIHRhYi9mb2xkZXIgcGFpciBvZiB0aGUgY2xpY2tlZCB0YWIuXG4gKiBEaXNhYmxlcyBhbGwgdGhlIG90aGVyIHBhaXJzIGluIHRoaXMgc2NvcGUgd2hpY2ggd2lsbCBpbmNsdWRlIHRoZSBwcmV2aW91c2x5IGVuYWJsZWQgcGFpci5cbiAqIEBwcml2YXRlXG4gKiBAdGhpcyBUYWJ6XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRpdiAtIFRoZSB0YWIgcGFuZWwgKGAudGFiemAgZWxlbWVudCkgdGhhdCdzIGhhbmRsaW5nIHRoZSBjbGljayBldmVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gVGhlIGVsZW1lbnQgdGhhdCByZWNlaXZlZCB0aGUgY2xpY2suXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfEVsZW1lbnR9IFRoZSBgPGhlYWRlcj5gIGVsZW1lbnQgKHRhYikgdGhlIHdhcyBjbGlja2VkOyBvciBgdW5kZWZpbmVkYCB3aGVuIGNsaWNrIHdhcyBub3Qgd2l0aGluIGEgdGFiLlxuICovXG5mdW5jdGlvbiBjbGljayhkaXYsIHRhcmdldCkge1xuICAgIHZhciBuZXdUYWIsIG9sZFRhYjtcblxuICAgIGZvckVhY2hFbCgnOnNjb3BlPmhlYWRlcjpub3QoLnRhYnotZW5hYmxlKScsIGZ1bmN0aW9uKHRhYikgeyAvLyB0b2RvOiB1c2UgYSAuZmluZCgpIHBvbHlmaWxsIGhlcmVcbiAgICAgICAgaWYgKHRhYi5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICBuZXdUYWIgPSB0YWI7XG4gICAgICAgIH1cbiAgICB9LCBkaXYpO1xuXG4gICAgaWYgKG5ld1RhYikge1xuICAgICAgICBvbGRUYWIgPSB0aGlzLmVuYWJsZWRUYWIoZGl2KTtcbiAgICAgICAgdG9nZ2xlVGFiLmNhbGwodGhpcywgb2xkVGFiLCBmYWxzZSk7XG4gICAgICAgIHRvZ2dsZVRhYi5jYWxsKHRoaXMsIG5ld1RhYiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1RhYjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHRoaXMgVGFielxuICogQHBhcmFtIHtFbGVtZW50fSB0YWIgLSBUaGUgYDxoZWFkZXI+YCBlbGVtZW50IG9mIHRoZSB0YWIgdG8gZW5hYmxlIG9yIGRpc2FibGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZSAtIEVuYWJsZSAodnMuIGRpc2FibGUpIHRoZSB0YWIuXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZVRhYih0YWIsIGVuYWJsZSkge1xuICAgIGlmICh0YWIpIHtcbiAgICAgICAgdmFyIGZvbGRlciA9IHRoaXMuZm9sZGVyKHRhYiksXG4gICAgICAgICAgICBtZXRob2QgPSBlbmFibGUgPyAnb25FbmFibGUnIDogJ29uRGlzYWJsZSc7XG5cbiAgICAgICAgdGhpc1ttZXRob2RdLmNhbGwodGhpcywgdGFiLCBmb2xkZXIpO1xuXG4gICAgICAgIHRhYi5jbGFzc0xpc3QudG9nZ2xlKCd0YWJ6LWVuYWJsZScsIGVuYWJsZSk7XG4gICAgICAgIGZvbGRlci5jbGFzc0xpc3QudG9nZ2xlKCd0YWJ6LWVuYWJsZScsIGVuYWJsZSk7XG5cbiAgICAgICAgbWV0aG9kICs9ICdkJztcbiAgICAgICAgdGhpc1ttZXRob2RdLmNhbGwodGhpcywgdGFiLCBmb2xkZXIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB0YWJFdmVudFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHt0YWJFdmVudE9iamVjdH1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHRhYkV2ZW50T2JqZWN0XG4gKiBAcHJvcGVydHkge1RhYnp9IHRhYnogLSBUaGUgdGFiIG9iamVjdCBpc3N1aW5nIHRoZSBjYWxsYmFjay5cbiAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gdGFyZ2V0IC0gVGhlIHRhYiAoYDxoZWFkZXI+YCBlbGVtZW50KS5cbiAqL1xuXG4vKipcbiAqIENhbGxlZCBiZWZvcmUgYSBwcmV2aW91c2x5IGRpc2FibGVkIHRhYiBpcyBlbmFibGVkLlxuICogQHR5cGUge3RhYkV2ZW50fVxuICogQGFic3RyYWN0XG4gKiBAbWVtYmVyT2YgVGFiei5wcm90b3R5cGVcbiAqL1xuVGFiei5wcm90b3R5cGUub25FbmFibGUgPSBub29wO1xuXG4vKipcbiAqIENhbGxlZCBiZWZvcmUgYSBwcmV2aW91c2x5IGVuYWJsZWQgdGFiIGlzIGRpc2FibGVkIGJ5IGFub3RoZXIgdGFiIGJlaW5nIGVuYWJsZWQuXG4gKiBAdHlwZSB7dGFiRXZlbnR9XG4gKiBAYWJzdHJhY3RcbiAqIEBtZW1iZXJPZiBUYWJ6LnByb3RvdHlwZVxuICovXG5UYWJ6LnByb3RvdHlwZS5vbkRpc2FibGUgPSBub29wO1xuXG4vKipcbiAqIENhbGxlZCBhZnRlciBhIHByZXZpb3VzbHkgZGlzYWJsZWQgdGFiIGlzIGVuYWJsZWQuXG4gKiBAdHlwZSB7dGFiRXZlbnR9XG4gKiBAYWJzdHJhY3RcbiAqIEBtZW1iZXJPZiBUYWJ6LnByb3RvdHlwZVxuICovXG5UYWJ6LnByb3RvdHlwZS5vbkVuYWJsZWQgPSBub29wO1xuXG4vKipcbiAqIENhbGxlZCBhZnRlciBhIHByZXZpb3VzbHkgZW5hYmxlZCB0YWIgaXMgZGlzYWJsZWQgYnkgYW5vdGhlciB0YWIgYmVpbmcgZW5hYmxlZC5cbiAqIEB0eXBlIHt0YWJFdmVudH1cbiAqIEBhYnN0cmFjdFxuICogQG1lbWJlck9mIFRhYnoucHJvdG90eXBlXG4gKi9cblRhYnoucHJvdG90eXBlLm9uRGlzYWJsZWQgPSBub29wO1xuXG5mdW5jdGlvbiBub29wKCkge30gLy8gbnVsbCBwYXR0ZXJuXG5cbmZ1bmN0aW9uIGZvckVhY2hFbChzZWxlY3RvciwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbCgoY29udGV4dCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksIGl0ZXJhdGVlKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRhYno7XG4iLCIvLyB0ZW1wbGV4IG5vZGUgbW9kdWxlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L3RlbXBsZXhcblxuLyogZXNsaW50LWVudiBub2RlICovXG5cbi8qKlxuICogTWVyZ2VzIHZhbHVlcyBvZiBleGVjdXRpb24gY29udGV4dCBwcm9wZXJ0aWVzIG5hbWVkIGluIHRlbXBsYXRlIGJ5IHtwcm9wMX0sXG4gKiB7cHJvcDJ9LCBldGMuLCBvciBhbnkgamF2YXNjcmlwdCBleHByZXNzaW9uIGluY29ycG9yYXRpbmcgc3VjaCBwcm9wIG5hbWVzLlxuICogVGhlIGNvbnRleHQgYWx3YXlzIGluY2x1ZGVzIHRoZSBnbG9iYWwgb2JqZWN0LiBJbiBhZGRpdGlvbiB5b3UgY2FuIHNwZWNpZnkgYSBzaW5nbGVcbiAqIGNvbnRleHQgb3IgYW4gYXJyYXkgb2YgY29udGV4dHMgdG8gc2VhcmNoIChpbiB0aGUgb3JkZXIgZ2l2ZW4pIGJlZm9yZSBmaW5hbGx5XG4gKiBzZWFyY2hpbmcgdGhlIGdsb2JhbCBjb250ZXh0LlxuICpcbiAqIE1lcmdlIGV4cHJlc3Npb25zIGNvbnNpc3Rpbmcgb2Ygc2ltcGxlIG51bWVyaWMgdGVybXMsIHN1Y2ggYXMgezB9LCB7MX0sIGV0Yy4sIGRlcmVmXG4gKiB0aGUgZmlyc3QgY29udGV4dCBnaXZlbiwgd2hpY2ggaXMgYXNzdW1lZCB0byBiZSBhbiBhcnJheS4gQXMgYSBjb252ZW5pZW5jZSBmZWF0dXJlLFxuICogaWYgYWRkaXRpb25hbCBhcmdzIGFyZSBnaXZlbiBhZnRlciBgdGVtcGxhdGVgLCBgYXJndW1lbnRzYCBpcyB1bnNoaWZ0ZWQgb250byB0aGUgY29udGV4dFxuICogYXJyYXksIHRodXMgbWFraW5nIGZpcnN0IGFkZGl0aW9uYWwgYXJnIGF2YWlsYWJsZSBhcyB7MX0sIHNlY29uZCBhcyB7Mn0sIGV0Yy4sIGFzIGluXG4gKiBgdGVtcGxleCgnSGVsbG8sIHsxfSEnLCAnV29ybGQnKWAuICh7MH0gaXMgdGhlIHRlbXBsYXRlIHNvIGNvbnNpZGVyIHRoaXMgdG8gYmUgMS1iYXNlZC4pXG4gKlxuICogSWYgeW91IHByZWZlciBzb21ldGhpbmcgb3RoZXIgdGhhbiBicmFjZXMsIHJlZGVmaW5lIGB0ZW1wbGV4LnJlZ2V4cGAuXG4gKlxuICogU2VlIHRlc3RzIGZvciBleGFtcGxlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVcbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBbYXJnc11cbiAqL1xuZnVuY3Rpb24gdGVtcGxleCh0ZW1wbGF0ZSkge1xuICAgIHZhciBjb250ZXh0cyA9IHRoaXMgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMgOiBbdGhpc107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7IGNvbnRleHRzLnVuc2hpZnQoYXJndW1lbnRzKTsgfVxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKHRlbXBsZXgucmVnZXhwLCB0ZW1wbGV4Lm1lcmdlci5iaW5kKGNvbnRleHRzKSk7XG59XG5cbnRlbXBsZXgucmVnZXhwID0gL1xceyguKj8pXFx9L2c7XG5cbnRlbXBsZXgud2l0aCA9IGZ1bmN0aW9uIChpLCBzKSB7XG4gICAgcmV0dXJuICd3aXRoKHRoaXNbJyArIGkgKyAnXSl7JyArIHMgKyAnfSc7XG59O1xuXG50ZW1wbGV4LmNhY2hlID0gW107XG5cbnRlbXBsZXguZGVyZWYgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCEodGhpcy5sZW5ndGggaW4gdGVtcGxleC5jYWNoZSkpIHtcbiAgICAgICAgdmFyIGNvZGUgPSAncmV0dXJuIGV2YWwoZXhwciknO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29kZSA9IHRlbXBsZXgud2l0aChpLCBjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBsZXguY2FjaGVbdGhpcy5sZW5ndGhdID0gZXZhbCgnKGZ1bmN0aW9uKGV4cHIpeycgKyBjb2RlICsgJ30pJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuICAgIH1cbiAgICByZXR1cm4gdGVtcGxleC5jYWNoZVt0aGlzLmxlbmd0aF0uY2FsbCh0aGlzLCBrZXkpO1xufTtcblxudGVtcGxleC5tZXJnZXIgPSBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuICAgIC8vIEFkdmFuY2VkIGZlYXR1cmVzOiBDb250ZXh0IGNhbiBiZSBhIGxpc3Qgb2YgY29udGV4dHMgd2hpY2ggYXJlIHNlYXJjaGVkIGluIG9yZGVyLlxuICAgIHZhciByZXBsYWNlbWVudDtcblxuICAgIHRyeSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gaXNOYU4oa2V5KSA/IHRlbXBsZXguZGVyZWYuY2FsbCh0aGlzLCBrZXkpIDogdGhpc1swXVtrZXldO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSAneycgKyBrZXkgKyAnfSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcGxhY2VtZW50O1xufTtcblxuLy8gdGhpcyBpbnRlcmZhY2UgY29uc2lzdHMgc29sZWx5IG9mIHRoZSB0ZW1wbGV4IGZ1bmN0aW9uIChhbmQgaXQncyBwcm9wZXJ0aWVzKVxubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGV4O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgRXh0ZW5kIGZyb20gdGhpcyBiYXNlIGNsYXNzIHVzaW5nIGBCYXNlLmV4dGVuZGAgcGVyIGV4YW1wbGUuXG4gKiBAZXhhbXBsZVxuICogdmFyIHByb3RvdHlwZSA9IHsgLi4uIH07XG4gKiB2YXIgZGVzY2VuZGFudENsYXNzID0gQmFzZS5leHRlbmQocHJvdG90eXBlfTtcbiAqIEBjbGFzc2Rlc2MgVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzIGF2YWlsYWJsZSBmb3IgYWxsIEh5cGVyZ3JpZCBjbGFzc2VzLlxuICovXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2V4dGVuZC1tZScpLkJhc2U7XG5cbkJhc2UucHJvdG90eXBlLmRlcHJlY2F0ZWQgPSByZXF1aXJlKCcuL2xpYi9kZXByZWNhdGVkJyk7XG5CYXNlLnByb3RvdHlwZS5IeXBlcmdyaWRFcnJvciA9IHJlcXVpcmUoJy4vbGliL2Vycm9yJyk7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGdldHRpbmcgdGhlIHZhbHVlIHdoZW4gdGhhdCB2YWx1ZSBjYW4gYmUgZGVmaW5lZCBhcyBhIGZ1bmN0aW9uIHRoYXQgbmVlZHMgdG8gYmUgY2FsbGVkIHRvIGdldCB0aGUgYWN0dWFsIChwcmltaXRpdmUpIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuQmFzZS5wcm90b3R5cGUudW53cmFwID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kXG4gKiBAc3VtbWFyeSBNaXhlcyBzb3VyY2UgbWVtYmVycyBpbnRvIGNhbGxpbmcgY29udGV4dC5cbiAqIEBkZXNjIENvbnRleHQgaXMgdHlwaWNhbGx5IGVpdGhlciBhbiBpbnN0YW5jZSBvciB0aGUgKHNoYXJlZCkgcHJvdG90eXBlIG9mIGEgXCJjbGFzc1wiIGV4dGVuZGVkIGZyb20ge0BsaW5rIEJhc2V9IChzZWUgZXhhbXBsZXMpLlxuICpcbiAqIFR5cGljYWxseSB1c2VkIGJ5IHBsdWctaW5zLlxuICogQGV4YW1wbGVcbiAqIC8vIGRlZmluZSBpbnN0YW5jZSBtZW1iZXJzOiBteUdyaWQuZml4KCksIGV0Yy5cbiAqIG15R3JpZC5taXhJbih7IGZpeDogZnVuY3Rpb24oKSB7Li4ufSwgLi4uIH0pO1xuICogQGV4YW1wbGVcbiAqIC8vIGRlZmluZSBwcm90b3R5cGUgbWVtYmVyczogSHlwZXJncmlkLnByb3RvdHlwZS5maXgoKSwgZXRjLlxuICogSHlwZXJncmlkLnByb3RvdHlwZS5taXhJbih7IGZpeDogZnVuY3Rpb24oKSB7Li4ufSwgLi4uIH0pO1xuICogQFNlZSB7QGxpbmsgaHR0cHM6Ly9qb25laXQuZ2l0aHViLmlvL292ZXJyaWRlci9tb2R1bGUtb3ZlcnJpZGVyLmh0bSMubWl4SW59XG4gKiBAcGFyYW0ge29iamVjdH0gc291cmNlXG4gKi9cbkJhc2UucHJvdG90eXBlLm1peEluID0gcmVxdWlyZSgnb3ZlcnJpZGVyJykubWl4SW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9saWIvcG9seWZpbGxzJyk7IC8vIEluc3RhbGxzIG1pc2MuIHBvbHlmaWxscyBpbnRvIGdsb2JhbCBvYmplY3RzLCBhcyBuZWVkZWRcblxudmFyIEZpbkJhciA9IHJlcXVpcmUoJ2ZpbmJhcnMnKTtcbnZhciBDYW52YXMgPSByZXF1aXJlKCdmaW5jYW52YXMnKTtcbnZhciBQb2ludCA9IHJlcXVpcmUoJ3JlY3Rhbmd1bGFyJykuUG9pbnQ7XG52YXIgUmVjdGFuZ2xlID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKS5SZWN0YW5nbGU7XG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTsgLy8gZnlpOiBpbnN0YWxscyB0aGUgQXJyYXkucHJvdG90eXBlLmZpbmQgcG9seWZpbGwsIGFzIG5lZWRlZFxuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vQmFzZScpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xudmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi9saWIvUmVuZGVyZXInKTtcbnZhciBTZWxlY3Rpb25Nb2RlbCA9IHJlcXVpcmUoJy4vbGliL1NlbGVjdGlvbk1vZGVsJyk7XG52YXIgc3R5bGVzaGVldCA9IHJlcXVpcmUoJy4vbGliL3N0eWxlc2hlZXQnKTtcbnZhciBMb2NhbGl6YXRpb24gPSByZXF1aXJlKCcuL2xpYi9Mb2NhbGl6YXRpb24nKTtcbi8vdmFyIGJlaGF2aW9ycyA9IHJlcXVpcmUoJy4vYmVoYXZpb3JzJyk7XG52YXIgQ2VsbFJlbmRlcmVycyA9IHJlcXVpcmUoJy4vY2VsbFJlbmRlcmVycycpO1xudmFyIENlbGxFZGl0b3JzID0gcmVxdWlyZSgnLi9jZWxsRWRpdG9ycycpO1xudmFyIEJlaGF2aW9ySlNPTiA9IHJlcXVpcmUoJy4vYmVoYXZpb3JzL0pTT04nKTtcblxudmFyIHRoZW1lSW5pdGlhbGl6ZWQgPSBmYWxzZSxcbiAgICBncmlkVGhlbWUgPSBPYmplY3QuY3JlYXRlKGRlZmF1bHRzKSxcbiAgICBnbG9iYWxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShncmlkVGhlbWUpO1xuXG52YXIgd2FybmVkID0ge307XG5cbi8qKnNcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudH0gW2NvbnRhaW5lcl0gLSBDU1Mgc2VsZWN0b3Igb3IgRWxlbWVudFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMuQmVoYXZpb3I9YmVoYXZpb3JzLkpTT05dIC0gQSBiZWhhdmlvciBjb25zdHJ1Y3RvciBvciBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbltdfSBbb3B0aW9ucy5waXBlbGluZV0gLSBBIGxpc3QgZnVuY3Rpb24gY29uc3RydWN0b3JzIHRvIHVzZSBmb3IgcGFzc2luZyBkYXRhIHRocm91Z2ggYSBzZXJpZXMgb2YgdHJhbnNmb3JtcyB0byBvY2N1ciBvbiByZWluZGV4IGNhbGxcbiAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0W119IFtvcHRpb25zLmRhdGFdIC0gUGFzc2VkIHRvIGJlaGF2aW9yIGNvbnN0cnVjdG9yLiBNYXkgYmU6XG4gKiAqIEFuIGFycmF5IG9mIGNvbmdydWVudCByYXcgZGF0YSBvYmplY3RzXG4gKiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb258bWVudUl0ZW1bXX0gW29wdGlvbnMuc2NoZW1hPWRlcml2ZWRTY2hlbWFdIC0gUGFzc2VkIHRvIGJlaGF2aW9yIGNvbnN0cnVjdG9yLiBNYXkgYmU6XG4gKiAqIEEgc2NoZW1hIGFycmF5XG4gKiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgc2NoZW1hIGFycmF5LiBDYWxsZWQgYXQgZmlsdGVyIHJlc2V0IHRpbWUgd2l0aCBiZWhhdmlvciBhcyBjb250ZXh0LlxuICogKiBPbWl0IHRvIGdlbmVyYXRlIGEgYmFzaWMgc2NoZW1hIGZyb20gYHRoaXMuYmVoYXZpb3IuY29sdW1uc2AuXG4gKiBAcGFyYW0ge0JlaGF2aW9yfSBbb3B0aW9ucy5CZWhhdmlvcj1KU09OXSAtIEEgZ3JpZCBiZWhhdmlvciAoZGVzY2VuZGFudCBvZiBCZWhhdmlvciBcImNsYXNzXCIpLlxuICogQHBhcmFtIHtwbHVnaW5TcGVjfHBsdWdpblNwZWNbXX0gW29wdGlvbnMucGx1Z2luc11cbiAqIEBwYXJhbSB7RGF0YU1vZGVsc1tdfSBbb3B0aW9ucy5zdWJncmlkc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGl6YXRpb249SHlwZXJncmlkLmxvY2FsaXphdGlvbl1cbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IFtvcHRpb25zLmNvbnRhaW5lcl0gLSBDU1Mgc2VsZWN0b3Igb3IgRWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFtvcHRpb25zLmxvY2FsaXphdGlvbi5sb2NhbGU9SHlwZXJncmlkLmxvY2FsaXphdGlvbi5sb2NhbGVdIC0gVGhlIGRlZmF1bHQgbG9jYWxlIHRvIHVzZSB3aGVuIGFuIGV4cGxpY2l0IGBsb2NhbGVgIGlzIG9taXR0ZWQgZnJvbSBsb2NhbGl6ZXIgY29uc3RydWN0b3IgY2FsbHMuIFBhc3NlZCB0byBJbnRsLk51bWJlckZvbXJhdGAgYW5kIGBJbnRsLkRhdGVGb21yYXRgLiBTZWUge0AgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bCNMb2NhbGVfaWRlbnRpZmljYXRpb25fYW5kX25lZ290aWF0aW9ufExvY2FsZSBpZGVudGlmaWNhdGlvbiBhbmQgbmVnb3RpYXRpb259IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxvY2FsaXphdGlvbi5udW1iZXJPcHRpb25zPUh5cGVyZ3JpZC5sb2NhbGl6YXRpb24ubnVtYmVyT3B0aW9uc10gLSBPcHRpb25zIHBhc3NlZCB0byBgSW50bC5OdW1iZXJGb21yYXRgIGZvciBjcmVhdGluZyB0aGUgYmFzaWMgXCJudW1iZXJcIiBsb2NhbGl6ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxpemF0aW9uLmRhdGVPcHRpb25zPUh5cGVyZ3JpZC5sb2NhbGl6YXRpb24uZGF0ZU9wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gYEludGwuRGF0ZUZvbXJhdGAgZm9yIGNyZWF0aW5nIHRoZSBiYXNpYyBcImRhdGVcIiBsb2NhbGl6ZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMuc2NoZW1hXVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1hcmdpbl0gLSBvcHRpb25hbCBjYW52YXMgbWFyZ2luc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmdpbi50b3A9MF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tYXJnaW4ucmlnaHQ9MF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tYXJnaW4uYm90dG9tPTBdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFyZ2luLmxlZnQ9MF1cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5ib3VuZGluZ1JlY3RdIC0gb3B0aW9uYWwgZ3JpZCBjb250YWluZXIgYXJndW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ib3VuZGluZ1JlY3QuaGVpZ2h0PTMwMF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ib3VuZGluZ1JlY3Qud2lkdGg9MzAwXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJvdW5kaW5nUmVjdC5wb3N0aW9uPXJlbGF0aXZlXVxuICovXG52YXIgSHlwZXJncmlkID0gQmFzZS5leHRlbmQoJ0h5cGVyZ3JpZCcsIHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGVtZUluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGVtZUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGdyaWRUaGVtZSA9IGJ1aWxkVGhlbWUoZ3JpZFRoZW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vT3B0aW9uYWwgY29udGFpbmVyIGFyZ3VtZW50XG4gICAgICAgIGlmICghKHR5cGVvZiBjb250YWluZXIgPT09ICdzdHJpbmcnKSAmJiAhKGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAvLyBJbnN0YWxsIHNoYXJlZCBwbHVnLWlucyAodGhvc2Ugd2l0aCBhIGBwcmVpbnN0YWxsYCBtZXRob2QpXG4gICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5pbnN0YWxsUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuXG4gICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb24gPSBbMCwgMF07XG4gICAgICAgIHRoaXMubG5mUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsUHJvcGVydGllcyk7XG4gICAgICAgIHRoaXMuaXNXZWJraXQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignd2Via2l0JykgPiAtMTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbCA9IG5ldyBTZWxlY3Rpb25Nb2RlbCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW5kZXJPdmVycmlkZXNDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmFsbG93RXZlbnRIYW5kbGVycyA9IHRydWU7XG4gICAgICAgIHRoaXMuZHJhZ0V4dGVudCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICAgICAgdGhpcy5udW1Sb3dzID0gMDtcbiAgICAgICAgdGhpcy5udW1Db2x1bW5zID0gMDtcbiAgICAgICAgdGhpcy5jbGVhck1vdXNlRG93bigpO1xuICAgICAgICB0aGlzLnNldEZvcm1hdHRlcihvcHRpb25zLmxvY2FsaXphdGlvbik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIGNlbGxSZW5kZXJlcnNcbiAgICAgICAgICogQHR5cGUge0NlbGxSZW5kZXJlcn1cbiAgICAgICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2VsbFJlbmRlcmVycyA9IG5ldyBDZWxsUmVuZGVyZXJzKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIGNlbGxFZGl0b3JzXG4gICAgICAgICAqIEB0eXBlIHtDZWxsRWRpdG9yfVxuICAgICAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jZWxsRWRpdG9ycyA9IG5ldyBDZWxsRWRpdG9ycyh0aGlzKTtcblxuICAgICAgICAvL1NldCB1cCB0aGUgY29udGFpbmVyIGZvciBhIGdyaWQgaW5zdGFuY2VcbiAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IG9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIgfHwgZmluZE9yQ3JlYXRlQ29udGFpbmVyKG9wdGlvbnMuYm91bmRpbmdSZWN0KTtcbiAgICAgICAgdGhpcy5zZXRDb250YWluZXIoY29udGFpbmVyKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLkJlaGF2aW9yKSB7XG4gICAgICAgICAgICB0aGlzLnNldEJlaGF2aW9yKHRoaXMub3B0aW9ucyk7IC8vIGFsc28gc2V0cyB0aGlzLm9wdGlvbnMucGlwZWxpbmUgYW5kIHRoaXMub3B0aW9ucy5kYXRhXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YSh0aGlzLm9wdGlvbnMuZGF0YSwgdGhpcy5vcHRpb25zKTsgLy8gaWYgbm8gYmVoYXZpb3IgaGFzIHlldCBiZWVuIHNldCwgYHNldERhdGFgIHNldHMgYSBkZWZhdWx0IGJlaGF2aW9yIGFuZCB0aGlzLm9wdGlvbnMucGlwZWxpbmVcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBwbHVnaW5zXG4gICAgICAgICAqIEBzdW1tYXJ5IERpY3Rpb25hcnkgb2YgbmFtZWQgaW5zdGFuY2UgcGx1Zy1pbnMuXG4gICAgICAgICAqIEBkZXNjIFNlZSBleGFtcGxlcyBmb3IgaG93IHRvIHJlZmVyZW5jZSAoYWxiZWl0IHRoZXJlIGlzIG5vcm1hbGx5IG5vIG5lZWQgdG8gcmVmZXJlbmNlIHBsdWdpbnMgZGlyZWN0bHkpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgdGhlIGRpY3Rpb25hcnkgb2YgX3NoYXJlZF8gcGx1Z2lucywgc2VlIHtAbGluayBIeXBlcmdyaWQucGx1Z2luc3xwbHVnaW5zfSAoYSBwcm9wZXJ0eSBvZiB0aGUgY29uc3RydWN0b3IpLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgaW5zdGFuY2VQbHVnaW5zID0gbXlHcmlkLnBsdWdpbnM7XG4gICAgICAgICAqIHZhciBpbnN0YW5jZVBsdWdpbnMgPSB0aGlzLnBsdWdpbnMgLy8gaW50ZXJuYWwgdXNlXG4gICAgICAgICAqIHZhciBteUluc3RhbmNlUGx1Z2luID0gbXlHcmlkLnBsdWdpbnMubXlJbnN0YW5jZVBsdWdpbjtcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuXG4gICAgICAgIC8vIEluc3RhbGwgaW5zdGFuY2UgcGx1Zy1pbnMgKHRob3NlIHRoYXQgYXJlIGNvbnN0cnVjdG9ycyBPUiBoYXZlIGFuIGBpbnN0YWxsYCBtZXRob2QpXG4gICAgICAgIHRoaXMuaW5zdGFsbFBsdWdpbnMob3B0aW9ucy5wbHVnaW5zKTtcblxuICAgICAgICAvLyBMaXN0ZW4gZm9yIHByb3BhZ2F0ZWQgbW91c2VjbGlja3MuIFVzZWQgZm9yIGFib3J0aW5nIGVkaXQgbW9kZS5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZUNhdGNoZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRFZGl0aW5nKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2VDYXRjaGVyKTtcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJDZWxsRWRpdG9yOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdyZWdpc3RlckNlbGxFZGl0b3IoQ29uc3RydWN0b3IsIG5hbWUpJywgJ2NlbGxFZGl0b3JzLmFkZChuYW1lLCBDb25zdHJ1Y3RvciknLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgY3JlYXRlQ2VsbEVkaXRvcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdjcmVhdGVDZWxsRWRpdG9yKG5hbWUpJywgJ2NlbGxFZGl0b3JzLmNyZWF0ZShuYW1lKScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBnZXRDZWxsUHJvdmlkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0Q2VsbFByb3ZpZGVyKCknLCAnY2VsbFJlbmRlcmVycycsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICByZWdpc3RlckxvY2FsaXplcjogZnVuY3Rpb24obmFtZSwgbG9jYWxpemVyLCBiYXNlQ2xhc3NOYW1lLCBuZXdDbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgncmVnaXN0ZXJMb2NhbGl6ZXIobmFtZSwgbG9jYWxpemVyLCBiYXNlQ2xhc3NOYW1lLCBuZXdDbGFzc05hbWUpJywgJ2xvY2FsaXphdGlvbi5hZGQobmFtZSwgbG9jYWxpemVyKScsICcxLjAuNicsIGFyZ3VtZW50cyxcbiAgICAgICAgICAgICdTVFJVQ1RVUkFMIENIQU5HRTogTm8gbG9uZ2VyIHN1cHBvcnRzIGRlcml2aW5nIGFuZCByZWdpc3RlcmluZyBhIG5ldyBjZWxsIGVkaXRvciBjbGFzcy4gVXNlIC5jZWxsRWRpdG9ycy5nZXQoYmFzZUNsYXNzTmFtZSkuZXh0ZW5kKG5ld0NsYXNzTmFtZSB8fCBuYW1lLCB7Li4ufSkgZm9yIHRoYXQuJyk7XG4gICAgfSxcbiAgICBnZXRSZW5kZXJlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldFJlbmRlcmVyKCknLCAncmVuZGVyZXInLCAnMS4xLjAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIG51bGwgb2JqZWN0IGJlaGF2aW9yIHNlcnZlcyBhcyBhIHBsYWNlIGhvbGRlci5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgYmVoYXZpb3I6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgcmVzdWxhbn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGlzV2Via2l0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIGFuIGluaXRpYWwgbW91c2Vkb3duIGNsaWNrLCBlaXRoZXIgZm9yIGVkaXRpbmcgYSBjZWxsIG9yIGZvciBkcmFnZ2luZyBhIHNlbGVjdGlvbi5cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtb3VzZURvd246IFtdLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVudCBmcm9tIHRoZSBtb3VzZWRvd24gcG9pbnQgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBkcmFnRXh0ZW50OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQSBmbG9hdCB2YWx1ZSBiZXR3ZWVuIDAuMCAtIDEuMCBvZiB0aGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2U2Nyb2xsVmFsdWU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBIGZsb2F0IHZhbHVlIGJldHdlZW4gMC4wIC0gMS4wIG9mIHRoZSBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgaFNjcm9sbFZhbHVlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbH0gc2VsZWN0aW9uTW9kZWwgLSBBIFtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbF0obW9kdWxlLS5fc2VsZWN0aW9uLW1vZGVsLmh0bWwpIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2VsZWN0aW9uTW9kZWw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Zpbi1oeXBlcmdyaWQtY2VsbC1lZGl0b3J9IGNlbGxFZGl0b3IgLSBUaGUgY3VycmVudCBpbnN0YW5jZSBvZiBbZmluLWh5cGVyZ3JpZC1jZWxsLWVkaXRvcl0obW9kdWxlLWNlbGwtZWRpdG9yc19iYXNlLmh0bWwpLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgY2VsbEVkaXRvcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7ZmluLXZhbXBpcmUtYmFyfSBzYkhTY3JvbGxlciAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3BlbmZpbi9maW5iYXJzfEZpbkJhcn0uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkhTY3JvbGxlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7ZmluLXZhbXBpcmUtYmFyfSBzYlZTY3JvbGxlciAtIEFuIGluc3RhbmNlIG9mIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vb3BlbmZpbi9maW5iYXJzfEZpbkJhcn0uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYlZTY3JvbGxlcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyB2YWx1ZSBvZiBzYlZTY3JvbGxWYWwuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiUHJldlZTY3JvbGxWYWx1ZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmV2aW91cyB2YWx1ZSBvZiBzYkhTY3JvbGxWYWx1ZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JQcmV2SFNjcm9sbFZhbHVlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogaXMgdGhlIHNob3J0IHRlcm0gbWVtb3J5IG9mIHdoYXQgY29sdW1uIEkgbWlnaHQgYmUgZHJhZ2dpbmcgYXJvdW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuXG4gICAgcmVuZGVyT3ZlcnJpZGVzQ2FjaGU6IHt9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjdXJyZW50IGhvdmVyZWQgY2VsbC5cbiAgICAgKiBAdG9kbyBOZWVkIHRvIGRldGVjdCBob3ZlcmluZyBvdmVyIGJvdHRvbSB0b3RhbHMuXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgaG92ZXJDZWxsOiBudWxsLFxuXG4gICAgc2Nyb2xsaW5nTm93OiBmYWxzZSxcblxuICAgIGxhc3RFZGdlU2VsZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIENsZWFyIG91dCBhbGwgc3RhdGUgYW5kIGRhdGEgb2YgYSBncmlkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvbiA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5sbmZQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShnbG9iYWxQcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbCA9IG5ldyBTZWxlY3Rpb25Nb2RlbCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW5kZXJPdmVycmlkZXNDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmNsZWFyTW91c2VEb3duKCk7XG4gICAgICAgIHRoaXMuZHJhZ0V4dGVudCA9IG5ldyBQb2ludCgwLCAwKTtcblxuICAgICAgICB0aGlzLm51bVJvd3MgPSAwO1xuICAgICAgICB0aGlzLm51bUNvbHVtbnMgPSAwO1xuXG4gICAgICAgIHRoaXMudlNjcm9sbFZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5oU2Nyb2xsVmFsdWUgPSAwO1xuXG4gICAgICAgIHRoaXMuY2FuY2VsRWRpdGluZygpO1xuXG4gICAgICAgIHRoaXMuc2JQcmV2VlNjcm9sbFZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYlByZXZIU2Nyb2xsVmFsdWUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuaG92ZXJDZWxsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zY3JvbGxpbmdOb3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvbiA9IFswLCAwXTtcblxuICAgICAgICB0aGlzLmJlaGF2aW9yLnJlc2V0KCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVzZXQoKTtcbiAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5yZXNpemUoKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvckNoYW5nZWQoKTtcblxuICAgICAgICB0aGlzLnJlZnJlc2hQcm9wZXJ0aWVzKCk7XG4gICAgfSxcblxuICAgIC8qKiBAdHlwZWRlZiB7b2JqZWN0fGZ1bmN0aW9ufEFycmF5fSBwbHVnaW5TcGVjXG4gICAgICogQGRlc2MgT25lIG9mOlxuICAgICAqICogc2ltcGxlIEFQSSAtIGEgcGxhaW4gb2JqZWN0IHdpdGggYW4gYGluc3RhbGxgIG1ldGhvZFxuICAgICAqICogb2JqZWN0IEFQSSAtIGFuIG9iamVjdCBjb25zdHJ1Y3RvclxuICAgICAqICogYXJyYXk6XG4gICAgICogICAgKiBmaXJzdCBlbGVtZW50IGlzIGFuIG9wdGlvbmFsIG5hbWUgZm9yIHRoZSBBUEkgb3IgdGhlIG5ld2x5IGluc3RhbnRpYXRlZCBvYmplY3RcbiAgICAgKiAgICAqIG5leHQgZWxlbWVudCAob3IgZmlyc3QgZWxlbWVudCB3aGVuIG5vdCBhIHN0cmluZykgaXMgdGhlIHNpbXBsZSBvciBvYmplY3QgQVBJXG4gICAgICogICAgKiByZW1haW5pbmcgYXJndW1lbnRzIGFyZSBvcHRpb25hbCBhcmd1bWVudHMgZm9yIHRoZSBvYmplY3QgY29uc3RydWN0b3JcbiAgICAgKiAqIGZhbHN5IHZhbHVlIHN1Y2ggYXMgYHVuZGVmaW5lZGAgLSBpZ25vcmVkXG4gICAgICpcbiAgICAgKiBUaGUgQVBJIG1heSBoYXZlIGEgYG5hbWVgIG9yIGAkJENMQVNTX05BTUVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEluc3RhbGwgcGx1Z2lucy5cbiAgICAgKiBAZGVzYyBQbHVnaW4gaW5zdGFsbGF0aW9uOlxuICAgICAqICogRWFjaCBzaW1wbGUgQVBJIGlzIGluc3RhbGxlZCBieSBjYWxsaW5nIGl0J3MgYGluc3RhbGxgIG1ldGhvZCB3aXRoIGB0aGlzYCBhcyBmaXJzdCBhcmcgKyBhbnkgYWRkaXRpb25hbCBhcmdzIGxpc3RlZCBpbiB0aGUgYHBsdWdpblNwZWNgICh3aGVuIGl0IGlzIGFuIGFycmF5KS5cbiAgICAgKiAqIEVhY2ggb2JqZWN0IEFQSSBpcyBpbnN0YWxsZWQgYnkgaW5zdGFudGlhdGluZyBpdCdzIGNvbnN0cnVjdG9yIHdpdGggYHRoaXNgIGFzIGZpcnN0IGFyZyArIGFueSBhZGRpdGlvbmFsIGFyZ3MgbGlzdGVkIGluIHRoZSBgcGx1Z2luU3BlY2AgKHdoZW4gaXQgaXMgYW4gYXJyYXkpLlxuICAgICAqXG4gICAgICogVGhlIHJlc3VsdGluZyBwbGFpbiBvYmplY3Qgb3IgaW5zdGFudGlhdGVkIG9iamVjdHMgbWF5IGJlIG5hbWVkIGJ5IChpbiBwcmlvcml0eSBvcmRlcik6XG4gICAgICogMS4gaWYgYHBsdWdpblNwZWNgIGNvbnRhaW5zIGFuIGFycmF5IGFuZCBmaXJzdCBlbGVtZW50IGlzIGEgc3RyaW5nXG4gICAgICogMi4gb2JqZWN0IGhhcyBhIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAqIDMuIG9iamVjdCBoYXMgYSBgJCRDTEFTU19OQU1FYCBwcm9wZXJ0eVxuICAgICAqXG4gICAgICogSWYgbmFtZWQsIGEgcmVmZXJlbmNlIHRvIGVhY2ggb2JqZWN0IGlzIHNhdmVkIGluIGB0aGlzLnBsdWdpbnNgLiBJZiB0aGUgcGx1Zy1pbiBpcyB1bm5hbWVkLCBubyByZWZlcmVuY2UgaXMga2VwdC5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSB0d28gdHlwZXMgb2YgcGx1Z2luIGluc3RhbGxhdGlvbnM6XG4gICAgICogKiBQcmVpbnN0YWxsZWQgcGx1Z2lucyB3aGljaCBhcmUgaW5zdGFsbGVkIG9uIHRoZSBwcm90b3R5cGUuIFRoZXNlIGFyZSBzaW1wbGUgQVBJIHBsdWdpbnMgd2l0aCBhIGBwcmVpbnN0YWxsYCBtZXRob2QgY2FsbGVkIHdpdGggdGhlIGBpbnN0YWxsUGx1Z2luc2AgY2FsbGluZyBjb250ZXh0IGFzIHRoZSBmaXJzdCBhcmd1bWVudC4gUHJlaW5zdGFsbGF0aW9ucyBhcmUgYXV0b21hdGljYWxseSBwZXJmb3JtZWQgd2hlbmV2ZXIgYSBncmlkIGlzIGluc3RhbnRpYXRlZCAoYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY29uc3RydWN0b3IpLCBieSBjYWxsaW5nIGBpbnN0YWxsUGx1Z2luc2Agd2l0aCBgSHlwZXJncmlkLnByb3RvdHlwZWAgYXMgdGhlIGNhbGxpbmcgY29udGV4dC5cbiAgICAgKiAqIFJlZ3VsYXIgcGx1Z2lucyB3aGljaCBhcmUgaW5zdGFsbGVkIG9uIHRoZSBpbnN0YW5jZS4gVGhlc2UgYXJlIHNpbXBsZSBBUEkgcGx1Z2lucyB3aXRoIGFuIGBpbnN0YWxsYCBtZXRob2QsIGFzIHdlbGwgYXMgYWxsIG9iamVjdCBBUEkgcGx1Z2lucyAoY29uc3RydWN0b3JzKSwgY2FsbGVkIHdpdGggdGhlIGBpbnN0YWxsUGx1Z2luc2AgY2FsbGluZyBjb250ZXh0IGFzIHRoZSBmaXJzdCBhcmd1bWVudC4gVGhlc2UgaW5zdGFsbGF0aW9ucyBhcmUgYXV0b21hdGljYWxseSBwZXJmb3JtZWQgd2hlbmV2ZXIgYSBncmlkIGlzIGluc3RhbnRpYXRlZCAoYXQgdGhlIGVuZCBvZiB0aGUgY29uc3RydWN0b3IpLCBjYWxsZWQgd2l0aCB0aGUgbmV3IGdyaWQgaW5zdGFuY2UgYXMgdGhlIGNhbGxpbmcgY29udGV4dC5cbiAgICAgKlxuICAgICAqIFBsdWdpbnMgbWF5IGhhdmUgYm90aCBgcHJlaW5zdGFsbGAgX2FuZF8gYGluc3RhbGxgIG1ldGhvZHMsIGluIHdoaWNoIGNhc2UgYm90aCB3aWxsIGJlIGNhbGxlZC4gSG93ZXZlciwgbm90ZSB0aGF0IGluIGFueSBjYXNlLCBgaW5zdGFsbGAgbWV0aG9kcyBvbiBvYmplY3QgQVBJIHBsdWdpbnMgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAdGhpcyB7SHlwZXJncmlkfEh5cGVyZ3JpZC5wcm90b3R5cGV9XG4gICAgICogQHBhcmFtIHtwbHVnaW5TcGVjfHBsdWdpblNwZWNbXX0gW3BsdWdpbnNdIC0gVGhlIHBsdWdpbnMgdG8gaW5zdGFsbC4gVGhpcyBjYWxsIGlzIGEgbm8tb3AgaWYgb21pdHRlZC5cbiAgICAgKi9cbiAgICBpbnN0YWxsUGx1Z2luczogZnVuY3Rpb24ocGx1Z2lucykge1xuICAgICAgICB2YXIgc2hhcmVkID0gdGhpcyA9PT0gSHlwZXJncmlkLnByb3RvdHlwZTsgLy8gRG8gc2hhcmVkIChcInByZWluc3RhbGxlZFwiKSBwbHVnaW5zIChpZiBhbnkpXG5cbiAgICAgICAgaWYgKCFwbHVnaW5zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocGx1Z2lucykpIHtcbiAgICAgICAgICAgIHBsdWdpbnMgPSBbcGx1Z2luc107XG4gICAgICAgIH1cblxuICAgICAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSwgYXJncywgaGFzaDtcblxuICAgICAgICAgICAgaWYgKCFwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGlnbm9yZSBmYWxzeSBwbHVnaW4gc3BlY1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgZmlyc3QgYXJnIHRvIGNvbnN0cnVjdG9yIHRvIGB0aGlzYCAodGhlIGdyaWQgaW5zdGFuY2UpXG4gICAgICAgICAgICAvLyBzZXQgZmlyc3QgYXJnIHRvIGBpbnN0YWxsYCBtZXRob2QgdG8gYHRoaXNgICh0aGUgZ3JpZCBpbnN0YW5jZSlcbiAgICAgICAgICAgIC8vIHNldCBmaXJzdCBhcmcgdG8gYHByZWluc3RhbGxgIG1ldGhvZCB0byBgdGhpc2AgKHRoZSBIeXBlcmdyaWQgcHJvdG90eXBlKVxuICAgICAgICAgICAgYXJncyA9IFt0aGlzXTtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGx1Z2luKSkge1xuICAgICAgICAgICAgICAgIGlmICghcGx1Z2luLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQocGx1Z2luLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luID0gcGx1Z2luWzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGx1Z2luLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChwbHVnaW4uc2xpY2UoMikpO1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gcGx1Z2luWzBdO1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4gPSBwbHVnaW5bMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIGlnbm9yZSBlbXB0eSBhcnJheSBvciBhcnJheSB3aXRoIHNpbmdsZSBzdHJpbmcgZWxlbWVudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXJpdmUgQVBJIG5hbWUgaWYgbm90IGdpdmVuIGluIHBsdWdpblNwZWNcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IHBsdWdpbi5uYW1lIHx8IHBsdWdpbi4kJENMQVNTX05BTUU7XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSBmaXJzdCBjaGFyYWN0ZXIgdG8gbG93ZXIgY2FzZVxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigwLCAxKS50b0xvd2VyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaGFyZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBgcHJlaW5zdGFsbGAgbWV0aG9kXG4gICAgICAgICAgICAgICAgaGFzaCA9IHRoaXMuY29uc3RydWN0b3IucGx1Z2lucztcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnByZWluc3RhbGwgJiYgIWhhc2hbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLnByZWluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpbnN0YW5jZSBwbHVnLWluczpcbiAgICAgICAgICAgICAgICBoYXNoID0gdGhpcy5wbHVnaW5zO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RhbGwgXCJvYmplY3QgQVBJXCIgYnkgaW5zdGFudGlhdGluZ1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQobnVsbCk7IC8vIGNvbnRleHQgZm9yIHRoZSBgYmluZGAgY2FsbFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4gPSBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KHBsdWdpbiwgYXJncykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGx1Z2luLmluc3RhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGFsbCBcInNpbXBsZSBBUElcIiBieSBjYWxsaW5nIGl0cyBgaW5zdGFsbGAgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcGx1Z2luLnByZWluc3RhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJhc2UucHJvdG90eXBlLkh5cGVyZ3JpZEVycm9yKCdFeHBlY3RlZCBwbHVnaW4gKGEgY29uc3RydWN0b3I7IG9yIGFuIEFQSSB3aXRoIGEgYHByZWluc3RhbGxgIG1ldGhvZCBhbmQvb3IgYW4gYGluc3RhbGxgIG1ldGhvZCkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGhhc2hbbmFtZV0gPSBwbHVnaW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFVuaW5zdGFsbCBhbGwgdW5pbnN0YWxsYWJsZSBwbHVnaW5zIG9yIGp1c3QgbmFtZWQgcGx1Z2lucy5cbiAgICAgKiBAZGVzYyBDYWxscyBgdW5pbnN0YWxsYCBvbiBwbHVnaW5zIHRoYXQgZGVmaW5lIHN1Y2ggYSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBUbyB1bmluc3RhbGwgXCJwcmVpbnN0YWxsZWRcIiBwbHVnaW5zLCBjYWxsIHdpdGggYEh5cGVyZ3JpZC5wcm90b3R5cGVgIGFzIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBGb3IgY29udmVuaWVuY2UsIHRoZSBmb2xsb3dpbmcgYXJncyBhcmUgcGFzc2VkIHRvIHRoZSBjYWxsOlxuICAgICAqICogYHRoaXNgIC0gdGhlIHBsdWdpbiB0byBiZSB1bmluc3RhbGxlZFxuICAgICAqICogYGdyaWRgIC0gdGhlIGh5cGVyZ3JpZCBvYmplY3RcbiAgICAgKiAqIGBrZXlgIC0gbmFtZSBvZiB0aGUgcGx1Z2luIHRvIGJlIHVuaW5zdGFsbGVkIChfaS5lLixfIGtleSBpbiBgcGx1Z2luc2ApXG4gICAgICogKiBgcGx1Z2luc2AgLSB0aGUgcGx1Z2lucyBoYXNoIChhLmsuYS4gYGdyaWQucGx1Z2luc2ApXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3Rpcm5nW119IFtwbHVnaW5OYW1lc10gSWYgcHJvdmlkZWQsIGxpbWl0IHVuaW5zdGFsbCB0byB0aGUgbmFtZWQgcGx1Z2luIChzdHJpbmcpIG9yIHBsdWdpbnMgKHN0cmluZ1tdKS5cbiAgICAgKi9cbiAgICB1bmluc3RhbGxQbHVnaW5zOiBmdW5jdGlvbihwbHVnaW5OYW1lcykge1xuICAgICAgICBpZiAoIXBsdWdpbk5hbWVzKSB7XG4gICAgICAgICAgICBwbHVnaW5OYW1lcyA9IFtdO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBsdWdpbk5hbWVzKSkge1xuICAgICAgICAgICAgcGx1Z2luTmFtZXMgPSBbcGx1Z2luTmFtZXNdO1xuICAgICAgICB9XG4gICAgICAgIF8odGhpcy5wbHVnaW5zKS5lYWNoKGZ1bmN0aW9uKHBsdWdpbiwga2V5LCBwbHVnaW5zKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICAgICAgICAgcGx1Z2luTmFtZXMuaW5kZXhPZihrZXkpID49IDAgJiZcbiAgICAgICAgICAgICAgICBwbHVnaW4udW5pbnN0YWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwbHVnaW4udW5pbnN0YWxsKHRoaXMsIGtleSwgcGx1Z2lucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICBnZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0UHJvcGVydGllcygpJywgJ3Byb3BlcnRpZXMnLCAnMS4yLjAnKTtcbiAgICB9LFxuXG4gICAgX2dldFByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sbmZQcm9wZXJ0aWVzO1xuICAgIH0sXG5cbiAgICBjb21wdXRlQ2VsbHNCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgIH0sXG5cbiAgICBzZXRGb3JtYXR0ZXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uID0gbmV3IExvY2FsaXphdGlvbihcbiAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlIHx8IEh5cGVyZ3JpZC5sb2NhbGl6YXRpb24ubG9jYWxlLFxuICAgICAgICAgICAgb3B0aW9ucy5udW1iZXJPcHRpb25zIHx8IEh5cGVyZ3JpZC5sb2NhbGl6YXRpb24ubnVtYmVyT3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0ZU9wdGlvbnMgfHwgSHlwZXJncmlkLmxvY2FsaXphdGlvbi5kYXRlT3B0aW9uc1xuICAgICAgICApO1xuICAgIH0sXG4gICAgZ2V0Rm9ybWF0dGVyOiBmdW5jdGlvbihsb2NhbGl6ZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXphdGlvbi5nZXQobG9jYWxpemVyTmFtZSkuZm9ybWF0O1xuICAgIH0sXG5cbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24obG9jYWxpemVyTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZ2V0Rm9ybWF0dGVyKGxvY2FsaXplck5hbWUpO1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgaXNSb3dSZXNpemVhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5yb3dSZXNpemU7XG4gICAgfSxcblxuICAgIGlzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMuY2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UG9pbnR9IFRoZSBjZWxsIG92ZXIgd2hpY2ggdGhlIGN1cnNvciBpcyBob3ZlcmluZy5cbiAgICAgKi9cbiAgICBnZXRIb3ZlckNlbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRIb3ZlckNlbGwoKScsICdob3ZlckNlbGwnLCAndjEuMi4wJyk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIGNlbGwgdW5kZXIgdGhlIGN1cnNvci5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICAgICAqL1xuICAgIHNldEhvdmVyQ2VsbDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdmFyIG1lID0gdGhpcy5ob3ZlckNlbGw7XG4gICAgICAgIHZhciBuZXdQb2ludCA9IG5ldyBQb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgaWYgKG1lICYmIG1lLmVxdWFscyhuZXdQb2ludCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvdmVyQ2VsbCA9IG5ld1BvaW50O1xuICAgICAgICBpZiAobWUpIHsgdGhpcy5maXJlU3ludGhldGljT25DZWxsRXhpdEV2ZW50KG1lKTsgfSAvL0V4aXQgZmlyc3RcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljT25DZWxsRW50ZXJFdmVudChuZXdQb2ludCk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFtbWVuZCBwcm9wZXJ0aWVzIGZvciBhbGwgaHlwZXJncmlkcyBpbiB0aGlzIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBBIHNpbXBsZSBwcm9wZXJ0aWVzIGhhc2guXG4gICAgICovXG4gICAgYWRkR2xvYmFsUHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICAvL3dlIGNoZWNrIGZvciBleGlzdGVuY2UgdG8gYXZvaWQgcmFjZSBjb25kaXRpb24gaW4gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgaWYgKCFnbG9iYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYWRkR2xvYmFsUHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEdsb2JhbFByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFtZW5kIHByb3BlcnRpZXMgZm9yIGFsbCBoeXBlcmdyaWRzIGluIHRoaXMgcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllcyAtIEEgc2ltcGxlIHByb3BlcnRpZXMgaGFzaC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGRHbG9iYWxQcm9wZXJ0aWVzOiBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIF8ocHJvcGVydGllcykuZWFjaChmdW5jdGlvbihwcm9wZXJ0eSwga2V5KSB7XG4gICAgICAgICAgICBnbG9iYWxQcm9wZXJ0aWVzW2tleV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVXRpbGl0eSBmdW5jdGlvbiB0byBwdXNoIG91dCBwcm9wZXJ0aWVzIGlmIHdlIGNoYW5nZSB0aGVtLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gQW4gb2JqZWN0IG9mIHZhcmlvdXMga2V5IHZhbHVlIHBhaXJzLlxuICAgICAqL1xuICAgIHJlZnJlc2hQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLm11bHRpcGxlU2VsZWN0aW9ucyA9IHN0YXRlLm11bHRpcGxlU2VsZWN0aW9ucztcblxuICAgICAgICAvLyB0aGlzLmNhbnZhcyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKCdmaW4tY2FudmFzJyk7XG4gICAgICAgIC8vdGhpcy5jYW52YXMgPSBuZXcgQ2FudmFzKHRoaXMuZGl2Q2FudmFzLCB0aGlzLnJlbmRlcmVyKTsgLy9UT0RPOiBEbyB3ZSByZWFsbHkgbmVlZCB0byBiZSByZWNyZWF0aW5nIGl0IGhlcmU/XG5cbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5jaGVja1Njcm9sbGJhclZpc2liaWxpdHkoKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5kZWZhdWx0Um93SGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNDb2x1bW5BdXRvc2l6aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuYXV0b3NpemVBbGxDb2x1bW5zKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBbWVuZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGh5cGVyZ3JpZCBvbmx5LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb3JlUHJvcGVydGllcyAtIEEgc2ltcGxlIHByb3BlcnRpZXMgaGFzaC5cbiAgICAgKi9cbiAgICBhZGRQcm9wZXJ0aWVzOiBmdW5jdGlvbihtb3JlUHJvcGVydGllcykge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgYWRkRGVlcFByb3BlcnRpZXMocHJvcGVydGllcywgbW9yZVByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLnJlZnJlc2hQcm9wZXJ0aWVzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIHN0YXRlIG9iamVjdCBmb3IgcmVtZW1iZXJpbmcgb3VyIHN0YXRlLlxuICAgICAqIEBzZWUgW01lbWVudG8gcGF0dGVybl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZW1lbnRvX3BhdHRlcm4pXG4gICAgICovXG4gICAgZ2V0UHJpdmF0ZVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlKCdnZXRQcml2YXRlU3RhdGUoKScsICdwcm9wZXJ0aWVzJywgJzEuMi4wJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBzdGF0ZSBvYmplY3QgdG8gcmV0dXJuIHRvIHRoZSBnaXZlbiB1c2VyIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gQSBtZW1lbnRvIG9iamVjdC5cbiAgICAgKiBAc2VlIFtNZW1lbnRvIHBhdHRlcm5dKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWVtZW50b19wYXR0ZXJuKVxuICAgICAqL1xuICAgIHNldFN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0U3RhdGUoc3RhdGUpO1xuICAgICAgICB0aGlzLnJlZnJlc2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmJlaGF2aW9yQ2hhbmdlZCgpO1xuICAgICAgICAgICAgc2VsZi5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kYXJpZXMoKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9LFxuXG4gICAgZ2V0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRTdGF0ZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgaW5pdGlhbCBtb3VzZSBwb3NpdGlvbiBvbiBhIG1vdXNlIGRvd24gZXZlbnQgZm9yIGNlbGwgZWRpdGluZyBvciBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0TW91c2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLm1vdXNlRG93bi5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlRG93bltsYXN0XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZW1vdmUgdGhlIGxhc3QgaXRlbSBmcm9tIHRoZSBtb3VzZSBkb3duIHN0YWNrLlxuICAgICAqL1xuICAgIHBvcE1vdXNlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93bi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VEb3duLmxlbmd0aCA9IHRoaXMubW91c2VEb3duLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBFbXB0eSBvdXQgdGhlIG1vdXNlIGRvd24gc3RhY2suXG4gICAgICovXG4gICAgY2xlYXJNb3VzZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IFtuZXcgUG9pbnQoLTEsIC0xKV07XG4gICAgICAgIHRoaXMuZHJhZ0V4dGVudCA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbW91c2UgcG9pbnQgdGhhdCBpbml0aWF0ZWQgYSBjZWxsIGVkaXQgb3IgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldE1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdGhpcy5tb3VzZURvd24ucHVzaChwb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1BvaW50fSBUaGUgZXh0ZW50IHBvaW50IG9mIHRoZSBjdXJyZW50IGRyYWcgc2VsZWN0aW9uIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBnZXREcmFnRXh0ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0V4dGVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZXQgdGhlIGV4dGVudCBwb2ludCBvZiB0aGUgY3VycmVudCBkcmFnIHNlbGVjdGlvbiBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKi9cbiAgICBzZXREcmFnRXh0ZW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB0aGlzLmRyYWdFeHRlbnQgPSBwb2ludDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIGlzIGEgY2FsbGJhY2sgZnJvbSB0aGUgSHlwZXJncmlkUmVuZGVyZXIgc3ViLWNvbXBvbmVudC4gSXQgaXMgY2FsbGVkIGFmdGVyIGVhY2ggcGFpbnQgb2YgdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBncmlkUmVuZGVyZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxFZGl0b3IuZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0NvbHVtbkF1dG9zaXppbmcoKTtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljR3JpZFJlbmRlcmVkRXZlbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZ3JpZCBoYXMganVzdCBiZWVuIHJlbmRlcmVkLCBtYWtlIHN1cmUgdGhlIGNvbHVtbiB3aWR0aHMgYXJlIG9wdGltYWwuXG4gICAgICovXG4gICAgY2hlY2tDb2x1bW5BdXRvc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5iZWhhdmlvcjtcbiAgICAgICAgYmVoYXZpb3IuYXV0b1NpemVSb3dOdW1iZXJDb2x1bW4oKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDb2x1bW5BdXRvc2l6aW5nKCkgJiYgYmVoYXZpb3IuY2hlY2tDb2x1bW5BdXRvc2l6aW5nKGZhbHNlKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWhhdmlvci5ncmlkLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRhcmllcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBDb25kaXRpb25hbGx5IGNvcHkgdG8gY2xpcGJvYXJkLlxuICAgICAqIEBkZXNjIElmIHdlIGhhdmUgZm9jdXMsIGNvcHkgb3VyIGN1cnJlbnQgc2VsZWN0aW9uIGRhdGEgdG8gdGhlIHN5c3RlbSBjbGlwYm9hcmQuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgY29weSBzeXN0ZW0gZXZlbnQuXG4gICAgICovXG4gICAgY2hlY2tDbGlwYm9hcmRDb3B5OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAodGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGNzdkRhdGEgPSB0aGlzLmdldFNlbGVjdGlvbkFzVFNWKCk7XG4gICAgICAgICAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBjc3ZEYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXZSBoYXZlIGFueSBzZWxlY3Rpb25zLlxuICAgICAqL1xuICAgIGhhc1NlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gd2VyZSBub3QgZnVsbHkgaW5pdGlhbGl6ZWQgeWV0XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuaGFzU2VsZWN0aW9ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRhYiBzZXBhcmF0ZWQgdmFsdWUgc3RyaW5nIGZyb20gdGhlIHNlbGVjdGlvbiBhbmQgb3VyIGRhdGEuXG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uQXNUU1Y6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc20gPSB0aGlzLnNlbGVjdGlvbk1vZGVsO1xuICAgICAgICBpZiAoc20uaGFzU2VsZWN0aW9ucygpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9uTWF0cml4KCk7XG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gc2VsZWN0aW9uc1tzZWxlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF0cml4U2VsZWN0aW9uQXNUU1Yoc2VsZWN0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc20uaGFzUm93U2VsZWN0aW9ucygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXRyaXhTZWxlY3Rpb25Bc1RTVih0aGlzLmdldFJvd1NlbGVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzbS5oYXNDb2x1bW5TZWxlY3Rpb25zKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1hdHJpeFNlbGVjdGlvbkFzVFNWKHRoaXMuZ2V0Q29sdW1uU2VsZWN0aW9uTWF0cml4KCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE1hdHJpeFNlbGVjdGlvbkFzVFNWOiBmdW5jdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgICAgICAvL29ubHkgdXNlIHRoZSBkYXRhIGZyb20gdGhlIGxhc3Qgc2VsZWN0aW9uXG4gICAgICAgIGlmIChzZWxlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2VsZWN0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc2VsZWN0aW9uc1swXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYXJlYSA9IHdpZHRoICogaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxhc3RDb2wgPSB3aWR0aCAtIDEsXG4gICAgICAgICAgICAgICAgLy9XaGl0ZXNwYWNlIHdpbGwgb25seSBiZSBhZGRlZCBvbiBub24tc2luZ3VsYXIgcm93cywgc2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgIHdoaXRlU3BhY2VEZWxpbWl0ZXJGb3JSb3cgPSAoaGVpZ2h0ID4gMSA/ICdcXG4nIDogJycpO1xuXG4gICAgICAgICAgICAvL2Rpc2FsbG93IGlmIHNlbGVjdGlvbiBpcyB0b28gYmlnXG4gICAgICAgICAgICBpZiAoYXJlYSA+IDIwMDAwKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ3NlbGVjdGlvbiBzaXplIGlzIHRvbyBiaWcgdG8gY29weSB0byB0aGUgcGFzdGUgYnVmZmVyJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgaGVpZ2h0OyBoKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHdpZHRoOyB3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNlbGVjdGlvbnNbd11baF0gKyAodyA8IGxhc3RDb2wgPyAnXFx0JyA6IHdoaXRlU3BhY2VEZWxpbWl0ZXJGb3JSb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdlIGhhdmUgZm9jdXMuXG4gICAgICovXG4gICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYW52YXMoKS5oYXNGb2N1cygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIENsZWFyIGFsbCB0aGUgc2VsZWN0aW9ucy5cbiAgICAgKi9cbiAgICBjbGVhclNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG9udENsZWFyUm93cyA9IHRoaXMuaXNDaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuY2xlYXIoZG9udENsZWFyUm93cyk7XG4gICAgICAgIHRoaXMuY2xlYXJNb3VzZURvd24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBDbGVhciB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb250Q2xlYXJSb3dzID0gdGhpcy5pc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oZG9udENsZWFyUm93cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgQ2xlYXIgdGhlIG1vc3QgcmVjZW50IGNvbHVtbiBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBDbGVhciB0aGUgbW9zdCByZWNlbnQgcm93IHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL3RoaXMuc2VsZWN0aW9uTW9kZWwuY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uKCk7IC8vIGNvbW1lbnRlZCBvZmYgYXMgcGVyIEdSSUQtMTEyXG4gICAgfSxcblxuICAgIGNsZWFyUm93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5jbGVhclJvd1NlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmRhdGFNb2RlbC5jbGVhclNlbGVjdGVkRGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNlbGVjdCBnaXZlbiByZWdpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG94IC0gb3JpZ2luIHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3kgLSBvcmlnaW4geVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleCAtIGV4dGVudCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHlcbiAgICAgKi9cbiAgICBzZWxlY3Q6IGZ1bmN0aW9uKG94LCBveSwgZXgsIGV5KSB7XG4gICAgICAgIGlmIChveCA8IDAgfHwgb3kgPCAwKSB7XG4gICAgICAgICAgICAvL3dlIGRvbid0IHNlbGVjdCBuZWdhdGl2ZSBhcmVhXG4gICAgICAgICAgICAvL2Fsc28gdGhpcyBtZWFucyB0aGVyZSBpcyBubyBvcmlnaW4gbW91c2UgZG93biBmb3IgYSBzZWxlY3Rpb24gcmVjdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0KG94LCBveSwgZXgsIGV5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gR2l2ZW4gcG9pbnQgaXMgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIHNlbGVjdGVkIGFueXdoZXJlIGluIHRoZSBlbnRpcmUgdGFibGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgcm93IGluZGV4LlxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkSW5Sb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuaXNDZWxsU2VsZWN0ZWRJblJvdyh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIHJvdyBpcyBzZWxlY3RlZCBhbnl3aGVyZSBpbiB0aGUgZW50aXJlIHRhYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluQ29sdW1uOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzQ2VsbFNlbGVjdGVkSW5Db2x1bW4oeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBCZWhhdmlvciAobW9kZWwpIG9iamVjdCBmb3IgdGhpcyBncmlkIGNvbnRyb2wuXG4gICAgICogQGRlc2MgVGhpcyBjYW4gYmUgZG9uZSBkeW5hbWljYWxseS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIF8oU2VlIHtAbGluayBiZWhhdmlvcnMuSlNPTiNzZXREYXRhfS4pX1xuICAgICAqIEBwYXJhbSB7QmVoYXZpb3J9IFtvcHRpb25zLmJlaGF2aW9yPUJlaGF2aW9ySlNPTl0gLSBUaGUgYmVoYXZpb3IgKG1vZGVsKSBjYW4gYmUgZWl0aGVyIGEgY29uc3RydWN0b3Igb3IgYW4gaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtkYXRhUm93T2JqZWN0W119IFtvcHRpb25zLmRhdGFdIC0gXyhTZWUge0BsaW5rIGJlaGF2aW9ycy5KU09OI3NldERhdGF9LilfXG4gICAgICogQHBhcmFtIHtwaXBlbGluZVNjaGVtYX0gW29wdGlvbnMucGlwZWxpbmVdIC0gTmV3IHBpcGVsaW5lIGRlc2NyaXB0aW9uLlxuICAgICAqL1xuICAgIHNldEJlaGF2aW9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBCZWhhdmlvciA9IG9wdGlvbnMuQmVoYXZpb3IgfHwgQmVoYXZpb3JKU09OO1xuICAgICAgICB0aGlzLmJlaGF2aW9yID0gbmV3IEJlaGF2aW9yKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmluaXRDYW52YXMoKTtcbiAgICAgICAgdGhpcy5pbml0U2Nyb2xsYmFycygpO1xuICAgICAgICB0aGlzLnJlZnJlc2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IucmVpbmRleCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNldCB0aGUgdW5kZXJseWluZyBkYXRhc291cmNlLlxuICAgICAqIEBkZXNjIFRoaXMgY2FuIGJlIGRvbmUgZHluYW1pY2FsbHkuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3RbXX0gZGF0YVJvd3MgLSBNYXkgYmU6XG4gICAgICogKiBBbiBhcnJheSBvZiBjb25ncnVlbnQgcmF3IGRhdGEgb2JqZWN0cy5cbiAgICAgKiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIF8oU2VlIHtAbGluayBiZWhhdmlvcnMuSlNPTiNzZXREYXRhfS4pX1xuICAgICAqL1xuICAgIHNldERhdGE6IGZ1bmN0aW9uKGRhdGFSb3dzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5iZWhhdmlvcikge1xuICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGhlYXIgaXQgbWVhbnM6XG4gICAgICAgICAgICAvLyAxLiBgQmVoYXZpb3JgIG9wdGlvbiB3YXNuJ3QgZ2l2ZW4gdG8gY29uc3RydWN0b3IuXG4gICAgICAgICAgICAvLyAyLiBgc2V0QmVoYXZpb3JgIHdhc24ndCBjYWxsZWQgZXhwbGljaXRseS5cbiAgICAgICAgICAgIC8vIFNvIHdlIGNhbGwgaXQgbm93IHRvIHNldCB0aGUgZGVmYXVsdCBiZWhhdmlvciAoYnkgbm90IHNwZWNpZnlpbmcgYSBgQmVoYXZpb3JgKSB3aXRoIHRoZSB1bnVzZWQgY29uc3RydWN0b3IgYHBpcGVsaW5lYCBvcHRpb24uXG4gICAgICAgICAgICB0aGlzLnNldEJlaGF2aW9yKHsgcGlwZWxpbmU6IHRoaXMub3B0aW9ucy5waXBlbGluZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldERhdGEoZGF0YVJvd3MsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBfKFNlZSB7QGxpbmsgSHlwZXJncmlkLnByb3RvdHlwZSNzZXREYXRhfS4pX1xuICAgICAqIEBkZXNjIEJpbmRzIHRoZSBkYXRhIGFuZCByZXNoYXBlcyB0aGUgZ3JpZCAobmV3IGNvbHVtbiBvYmplY3RzIGNyZWF0ZWQpXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3RbXX0gZGF0YVJvd3MgLSBNYXkgYmU6XG4gICAgICogKiBBbiBhcnJheSBvZiBjb25ncnVlbnQgcmF3IGRhdGEgb2JqZWN0cy5cbiAgICAgKiAqIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIHVwZGF0ZURhdGE6IGZ1bmN0aW9uKGRhdGFSb3dzLCBvcHRpb25zKXtcbiAgICAgICAgaWYgKCF0aGlzLmJlaGF2aW9yKXtcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YShkYXRhUm93cywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLnVwZGF0ZURhdGEoZGF0YVJvd3MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5iZWhhdmlvci5jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3BpcGVsaW5lc10gLSBOZXcgcGlwZWxpbmUgZGVzY3JpcHRpb24uIF8oU2VlIHtAbGluayBkYXRhTW9kZWxzLkpTT04jc2V0UGlwZWxpbmV9LilfXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIF8oU2VlIHtAbGluayBkYXRhTW9kZWxzLkpTT04jc2V0UGlwZWxpbmV9LilfXG4gICAgICovXG4gICAgc2V0UGlwZWxpbmU6IGZ1bmN0aW9uKERhdGFTb3VyY2VzLCBvcHRpb25zKXtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRQaXBlbGluZShEYXRhU291cmNlcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgSSd2ZSBiZWVuIG5vdGlmaWVkIHRoYXQgdGhlIGJlaGF2aW9yIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGJlaGF2aW9yQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRpdkNhbnZhcykge1xuICAgICAgICAgICAgaWYgKHRoaXMubnVtQ29sdW1ucyAhPT0gdGhpcy5nZXRDb2x1bW5Db3VudCgpIHx8IHRoaXMubnVtUm93cyAhPT0gdGhpcy5nZXRSb3dDb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5udW1Db2x1bW5zID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMubnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJlaGF2aW9yU2hhcGVDaGFuZ2VkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYmVoYXZpb3JTdGF0ZUNoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBncmlkIGRhdGEgaGF2ZSBjaGFuZ2VkLiBZb3UndmUgYmVlbiBub3RpZmllZC5cbiAgICAgKi9cbiAgICBiZWhhdmlvclNoYXBlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRpdkNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kYXJpZXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBncmlkIGRhdGEgaGF2ZSBjaGFuZ2VkLiBZb3UndmUgYmVlbiBub3RpZmllZC5cbiAgICAgKi9cbiAgICBiZWhhdmlvclN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRpdkNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gTXkgYm91bmRzLlxuICAgICAqL1xuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldEJvdW5kcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB2YWx1ZSBvZiBhIGxuZiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gQSBsb29rLWFuZC1mZWVsIGtleS5cbiAgICAgKi9cbiAgICByZXNvbHZlUHJvcGVydHk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAvLyB0b2RvOiB3aGVuIHdlIHJlbW92ZSB0aGlzIG1ldGhvZCwgYWxzbyByZW1vdmUgZm9yd2FyZHMgZnJvbSBCZWhhdmlvci5qcyBhbmQgUmVuZGVyZXIuanNcbiAgICAgICAgaWYgKCF3YXJuZWQucmVzb2x2ZVByb3BlcnR5KSB7XG4gICAgICAgICAgICB3YXJuZWQucmVzb2x2ZVByb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigncmVzb2x2ZVByb3BlcnR5KGtleSkgZGVwcmVjYXRlZCBhcyBvZiB2MS4yLjAgaW4gZmF2b3Igb2YgZ3JpZC5wcm9wZXJ0aWVzW2tleV0gYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNba2V5XTtcbiAgICB9LFxuXG4gICAgcmVwYWludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSB0aGlzLnByb3BlcnRpZXMucmVwYWludEltbWVkaWF0ZWx5O1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgaWYgKG5vdyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5wYWludE5vdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYW52YXMucmVwYWludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUGFpbnQgaW1tZWRpYXRlbHkgaW4gdGhpcyBtaWNyb3Rhc2suXG4gICAgICovXG4gICAgcGFpbnROb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldENhbnZhcygpLnBhaW50Tm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IEluIEhpRFBJIG1vZGUgKGhhcyBhbiBhdHRyaWJ1dGUgYXMgc3VjaCkuXG4gICAgICovXG4gICAgdXNlSGlEUEk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnVzZUhpRFBJICE9PSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZXQgdGhlIGNvbnRhaW5lciBmb3IgYSBncmlkIGluc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXRDb250YWluZXI6IGZ1bmN0aW9uKGRpdikge1xuICAgICAgICB0aGlzLmluaXRDb250YWluZXIoZGl2KTtcbiAgICAgICAgdGhpcy5pbml0UmVuZGVyZXIoKTtcbiAgICAgICAgLy8gaW5qZWN0R3JpZEVsZW1lbnRzLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgSW5pdGlhbGl6ZSBjb250YWluZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXRDb250YWluZXI6IGZ1bmN0aW9uKGRpdikge1xuICAgICAgICBpZiAodHlwZW9mIGRpdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZGl2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vRGVmYXVsdCBQb3NpdGlvbiBhbmQgaGVpZ2h0IHRvIGVuc3VyZSBEbkQgd29ya3NcbiAgICAgICAgaWYgKCFkaXYuc3R5bGUucG9zaXRpb24pIHtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IG51bGw7IC8vIHJldmVydCB0byBzdHlsZXNoZWV0IHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGl2LmNsaWVudEhlaWdodCA8IDEpIHtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBudWxsOyAvLyByZXZlcnQgdG8gc3R5bGVzaGVldCB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGVzaGVldC5pbmplY3QoJ2dyaWQnKTtcblxuICAgICAgICAvL3ByZXZlbnQgdGhlIGRlZmF1bHQgY29udGV4dCBtZW51IGZvciBhcHBlYXJpbmdcbiAgICAgICAgZGl2Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRpdi5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG5cbiAgICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoJ2h5cGVyZ3JpZC1jb250YWluZXInKTtcbiAgICAgICAgZGl2LmlkID0gZGl2LmlkIHx8ICdoeXBlcmdyaWQnICsgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5oeXBlcmdyaWQtY29udGFpbmVyJykubGVuZ3RoIC0gMSB8fCAnJyk7XG5cbiAgICAgICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgSW5pdGlhbGl6ZSBkcmF3aW5nIHN1cmZhY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGl2Q2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBtYXJnaW4gPSB0aGlzLm9wdGlvbnMubWFyZ2luIHx8IHt9LFxuICAgICAgICAgICAgZGl2Q2FudmFzID0gdGhpcy5kaXZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIHN0eWxlID0gZGl2Q2FudmFzLnN0eWxlO1xuXG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgc3R5bGUudG9wID0gbWFyZ2luLnRvcCB8fCAwO1xuICAgICAgICBzdHlsZS5yaWdodCA9IG1hcmdpbi5yaWdodCB8fCAwO1xuICAgICAgICBzdHlsZS5ib3R0b20gPSBtYXJnaW4uYm90dG9tIHx8IDA7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBtYXJnaW4ubGVmdCB8fCAwO1xuXG4gICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKGRpdkNhbnZhcyk7XG5cbiAgICAgICAgdGhpcy5jYW52YXMgPSBuZXcgQ2FudmFzKGRpdkNhbnZhcywgdGhpcy5yZW5kZXJlcik7XG4gICAgICAgIHRoaXMuY2FudmFzLmNhbnZhcy5jbGFzc0xpc3QuYWRkKCdoeXBlcmdyaWQnKTtcbiAgICAgICAgdGhpcy5jYW52YXMuY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMucHJvcGVydGllcy5saW5lQ29sb3I7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlc2l6ZSgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldE1vdXNlRXZlbnQoZSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQoZS5kZXRhaWwubW91c2UpLFxuICAgICAgICAgICAgICAgICdwcmltaXRpdmVFdmVudCcsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYW52YXMucmVzaXplTm90aWZpY2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnJlc2l6ZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtbW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucHJvcGVydGllcy5yZWFkT25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVNb3VzZU1vdmUoZ2V0TW91c2VFdmVudChlKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1tb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmFib3J0RWRpdGluZygpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBnZXRNb3VzZUV2ZW50KGUpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5rZXlzID0gZS5kZXRhaWwua2V5cztcbiAgICAgICAgICAgIHNlbGYubW91c2VEb3duU3RhdGUgPSBtb3VzZUV2ZW50O1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZU1vdXNlRG93bihtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY01vdXNlRG93bkV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgc2VsZi5yZXBhaW50KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1jbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IGdldE1vdXNlRXZlbnQoZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LmtleXMgPSBlLmRldGFpbC5rZXlzOyAvLyB0b2RvOiB0aGlzIHdhcyBpbiBmaW4tdGFwIGJ1dCB3YXNuJ3QgaGVyZVxuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljQ2xpY2tFdmVudChtb3VzZUV2ZW50KTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVDbGljayhtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLW1vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0U2Nyb2xsaW5nTm93KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBnZXRNb3VzZUV2ZW50KGUpO1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZU1vdXNlVXAobW91c2VFdmVudCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5tb3VzZURvd25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0J1dHRvblByZXNzZWRFdmVudChzZWxmLm1vdXNlRG93blN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYubW91c2VEb3duU3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljTW91c2VVcEV2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtZGJsY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBnZXRNb3VzZUV2ZW50KGUpO1xuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljRG91YmxlQ2xpY2tFdmVudChtb3VzZUV2ZW50LCBlKTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVEb3VibGVDbGljayhtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWRyYWcnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5wcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlTW91c2VEcmFnKGdldE1vdXNlRXZlbnQoZSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMta2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmZpcmVTeW50aGV0aWNLZXlkb3duRXZlbnQoZSk7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlS2V5RG93bihlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWtleXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucHJvcGVydGllcy5yZWFkT25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0tleXVwRXZlbnQoZSk7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlS2V5VXAoZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy13aGVlbG1vdmVkJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZVdoZWVsTW92ZWQoZ2V0TW91c2VFdmVudChlKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1tb3VzZW91dCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlTW91c2VFeGl0KGdldE1vdXNlRXZlbnQoZSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtY29udGV4dC1tZW51JywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZUNvbnRleHRNZW51KGdldE1vdXNlRXZlbnQoZSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvL1JlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIHRoZSBjb3B5IGV2ZW50IHNvIHdlIGNhbiBjb3B5IG91ciBzZWxlY3RlZCByZWdpb24gdG8gdGhlIHBhc3RlYnVmZmVyIGlmIGNvbmRpdGlvbnMgYXJlIHJpZ2h0LlxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NvcHknLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHNlbGYuY2hlY2tDbGlwYm9hcmRDb3B5KGV2dCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjb252ZXJ0Vmlld1BvaW50VG9EYXRhUG9pbnQ6IGZ1bmN0aW9uKHVuc2Nyb2xsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuY29udmVydFZpZXdQb2ludFRvRGF0YVBvaW50KHVuc2Nyb2xsZWQpO1xuICAgIH0sXG5cbiAgICBjb252ZXJ0RGF0YVBvaW50VG9WaWV3UG9pbnQ6IGZ1bmN0aW9uKGRhdGFQb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5jb252ZXJ0RGF0YVBvaW50VG9WaWV3UG9pbnQoZGF0YVBvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHdlIGFyZSBpbnRlcmVzdGVkIGluLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBkZWNvcmF0b3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbGxvd0V2ZW50SGFuZGxlcnMpe1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZGVjb3JhdG9yKTtcbiAgICB9LFxuXG4gICAgYWxsb3dFdmVudHM6IGZ1bmN0aW9uKGFsbG93KXtcbiAgICAgICAgaWYgKCh0aGlzLmFsbG93RXZlbnRIYW5kbGVycyA9ICEhYWxsb3cpKXtcbiAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuZmVhdHVyZUNoYWluLmF0dGFjaENoYWluKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLmZlYXR1cmVDaGFpbi5kZXRhY2hDaGFpbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iZWhhdmlvci5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2V0IGZvciBgc2Nyb2xsaW5nTm93YCBmaWVsZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSXROb3cgLSBUaGUgdHlwZSBvZiBldmVudCB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAgKi9cbiAgICBzZXRTY3JvbGxpbmdOb3c6IGZ1bmN0aW9uKGlzSXROb3cpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxpbmdOb3cgPSBpc0l0Tm93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgYHNjcm9sbGluZ05vd2AgZmllbGQuXG4gICAgICovXG4gICAgaXNTY3JvbGxpbmdOb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxpbmdOb3c7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gZGl2aWRlciB1bmRlciB0aGUgbW91c2UgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gVGhlIGV2ZW50IHRvIGludGVyb2dhdGUuXG4gICAgICovXG4gICAgb3ZlckNvbHVtbkRpdmlkZXI6IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIub3ZlckNvbHVtbkRpdmlkZXIobW91c2VFdmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSByb3cgZGl2aWRlciB1bmRlciB0aGUgbW91c2UgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gVGhlIGV2ZW50IHRvIGludGVyb2dhdGUuXG4gICAgICovXG4gICAgb3ZlclJvd0RpdmlkZXI6IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIub3ZlclJvd0RpdmlkZXIobW91c2VFdmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3dpdGNoIHRoZSBjdXJzb3IgZm9yIGEgZ3JpZCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3Vyc29yTmFtZSAtIEEgd2VsbCBrbm93IGN1cnNvciBuYW1lLlxuICAgICAqIEBzZWUgW2N1cnNvciBuYW1lc10oaHR0cDovL3d3dy5qYXZhc2NyaXB0ZXIubmV0L2ZhcS9zdHlsZXNjLmh0bSlcbiAgICAgKi9cbiAgICBiZUN1cnNvcjogZnVuY3Rpb24oY3Vyc29yTmFtZSkge1xuICAgICAgICBpZiAoIWN1cnNvck5hbWUpIHtcbiAgICAgICAgICAgIGN1cnNvck5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXYuc3R5bGUuY3Vyc29yID0gY3Vyc29yTmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSB0aGUgd2hlZWwgbW92ZWQgZXZlbnQgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZVdoZWVsTW92ZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25XaGVlbE1vdmVkKHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBNb3VzZUV4aXQgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VFeGl0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmhhbmRsZU1vdXNlRXhpdCh0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgTW91c2VFeGl0IHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZUNvbnRleHRNZW51OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uQ29udGV4dE1lbnUodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIE1vdXNlTW92ZSB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VNb3ZlOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbk1vdXNlTW92ZSh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIG1vdXNlZG93biB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VEb3duOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5oYW5kbGVNb3VzZURvd24odGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBtb3VzZXVwIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVNb3VzZVVwOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbk1vdXNlVXAodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBjbGljayB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlQ2xpY2s6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm9uQ2xpY2sodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBtb3VzZURyYWcgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlRHJhZzogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25Nb3VzZURyYWcodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBXZSd2ZSBiZWVuIGRvdWJsZWNsaWNrZWQgb24uIERlbGVnYXRlIHRocm91Z2ggdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZURvdWJsZUNsaWNrOiBmdW5jdGlvbihtb3VzZURldGFpbHMpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5vbkRvdWJsZUNsaWNrKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgR2VuZXJhdGUgYSBmdW5jdGlvbiBuYW1lIGFuZCBjYWxsIGl0IG9uIHNlbGYuXG4gICAgICogQGRlc2MgVGhpcyBzaG91bGQgYWxzbyBiZSBkZWxlZ2F0ZWQgdGhyb3VnaCBCZWhhdmlvciBrZWVwaW5nIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhlcmUgdGhvdWdoLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZUtleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25LZXlEb3duKHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG5hbWUgYW5kIGNhbGwgaXQgb24gc2VsZi5cbiAgICAgKiBAZGVzYyBUaGlzIHNob3VsZCBhbHNvIGJlIGRlbGVnYXRlZCB0aHJvdWdoIEJlaGF2aW9yIGtlZXBpbmcgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaGVyZSB0aG91Z2guXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlS2V5VXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iub25LZXlVcCh0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNodXQgZG93biB0aGUgY3VycmVudCBjZWxsIGVkaXRvciBhbmQgc2F2ZSB0aGUgZWRpdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBPbmUgb2Y6XG4gICAgICogKiBgZmFsc2VgIC0gRWRpdGluZyBCVVQgY291bGQgbm90IGFib3J0LlxuICAgICAqICogYHRydWVgIC0gTm90IGVkaXRpbmcgT1Igd2FzIGVkaXRpbmcgQU5EIGFib3J0IHdhcyBzdWNjZXNzZnVsLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc3RvcEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2VsbEVkaXRvciB8fCB0aGlzLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2h1dCBkb3duIHRoZSBjdXJyZW50IGNlbGwgZWRpdG9yIHdpdGhvdXQgc2F2aW5nIHRoZSBlZGl0ZWQgdmFsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IE9uZSBvZjpcbiAgICAgKiAqIGBmYWxzZWAgLSBFZGl0aW5nIEJVVCBjb3VsZCBub3QgYWJvcnQuXG4gICAgICogKiBgdHJ1ZWAgLSBOb3QgZWRpdGluZyBPUiB3YXMgZWRpdGluZyBBTkQgYWJvcnQgd2FzIHN1Y2Nlc3NmdWwuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjYW5jZWxFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNlbGxFZGl0b3IgfHwgdGhpcy5jZWxsRWRpdG9yLmNhbmNlbEVkaXRpbmcoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2l2ZSBjZWxsIGVkaXRvciBvcHBvcnR1bml0eSB0byBjYW5jZWwgKG9yIHNvbWV0aGluZykgaW5zdGVhZCBvZiBzdG9wIC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gT25lIG9mOlxuICAgICAqICogYGZhbHNlYCAtIEVkaXRpbmcgQlVUIGNvdWxkIG5vdCBhYm9ydC5cbiAgICAgKiAqIGB0cnVlYCAtIE5vdCBlZGl0aW5nIE9SIHdhcyBlZGl0aW5nIEFORCBhYm9ydCB3YXMgc3VjY2Vzc2Z1bC5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFib3J0RWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jZWxsRWRpdG9yIHx8IChcbiAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5hYm9ydEVkaXRpbmcgPyB0aGlzLmNlbGxFZGl0b3IuYWJvcnRFZGl0aW5nKCkgOiB0aGlzLmNlbGxFZGl0b3Iuc3RvcEVkaXRpbmcoKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiBqdXN0IHRoZSBjZW50ZXIgJ21haW5cIiBkYXRhIGFyZWEuXG4gICAgICovXG4gICAgZ2V0RGF0YUJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5jYW52YXMuYm91bmRzO1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLCBiLm9yaWdpbi54ICsgYi5leHRlbnQueCwgYi5vcmlnaW4ueSArIGIuZXh0ZW50LnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtDYW52YXN9IE91ciBmaW4tY2FudmFzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBPcGVuIHRoZSBjZWxsLWVkaXRvciBmb3IgdGhlIGNlbGwgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGVkaXRQb2ludCAtIFRoZSBncmlkIGNlbGwgY29vcmRpbmF0ZSBtaXhlZCB3aXRoIHRoZSBkYXRhIHJvdyBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZHxDZWxsRWRpdG9yfSBUaGUgY2VsbEVkaXRvciBkZXRlcm1pbmVkIGZyb20gdGhlIGNlbGwncyByZW5kZXIgcHJvcGVydGllcywgd2hpY2ggbWF5IGJlIG1vZGlmaWVkIGJ5IGxvZ2ljIGFkZGVkIGJ5IG92ZXJyaWRpbmcge0BsaW5rIERhdGFNb2RlbCNnZXRDZWxsRWRpdG9yQXR8Z2V0Q2VsbEVkaXRvckF0fS5cbiAgICAgKi9cbiAgICBlZGl0QXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsRWRpdG9yO1xuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdlZGl0QXQoY2VsbEVkaXRvciwgZXZlbnQpJywgJ2VkaXRBdChldmVudCknLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hYm9ydEVkaXRpbmcoKTsgLy8gaWYgYW5vdGhlciBlZGl0b3IgaXMgb3BlbiwgY2xvc2UgaXQgZmlyc3RcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBldmVudC5pc0dyaWRDb2x1bW4gJiZcbiAgICAgICAgICAgIGV2ZW50LmdldENlbGxQcm9wZXJ0eShldmVudC5pc0dyaWRSb3cgPyAnZWRpdGFibGUnIDogJ2ZpbHRlcmFibGUnKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TW91c2VEb3duKGV2ZW50LmdyaWRDZWxsKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhZ0V4dGVudChuZXcgUG9pbnQoMCwgMCkpO1xuXG4gICAgICAgICAgICBjZWxsRWRpdG9yID0gdGhpcy5nZXRDZWxsRWRpdG9yQXQoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBjZWxsRWRpdG9yLmJlZ2luRWRpdGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNlbGxFZGl0b3I7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIGNvbHVtbiBpcyBmdWxseSB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzQ29sdW1uVmlzaWJsZTogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaXNDb2x1bW5WaXNpYmxlKGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gciAtIFRoZSByYXcgcm93IGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gcm93IGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICovXG4gICAgaXNEYXRhUm93VmlzaWJsZTogZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5pc1Jvd1Zpc2libGUocik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0b2RvIHJlZmFjIGFuZCBtb3ZlIHRvIENlbGxFdmVudFxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBUaGUgY29sdW1uIGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBybiAtIFRoZSBncmlkIHJvdyBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIGNlbGwgaXMgZnVsbHkgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0RhdGFWaXNpYmxlOiBmdW5jdGlvbihjLCBybikge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0RhdGFSb3dWaXNpYmxlKHJuKSAmJiB0aGlzLmlzQ29sdW1uVmlzaWJsZShjKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgaW4gdGhlIGBvZmZzZXRYYCBkaXJlY3Rpb24gaWYgY29sdW1uIGluZGV4IGBjb2xJbmRleGAgaXMgbm90IHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIFRoZSBkaXJlY3Rpb24gYW5kIG1hZ25pdHVkZSB0byBzY3JvbGwgaWYgd2UgbmVlZCB0by5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDb2x1bW4gaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpbnN1cmVNb2RlbENvbElzVmlzaWJsZTogZnVuY3Rpb24oY29sSW5kZXgsIG9mZnNldFgpIHtcbiAgICAgICAgdmFyIG1heENvbHMgPSB0aGlzLmdldENvbHVtbkNvdW50KCkgLSAxLCAvLyAtMSBleGNsdWRlcyBwYXJ0aWFsbHkgdmlzaWJsZSBjb2x1bW5zXG4gICAgICAgICAgICBpbmRleFRvQ2hlY2sgPSBjb2xJbmRleCArIChvZmZzZXRYID4gMCksXG4gICAgICAgICAgICB2aXNpYmxlID0gIXRoaXMuaXNDb2x1bW5WaXNpYmxlKGluZGV4VG9DaGVjaykgfHwgY29sSW5kZXggPT09IG1heENvbHM7XG5cbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgIC8vdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyB0aGUgbGVmdG1vc3QgY29sdW1uXG4gICAgICAgICAgICB0aGlzLnNjcm9sbEJ5KG9mZnNldFgsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIGluIHRoZSBgb2Zmc2V0WWAgZGlyZWN0aW9uIGlmIGNvbHVtbiBpbmRleCBjIGlzIG5vdCB2aXNpYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFRoZSBjb2x1bW4gaW5kZXggaW4gcXVlc3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBUaGUgZGlyZWN0aW9uIGFuZCBtYWduaXR1ZGUgdG8gc2Nyb2xsIGlmIHdlIG5lZWQgdG8uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUm93IGlzIHZpc2libGUuXG4gICAgICovXG4gICAgaW5zdXJlTW9kZWxSb3dJc1Zpc2libGU6IGZ1bmN0aW9uKHJvd0luZGV4LCBvZmZzZXRZKSB7XG4gICAgICAgIHZhciBtYXhSb3dzID0gdGhpcy5nZXRSb3dDb3VudCgpIC0gMSwgLy8gLTEgZXhjbHVkZXMgcGFydGlhbGx5IHZpc2libGUgcm93c1xuICAgICAgICAgICAgaW5kZXhUb0NoZWNrID0gcm93SW5kZXggKyAob2Zmc2V0WSA+IDApLFxuICAgICAgICAgICAgdmlzaWJsZSA9ICF0aGlzLmlzRGF0YVJvd1Zpc2libGUoaW5kZXhUb0NoZWNrKSB8fCByb3dJbmRleCA9PT0gbWF4Um93cztcblxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgLy90aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIHRoZSB0b3Btb3N0IHJvd1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCeSgwLCBvZmZzZXRZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbGx5IGJ5IHRoZSBwcm92aWRlZCBvZmZzZXRzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gU2Nyb2xsIGluIHRoZSB4IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSBTY3JvbGwgaW4gdGhlIHkgZGlyZWN0aW9uIHRoaXMgbXVjaC5cbiAgICAgKi9cbiAgICBzY3JvbGxCeTogZnVuY3Rpb24ob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgICB0aGlzLnNjcm9sbEhCeShvZmZzZXRYKTtcbiAgICAgICAgdGhpcy5zY3JvbGxWQnkob2Zmc2V0WSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIHZlcnRpY2FsbHkgYnkgdGhlIHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIFNjcm9sbCBpbiB0aGUgeSBkaXJlY3Rpb24gdGhpcyBtdWNoLlxuICAgICAqL1xuICAgIHNjcm9sbFZCeTogZnVuY3Rpb24ob2Zmc2V0WSkge1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5zYlZTY3JvbGxlci5yYW5nZS5tYXg7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZ2V0VlNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMCwgb2xkVmFsdWUgKyBvZmZzZXRZKSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VlNjcm9sbFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBob3Jpem9udGFsbHkgYnkgdGhlIHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIFNjcm9sbCBpbiB0aGUgeCBkaXJlY3Rpb24gdGhpcyBtdWNoLlxuICAgICAqL1xuICAgIHNjcm9sbEhCeTogZnVuY3Rpb24ob2Zmc2V0WCkge1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5zYkhTY3JvbGxlci5yYW5nZS5tYXg7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgoMCwgb2xkVmFsdWUgKyBvZmZzZXRYKSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzY3JvbGxUb01ha2VWaXNpYmxlOiBmdW5jdGlvbihjLCByKSB7XG4gICAgICAgIHZhciBkZWx0YSxcbiAgICAgICAgICAgIGR3ID0gdGhpcy5yZW5kZXJlci5kYXRhV2luZG93LFxuICAgICAgICAgICAgZml4ZWRDb2x1bW5Db3VudCA9IHRoaXMucHJvcGVydGllcy5maXhlZENvbHVtbkNvdW50LFxuICAgICAgICAgICAgZml4ZWRSb3dDb3VudCA9IHRoaXMucHJvcGVydGllcy5maXhlZFJvd0NvdW50O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGMgPj0gZml4ZWRDb2x1bW5Db3VudCAmJiAvLyBzY3JvbGwgb25seSBpZiB0YXJnZXQgbm90IGluIGZpeGVkIGNvbHVtbnNcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgaXMgdG8gbGVmdCBvZiBzY3JvbGxhYmxlIGNvbHVtbnM7IG5lZ2F0aXZlIGRlbHRhIHNjcm9sbHMgbGVmdFxuICAgICAgICAgICAgICAgIChkZWx0YSA9IGMgLSBkdy5vcmlnaW4ueCkgPCAwIHx8XG5cbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgaXMgdG8gcmlnaHQgb2Ygc2Nyb2xsYWJsZSBjb2x1bW5zOyBwb3NpdGl2ZSBkZWx0YSBzY3JvbGxzIHJpZ2h0XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogVGhlICsxIGZvcmNlcyByaWdodC1tb3N0IGNvbHVtbiB0byBzY3JvbGwgbGVmdCAoanVzdCBpbiBjYXNlIGl0IHdhcyBvbmx5IHBhcnRpYWxseSBpbiB2aWV3KVxuICAgICAgICAgICAgICAgIChkZWx0YSA9IGMgLSBkdy5jb3JuZXIueCArIDEpID4gMFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2JIU2Nyb2xsZXIuaW5kZXggKz0gZGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICByID49IGZpeGVkUm93Q291bnQgJiYgLy8gc2Nyb2xsIG9ubHkgaWYgdGFyZ2V0IG5vdCBpbiBmaXhlZCByb3dzXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IGlzIGFib3ZlIHNjcm9sbGFibGUgcm93czsgbmVnYXRpdmUgZGVsdGEgc2Nyb2xscyB1cFxuICAgICAgICAgICAgICAgIChkZWx0YSA9IHIgLSBkdy5vcmlnaW4ueSkgPCAwIHx8XG5cbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgaXMgYmVsb3cgc2Nyb2xsYWJsZSByb3dzOyBwb3NpdGl2ZSBkZWx0YSBzY3JvbGxzIGRvd25cbiAgICAgICAgICAgICAgICAoZGVsdGEgPSByIC0gZHcuY29ybmVyLnkpID4gMFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIuaW5kZXggKz0gZGVsdGE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2VsZWN0Q2VsbEFuZFNjcm9sbFRvTWFrZVZpc2libGU6IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RDZWxsKGMsIHIsIHRydWUpO1xuICAgICAgICB0aGlzLnNjcm9sbFRvTWFrZVZpc2libGUoYywgcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQW5zd2VyIHdoaWNoIGRhdGEgY2VsbCBpcyB1bmRlciBhIHBpeGVsIHZhbHVlIG1vdXNlIHBvaW50LlxuICAgICAqIEBwYXJhbSB7bW91c2VQb2ludH0gbW91c2UgLSBUaGUgbW91c2UgcG9pbnQgdG8gaW50ZXJyb2dhdGUuXG4gICAgICovXG5cbiAgICBnZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50OiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQb2ludH0gZ3JpZENlbGwgLSBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIG1vdXNlIGluIHBoeXNpY2FsIGdyaWQgY29vcmRpbmF0ZXMuXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gVGhlIHBpeGVsIGJhc2VkIGJvdW5kcyByZWN0YW5nbGUgZ2l2ZW4gYSBkYXRhIGNlbGwgcG9pbnQuXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRCb3VuZHNPZkNlbGw6IGZ1bmN0aW9uKGdyaWRDZWxsKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5yZW5kZXJlci5nZXRCb3VuZHNPZkNlbGwoZ3JpZENlbGwueCwgZ3JpZENlbGwueSk7XG5cbiAgICAgICAgLy9jb252ZXJ0IHRvIGEgcHJvcGVyIHJlY3RhbmdsZVxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShiLngsIGIueSwgYi53aWR0aCwgYi5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBmaW4tY2FudmFzIHdoZW4gYSByZXNpemUgb2NjdXJzLlxuICAgICAqL1xuICAgIHJlc2l6ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRhcmllcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEEgY2xpY2sgZXZlbnQgb2NjdXJyZWQuXG4gICAgICogQGRlc2MgRGV0ZXJtaW5lIHRoZSBjZWxsIGFuZCBkZWxlZ2F0ZSB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIG1vdXNlIGV2ZW50IHRvIGludGVycm9nYXRlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gQ2hhbmdlZC4gU3BlY2lmaWNhbGx5LCBvbmUgb2Y6XG4gICAgICogKiBgdW5kZWZpbmVkYCByb3cgaGFkIG5vIGRyaWxsLWRvd24gY29udHJvbFxuICAgICAqICogYHRydWVgIGRyaWxsLWRvd24gY2hhbmdlZFxuICAgICAqICogYGZhbHNlYCBkcmlsbC1kb3duIHVuY2hhbmdlZCAod2FzIGFscmVhZHkgaW4gcmVxdWVzdGVkIHN0YXRlKVxuICAgICAqL1xuICAgIGNlbGxDbGlja2VkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgLy9jbGljayBvY2N1cnJlZCBpbiBiYWNrZ3JvdW5kIGFyZWFcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXZlbnQuZ3JpZENlbGwueCA8PSB0aGlzLmdldENvbHVtbkNvdW50KCkgJiZcbiAgICAgICAgICAgIGV2ZW50LmdyaWRDZWxsLnkgPD0gdGhpcy5nZXRSb3dDb3VudCgpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5iZWhhdmlvci5jZWxsQ2xpY2tlZChldmVudCk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmVoYXZpb3IuY2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYyAtIGdyaWQgY29sdW1uIGluZGV4LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGtleXNcbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljQ29sdW1uU29ydEV2ZW50OiBmdW5jdGlvbihjLCBrZXlzKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWNvbHVtbi1zb3J0Jywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjLFxuICAgICAgICAgICAgICAgIGtleXM6IGtleXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljRWRpdG9yS2V5VXBFdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBrZXlFdmVudCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWVkaXRvci1rZXl1cCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlucHV0OiBpbnB1dENvbnRyb2wsXG4gICAgICAgICAgICAgICAga2V5RXZlbnQ6IGtleUV2ZW50LFxuICAgICAgICAgICAgICAgIGNoYXI6IHRoaXMuY2FudmFzLmdldENoYXJNYXAoKVtrZXlFdmVudC5rZXlDb2RlXVtrZXlFdmVudC5zaGlmdEtleSA/IDEgOiAwXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleURvd25FdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBrZXlFdmVudCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWVkaXRvci1rZXlkb3duJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IGlucHV0Q29udHJvbCxcbiAgICAgICAgICAgICAgICBrZXlFdmVudDoga2V5RXZlbnQsXG4gICAgICAgICAgICAgICAgY2hhcjogdGhpcy5jYW52YXMuZ2V0Q2hhck1hcCgpW2tleUV2ZW50LmtleUNvZGVdW2tleUV2ZW50LnNoaWZ0S2V5ID8gMSA6IDBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljRWRpdG9yS2V5UHJlc3NFdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBrZXlFdmVudCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWVkaXRvci1rZXlwcmVzcycsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlucHV0OiBpbnB1dENvbnRyb2wsXG4gICAgICAgICAgICAgICAga2V5RXZlbnQ6IGtleUV2ZW50LFxuICAgICAgICAgICAgICAgIGNoYXI6IHRoaXMuY2FudmFzLmdldENoYXJNYXAoKVtrZXlFdmVudC5rZXlDb2RlXVtrZXlFdmVudC5zaGlmdEtleSA/IDEgOiAwXVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvckRhdGFDaGFuZ2VFdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1lZGl0b3ItZGF0YS1jaGFuZ2UnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXRDb250cm9sLFxuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1yb3ctc2VsZWN0aW9uLWNoYW5nZWRgIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1yb3ctc2VsZWN0aW9uLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCksXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KHNlbGVjdGlvbkV2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0NvbHVtblNlbGVjdGlvbkNoYW5nZWRFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25FdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWNvbHVtbi1zZWxlY3Rpb24tY2hhbmdlZCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHJvd3M6IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKCksXG4gICAgICAgICAgICAgICAgY29sdW1uczogdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChzZWxlY3Rpb25FdmVudCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGRpc3BhdGNoIGEgYGZpbi1zZWxlY3Rpb24tY2hhbmdlZGAgZXZlbnQuXG4gICAgICovXG4gICAgc2VsZWN0aW9uQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZFJvd3MgPSB0aGlzLmdldFNlbGVjdGVkUm93cygpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1zZWxlY3Rpb24tY2hhbmdlZCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHJvd3M6IHNlbGVjdGVkUm93cyxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChzZWxlY3Rpb25FdmVudCk7XG4gICAgfSxcblxuICAgIGdldFJvd1NlbGVjdGlvbjogZnVuY3Rpb24oaW5jbHVkZUhpZGRlbkNvbHVtbnMpIHtcbiAgICAgICAgdmFyIGNvbHVtbiwgcm93cywgZ2V0Q29sdW1uLFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgbnVtQ29sdW1ucyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGlmIChpbmNsdWRlSGlkZGVuQ29sdW1ucykge1xuICAgICAgICAgICAgbnVtQ29sdW1ucyArPSB0aGlzLmdldEhpZGRlbkNvbHVtbnMoKS5sZW5ndGg7XG4gICAgICAgICAgICBnZXRDb2x1bW4gPSB0aGlzLmJlaGF2aW9yLmdldENvbHVtbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldENvbHVtbiA9IHRoaXMuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGdldENvbHVtbiA9IGdldENvbHVtbi5iaW5kKHRoaXMuYmVoYXZpb3IpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbnVtQ29sdW1uczsgYysrKSB7XG4gICAgICAgICAgICBjb2x1bW4gPSBnZXRDb2x1bW4oYyk7XG4gICAgICAgICAgICByb3dzID0gcmVzdWx0W2NvbHVtbi5uYW1lXSA9IG5ldyBBcnJheShzZWxlY3RlZFJvd0luZGV4ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHNlbGVjdGVkUm93SW5kZXhlcy5mb3JFYWNoKGdldFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKHNlbGVjdGVkUm93SW5kZXgsIGopIHtcbiAgICAgICAgICAgIHZhciBkYXRhUm93ID0gc2VsZi5nZXRSb3coc2VsZWN0ZWRSb3dJbmRleCk7XG4gICAgICAgICAgICByb3dzW2pdID0gdmFsT3JGdW5jLmNhbGwoZGF0YVJvdywgY29sdW1uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldEhpZGRlbkNvbHVtbnM6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vQSBub24gaW4tbWVtb3J5IGJlaGF2aW9yIHdpbGwgYmUgbW9yZSB0cm91Ymxlc29tZVxuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRIaWRkZW5Db2x1bW5zKCk7XG4gICAgfSxcblxuICAgIGdldFJvd1NlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHNlbGVjdGVkUm93SW5kZXhlcyA9IHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0ZWRSb3dzKCksXG4gICAgICAgICAgICBudW1Db2xzID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KG51bUNvbHMpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbnVtQ29sczsgYysrKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oYyk7XG4gICAgICAgICAgICByZXN1bHRbY10gPSBuZXcgQXJyYXkoc2VsZWN0ZWRSb3dJbmRleGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMuZm9yRWFjaChnZXRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRWYWx1ZShzZWxlY3RlZFJvd0luZGV4LCByKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVJvdyA9IHNlbGYuZ2V0Um93KHNlbGVjdGVkUm93SW5kZXgpO1xuICAgICAgICAgICAgcmVzdWx0W2NdW3JdID0gdmFsT3JGdW5jLmNhbGwoZGF0YVJvdywgY29sdW1uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldENvbHVtblNlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhUm93LFxuICAgICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKSxcbiAgICAgICAgICAgIHNlbGVjdGVkQ29sdW1uSW5kZXhlcyA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICBudW1Sb3dzID0gdGhpcy5nZXRSb3dDb3VudCgpLFxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KHNlbGVjdGVkQ29sdW1uSW5kZXhlcy5sZW5ndGgpO1xuXG4gICAgICAgIHNlbGVjdGVkQ29sdW1uSW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGVkQ29sdW1uSW5kZXgsIGMpIHtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBzZWxmLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbihzZWxlY3RlZENvbHVtbkluZGV4KSxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSByZXN1bHRbY10gPSBuZXcgQXJyYXkobnVtUm93cyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHIgPSBoZWFkZXJSb3dDb3VudDsgciA8IG51bVJvd3M7IHIrKykge1xuICAgICAgICAgICAgICAgIGRhdGFSb3cgPSBzZWxmLmdldFJvdyhyKTtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbcl0gPSB2YWxPckZ1bmMuY2FsbChkYXRhUm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YVJvdyxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdldEhlYWRlclJvd0NvdW50KCksXG4gICAgICAgICAgICBzZWxlY3RlZENvbHVtbkluZGV4ZXMgPSB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICByb3dDb3VudCA9IHRoaXMuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICBzZWxlY3RlZENvbHVtbkluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3RlZENvbHVtbkluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gc2VsZi5iZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oc2VsZWN0ZWRDb2x1bW5JbmRleCksXG4gICAgICAgICAgICAgICAgdmFsdWVzID0gcmVzdWx0W2NvbHVtbi5uYW1lXSA9IG5ldyBBcnJheShyb3dDb3VudCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHIgPSBoZWFkZXJSb3dDb3VudDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhUm93ID0gc2VsZi5nZXRSb3cocik7XG4gICAgICAgICAgICAgICAgdmFsdWVzW3JdID0gdmFsT3JGdW5jLmNhbGwoZGF0YVJvdywgY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGFSb3csXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKSxcbiAgICAgICAgICAgIHJlY3RzID0gbmV3IEFycmF5KHNlbGVjdGlvbnMubGVuZ3RoKTtcblxuICAgICAgICBzZWxlY3Rpb25zLmZvckVhY2goZ2V0UmVjdCk7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmVjdChzZWxlY3Rpb25SZWN0LCBpKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IG5vcm1hbGl6ZVJlY3Qoc2VsZWN0aW9uUmVjdCksXG4gICAgICAgICAgICAgICAgY29sQ291bnQgPSByZWN0LmV4dGVudC54ICsgMSxcbiAgICAgICAgICAgICAgICByb3dDb3VudCA9IHJlY3QuZXh0ZW50LnkgKyAxLFxuICAgICAgICAgICAgICAgIGNvbHVtbnMgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDAsIHggPSByZWN0Lm9yaWdpbi54OyBjIDwgY29sQ291bnQ7IGMrKywgeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbiA9IHNlbGYuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1uKHgpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBjb2x1bW5zW2NvbHVtbi5uYW1lXSA9IG5ldyBBcnJheShyb3dDb3VudCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gMCwgeSA9IHJlY3Qub3JpZ2luLnk7IHIgPCByb3dDb3VudDsgcisrLCB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVJvdyA9IHNlbGYuZ2V0Um93KHkpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbcl0gPSB2YWxPckZ1bmMuY2FsbChkYXRhUm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVjdHNbaV0gPSBjb2x1bW5zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YVJvdyxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpLFxuICAgICAgICAgICAgcmVjdHMgPSBuZXcgQXJyYXkoc2VsZWN0aW9ucy5sZW5ndGgpO1xuXG4gICAgICAgIHNlbGVjdGlvbnMuZm9yRWFjaChnZXRSZWN0KTtcblxuICAgICAgICBmdW5jdGlvbiBnZXRSZWN0KHNlbGVjdGlvblJlY3QsIGkpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gbm9ybWFsaXplUmVjdChzZWxlY3Rpb25SZWN0KSxcbiAgICAgICAgICAgICAgICBjb2xDb3VudCA9IHJlY3QuZXh0ZW50LnggKyAxLFxuICAgICAgICAgICAgICAgIHJvd0NvdW50ID0gcmVjdC5leHRlbnQueSArIDEsXG4gICAgICAgICAgICAgICAgcm93cyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMCwgeCA9IHJlY3Qub3JpZ2luLng7IGMgPCBjb2xDb3VudDsgYysrLCB4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gcm93c1tjXSA9IG5ldyBBcnJheShyb3dDb3VudCksXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IHNlbGYuYmVoYXZpb3IuZ2V0QWN0aXZlQ29sdW1uKHgpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgciA9IDAsIHkgPSByZWN0Lm9yaWdpbi55OyByIDwgcm93Q291bnQ7IHIrKywgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFSb3cgPSBzZWxmLmdldFJvdyh5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW3JdID0gdmFsT3JGdW5jLmNhbGwoZGF0YVJvdywgY29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlY3RzW2ldID0gcm93cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWN0cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1jb250ZXh0LW1lbnVgIGV2ZW50XG4gICAgICogQHBhcmFtIHtrZXlFdmVudH0gZXZlbnQgLSBUaGUgY2FudmFzIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNDb250ZXh0TWVudUV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5yb3dzID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgZXZlbnQuY29sdW1ucyA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgICAgIGV2ZW50LnNlbGVjdGlvbnMgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudCgnZmluLWNvbnRleHQtbWVudScsIHsgZGV0YWlsOiBldmVudCB9KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljTW91c2VVcEV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5yb3dzID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgZXZlbnQuY29sdW1ucyA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgICAgIGV2ZW50LnNlbGVjdGlvbnMgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudCgnZmluLW1vdXNldXAnLCB7IGRldGFpbDogZXZlbnQgfSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY01vdXNlRG93bkV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBldmVudC5yb3dzID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgZXZlbnQuY29sdW1ucyA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgICAgIGV2ZW50LnNlbGVjdGlvbnMgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgIG5ldyBDdXN0b21FdmVudCgnZmluLW1vdXNlZG93bicsIHsgZGV0YWlsOiBldmVudCB9KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBpc1ZpZXdhYmxlQnV0dG9uOiBmdW5jdGlvbihjLCByKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmlzVmlld2FibGVCdXR0b24oYywgcik7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNCdXR0b25QcmVzc2VkRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlld2FibGVCdXR0b24oZXZlbnQuZGF0YUNlbGwueCwgZXZlbnQuZ3JpZENlbGwueSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoXG4gICAgICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KCdmaW4tYnV0dG9uLXByZXNzZWQnLCB7IGRldGFpbDogZXZlbnQgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY29sdW1uLWRyYWctc3RhcnRgIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNPbkNvbHVtbnNDaGFuZ2VkRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWNvbHVtbi1jaGFuZ2VkLWV2ZW50Jywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY0V2ZW50KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4ta2V5ZG93bmAgZXZlbnQuXG4gICAgICogQHBhcmFtIHtrZXlFdmVudH0gZXZlbnQgLSBUaGUgY2FudmFzIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNLZXlkb3duRXZlbnQ6IGZ1bmN0aW9uKGtleUV2ZW50KSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4ta2V5ZG93bicsIHtcbiAgICAgICAgICAgIGRldGFpbDoga2V5RXZlbnQuZGV0YWlsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWtleXVwYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge2tleUV2ZW50fSBldmVudCAtIFRoZSBjYW52YXMgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0tleXVwRXZlbnQ6IGZ1bmN0aW9uKGtleUV2ZW50KSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4ta2V5dXAnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGtleUV2ZW50LmRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0ZpbHRlckFwcGxpZWRFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmaWx0ZXJFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWZpbHRlci1hcHBsaWVkJyk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZmlsdGVyRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWNlbGwtZW50ZXJgIGV2ZW50XG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY2VsbCBpbiB3aGljaCB0aGUgY2xpY2sgZXZlbnQgb2NjdXJyZWQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBzeXN0ZW0gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY09uQ2VsbEVudGVyRXZlbnQ6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgdmFyIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1jZWxsLWVudGVyJywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWNlbGwtZXhpdGAgZXZlbnQuXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY2VsbCBpbiB3aGljaCB0aGUgY2xpY2sgZXZlbnQgb2NjdXJlZC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIHN5c3RlbSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljT25DZWxsRXhpdEV2ZW50OiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSB7XG4gICAgICAgICAgICBncmlkQ2VsbDogY2VsbCxcbiAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBncmlkOiB0aGlzXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tY2VsbC1leGl0Jywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY2VsbC1jbGlja2AgZXZlbnQuXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY2VsbCBpbiB3aGljaCB0aGUgY2xpY2sgZXZlbnQgb2NjdXJlZC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIHN5c3RlbSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljQ2xpY2tFdmVudDogZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgICAgICB2YXIgY2VsbCA9IG1vdXNlRXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciBkZXRhaWwgPSB7XG4gICAgICAgICAgICBncmlkQ2VsbDogY2VsbCxcbiAgICAgICAgICAgIG1vdXNlUG9pbnQ6IG1vdXNlRXZlbnQubW91c2VQb2ludCxcbiAgICAgICAgICAgIGtleXM6IG1vdXNlRXZlbnQua2V5cyxcbiAgICAgICAgICAgIHByaW1pdGl2ZUV2ZW50OiBtb3VzZUV2ZW50LFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5lbmhhbmNlRG91YmxlQ2xpY2tFdmVudChkZXRhaWwpO1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWNsaWNrJywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tZG91YmxlLWNsaWNrYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIHN5c3RlbSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljRG91YmxlQ2xpY2tFdmVudDogZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuYWJvcnRFZGl0aW5nKCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBjZWxsID0gbW91c2VFdmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdmFyIGRldGFpbCA9IHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgbW91c2VQb2ludDogbW91c2VFdmVudC5tb3VzZVBvaW50LFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5lbmhhbmNlRG91YmxlQ2xpY2tFdmVudChtb3VzZUV2ZW50KTtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1kb3VibGUtY2xpY2snLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5jZWxsRG91YmxlQ2xpY2tlZChjZWxsLCBtb3VzZUV2ZW50KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgcmVuZGVyZWQgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0dyaWRSZW5kZXJlZEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tZ3JpZC1yZW5kZXJlZCcsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIHNjcm9sbCBldmVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFNob3VsZCBiZSBlaXRoZXIgYGZpbi1zY3JvbGwteGAgb3IgYGZpbi1zY3JvbGwteWAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9sZFZhbHVlIC0gVGhlIG9sZCBzY3JvbGwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1ZhbHVlIC0gVGhlIG5ldyBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZmlyZVNjcm9sbEV2ZW50OiBmdW5jdGlvbih0eXBlLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KHR5cGUsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHZlcnRpY2FsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgLSBUaGUgbmV3IHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXRWU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB5ID0gTWF0aC5taW4odGhpcy5zYlZTY3JvbGxlci5yYW5nZS5tYXgsIE1hdGgubWF4KDAsIE1hdGgucm91bmQoeSkpKTtcbiAgICAgICAgaWYgKHkgIT09IHRoaXMudlNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLl9zZXRTY3JvbGxQb3NpdGlvblkoeSk7XG4gICAgICAgICAgICB2YXIgb2xkWSA9IHRoaXMudlNjcm9sbFZhbHVlO1xuICAgICAgICAgICAgdGhpcy52U2Nyb2xsVmFsdWUgPSB5O1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VsZi5zYlZSYW5nZUFkYXB0ZXIuc3ViamVjdENoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmZpcmVTY3JvbGxFdmVudCgnZmluLXNjcm9sbC15Jywgb2xkWSwgeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHZlcnRpY2FsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRWU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52U2Nyb2xsVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBob3Jpem9udGFsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgLSBUaGUgbmV3IHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXRIU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB4ID0gTWF0aC5taW4odGhpcy5zYkhTY3JvbGxlci5yYW5nZS5tYXgsIE1hdGgubWF4KDAsIE1hdGgucm91bmQoeCkpKTtcbiAgICAgICAgaWYgKHggIT09IHRoaXMuaFNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLl9zZXRTY3JvbGxQb3NpdGlvblgoeCk7XG4gICAgICAgICAgICB2YXIgb2xkWCA9IHRoaXMuaFNjcm9sbFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oU2Nyb2xsVmFsdWUgPSB4O1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy9zZWxmLnNiSFJhbmdlQWRhcHRlci5zdWJqZWN0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyZVNjcm9sbEV2ZW50KCdmaW4tc2Nyb2xsLXgnLCBvbGRYLCB4KTtcbiAgICAgICAgICAgICAgICAvL3NlbGYuc3luY2hyb25pemVTY3JvbGxpbmdCb3VuZHJpZXMoKTsgLy8gdG9kbzogQ29tbWVudGVkIG9mZiB0byBwcmV2ZW50IHRoZSBncmlkIGZyb20gYm91bmNpbmcgYmFjaywgYnV0IHRoZXJlIG1heSBiZSByZXB1cmN1c3Npb25zLi4uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIFRoZSB2ZXJ0aWNhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0SFNjcm9sbFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaFNjcm9sbFZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcXVlc3QgaW5wdXQgZm9jdXMuXG4gICAgICovXG4gICAgdGFrZUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHdhc0NlbGxFZGl0b3IgPSB0aGlzLmNlbGxFZGl0b3I7XG4gICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgaWYgKCF3YXNDZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmdldENhbnZhcygpLnRha2VGb2N1cygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVxdWVzdCBmb2N1cyBmb3Igb3VyIGNlbGwgZWRpdG9yLlxuICAgICAqL1xuICAgIGVkaXRvclRha2VGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGxFZGl0b3IudGFrZUZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJbml0aWFsaXplIHRoZSBzY3JvbGwgYmFycy5cbiAgICAgKi9cbiAgICBpbml0U2Nyb2xsYmFyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNiSFNjcm9sbGVyICYmIHRoaXMuc2JWU2Nyb2xsZXIpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBob3J6QmFyID0gbmV3IEZpbkJhcih7XG4gICAgICAgICAgICBvcmllbnRhdGlvbjogJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHNlbGYuc2V0SFNjcm9sbFZhbHVlLmJpbmQoc2VsZiksXG4gICAgICAgICAgICBjc3NTdHlsZXNoZWV0UmVmZXJlbmNlRWxlbWVudDogdGhpcy5kaXZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHZlcnRCYXIgPSBuZXcgRmluQmFyKHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiAndmVydGljYWwnLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHNlbGYuc2V0VlNjcm9sbFZhbHVlLmJpbmQoc2VsZiksXG4gICAgICAgICAgICBwYWdpbmc6IHtcbiAgICAgICAgICAgICAgICB1cDogc2VsZi5wYWdlVXAuYmluZChzZWxmKSxcbiAgICAgICAgICAgICAgICBkb3duOiBzZWxmLnBhZ2VEb3duLmJpbmQoc2VsZilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zYkhTY3JvbGxlciA9IGhvcnpCYXI7XG4gICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIgPSB2ZXJ0QmFyO1xuXG4gICAgICAgIHZhciBoUHJlZml4ID0gdGhpcy5wcm9wZXJ0aWVzLmhTY3JvbGxiYXJDbGFzc1ByZWZpeDtcbiAgICAgICAgdmFyIHZQcmVmaXggPSB0aGlzLnByb3BlcnRpZXMudlNjcm9sbGJhckNsYXNzUHJlZml4O1xuXG4gICAgICAgIGlmIChoUHJlZml4ICYmIGhQcmVmaXggIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnNiSFNjcm9sbGVyLmNsYXNzUHJlZml4ID0gaFByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2UHJlZml4ICYmIHZQcmVmaXggIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnNiVlNjcm9sbGVyLmNsYXNzUHJlZml4ID0gdlByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKGhvcnpCYXIuYmFyKTtcbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodmVydEJhci5iYXIpO1xuXG4gICAgICAgIHRoaXMucmVzaXplU2Nyb2xsYmFycygpO1xuICAgIH0sXG5cbiAgICByZXNpemVTY3JvbGxiYXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zYkhTY3JvbGxlci5zaG9ydGVuQnkodGhpcy5zYlZTY3JvbGxlcikucmVzaXplKCk7XG4gICAgICAgIC8vdGhpcy5zYlZTY3JvbGxlci5zaG9ydGVuQnkodGhpcy5zYkhTY3JvbGxlcik7XG4gICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIucmVzaXplKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2Nyb2xsIHZhbHVlcyBoYXZlIGNoYW5nZWQsIHdlJ3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgc2V0VlNjcm9sbGJhclZhbHVlczogZnVuY3Rpb24obWF4KSB7XG4gICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIucmFuZ2UgPSB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IG1heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzZXRIU2Nyb2xsYmFyVmFsdWVzOiBmdW5jdGlvbihtYXgpIHtcbiAgICAgICAgdGhpcy5zYkhTY3JvbGxlci5yYW5nZSA9IHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogbWF4XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuaFNjcm9sbFZhbHVlID09PSB0aGlzLnNiUHJldkhTY3JvbGxWYWx1ZSAmJiB0aGlzLnZTY3JvbGxWYWx1ZSA9PT0gdGhpcy5zYlByZXZWU2Nyb2xsVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2JQcmV2SFNjcm9sbFZhbHVlID0gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgICAgIHRoaXMuc2JQcmV2VlNjcm9sbFZhbHVlID0gdGhpcy52U2Nyb2xsVmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMuY2VsbEVkaXRvcikge1xuICAgICAgICAgICAgdGhpcy5jZWxsRWRpdG9yLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBHZXQgZGF0YSB2YWx1ZSBhdCBnaXZlbiBjZWxsLlxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFZhbHVlLmFwcGx5KHRoaXMuYmVoYXZpb3IsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IGEgZGF0YSB2YWx1ZSBpbnRvIHRoZSBiZWhhdmlvciAobW9kZWwpIGF0IHRoZSBnaXZlbiBwb2ludFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnNldFZhbHVlLmFwcGx5KHRoaXMuYmVhaHZpb3IsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhlIGRhdGEgZGltZW5zaW9ucyBoYXZlIGNoYW5nZWQsIG9yIG91ciBwaXhlbCBib3VuZHJpZXMgaGF2ZSBjaGFuZ2VkLlxuICAgICAqIEFkanVzdCB0aGUgc2Nyb2xsYmFyIHByb3BlcnRpZXMgYXMgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRhcmllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IHRoaXMuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBudW1Db2x1bW5zID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDE1cHggcGFkZGluZyBhdCBib3R0b20gYW5kIHJpZ2h0IHNpZGVcbiAgICAgICAgdmFyIHNjcm9sbGFibGVIZWlnaHQgPSBib3VuZHMuaGVpZ2h0IC0gdGhpcy5iZWhhdmlvci5nZXRGaXhlZFJvd3NNYXhIZWlnaHQoKSAtIDE1O1xuICAgICAgICB2YXIgc2Nyb2xsYWJsZVdpZHRoID0gYm91bmRzLndpZHRoIC0gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbnNNYXhXaWR0aCgpIC0gMTU7XG5cbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciBjb2x1bW5zV2lkdGggPSAwLCBsYXN0UGFnZUNvbHVtbkNvdW50ID0gMDtcbiAgICAgICAgICAgIGxhc3RQYWdlQ29sdW1uQ291bnQgPCBudW1Db2x1bW5zICYmIGNvbHVtbnNXaWR0aCA8PSBzY3JvbGxhYmxlV2lkdGg7XG4gICAgICAgICAgICBsYXN0UGFnZUNvbHVtbkNvdW50KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb2x1bW5zV2lkdGggKz0gdGhpcy5nZXRDb2x1bW5XaWR0aChudW1Db2x1bW5zIC0gbGFzdFBhZ2VDb2x1bW5Db3VudCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciByb3dzSGVpZ2h0ID0gMCwgbGFzdFBhZ2VSb3dDb3VudCA9IDA7XG4gICAgICAgICAgICBsYXN0UGFnZVJvd0NvdW50IDwgbnVtUm93cyAmJiByb3dzSGVpZ2h0IDw9IHNjcm9sbGFibGVIZWlnaHQ7XG4gICAgICAgICAgICBsYXN0UGFnZVJvd0NvdW50KytcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByb3dzSGVpZ2h0ICs9IHRoaXMuZ2V0Um93SGVpZ2h0KG51bVJvd3MgLSBsYXN0UGFnZVJvd0NvdW50IC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbmZvcm0gc2Nyb2xsIGJhcnNcbiAgICAgICAgaWYgKHRoaXMuc2JIU2Nyb2xsZXIpIHtcbiAgICAgICAgICAgIHZhciBoTWF4ID0gMSArIE1hdGgubWF4KDAsIG51bUNvbHVtbnMgLSBudW1GaXhlZENvbHVtbnMgLSBsYXN0UGFnZUNvbHVtbkNvdW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0SFNjcm9sbGJhclZhbHVlcyhoTWF4KTtcbiAgICAgICAgICAgIHRoaXMuc2V0SFNjcm9sbFZhbHVlKE1hdGgubWluKHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCksIGhNYXgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zYlZTY3JvbGxlcikge1xuICAgICAgICAgICAgdmFyIHZNYXggPSBNYXRoLm1heCgwLCBudW1Sb3dzIC0gbnVtRml4ZWRSb3dzIC0gbGFzdFBhZ2VSb3dDb3VudCk7XG4gICAgICAgICAgICB0aGlzLnNldFZTY3JvbGxiYXJWYWx1ZXModk1heCk7XG4gICAgICAgICAgICB0aGlzLnNldFZTY3JvbGxWYWx1ZShNYXRoLm1pbih0aGlzLmdldFZTY3JvbGxWYWx1ZSgpLCB2TWF4KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3RoaXMuZ2V0Q2FudmFzKCkucmVzaXplKCk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JTdGF0ZUNoYW5nZWQoKTtcblxuICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbGJhcnMoKTtcbiAgICB9LFxuICAgIHN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kZXByZWNhdGVkKCdzeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllcycsICdzeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kYXJpZXMnLCAnMS4yLjAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBOb3RlIHRoYXQgXCJ2aWV3YWJsZSByb3dzXCIgaW5jbHVkZXMgYW55IHBhcnRpYWxseSB2aWV3YWJsZSByb3dzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2Ygdmlld2FibGUgcm93cy5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFZpc2libGVSb3dzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgTm90ZSB0aGF0IFwidmlld2FibGUgY29sdW1uc1wiIGluY2x1ZGVzIGFueSBwYXJ0aWFsbHkgdmlld2FibGUgY29sdW1ucy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHZpZXdhYmxlIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRWaXNpYmxlQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEluaXRpYWxpemUgdGhlIHJlbmRlcmVyIHN1Yi1jb21wb25lbnQuXG4gICAgICovXG4gICAgaW5pdFJlbmRlcmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHRoaXMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIFRoZSB1bnRyYW5zbGF0ZWQgY29sdW1uIGluZGV4LlxuICAgICAqL1xuICAgIGdldENvbHVtbldpZHRoOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIFRoZSB1bnRyYW5zbGF0ZWQgY29sdW1uIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5XaWR0aCAtIFRoZSB3aWR0aCBpbiBwaXhlbHMuXG4gICAgICovXG4gICAgc2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uKGNvbHVtbkluZGV4LCBjb2x1bW5XaWR0aCkge1xuICAgICAgICBpZiAodGhpcy5hYm9ydEVkaXRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCwgY29sdW1uV2lkdGgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldENvbHVtbkVkZ2U6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1uRWRnZShjLCB0aGlzLmdldFJlbmRlcmVyKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCB3aWR0aCBvZiBhbGwgdGhlIGZpeGVkIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5zV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbnNXaWR0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIGdpdmVuIHJvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFRoZSB1bnRyYW5zbGF0ZWQgZml4ZWQgY29sdW1uIGluZGV4LlxuICAgICAqL1xuICAgIGdldFJvd0hlaWdodDogZnVuY3Rpb24ocm93SW5kZXgsIGRhdGFNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRSb3dIZWlnaHQocm93SW5kZXgsIGRhdGFNb2RlbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGdpdmVuIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dIZWlnaHQgLSBUaGUgd2lkdGggaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHNldFJvd0hlaWdodDogZnVuY3Rpb24ocm93SW5kZXgsIHJvd0hlaWdodCwgZGF0YU1vZGVsKSB7XG4gICAgICAgIGlmICh0aGlzLmFib3J0RWRpdGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yLnNldFJvd0hlaWdodChyb3dJbmRleCwgcm93SGVpZ2h0LCBkYXRhTW9kZWwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHRvdGFsIGZpeGVkIHJvd3MgaGVpZ2h0XG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dzSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBfdmlzaWJsZV8gY29sdW1ucy5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Um93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgZ2V0VW5maWx0ZXJlZFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0VW5maWx0ZXJlZFJvd0NvdW50KCknLCBudWxsLCAnMS4yLjAnLCBhcmd1bWVudHMsICdObyBsb25nZXIgc3VwcG9ydGVkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgVGhlIHRvcCBsZWZ0IGFyZWEgaGFzIGJlZW4gY2xpY2tlZCBvblxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICB0b3BMZWZ0Q2xpY2tlZDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci50b3BMZWZ0Q2xpY2tlZCh0aGlzLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQSBmaXhlZCByb3cgaGFzIGJlZW4gY2xpY2tlZC5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGRldGFpbHMuXG4gICAgICovXG4gICAgcm93SGVhZGVyQ2xpY2tlZDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5yb3dIZWFkZXJDbGlja2VkKHRoaXMsIG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBBIGZpeGVkIGNvbHVtbiBoYXMgYmVlbiBjbGlja2VkLlxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJDbGlja2VkOiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmNvbHVtbkhlYWRlckNsaWNrZWQodGhpcywgbW91c2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFuIGVkaXQgZXZlbnQgaGFzIG9jY3VycmVkLiBBY3RpdmF0ZSB0aGUgZWRpdG9yIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXZlbnQuZ3JpZENlbGwueCAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LmdyaWRDZWxsLnkgLSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtldmVudC5wcmltaXRpdmVFdmVudC50eXBlXVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Q2VsbEVkaXRvcn0gVGhlIGVkaXRvciBvYmplY3Qgb3IgYHVuZGVmaW5lZGAgaWYgbm8gZWRpdG9yIG9yIGVkaXRvciBhbHJlYWR5IG9wZW4uXG4gICAgICovXG4gICAgb25FZGl0b3JBY3RpdmF0ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdEF0KGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGNlbGwgZWRpdG9yLlxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHJldHVybnMgVGhlIGNlbGwgZWRpdG9yIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsRXZlbnQgLSBUaGUgZ3JpZCBjZWxsIGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIGdldENlbGxFZGl0b3JBdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Q2VsbEVkaXRvckF0KGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBUb2dnbGUgSGlEUEkgc3VwcG9ydC5cbiAgICAgKiBAZGVzYyBIaURQSSBzdXBwb3J0IGlzIG5vdyAqb24qIGJ5IGRlZmF1bHQuXG4gICAgICogPiBUaGVyZSB1c2VkIHRvIGJlIGEgYnVnIGluIENocm9tZSB0aGF0IGNhdXNlZCBzZXZlcmUgc2xvdyBkb3duIG9uIGJpdCBibGl0IG9mIGxhcmdlIGltYWdlcywgc28gdGhpcyBIaURQSSBuZWVkZWQgdG8gYmUgb3B0aW9uYWwuXG4gICAgICovXG4gICAgdG9nZ2xlSGlEUEk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy51c2VIaURQSSgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnaGlkcGknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoaWRwaScsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FudmFzLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRlIEhpRFBJIHJhdGlvLlxuICAgICAqL1xuICAgIGdldEhpRFBJOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICYmIHRoaXMudXNlSGlEUEkoKSkge1xuICAgICAgICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICAgICAgdmFyIGJhY2tpbmdTdG9yZVJhdGlvID0gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgICAgICAgICByZXR1cm4gcmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gKHJlY2VudGx5IHJlbmRlcmVkKSBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gVGhlIGNvbHVtbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZFdpZHRoOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRSZW5kZXJlZFdpZHRoKGNvbEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiAocmVjZW50bHkgcmVuZGVyZWQpIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUdGhlIHJvdyBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZEhlaWdodDogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0UmVuZGVyZWRIZWlnaHQocm93SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFVwZGF0ZSB0aGUgY3Vyc29yIHVuZGVyIHRoZSBob3ZlciBjZWxsLlxuICAgICAqL1xuICAgIHVwZGF0ZUN1cnNvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmJlaGF2aW9yLmdldEN1cnNvckF0KC0xLCAtMSk7XG4gICAgICAgIHZhciBob3ZlckNlbGwgPSB0aGlzLmhvdmVyQ2VsbDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaG92ZXJDZWxsICYmXG4gICAgICAgICAgICBob3ZlckNlbGwueCA+IC0xICYmXG4gICAgICAgICAgICBob3ZlckNlbGwueSA+IC0xXG4gICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHggPSBob3ZlckNlbGwueCArIHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgICAgICBjdXJzb3IgPSB0aGlzLmJlaGF2aW9yLmdldEN1cnNvckF0KHgsIGhvdmVyQ2VsbC55ICsgdGhpcy5nZXRWU2Nyb2xsVmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZUN1cnNvcihjdXJzb3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcGFpbnQgdGhlIGdpdmVuIGNlbGwuXG4gICAgICogQHBhcmFtIHt4fSB4IC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge3l9IHkgLSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICByZXBhaW50Q2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlcGFpbnRDZWxsKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgdXNlciBpcyBjdXJyZW50bHkgZHJhZ2dpbmcgYSBjb2x1bW4gdG8gcmVvcmRlciBpdC5cbiAgICAgKi9cbiAgICBpc0RyYWdnaW5nQ29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNjcm9sbCB1cCBvbmUgZnVsbCBwYWdlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcGFnZVVwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJvd051bSA9IHRoaXMucmVuZGVyZXIuZ2V0UGFnZVVwUm93KCk7XG4gICAgICAgIHRoaXMuc2V0VlNjcm9sbFZhbHVlKHJvd051bSk7XG4gICAgICAgIHJldHVybiByb3dOdW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2Nyb2xsIGRvd24gb25lIGZ1bGwgcGFnZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHBhZ2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJvd051bSA9IHRoaXMucmVuZGVyZXIuZ2V0UGFnZURvd25Sb3coKTtcbiAgICAgICAgdGhpcy5zZXRWU2Nyb2xsVmFsdWUocm93TnVtKTtcbiAgICAgICAgcmV0dXJuIHJvd051bTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBOb3QgeWV0IGltcGxlbWVudGVkLlxuICAgICAqL1xuICAgIHBhZ2VMZWZ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgJ3BhZ2UgbGVmdCBub3QgeWV0IGltcGxlbWVudGVkJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBOb3QgeWV0IGltcGxlbWVudGVkLlxuICAgICAqL1xuICAgIHBhZ2VSaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93ICdwYWdlIHJpZ2h0IG5vdCB5ZXQgaW1wbGVtZW50ZWQnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX0gT2JqZWN0cyB3aXRoIHRoZSB2YWx1ZXMgdGhhdCB3ZXJlIGp1c3QgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYXNzdW1lcyBvbmUgcm93IG9mIGhlYWRlcnNcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5iZWhhdmlvcixcbiAgICAgICAgICAgIGNvbENvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpLmxlbmd0aCxcbiAgICAgICAgICAgIHJvd0NvdW50ID0gdGhpcy5yZW5kZXJlci52aXNpYmxlUm93cy5sZW5ndGgsXG4gICAgICAgICAgICBoZWFkZXJzID0gbmV3IEFycmF5KGNvbENvdW50KSxcbiAgICAgICAgICAgIHJlc3VsdHMgPSBuZXcgQXJyYXkocm93Q291bnQpLFxuICAgICAgICAgICAgcm93O1xuXG4gICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIsIGMpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbY10gPSBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oYykuaGVhZGVyO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24ocmVzdWx0LCByKSB7XG4gICAgICAgICAgICByb3cgPSByZXN1bHRzW3JdID0ge1xuICAgICAgICAgICAgICAgIGhpZXJhcmNoeTogYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5WYWx1ZSgwLCByKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgYykge1xuICAgICAgICAgICAgICAgIHJvd1tmaWVsZF0gPSBiZWhhdmlvci5nZXRWYWx1ZShjLCByKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50bHkgc2VsZWN0aW9uIHJvdy5cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxzID0gdGhpcy5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5iZWhhdmlvcixcbiAgICAgICAgICAgICAgICBjb2xDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgICAgICB0b3BSb3cgPSBzZWxzWzBdLm9yaWdpbi55LFxuICAgICAgICAgICAgICAgIHJvdyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy9oaWVyYXJjaHk6IGJlaGF2aW9yLmdldEZpeGVkQ29sdW1uVmFsdWUoMCwgdG9wUm93KVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHJvd1tiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4oYykuaGVhZGVyXSA9IGJlaGF2aW9yLmdldFZhbHVlKGMsIHRvcFJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlyZVJlcXVlc3RDZWxsRWRpdDogZnVuY3Rpb24oY2VsbCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1yZXF1ZXN0LWNlbGwtZWRpdCcsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7IC8vSSB3YXNuJ3QgY2FuY2VsbGVkXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBmaW4tYmVmb3JlLWNlbGwtZWRpdCBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHgseSBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSBUaGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUHJvY2VlZCAoZG9uJ3QgY2FuY2VsKS5cbiAgICAgKi9cbiAgICBmaXJlQmVmb3JlQ2VsbEVkaXQ6IGZ1bmN0aW9uKGNlbGwsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgY29udHJvbCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWJlZm9yZS1jZWxsLWVkaXQnLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogY2VsbCxcbiAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIGlucHV0OiBjb250cm9sLFxuICAgICAgICAgICAgICAgIHJvdzogdGhpcy5nZXRSb3coY2VsbC55KVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1JlbmRlcmVyfSBzdWItY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSB4LHkgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlIC0gVGhlIG9sZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWUgLSBUaGUgbmV3IHZhbHVlLlxuICAgICAqL1xuICAgIGZpcmVBZnRlckNlbGxFZGl0OiBmdW5jdGlvbihjZWxsLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGNvbnRyb2wpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1hZnRlci1jZWxsLWVkaXQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGNvbnRyb2wsXG4gICAgICAgICAgICAgICAgcm93OiB0aGlzLmdldFJvdyhjZWxsLnkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEF1dG9zaXplIHRoZSBjb2x1bW4gYXQgY29sSW5kZXggZm9yIGJlc3QgZml0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleCAtIFRoZSBjb2x1bW4gaW5kZXggdG8gbW9kaWZ5IGF0XG4gICAgICovXG4gICAgYXV0b3NpemVDb2x1bW46IGZ1bmN0aW9uKGFjdGl2ZUNvbHVtbkluZGV4KSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbihhY3RpdmVDb2x1bW5JbmRleCk7XG4gICAgICAgIGNvbHVtbi5jaGVja0NvbHVtbkF1dG9zaXppbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRW5hYmxlL2Rpc2FibGUgaWYgdGhpcyBjb21wb25lbnQgY2FuIHJlY2VpdmUgdGhlIGZvY3VzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gLSBjYW5SZWNlaXZlRm9jdXNcbiAgICAgKi9cbiAgICBzZXRGb2N1c2FibGU6IGZ1bmN0aW9uKGNhblJlY2VpdmVGb2N1cykge1xuICAgICAgICB0aGlzLmdldENhbnZhcygpLnNldEZvY3VzYWJsZShjYW5SZWNlaXZlRm9jdXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY29sdW1ucyB0aGF0IHdlcmUganVzdCByZW5kZXJlZFxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiByb3dzIHRoYXQgd2VyZSBqdXN0IHJlbmRlcmVkXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZVJvd3NDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFZpc2libGVSb3dzQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBVcGRhdGUgdGhlIHNpemUgb2YgYSBncmlkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHVwZGF0ZVNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5jaGVja3NpemUoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN0b3AgdGhlIGdsb2JhbCByZXBhaW50aW5nIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHN0b3BQYWludFRocmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0b3BQYWludFRocmVhZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN0b3AgdGhlIGdsb2JhbCByZXNpemUgY2hlY2sgZmxhZyB0aHJlYWQuXG4gICAgICovXG4gICAgc3RvcFJlc2l6ZVRocmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0b3BSZXNpemVUaHJlYWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXN0YXJ0IHRoZSBnbG9iYWwgcmVzaXplIGNoZWNrIGZsYWcgdGhyZWFkLlxuICAgICAqL1xuICAgIHJlc3RhcnRSZXNpemVUaHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXN0YXJ0UmVzaXplVGhyZWFkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVzdGFydCB0aGUgZ2xvYmFsIHJlcGFpbnRpbmcgY2hlY2sgZmxhZyB0aHJlYWQuXG4gICAgICovXG4gICAgcmVzdGFydFBhaW50VGhyZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMucmVzdGFydFBhaW50VGhyZWFkKCk7XG4gICAgfSxcblxuICAgIHN3YXBDb2x1bW5zOiBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCkge1xuICAgICAgICAvL1R1cm5zIG91dCB0aGlzIGlzIGNhbGxlZCBkdXJpbmcgZHJhZ2dlZCAnaS5lJyB3aGVuIHRoZSBmbG9hdGVyIGNvbHVtbiBpcyByZXNodWZmbGVkXG4gICAgICAgIC8vYnkgdGhlIGN1cnJlbnRseSBkcmFnZ2VkIGNvbHVtbi4gVGhlIGNvbHVtbiBwb3NpdGlvbnMgYXJlIGNvbnN0YW50bHkgcmVzaHVmZmxlZFxuICAgICAgICB0aGlzLmJlaGF2aW9yLnN3YXBDb2x1bW5zKHNvdXJjZSwgdGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbigpO1xuICAgIH0sXG5cbiAgICBnZXRGaXhlZENvbHVtbnNNYXhXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldEZpeGVkQ29sdW1uc01heFdpZHRoKCk7XG4gICAgfSxcblxuICAgIGlzTW91c2VEb3duSW5IZWFkZXJBcmVhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgbW91c2VEb3duID0gdGhpcy5nZXRNb3VzZURvd24oKTtcbiAgICAgICAgcmV0dXJuIG1vdXNlRG93bi54IDwgMCB8fCBtb3VzZURvd24ueSA8IGhlYWRlclJvd0NvdW50O1xuICAgIH0sXG5cbiAgICBpc0hlYWRlcldyYXBwaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5oZWFkZXJUZXh0V3JhcHBpbmc7XG4gICAgfSxcblxuICAgIF9nZXRCb3VuZHNPZkNlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnX2dldEJvdW5kc09mQ2VsbCgpJywgJ2dldEJvdW5kc09mQ2VsbCgpJywgJzEuMi4wJywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtpbmRleH0geCAtIERhdGEgeCBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHByb3BlcnRpZXMgZm9yIGEgc3BlY2lmaWMgY29sdW1uLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRDb2x1bW5Qcm9wZXJ0aWVzKHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2luZGV4fSB4IC0gRGF0YSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcHJvcGVydGllcyBmb3IgYSBzcGVjaWZpYyBjb2x1bW4uXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbih4LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2V0Q29sdW1uUHJvcGVydGllcyh4LCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB0aGlzLmJlaGF2aW9yLm1vdmVTaW5nbGVTZWxlY3QodGhpcywgeCwgeSk7XG4gICAgfSxcblxuICAgIHNlbGVjdENlbGw6IGZ1bmN0aW9uKHgsIHksIHNpbGVudCkge1xuICAgICAgICB2YXIgZG9udENsZWFyUm93cyA9IHRoaXMuaXNDaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuY2xlYXIoZG9udENsZWFyUm93cyk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHgsIHksIDAsIDAsIHNpbGVudCk7XG4gICAgfSxcblxuICAgIHRvZ2dsZVNlbGVjdENvbHVtbjogZnVuY3Rpb24oeCwga2V5cykge1xuICAgICAgICBrZXlzID0ga2V5cyB8fCBbXTtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5zZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgdmFyIGFscmVhZHlTZWxlY3RlZCA9IG1vZGVsLmlzQ29sdW1uU2VsZWN0ZWQoeCk7XG4gICAgICAgIHZhciBoYXNDVFJMID0ga2V5cy5pbmRleE9mKCdDVFJMJykgPiAtMTtcbiAgICAgICAgdmFyIGhhc1NISUZUID0ga2V5cy5pbmRleE9mKCdTSElGVCcpID4gLTE7XG4gICAgICAgIGlmICghaGFzQ1RSTCAmJiAhaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIG1vZGVsLmNsZWFyKCk7XG4gICAgICAgICAgICBpZiAoIWFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIG1vZGVsLnNlbGVjdENvbHVtbih4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDVFJMKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kZXNlbGVjdENvbHVtbih4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zZWxlY3RDb2x1bW4oeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBtb2RlbC5zZWxlY3RDb2x1bW4odGhpcy5sYXN0RWRnZVNlbGVjdGlvblswXSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbHJlYWR5U2VsZWN0ZWQgJiYgIWhhc1NISUZUKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RFZGdlU2VsZWN0aW9uWzBdID0geDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljQ29sdW1uU2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgfSxcblxuICAgIHRvZ2dsZVNlbGVjdFJvdzogZnVuY3Rpb24oeSwga2V5cykge1xuICAgICAgICAvL3dlIGNhbiBzZWxlY3QgdGhlIHRvdGFscyByb3dzIGlmIHRoZXkgZXhpc3QsIGJ1dCBub3Qgcm93cyBhYm92ZSB0aGF0XG4gICAgICAgIGtleXMgPSBrZXlzIHx8IFtdO1xuXG4gICAgICAgIHZhciBzbSA9IHRoaXMuc2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHZhciBhbHJlYWR5U2VsZWN0ZWQgPSBzbS5pc1Jvd1NlbGVjdGVkKHkpO1xuICAgICAgICB2YXIgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgPj0gMDtcblxuICAgICAgICBpZiAoYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzbS5kZXNlbGVjdFJvdyh5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2luZ2xlU2VsZWN0KCk7XG4gICAgICAgICAgICBzbS5zZWxlY3RSb3coeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIHNtLmNsZWFyKCk7XG4gICAgICAgICAgICBzbS5zZWxlY3RSb3codGhpcy5sYXN0RWRnZVNlbGVjdGlvblsxXSwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFscmVhZHlTZWxlY3RlZCAmJiAhaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb25bMV0gPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNpbmdsZVNlbGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMgPSB0aGlzLmlzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucygpLFxuICAgICAgICAgICAgaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlID0gdGhpcy5pc1NpbmdsZVJvd1NlbGVjdGlvbk1vZGUoKSxcbiAgICAgICAgICAgIGhhc0NUUkwgPSBmYWxzZSxcbiAgICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgICBpZiAodGhpcy5tb3VzZURvd25TdGF0ZSl7XG4gICAgICAgICAgICAvL3RyaWdnZXJlZCBwcm9ncmFtbWF0aWNhbGx5XG4gICAgICAgICAgICBoYXNDVFJMID0gdGhpcy5tb3VzZURvd25TdGF0ZS5wcmltaXRpdmVFdmVudC5kZXRhaWwucHJpbWl0aXZlRXZlbnQuY3RybEtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IChcbiAgICAgICAgICAgIGlzQ2hlY2tib3hPbmx5Um93U2VsZWN0aW9ucyAmJiBpc1NpbmdsZVJvd1NlbGVjdGlvbk1vZGUgfHxcbiAgICAgICAgICAgICFpc0NoZWNrYm94T25seVJvd1NlbGVjdGlvbnMgJiYgKCFoYXNDVFJMIHx8IGlzU2luZ2xlUm93U2VsZWN0aW9uTW9kZSlcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyUm93U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBzZWxlY3RWaWV3cG9ydENlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpLFxuICAgICAgICAgICAgcmVhbFggPSB0aGlzLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zW3hdLkNvbHVtbkluZGV4LCAvLyB0b2RvIHJlZmFjXG4gICAgICAgICAgICByZWFsWSA9IHRoaXMucmVuZGVyZXIudmlzaWJsZVJvd3NbeV0ucm93SW5kZXg7IC8vIHRvZG8gcmVmYWNcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZWxlY3QocmVhbFgsIHJlYWxZICsgaGVhZGVyUm93Q291bnQsIDAsIDApO1xuICAgICAgICB0aGlzLnNldE1vdXNlRG93bih0aGlzLm5ld1BvaW50KHJlYWxYLCByZWFsWSArIGhlYWRlclJvd0NvdW50KSk7IC8vIHRvZG8gcmVmYWNcbiAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0VG9WaWV3cG9ydENlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbnMgJiYgc2VsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKSxcbiAgICAgICAgICAgICAgICByZWFsWCA9IHRoaXMucmVuZGVyZXIudmlzaWJsZUNvbHVtbnNbeF0uY29sdW1uSW5kZXgsIC8vIHRvZG8gcmVmYWNcbiAgICAgICAgICAgICAgICByZWFsWSA9IHRoaXMucmVuZGVyZXIudmlzaWJsZVJvd3NbeV0ucm93SW5kZXggKyBoZWFkZXJSb3dDb3VudCwgLy8gdG9kbyByZWZhY1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgb3JpZ2luID0gc2VsZWN0aW9uLm9yaWdpbjtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhZ0V4dGVudCh0aGlzLm5ld1BvaW50KHJlYWxYIC0gb3JpZ2luLngsIHJlYWxZIC0gb3JpZ2luLnkpKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgcmVhbFggLSBvcmlnaW4ueCwgcmVhbFkgLSBvcmlnaW4ueSk7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWxlY3RGaW5hbENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDEsXG4gICAgICAgICAgICB5ID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKVswXSxcbiAgICAgICAgICAgIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNjcm9sbEJ5KHRoaXMuZ2V0Q29sdW1uQ291bnQoKSwgMCk7XG4gICAgICAgIHRoaXMuc2VsZWN0KHgsIHkgKyBoZWFkZXJSb3dDb3VudCwgMCwgMCk7XG4gICAgICAgIHRoaXMuc2V0TW91c2VEb3duKHRoaXMubmV3UG9pbnQoeCwgeSArIGhlYWRlclJvd0NvdW50KSk7XG4gICAgICAgIHRoaXMuc2V0RHJhZ0V4dGVudCh0aGlzLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNlbGVjdFRvRmluYWxDZWxsT2ZDdXJyZW50Um93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbnMgJiYgc2VsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBzZWxlY3Rpb25zWzBdLFxuICAgICAgICAgICAgICAgIG9yaWdpbiA9IHNlbGVjdGlvbi5vcmlnaW4sXG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gc2VsZWN0aW9uLmV4dGVudCxcbiAgICAgICAgICAgICAgICBjb2x1bW5Db3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnkoY29sdW1uQ291bnQsIDApO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Qob3JpZ2luLngsIG9yaWdpbi55LCBjb2x1bW5Db3VudCAtIG9yaWdpbi54IC0gMSwgZXh0ZW50LnkpO1xuXG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzZWxlY3RGaXJzdENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeCA9IDAsXG4gICAgICAgICAgICB5ID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKVswXSxcbiAgICAgICAgICAgIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNldEhTY3JvbGxWYWx1ZSgwKTtcbiAgICAgICAgdGhpcy5zZWxlY3QoeCwgeSArIGhlYWRlclJvd0NvdW50LCAwLCAwKTtcbiAgICAgICAgdGhpcy5zZXRNb3VzZURvd24odGhpcy5uZXdQb2ludCh4LCB5ICsgaGVhZGVyUm93Q291bnQpKTtcbiAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0VG9GaXJzdENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoc2VsZWN0aW9ucyAmJiBzZWxlY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbMF0sXG4gICAgICAgICAgICAgICAgb3JpZ2luID0gc2VsZWN0aW9uLm9yaWdpbixcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBzZWxlY3Rpb24uZXh0ZW50O1xuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG9yaWdpbi54LCBvcmlnaW4ueSwgLW9yaWdpbi54LCBleHRlbnQueSk7XG4gICAgICAgICAgICB0aGlzLnNldEhTY3JvbGxWYWx1ZSgwKTtcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlbGVjdEZpbmFsQ2VsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0Q2VsbCh0aGlzLmdldENvbHVtbkNvdW50KCkgLSAxLCB0aGlzLmdldFJvd0NvdW50KCkgLSAxKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCeSh0aGlzLmdldENvbHVtbkNvdW50KCksIHRoaXMuZ2V0Um93Q291bnQoKSk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RUb0ZpbmFsQ2VsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmIChzZWxlY3Rpb25zICYmIHNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1swXSxcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBzZWxlY3Rpb24ub3JpZ2luLFxuICAgICAgICAgICAgICAgIGNvbHVtbkNvdW50ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgICAgIHJvd0NvdW50ID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Qob3JpZ2luLngsIG9yaWdpbi55LCBjb2x1bW5Db3VudCAtIG9yaWdpbi54IC0gMSwgcm93Q291bnQgLSBvcmlnaW4ueSAtIDEpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCeShjb2x1bW5Db3VudCwgcm93Q291bnQpO1xuICAgICAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNTaG93Um93TnVtYmVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMuc2hvd1Jvd051bWJlcnM7XG4gICAgfSxcbiAgICBpc0VkaXRhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5lZGl0YWJsZSA9PT0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHRvZG8gcm93IHJlZmFjOiBkZXByZWNhdGUgaW4gZmF2b3Igb2YgQ2VsbEV2ZW50LmlzR3JpZFJvd1xuICAgICAqIEBwYXJhbSB7aW50ZWdlclJvd0luZGV4fHNlY3Rpb25Qb2ludH0gcm5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0dyaWRSb3c6IGZ1bmN0aW9uKHJuKSB7XG4gICAgICAgIHJldHVybiBybiA+PSAwIHx8IHJuLnkgPj0gMDtcbiAgICB9LFxuXG4gICAgaXNTaG93SGVhZGVyUm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5zaG93SGVhZGVyUm93O1xuICAgIH0sXG4gICAgZ2V0SGVhZGVyUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICBpc1Nob3dGaWx0ZXJSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnNob3dGaWx0ZXJSb3c7XG4gICAgfSxcblxuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmhhc0hpZXJhcmNoeUNvbHVtbigpO1xuICAgIH0sXG4gICAgaXNIaWVyYXJjaHlDb2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGllcmFyY2h5Q29sdW1uKCkgJiYgeCA9PT0gMDtcbiAgICB9LFxuICAgIGNoZWNrU2Nyb2xsYmFyVmlzaWJpbGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHZhciBob3ZlckNsYXNzT3ZlciA9IHRoaXMucHJvcGVydGllcy5zY3JvbGxiYXJIb3Zlck92ZXI7XG4gICAgICAgIC8vIHZhciBob3ZlckNsYXNzT2ZmID0gdGhpcy5wcm9wZXJ0aWVzLnNjcm9sbGJhckhvdmVyT2ZmO1xuXG4gICAgICAgIC8vIGlmIChob3ZlckNsYXNzT2ZmID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuc2JIU2Nyb2xsZXIuY2xhc3NMaXN0LnJlbW92ZShob3ZlckNsYXNzT3Zlcik7XG4gICAgICAgIC8vICAgICB0aGlzLnNiVlNjcm9sbGVyLmNsYXNzTGlzdC5yZW1vdmUoaG92ZXJDbGFzc09mZik7XG4gICAgICAgIC8vICAgICB0aGlzLnNiSFNjcm9sbGVyLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgLy8gICAgIHRoaXMuc2JWU2Nyb2xsZXIuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAvLyB9XG4gICAgfSxcbiAgICBpc0NvbHVtbk9yUm93U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc0NvbHVtbk9yUm93U2VsZWN0ZWQoKTtcbiAgICB9LFxuICAgIHNlbGVjdENvbHVtbjogZnVuY3Rpb24oeDEsIHgyKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0Q29sdW1uKHgxLCB4Mik7XG4gICAgfSxcbiAgICBzZWxlY3RSb3c6IGZ1bmN0aW9uKHkxLCB5Mikge1xuICAgICAgICB2YXIgc20gPSB0aGlzLnNlbGVjdGlvbk1vZGVsO1xuXG4gICAgICAgIGlmICh0aGlzLnNpbmdsZVNlbGVjdCgpKSB7XG4gICAgICAgICAgICB5MSA9IHkyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbXVsdGlwbGUgcm93IHNlbGVjdGlvblxuICAgICAgICAgICAgeTIgPSB5MiB8fCB5MTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNtLnNlbGVjdFJvdyhNYXRoLm1pbih5MSwgeTIpLCBNYXRoLm1heCh5MSwgeTIpKTtcbiAgICB9LFxuICAgIGlzUm93TnVtYmVyQXV0b3NpemluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMucm93TnVtYmVyQXV0b3NpemluZztcbiAgICB9LFxuICAgIGxvb2t1cEZlYXR1cmU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5sb29rdXBGZWF0dXJlKGtleSk7XG4gICAgfSxcbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0Um93KHkpO1xuICAgIH0sXG4gICAgaXNDZWxsU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5jZWxsU2VsZWN0aW9uID09PSB0cnVlO1xuICAgIH0sXG4gICAgaXNSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnJvd1NlbGVjdGlvbiA9PT0gdHJ1ZTtcbiAgICB9LFxuICAgIGlzQ29sdW1uU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5jb2x1bW5TZWxlY3Rpb24gPT09IHRydWU7XG4gICAgfSxcbiAgICBpc0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmNvbHVtbkF1dG9zaXppbmcgPT09IHRydWU7XG4gICAgfSxcblxuICAgIHNlbGVjdFJvd3NGcm9tQ2VsbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDaGVja2JveE9ubHlSb3dTZWxlY3Rpb25zKCkpIHtcbiAgICAgICAgICAgIHZhciBsYXN0LFxuICAgICAgICAgICAgICAgIGhhc0NUUkwgPSB0aGlzLm1vdXNlRG93blN0YXRlLnByaW1pdGl2ZUV2ZW50LmRldGFpbC5wcmltaXRpdmVFdmVudC5jdHJsS2V5O1xuXG4gICAgICAgICAgICBpZiAoaGFzQ1RSTCAmJiAhdGhpcy5pc1NpbmdsZVJvd1NlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0Um93c0Zyb21DZWxscygwLCBoYXNDVFJMKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGxhc3QgPSB0aGlzLnNlbGVjdGlvbk1vZGVsLmdldExhc3RTZWxlY3Rpb24oKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFJvdyhudWxsLCBsYXN0LmNvcm5lci55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclJvd1NlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3RDb2x1bW5zRnJvbUNlbGxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5zZWxlY3RDb2x1bW5zRnJvbUNlbGxzKCk7XG4gICAgfSxcbiAgICBnZXRTZWxlY3RlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICB9LFxuICAgIGdldFNlbGVjdGVkQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdldFNlbGVjdGlvbnMoKTtcbiAgICB9LFxuICAgIGdldExhc3RTZWxlY3Rpb25UeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0TGFzdFNlbGVjdGlvblR5cGUoKTtcbiAgICB9LFxuICAgIGlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlKHgsIHkpO1xuICAgIH0sXG4gICAgc2VsZWN0QWxsUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuc2VsZWN0QWxsUm93cygpO1xuICAgIH0sXG4gICAgYXJlQWxsUm93c1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuYXJlQWxsUm93c1NlbGVjdGVkKCk7XG4gICAgfSxcbiAgICB0b2dnbGVTZWxlY3RBbGxSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJlQWxsUm93c1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0QWxsUm93cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG4gICAgaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5zaW5nbGVSb3dTZWxlY3Rpb25Nb2RlO1xuICAgIH0sXG5cbiAgICBuZXdQb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgIH0sXG4gICAgbmV3UmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBfR2V0dGVyX1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7c29ydGVyQVBJfSBUaGUgZ3JpZCdzIGN1cnJlbnRseSBhc3NpZ25lZCBzb3J0ZXIuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQgc29ydGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5zb3J0ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IF9TZXR0ZXI6XyBBc3NpZ24gYSBzb3J0ZXIgdG8gdGhlIGdyaWQuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7c29ydGVyQVBJfHVuZGVmaW5lZHxudWxsfSBzb3J0ZXIgLSBPbmUgb2Y6XG4gICAgICogKiBBIHNvcnRlciBvYmplY3QsIHR1cm5pbmcgc29ydGluZyAqT04qLlxuICAgICAqICogSWYgYHVuZGVmaW5lZGAgb3IgYG51bGxgLCB0aGUge0BsaW5rIGRhdGFNb2RlbHMuSlNPTn5udWxsU29ydGVyfG51bGxTb3J0ZXJ9IGlzIHJlYXNzaWduZWQgdG8gdGhlIGdyaWQsIHR1cm5pbmcgc29ydGluZyAqT0ZGLipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBzb3J0ZXIoc29ydGVyKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc29ydGVyID0gc29ydGVyO1xuICAgICAgICB0aGlzLmJlaGF2aW9yQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBfR2V0dGVyX1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7ZGF0YVNvdXJjZUhlbHBlckFQSX0gVGhlIGdyaWQncyBjdXJyZW50bHkgYXNzaWduZWQgZmlsdGVyLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IGZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZmlsdGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBfU2V0dGVyOl8gU2V0IGEgZ3JpZCBpbnN0YW5jZSdzIGZpbHRlci5cbiAgICAgKiBAZGVzYyBSZXF1aXJlcyBhIGZpbHRlciBkYXRhIHNvdXJjZSBiZSBpbnN0YWxsZWQgaW4gdGhlIHRyYW5zZm9ybWF0aW9uIHBpcGVsaW5lLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge2RhdGFTb3VyY2VIZWxwZXJBUEl8dW5kZWZpbmVkfG51bGx9IGZpbHRlciAtIE9uZSBvZjpcbiAgICAgKiAqIEEgZmlsdGVyIG9iamVjdCwgdHVybmluZyBmaWx0ZXIgKk9OKi5cbiAgICAgKiAqIElmIGB1bmRlZmluZWRgIG9yIGBudWxsYCwgdGhlIG51bGwgZmlsdGVyIGlzIHJlYXNzaWduZWQgdG8gdGhlIGdyaWQsIHR1cm5pbmcgZmlsdGVyaW5nICpPRkYuKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IGZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFN0aWNreSBoYXNoIG9mIGRpYWxvZyBvcHRpb25zIG9iamVjdHMuXG4gICAgICogQGRlc2MgRWFjaCBrZXkgaXMgYSBkaWFsb2cgbmFtZTsgdGhlIHZhbHVlIGlzIHRoZSBvcHRpb25zIG9iamVjdCBmb3IgdGhhdCBkaWFsb2cuXG4gICAgICogVGhlIGRlZmF1bHQgZGlhbG9nIG9wdGlvbnMgb2JqZWN0IGhhcyB0aGUga2V5IGAndW5kZWZpbmVkJ2AsIHdoaWNoIGlzIHVuZGVmaW5lZCBieSBkZWZhdWx0OyBpdCBpcyBzZXQgYnkgY2FsbGluZyBgc2V0RGlhbG9nT3B0aW9uc2Agd2l0aCBubyBgZGlhbG9nTmFtZWAgcGFyYW1ldGVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGlhbG9nT3B0aW9uczoge30sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgYW5kL29yIHJldHVybiBhIHNwZWNpZmljIGRpYWxvZyBvcHRpb25zIG9iamVjdCAqb3IqIGEgZGVmYXVsdCBkaWFsb2cgb3B0aW9ucyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAZGVzYyBJZiBgb3B0aW9uc2AgZGVmaW5lZDpcbiAgICAgKiAqIElmIGBkaWFsb2dOYW1lYCBkZWZpbmVkOiBTYXZlIHRoZSBzcGVjaWZpYyBkaWFsb2cncyBvcHRpb25zIG9iamVjdC5cbiAgICAgKiAqIElmIGBkaWFsb2dOYW1lYCB1bmRlZmluZWQ6IFNhdmUgdGhlIGRlZmF1bHQgZGlhbG9nIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogSWYgYG9wdGlvbnNgIGlzIF9ub3RfIGRlZmluZWQsIG5vIG5ldyBkaWFsb2cgb3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBzYXZlZDsgYnV0IGEgcHJldmlvdXNseSBzYXZlZCBwcmVzZXQgd2lsbCBiZSByZXR1cm5lZCAoYWZ0ZXIgbWl4aW5nIGluIHRoZSBkZWZhdWx0IHByZXNldCBpZiB0aGVyZSBpcyBvbmUpLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgZGlhbG9nIG9wdGlvbnMgb2JqZWN0IGlzIHVzZWQgaW4gdHdvIHdheXM6XG4gICAgICogKiB3aGVuIGEgZGlhbG9nIGhhcyBubyBvcHRpb25zIG9iamVjdFxuICAgICAqICogYXMgYSBtaXgtaW4gYmFzZSB3aGVuIGEgZGlhbG9nIGRvZXMgaGF2ZSBhbiBvcHRpb25zIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtkaWFsb2dOYW1lXSBJZiB1bmRlZmluZWQsIGBvcHRpb25zYCBkZWZpbmVzIHRoZSBkZWZhdWx0IGRpYWxvZyBvcHRpb25zIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gSWYgZGVmaW5lZCwgcHJlc2V0IHRoZSBuYW1lZCBkaWFsb2cgb3B0aW9ucyBvYmplY3Qgb3IgdGhlIGRlZmF1bHQgZGlhbG9nIG9wdGlvbnMgb2JqZWN0IGlmIG5hbWUgaXMgdW5kZWZpbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH0gT25lIG9mOlxuICAgICAqICogV2hlbiBgb3B0aW9uc2AgdW5kZWZpbmVkLCBmaXJzdCBvZjpcbiAgICAgKiAgICogcHJldmlvdXMgcHJlc2V0XG4gICAgICogICAqIGRlZmF1bHQgcHJlc2V0XG4gICAgICogICAqIGVtcHR5IG9iamVjdFxuICAgICAqICogV2hlbiBgb3B0aW9uc2AgZGVmaW5lZCwgZmlyc3Qgb2Y6XG4gICAgICogICAqIG1peC1pbjogZGVmYXVsdCBwcmVzZXQgbWVtYmVycyArIGBvcHRpb25zYCBtZW1iZXJzXG4gICAgICogICAqIGBvcHRpb25zYCB2ZXJiYXRpbSB3aGVuIGRlZmF1bHQgcHJlc2V0IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIHNldERpYWxvZ09wdGlvbnM6IGZ1bmN0aW9uKGRpYWxvZ05hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkaWFsb2dOYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGRpYWxvZ05hbWU7XG4gICAgICAgICAgICBkaWFsb2dOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHRoaXMuZGlhbG9nT3B0aW9ucy51bmRlZmluZWQ7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRpYWxvZ05hbWUgJiYgdGhpcy5kaWFsb2dPcHRpb25zW2RpYWxvZ05hbWVdO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5kaWFsb2dPcHRpb25zW2RpYWxvZ05hbWVdID0gb3B0aW9ucztcbiAgICAgICAgICAgIGlmIChkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfKHt9KS5leHRlbmQoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpOyAvLyBtYWtlIGEgbWl4LWluXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMgfHwge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgb2JqZWN0cyBhcmUgcmVtZW1iZXJlZCBmb3Igc3Vic2VxdWVudCB1c2UuIEFsdGVybmF0aXZlbHksIHRoZXkgY2FuIGJlIHByZXNldCBieSBjYWxsaW5nIHtAbGluayBIeXBlcmdyaWQjc2V0RGlhbG9nT3B0aW9uc3xzZXREaWFsb2dPcHRpb25zfS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlhbG9nTmFtZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBJZiBvbWl0dGVkLCB1c2UgdGhlIG9wdGlvbnMgb2JqZWN0IHByZXZpb3VzbHkgZ2l2ZW4gaGVyZSAob3IgdG8ge0BsaW5rIEh5cGVyZ3JpZCNzZXREaWFsb2dPcHRpb25zfHNldERpYWxvZ09wdGlvbnN9KSwgaWYgYW55LiBJbiBhbnkgY2FzZSwgdGhlIHJlc3VsdGFudCBvcHRpb25zIG9iamVjdCwgaWYgYW55LCBpcyBtaXhlZCBpbnRvIHRoZSBkZWZhdWx0IG9wdGlvbnMgb2JqZWN0LCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgICovXG4gICAgb3BlbkRpYWxvZzogZnVuY3Rpb24oZGlhbG9nTmFtZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuYWJvcnRFZGl0aW5nKCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLnNldERpYWxvZ09wdGlvbnMoZGlhbG9nTmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMudGVybWluYXRlID0gZnVuY3Rpb24oKSB7IC8vIHdoZW4gYWJvdXQtdG8tYmUtb3BlbmVkIGRpYWxvZyBpcyBldmVudHVhbGx5IGNsb3NlZFxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGlhbG9nO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGlhbG9nID0gdGhpcy5iZWhhdmlvci5vcGVuRGlhbG9nKGRpYWxvZ05hbWUsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBhbHRob3VnaCB5b3UgY2FuIGhhdmUgbXVsdGlwbGUgZGlhbG9ncyBvcGVuIGF0IHRoZSBzYW1lIHRpbWUsIHRoZSBmb2xsb3dpbmcgZW5mb3JjZXMgb25lIGF0IGEgdGltZSAoZm9yIG5vdylcbiAgICB0b2dnbGVEaWFsb2c6IGZ1bmN0aW9uKG5ld0RpYWxvZ05hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRpYWxvZyA9IHRoaXMuZGlhbG9nLFxuICAgICAgICAgICAgb2xkRGlhbG9nTmFtZSA9IGRpYWxvZyAmJiBkaWFsb2cuJCRDTEFTU19OQU1FO1xuICAgICAgICBpZiAoIWRpYWxvZyB8fCAhdGhpcy5kaWFsb2cuY2xvc2UoKSAmJiBvbGREaWFsb2dOYW1lICE9PSBuZXdEaWFsb2dOYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWRpYWxvZykge1xuICAgICAgICAgICAgICAgIC8vIG9wZW4gbmV3IGRpYWxvZyBub3dcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5EaWFsb2cobmV3RGlhbG9nTmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG9wZW4gbmV3IGRpYWxvZyB3aGVuIGFscmVhZHktb3BlbmVkIGRpYWxvZyBmaW5pc2hlcyBjbG9zaW5nIGR1ZSB0byAuY2xvc2VEaWFsb2coKSBhYm92ZVxuICAgICAgICAgICAgICAgIGRpYWxvZy50ZXJtaW5hdGUgPSB0aGlzLm9wZW5EaWFsb2cuYmluZCh0aGlzLCBuZXdEaWFsb2dOYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBmaW5kT3JDcmVhdGVDb250YWluZXIoYm91bmRpbmdSZWN0KSB7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoeXBlcmdyaWQnKSxcbiAgICAgICAgdXNlZCA9IGRpdiAmJiAhZGl2LmZpcnN0RWxlbWVudENoaWxkO1xuXG4gICAgaWYgKCF1c2VkKSB7XG4gICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIGlmIChib3VuZGluZ1JlY3QpIHtcbiAgICAgICAgICAgIFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3Bvc2l0aW9uJywgJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCddLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRpbmdSZWN0W3N0eWxlXSkge1xuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGVbc3R5bGVdID0gYm91bmRpbmdSZWN0W3N0eWxlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGl2O1xufVxuXG5cbi8qKlxuICogQHN1bW1hcnkgVXBkYXRlIGRlZXAgcHJvcGVydGllcyB3aXRoIG5ldyB2YWx1ZXMuXG4gKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIGlzIGEgcmVjdXJzaXZlIHByb3BlcnR5IHNldHRlciB3aGljaCB1cGRhdGVzIGEgZGVlcCBwcm9wZXJ0eSBpbiBhIGRlc3RpbmF0aW9uIG9iamVjdCB3aXRoIHRoZSB2YWx1ZSBvZiBhIGNvbmdydWVudCBwcm9wZXJ0eSBpbiBhIHNvdXJjZSBvYmplY3QuXG4gKlxuICogPiBUZXJtaW5vbG9neTogQSBkZWVwIHByb3BlcnR5IGlzIGEgXCJ0ZXJtaW5hbCBub2RlXCIgKHByaW1pdGl2ZSB2YWx1ZSkgbmVzdGVkIGF0IHNvbWUgZGVwdGggKGkuZS4sIGRlcHRoID4gMSkgaW5zaWRlIGEgY29tcGxleCBvYmplY3QgKGFuIG9iamVjdCBjb250YWluaW5nIG5lc3RlZCBvYmplY3RzKS4gQSBjb25ncnVlbnQgcHJvcGVydHkgaXMgYSBwcm9wZXJ0eSBpbiBhbm90aGVyIG9iamVjdCB3aXRoIHRoZSBzYW1lIG5hbWUgYW5kIGF0IHRoZSBzYW1lIGxldmVsIG9mIG5lc3RpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBzaW1wbGUgYW5kIGVsZWdhbnQuIEkgcmVjb21tZW5kIHlvdSBzdHVkeSB0aGUgY29kZSwgd2hpY2ggbm9uZXRoZWxlc3MgaW1wbGllcyBhbGwgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAqIElmIHRoZSBkZWVwIHByb3BlcnR5IGlzIF9ub3RfIGZvdW5kIGluIGBkZXN0aW5hdGlvbmAsIGl0IHdpbGwgYmUgY3JlYXRlZC5cbiAqICogSWYgdGhlIGRlZXAgcHJvcGVydHkgaXMgZm91bmQgaW4gYGRlc3RpbmF0aW9uYCBfYW5kXyBpcyBhIHByaW1pdGl2ZSB0eXBlLCBpdCB3aWxsIGJlIG1vZGlmaWVkIChvdmVyd3JpdHRlbiB3aXRoIHRoZSB2YWx1ZSBmcm9tIGBzb3VyY2VgKS5cbiAqICogSWYgdGhlIGRlZXAgcHJvcGVydHkgaXMgZm91bmQgaW4gYGRlc3RpbmF0aW9uYCBfYnV0XyBpcyBub3QgYSBwcmltaXRpdmUgdHlwZSAoaS5lLiwgaXMgYSBuZXN0ZWQgb2JqZWN0KSwgaXQgd2lsbCBfYWxzb18gYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgKHByaW1pdGl2ZSkgdmFsdWUgZnJvbSBgc291cmNlYC5cbiAqICogSWYgdGhlIG5lc3RlZCBvYmplY3QgdGhlIGRlZXAgcHJvcGVydHkgaW5oYWJpdHMgaW4gYHNvdXJjZWAgaXMgbm90IGZvdW5kIGluIGBkZXN0aW5hdGlvbmAsIGl0IHdpbGwgYmUgY3JlYXRlZC5cbiAqICogSWYgdGhlIG5lc3RlZCBvYmplY3QgdGhlIGRlZXAgcHJvcGVydHkgaW5oYWJpdHMgaW4gYHNvdXJjZWAgaXMgZm91bmQgaW4gYGRlc3RpbmF0aW9uYCBidXQgaXMgbm90IGluIGZhY3QgYW4gb2JqZWN0IChpLmUuLCBpdCBpcyBhIHByaW1pdGl2ZSB2YWx1ZSksIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCBhIHJlZmVyZW5jZSB0byB0aGF0IG9iamVjdC5cbiAqICogSWYgdGhlIHByaW1pdGl2ZSB2YWx1ZSBpcyBgdW5kZWZpbmVkYCwgdGhlIGRlc3RpbmF0aW9uIHByb3BlcnR5IGlzIGRlbGV0ZWQuXG4gKiAqIGBzb3VyY2VgIG1heSBjb250YWluIG11bHRpcGxlIHByb3BlcnRpZXMgdG8gdXBkYXRlLlxuICpcbiAqIFRoYXQgb25lIHJ1bGUgaXMgc2ltcGx5IHRoaXM6IElmIGJvdGggdGhlIHNvdXJjZSBfYW5kXyB0aGUgZGVzdGluYXRpb24gcHJvcGVydGllcyBhcmUgb2JqZWN0cywgdGhlbiByZWN1cnNlOyBlbHNlIG92ZXJ3cml0ZSB0aGUgZGVzdGluYXRpb24gcHJvcGVydHkgd2l0aCB0aGUgc291cmNlIHByb3BlcnR5LlxuICpcbiAqID4gQ2F2ZWF0OiBUaGlzIGlzIF9ub3RfIGVxdWl2YWxlbnQgdG8gYSBkZWVwIGV4dGVuZCBmdW5jdGlvbi4gV2hpbGUgYm90aCBhIGRlZXAgZXh0ZW5kIGFuZCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmVjdXJzZSBvdmVyIGEgY29tcGxleCBvYmplY3QsIHRoZXkgYXJlIGZ1bmRhbWVudGFsbHkgZGlmZmVyZW50OiBBIGRlZXAgZXh0ZW5kIGNsb25lcyB0aGUgbmVzdGVkIG9iamVjdHMgYXMgaXQgZmluZHMgdGhlbTsgdGhpcyBmdW5jdGlvbiBtZXJlbHkgdXBkYXRlcyB0aGVtIChvciBjcmVhdGVzIHRoZW0gd2hlcmUgdGhleSBkb24ndCBleGlzdCkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRlc3RpbmF0aW9uIC0gQW4gb2JqZWN0IHRvIHVwZGF0ZSB3aXRoIG5ldyBvciBtb2RpZmllZCBwcm9wZXJ0eSB2YWx1ZXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgLSBBIGNvbmdydWVudCBvYmplY3QgY29udGluYWx5IChvbmx5KSB0aGUgbmV3IG9yIG1vZGlmaWVkIHByb3BlcnR5IHZhbHVlcy5cbiAqIEByZXR1cm5zIHtvYmplY3R9IEFsd2F5cyByZXR1cm5zIGBkZXN0aW5hdGlvbmAuXG4gKi9cbmZ1bmN0aW9uIGFkZERlZXBQcm9wZXJ0aWVzKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICBfKHNvdXJjZSkuZWFjaChmdW5jdGlvbihwcm9wZXJ0eSwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25ba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb3BlcnR5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYWRkRGVlcFByb3BlcnRpZXMoZGVzdGluYXRpb25ba2V5XSwgcHJvcGVydHkpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkZXN0aW5hdGlvbltrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHByb3BlcnR5O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICB2YXIgbyA9IHJlY3Qub3JpZ2luLFxuICAgICAgICBjID0gcmVjdC5jb3JuZXIsXG5cbiAgICAgICAgb3ggPSBNYXRoLm1pbihvLngsIGMueCksXG4gICAgICAgIG95ID0gTWF0aC5taW4oby55LCBjLnkpLFxuXG4gICAgICAgIGN4ID0gTWF0aC5tYXgoby54LCBjLngpLFxuICAgICAgICBjeSA9IE1hdGgubWF4KG8ueSwgYy55KTtcblxuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKG94LCBveSwgY3ggLSBveCwgY3kgLSBveSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVGhlbWUodGhlbWUpIHtcbiAgICBjbGVhck9iamVjdFByb3BlcnRpZXModGhlbWUpO1xuICAgIHZhciBwYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BhcGVyLWJ1dHRvbicpOyAvLyBzdHlsZXMgd2VyZSBiYXNlZCBvbiBvbGQgcG9seW1lciB0aGVtZVxuXG4gICAgcGIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBwYi5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwYik7XG4gICAgdmFyIHAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYik7XG5cbiAgICB2YXIgc2VjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlY3Rpb24nKTtcbiAgICBzZWN0aW9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgc2VjdGlvbi5zZXRBdHRyaWJ1dGUoJ2hlcm8nLCB0cnVlKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNlY3Rpb24pO1xuXG4gICAgdmFyIGggPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sJykpO1xuICAgIHZhciBoYiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2h0bWwsIGJvZHknKSk7XG4gICAgdmFyIHMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzZWN0aW9uKTtcblxuICAgIHRoZW1lLmNvbHVtbkhlYWRlckJhY2tncm91bmRDb2xvciA9IHAuY29sb3I7XG4gICAgdGhlbWUucm93SGVhZGVyQmFja2dyb3VuZENvbG9yID0gcC5jb2xvcjtcbiAgICB0aGVtZS50b3BMZWZ0QmFja2dyb3VuZENvbG9yID0gcC5jb2xvcjtcbiAgICB0aGVtZS5saW5lQ29sb3IgPSBwLmJhY2tncm91bmRDb2xvcjtcblxuICAgIHRoZW1lLmJhY2tncm91bmRDb2xvcjIgPSBoYi5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICB0aGVtZS5jb2xvciA9IGguY29sb3I7XG4gICAgdGhlbWUuZm9udEZhbWlseSA9IGguZm9udEZhbWlseTtcbiAgICB0aGVtZS5iYWNrZ3JvdW5kQ29sb3IgPSBzLmJhY2tncm91bmRDb2xvcjtcblxuICAgIHBiLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgcGIuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnknLCB0cnVlKTtcbiAgICBwYi5zZXRBdHRyaWJ1dGUoJ3JhaXNlZCcsIHRydWUpO1xuICAgIHAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYik7XG5cbiAgICB0aGVtZS5jb2x1bW5IZWFkZXJDb2xvciA9IHAuY29sb3I7XG4gICAgdGhlbWUucm93SGVhZGVyQ29sb3IgPSBwLmNvbG9yO1xuICAgIHRoZW1lLnRvcExlZnRDb2xvciA9IHAuY29sb3I7XG5cblxuICAgIHRoZW1lLmJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuICAgIHRoZW1lLmZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuY29sb3I7XG5cbiAgICBwYi5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeScsIGZhbHNlKTtcbiAgICBwYi5zZXRBdHRyaWJ1dGUoJ3dhcm5pbmcnLCB0cnVlKTtcblxuICAgIHRoZW1lLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuY29sb3I7XG4gICAgdGhlbWUuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gcC5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgdGhlbWUucm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gcC5jb2xvcjtcbiAgICB0aGVtZS5maXhlZENvbHVtbkJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgLy9jaGVjayBpZiB0aGVyZSBpcyBhY3R1YWxseSBhIHRoZW1lIGxvYWRlZCBpZiBub3QsIGNsZWFyIG91dCBhbGwgYm9ndXMgdmFsdWVzXG4gICAgLy9mcm9tIG15IGNhY2hlXG4gICAgaWYgKHRoZW1lLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9PT0gJ3JnYmEoMCwgMCwgMCwgMCknIHx8XG4gICAgICAgIHRoZW1lLmxpbmVDb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICBjbGVhck9iamVjdFByb3BlcnRpZXModGhlbWUpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocGIpO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2VjdGlvbik7XG5cbiAgICByZXR1cm4gdGhlbWU7XG59XG5cbmZ1bmN0aW9uIGNsZWFyT2JqZWN0UHJvcGVydGllcyhvYmopIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEB0aGlzIHtkYXRhUm93T2JqZWN0fVxuICogQHBhcmFtIGNvbHVtblxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdmFsT3JGdW5jKGNvbHVtbikge1xuICAgIHZhciByZXN1bHQsIGNhbGN1bGF0b3I7XG4gICAgaWYgKHRoaXMpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpc1tjb2x1bW4ubmFtZV07XG4gICAgICAgIGNhbGN1bGF0b3IgPSAodHlwZW9mIHJlc3VsdClbMF0gPT09ICdmJyAmJiByZXN1bHQgfHwgY29sdW1uLmNhbGN1bGF0b3I7XG4gICAgICAgIGlmIChjYWxjdWxhdG9yKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxjdWxhdG9yLmNhbGwodGhpcywgY29sdW1uLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgfHwgcmVzdWx0ID09PSAwIHx8IHJlc3VsdCA9PT0gZmFsc2UgPyByZXN1bHQgOiAnJztcbn1cblxuLyoqXG4gKiBAc3VtbWFyeSBIYXNoIG9mIHJlZmVyZW5jZXMgdG8gc2hhcmVkIHBsdWctaW5zLlxuICogQGRlc2MgRGljdGlvbmFyeSBvZiBzaGFyZWQgKHByZS1pbnN0YWxsZWQpIHBsdWctaW5zLiBVc2VkIGludGVybmFsbHksIHByaW1hcmlseSB0byBhdm9pZCByZWluc3RhbGxhdGlvbnMuIFNlZSBleGFtcGxlcyBmb3IgaG93IHRvIHJlZmVyZW5jZSAoYWxiZWl0IHRoZXJlIGlzIG5vcm1hbGx5IG5vIG5lZWQgdG8gcmVmZXJlbmNlIHBsdWdpbnMgZGlyZWN0bHkpLlxuICpcbiAqIEZvciB0aGUgZGljdGlvbmFyeSBvZiBfaW5zdGFuY2VfIHBsdWdpbnMsIHNlZSB7QGxpbmsgSHlwZXJncmlkI3BsdWdpbnN8cGx1Z2luc30gKGRlZmluZWQgaW4gdGhlIHtAbGluayBIeXBlcmdyaWQjaW50aWFsaXplfEh5cGVyZ3JpZCBjb25zdHJ1Y3Rvcn0pLlxuICpcbiAqIFRvIGZvcmNlIHJlaW5zdGFsbGF0aW9uIG9mIGEgc2hhcmVkIHBsdWdpbiBkZWxldGUgaXQgZmlyc3Q6XG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBkZWxldGUgSHlwZXJncmlkLnBsdWdpbnMubXlTaGFyZWRQbHVnaW47XG4gKiBgYGBcbiAqIFRvIGZvcmNlIHJlaW5zdGFsbGF0aW9uIG9mIGFsbCBzaGFyZWQgcGx1Z2luczpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIEh5cGVyZ3JpZC5wbHVnaW5zID0ge307XG4gKiBgYGBcbiAqIEBleGFtcGxlXG4gKiB2YXIgYWxsU2hhcmVkUGx1Z2lucyA9IEh5cGVyZ3JpZC5wbHVnaW5zO1xuICogdmFyIG15U2hhcmVkUGx1Z2luID0gSHlwZXJncmlkLnBsdWdpbnMubXlTaGFyZWRQbHVnaW47XG4gKiBAdHlwZSB7b2JqZWN0fVxuICovXG5IeXBlcmdyaWQucGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIEBzdW1tYXJ5IFNoYXJlZCBsb2NhbGl6YXRpb24gZGVmYXVsdHMgZm9yIGFsbCBncmlkIGluc3RhbmNlcy5cbiAqIEBkZXNjIFRoZXNlIHByb3BlcnR5IHZhbHVlcyBhcmUgb3ZlcnJpZGRlbiBieSB0aG9zZSBzdXBwbGllZCBpbiB0aGUgYEh5cGVyZ3JpZGAgY29uc3RydWN0b3IncyBgb3B0aW9ucy5sb2NhbGl6YXRpb25gLlxuICogQHByb3BlcnR5IHtzdHJpbmd8c3RyaW5nW119IFtsb2NhbGVdIC0gVGhlIGRlZmF1bHQgbG9jYWxlIHRvIHVzZSB3aGVuIGFuIGV4cGxpY2l0IGBsb2NhbGVgIGlzIG9taXR0ZWQgZnJvbSBsb2NhbGl6ZXIgY29uc3RydWN0b3IgY2FsbHMuIFBhc3NlZCB0byBJbnRsLk51bWJlckZvcm1hdGAgYW5kIGBJbnRsLkRhdGVGb3JtYXRgLiBTZWUge0AgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bCNMb2NhbGVfaWRlbnRpZmljYXRpb25fYW5kX25lZ290aWF0aW9ufExvY2FsZSBpZGVudGlmaWNhdGlvbiBhbmQgbmVnb3RpYXRpb259IGZvciBtb3JlIGluZm9ybWF0aW9uLiBPbWl0dGluZyB3aWxsIHVzZSB0aGUgcnVudGltZSdzIGxvY2FsIGxhbmd1YWdlIGFuZCByZWdpb24uXG4gKiBAcHJvcGVydHkge29iamVjdH0gW251bWJlck9wdGlvbnNdIC0gT3B0aW9ucyBwYXNzZWQgdG8gYEludGwuTnVtYmVyRm9ybWF0YCBmb3IgY3JlYXRpbmcgdGhlIGJhc2ljIFwibnVtYmVyXCIgbG9jYWxpemVyLlxuICogQHByb3BlcnR5IHtvYmplY3R9IFtkYXRlT3B0aW9uc10gLSBPcHRpb25zIHBhc3NlZCB0byBgSW50bC5EYXRlRm9ybWF0YCBmb3IgY3JlYXRpbmcgdGhlIGJhc2ljIFwiZGF0ZVwiIGxvY2FsaXplci5cbiAqIEB0eXBlIHtvYmplY3R9XG4gKi9cblxuSHlwZXJncmlkLmxvY2FsaXphdGlvbiA9IHtcbiAgICBsb2NhbGU6ICdlbi1VUycsXG4gICAgbnVtYmVyT3B0aW9uczogeyBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIeXBlcmdyaWQ7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBPbmx5IDEgY2hvaWNlIGZyb20gZWFjaCBibG9jayBiZWxvdyBzaG91bGQgYmUgZXhwb3NlZCAodW5jb21tZW50ZWQpOlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHRhbmFseXRpY3M6IHJlcXVpcmUoJ2h5cGVyLWFuYWx5dGljcycpLCAvLyBucG1cbiAgICAvLyBhbmFseXRpY3M6IHJlcXVpcmUoJy4uLy4uL2h5cGVyLWFuYWx5dGljcycpLCAvLyBkZXZlbG9wZXJcblxufTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xudmFyIFBvaW50ID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKS5Qb2ludDtcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuLi9CYXNlJyk7XG52YXIgQ29sdW1uID0gcmVxdWlyZSgnLi9Db2x1bW4nKTtcbnZhciBjZWxsRXZlbnRGYWN0b3J5ID0gcmVxdWlyZSgnLi8uLi9saWIvY2VsbEV2ZW50RmFjdG9yeScpO1xudmFyIEhlYWRlclN1YmdyaWQgPSByZXF1aXJlKCcuLi9kYXRhTW9kZWxzL0hlYWRlclN1YmdyaWQnKTtcbnZhciBGaWx0ZXJTdWJncmlkID0gcmVxdWlyZSgnLi4vZGF0YU1vZGVscy9GaWx0ZXJTdWJncmlkJyk7XG52YXIgU3VtbWFyeVN1YmdyaWQgPSByZXF1aXJlKCcuLi9kYXRhTW9kZWxzL1N1bW1hcnlTdWJncmlkJyk7XG52YXIgZGlhbG9ncyA9IHJlcXVpcmUoJy4uL2RpYWxvZ3MnKTtcblxudmFyIG5vRXhwb3J0UHJvcGVydGllcyA9IFtcbiAgICAnY29sdW1uSGVhZGVyJyxcbiAgICAnY29sdW1uSGVhZGVyQ29sdW1uU2VsZWN0aW9uJyxcbiAgICAnZmlsdGVyUHJvcGVydGllcycsXG4gICAgJ3Jvd0hlYWRlcicsXG4gICAgJ3Jvd0hlYWRlclJvd1NlbGVjdGlvbicsXG4gICAgJ3Jvd051bWJlcnNQcm9wZXJ0aWVzJyxcbiAgICAndHJlZUNvbHVtblByb3BlcnRpZXMnLFxuICAgICd0cmVlQ29sdW1uUHJvcGVydGllc0NvbHVtblNlbGVjdGlvbicsXG5dO1xuXG52YXIgd2FybmVkID0ge307XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWJzdHJhY3RcbiAqIEBkZXNjIEEgc29ydCBvZiBcIm1vZGVsKysuXCIgSXQgY29udGFpbnMgYWxsIGNvZGUvZGF0YSB0aGF0J3MgbmVjZXNzYXJ5IGZvciBlYXNpbHkgaW1wbGVtZW50aW5nIGEgdmlydHVhbCBkYXRhIHNvdXJjZSBhbmQgaXRzIG1hbmlwdWxhdGlvbi9hbmFseXRpY3MuXG4gKlxuICovXG52YXIgQmVoYXZpb3IgPSBCYXNlLmV4dGVuZCgnQmVoYXZpb3InLCB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyB0aGlzIGlzIHRoZSBjYWxsYmFjayBmb3IgdGhlIHBsdWdpbiBwYXR0ZXJuIG9mIG5lc3RlZCB0YWdzXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gXyhTZWUge0BsaW5rIGJlaGF2aW9ycy5KU09OI3NldERhdGF9IGZvciBhZGRpdGlvbmFsIG9wdGlvbnMuKV9cbiAgICAgKiBAcGFyYW0ge0RhdGFNb2RlbHNbXX0gW29wdGlvbnMuc3ViZ3JpZHNdXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtIeXBlcmdyaWR9XG4gICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXplRmVhdHVyZUNoYWluKGdyaWQpO1xuXG4gICAgICAgIHRoaXMuZ3JpZC5iZWhhdmlvciA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzZXQob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGNyZWF0ZSB0aGUgZmVhdHVyZSBjaGFpbiAtIHRoaXMgaXMgdGhlIFtjaGFpbiBvZiByZXNwb25zaWJpbGl0eV0oaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9DaGFpbk9mUmVzcG9uc2liaWxpdHlQYXR0ZXJuKSBwYXR0ZXJuLlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemVGZWF0dXJlQ2hhaW46IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBIYXNoIG9mIGZlYXR1cmUgY2xhc3MgbmFtZXMuXG4gICAgICAgICAqIEBkZXNjIEJ1aWx0IGhlcmUgYnV0IG90aGVyd2lzZSBub3QgaW4gdXNlLlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZlYXR1cmVNYXAgPSB7fTtcblxuICAgICAgICB0aGlzLmZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24oRmVhdHVyZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgbmV3RmVhdHVyZSA9IG5ldyBGZWF0dXJlQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBzZWxmLmZlYXR1cmVNYXBbbmV3RmVhdHVyZS4kJENMQVNTX05BTUVdID0gbmV3RmVhdHVyZTtcbiAgICAgICAgICAgIGlmIChzZWxmLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgICAgIHNlbGYuZmVhdHVyZUNoYWluLnNldE5leHQobmV3RmVhdHVyZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBzdW1tYXJ5IENvbnRyb2xsZXIgY2hhaW4gb2YgY29tbWFuZC5cbiAgICAgICAgICAgICAgICAgKiBAZGVzYyBFYWNoIGZlYXR1cmUgaXMgbGlua2VkIHRvIHRoZSBuZXh0IGZlYXR1cmUuXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICAgICAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNlbGYuZmVhdHVyZUNoYWluID0gbmV3RmVhdHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZlYXR1cmVzOiBbXSwgLy8gb3ZlcnJpZGUgaW4gaW1wbGVtZW50aW5nIGNsYXNzIHVubGVzcyBubyBmZWF0dXJlc1xuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jbGVhclN0YXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YU1vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFNb2RlbC5yZXNldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7RGF0YU1vZGVsfVxuICAgICAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmRhdGFNb2RlbCA9IHRoaXMuZ2V0TmV3RGF0YU1vZGVsKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjcmVhdGUgYENlbGxFdmVudGAgY2xhc3Mgc28gaXQgY2FuIHNldCB1cCBpdHMgaW50ZXJuYWwgYGdyaWRgLCBgYmVoYXZpb3JgLCBhbmQgYGRhdGFNb2RlbGAgY29udmVuaWVuY2UgcHJvcGVydGllc1xuICAgICAgICB0aGlzLkNlbGxFdmVudCA9IGNlbGxFdmVudEZhY3RvcnkodGhpcy5ncmlkKTtcblxuICAgICAgICB0aGlzLmRhdGFVcGRhdGVzID0ge307IC8vZm9yIG92ZXJyaWRpbmcgd2l0aCBlZGl0IHZhbHVlcztcbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvblggPSB0aGlzLnNjcm9sbFBvc2l0aW9uWSA9IDA7XG4gICAgICAgIHRoaXMuY2xlYXJDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcblxuICAgICAgICB0aGlzLnN1YmdyaWRzID0gb3B0aW9ucy5zdWJncmlkcyB8fCBbXG4gICAgICAgICAgICBIZWFkZXJTdWJncmlkLFxuICAgICAgICAgICAgRmlsdGVyU3ViZ3JpZCxcbiAgICAgICAgICAgIFtTdW1tYXJ5U3ViZ3JpZCwgeyBuYW1lOiAndG9wVG90YWxzJyB9XSxcbiAgICAgICAgICAgIHRoaXMuZGF0YU1vZGVsLFxuICAgICAgICAgICAgW1N1bW1hcnlTdWJncmlkLCB7IG5hbWU6ICdib3R0b21Ub3RhbHMnIH1dXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGdldCByZW5kZXJlZENvbHVtbkNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgZ2V0IHJlbmRlcmVkUm93Q291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucmVuZGVyZXIudmlzaWJsZVJvd3MubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBjbGVhckNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0NvbHVtbltdfVxuICAgICAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0NvbHVtbltdfVxuICAgICAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsbENvbHVtbnMgPSBbXTtcblxuICAgICAgICB0aGlzLmFsbENvbHVtbnNbLTFdID0gdGhpcy5jb2x1bW5zWy0xXSA9IHRoaXMubmV3Q29sdW1uKHsgaW5kZXg6IC0xIH0pO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnNbLTJdID0gdGhpcy5jb2x1bW5zWy0yXSA9IHRoaXMubmV3Q29sdW1uKHsgaW5kZXg6IC0yIH0pO1xuXG4gICAgICAgIHRoaXMuY29sdW1uRW51bSA9IHt9O1xuICAgIH0sXG5cbiAgICBnZXRBY3RpdmVDb2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc1t4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIFwiZ3JpZCBpbmRleFwiIGdpdmVuIGEgXCJkYXRhIGluZGV4XCIgKG9yIGNvbHVtbiBvYmplY3QpXG4gICAgICogQHBhcmFtIHtDb2x1bW58bnVtYmVyfSBjb2x1bW5PckluZGV4XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxudW1iZXJ9IFRoZSBncmlkIGluZGV4IG9mIHRoZSBjb2x1bW4gb3IgdW5kZWZpbmVkIGlmIGNvbHVtbiBub3QgaW4gZ3JpZC5cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVDb2x1bW5JbmRleDogZnVuY3Rpb24oY29sdW1uT3JJbmRleCkge1xuICAgICAgICB2YXIgaW5kZXggPSBjb2x1bW5PckluZGV4IGluc3RhbmNlb2YgQ29sdW1uID8gY29sdW1uT3JJbmRleC5pbmRleCA6IGNvbHVtbk9ySW5kZXg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb2x1bW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW5zW2ldLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFZpc2libGVDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRWaXNpYmxlQ29sdW1uKHgpJywgJ2dldEFjdGl2ZUNvbHVtbih4KScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBnZXRWaXNpYmxlQ29sdW1uTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldFZpc2libGVDb2x1bW5OYW1lKHgpJywgJ2dldEFjdGl2ZUNvbHVtbih4KS5uYW1lJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGdldENvbHVtbklkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0Q29sdW1uSWQoeCknLCAnZ2V0QWN0aXZlQ29sdW1uKHgpLmhlYWRlcicsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBnZXRIZWFkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRIZWFkZXIoeCknLCAnZ2V0QWN0aXZlQ29sdW1uKHgpLmhlYWRlcicsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbjogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxDb2x1bW5zW3hdO1xuICAgIH0sXG5cbiAgICBuZXdDb2x1bW46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2x1bW4odGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIGFkZENvbHVtbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5uZXdDb2x1bW4ob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgfSxcblxuICAgIGNyZWF0ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL2NvbmNyZXRlIGltcGxlbWVudGF0aW9uIGhlcmVcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0QWN0aXZlQ29sdW1uKHgpO1xuICAgICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmRlZmF1bHRDb2x1bW5XaWR0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGggPSBjb2x1bW4uZ2V0V2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICBzZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oeCwgd2lkdGgpIHtcbiAgICAgICAgdGhpcy5nZXRBY3RpdmVDb2x1bW4oeCkuc2V0V2lkdGgod2lkdGgpO1xuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsUmVuZGVyZXI6IGZ1bmN0aW9uKGNvbmZpZywgY2VsbEV2ZW50KSB7XG4gICAgICAgIHJldHVybiBjZWxsRXZlbnQuY29sdW1uLmdldENlbGxSZW5kZXJlcihjb25maWcsIGNlbGxFdmVudCk7XG4gICAgfSxcbiAgICBnZXRDZWxsUHJvdmlkZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0Q2VsbFByb3ZpZGVyKCknLCAnZ3JpZC5jZWxsUmVuZGVyZXJzJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNlbGxQcm92aWRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdnZXRDZWxsUHJvdmlkZXIoKSBpcyBkZXByZWNhdGVkIGFzIG9mIHYxLjAuNi4gTm8gcmVwbGFjZW1lbnQ7IGRvIG5vdCBjYWxsLiBQcmV2aW91c2x5IGNhbGxlZCBieSBgQmVoYXZpb3JgIGNvbnN0cnVjdG9yOyBgbmV3IENlbGxSZW5kZXJlcnMoKWAgaXMgbm93IGNhbGxlZCBieSBgSHlwZXJncmlkYCBjb25zdHJ1Y3RvciBpbnN0ZWFkLicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5QW5hbHl0aWNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwucmVpbmRleCgpO1xuICAgICAgICB0aGlzLnNoYXBlQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBmdW5jdGlvbiB0byBlbXB0eSBhbiBvYmplY3Qgb2YgaXRzIG1lbWJlcnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBlbXB0eVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4cG9ydFByb3BzXVxuICAgICAqICogYHVuZGVmaW5lZGAgKG9taXR0ZWQpIC0gZGVsZXRlICphbGwqIHByb3BlcnRpZXNcbiAgICAgKiAqICoqZmFsc3kqKiAtIGRlbGV0ZSAqb25seSogdGhlIGV4cG9ydCBwcm9wZXJ0aWVzXG4gICAgICogKiAqKnRydXRoeSoqIC0gZGVsZXRlIGFsbCBwcm9wZXJ0aWVzICpleGNlcHQqIHRoZSBleHBvcnQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGNsZWFyT2JqZWN0UHJvcGVydGllczogZnVuY3Rpb24ob2JqLCBleHBvcnRQcm9wcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgKFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRQcm9wcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICFleHBvcnRQcm9wcyAmJiBub0V4cG9ydFByb3BlcnRpZXMuaW5kZXhPZihrZXkpID49IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0UHJvcHMgJiYgbm9FeHBvcnRQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA8IDBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldHRlciBmb3IgYSBbTWVtZW50b10oaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9NZW1lbnRvUGF0dGVybikgT2JqZWN0XG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRQcml2YXRlU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGUoJ2dldFByaXZhdGVTdGF0ZSgpJywgJ2dyaWQucHJvcGVydGllcycsICcxLjIuMCcpO1xuICAgIH0sXG5cbiAgICAvL3RoaXMgaXMgZWZmZWN0aXZlbHkgYSBjbG9uZSwgd2l0aCBjZXJ0YWluIHRoaW5ncyByZW1vdmVkLi4uLlxuICAgIGdldFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuZ3JpZC5wcm9wZXJ0aWVzKSk7XG4gICAgICAgIHRoaXMuY2xlYXJPYmplY3RQcm9wZXJ0aWVzKGNvcHkuY29sdW1uUHJvcGVydGllcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjbGVhciBhbGwgdGFibGUgc3RhdGVcbiAgICAgKi9cbiAgICBjbGVhclN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1lbWVudG8gZm9yIHRoZSB1c2VyIGNvbmZpZ3VyZWQgdmlzdWFsIHByb3BlcnRpZXMgb2YgdGhlIHRhYmxlXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ3JpZC5wcm9wZXJ0aWVzID0gdGhpcy5nZXREZWZhdWx0U3RhdGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge29iamVjdH0gTmV3bHkgY3JlYXRlZCBkZWZhdWx0IGVtcHR5IHRhYmxlc3RhdGUuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhYmxlUHJvcGVydGllcyA9IHRoaXMuZ3JpZC5fZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB2YXIgc3RhdGUgPSBPYmplY3QuY3JlYXRlKHRhYmxlUHJvcGVydGllcyk7XG5cbiAgICAgICAgXyhzdGF0ZSkuZXh0ZW5kT3duKHtcbiAgICAgICAgICAgIGNvbHVtblByb3BlcnRpZXM6IFtdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlc3RvcmUgdGhpcyB0YWJsZSB0byBhIHByZXZpb3VzIHN0YXRlLlxuICAgICAqIFNlZSB0aGUgW21lbWVudG8gcGF0dGVybl0oaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9NZW1lbnRvUGF0dGVybikuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1lbWVudG8gLSBhbiBlbmNhcHN1bGF0ZWQgcmVwcmVzZW50YXRpb24gb2YgdGFibGUgc3RhdGVcbiAgICAgKi9cbiAgICBzZXRTdGF0ZTogZnVuY3Rpb24obWVtZW50bykge1xuXG4gICAgICAgIGlmIChtZW1lbnRvLnJvd0hlaWdodHMpIHtcbiAgICAgICAgICAgIGlmICghd2FybmVkLnJvd0hlaWdodHMpIHtcbiAgICAgICAgICAgICAgICB3YXJuZWQucm93SGVpZ2h0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdyb3dIZWlnaHRzLCB0aGUgaGFzaCBvZiByb3cgaGVpZ2h0cyB5b3UgcHJvdmlkZWQgdG8gc2V0U3RhdGUgbWV0aG9kLCBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGFzIG9mIHYxLjIuMCBhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkIHVzZSBpbmRpdmlkdWFsIGNhbGxzIHRvIHNldFJvd0hlaWdodCh5LCBoZWlnaHQsIGRhdGFNb2RlbCkgZm9yIGVhY2ggcm93IGhlaWdodCB5b3Ugd2lzaCB0byBzZXQsIHdoZXJlIHkgaXMgbG9jYWwgemVyby1iYXNlZCByb3cgaW5kZXggd2l0aGluIGRhdGFNb2RlbC4gVGhlIGRhdGFNb2RlbCBhcmcgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIHRoaXMuZGF0YU1vZGVsOyBzcGVjaWZ5IHRvIHNldCByb3cgaGVpZ2h0cyBpbiBvdGhlciBkYXRhIG1vZGVscywgc3VjaCBhcyBoZWFkZXIgcm93LCBmaWx0ZXIgY2VsbCByb3csIGluZGl2aWR1YWwgc3VtbWFyeSByb3dzLCBldGMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3dlIGRvbid0IHdhbnQgdG8gY2xvYmJlciB0aGUgY29sdW1uIHByb3BlcnRpZXMgY29tcGxldGVseVxuICAgICAgICBpZiAoIW1lbWVudG8uY29sdW1uSW5kZXhlcykge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuZGF0YU1vZGVsLnNjaGVtYS5sZW5ndGg7XG4gICAgICAgICAgICBtZW1lbnRvLmNvbHVtbkluZGV4ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtZW1lbnRvLmNvbHVtbkluZGV4ZXNbaV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xQcm9wZXJ0aWVzID0gbWVtZW50by5jb2x1bW5Qcm9wZXJ0aWVzO1xuICAgICAgICBkZWxldGUgbWVtZW50by5jb2x1bW5Qcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLmNsZWFyU3RhdGUoKTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5ncmlkLnByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29sdW1ucygpO1xuICAgICAgICB0aGlzLl9zZXRDb2x1bW5PcmRlcihtZW1lbnRvLmNvbHVtbkluZGV4ZXMpO1xuICAgICAgICBfKHN0YXRlKS5leHRlbmRPd24obWVtZW50byk7XG4gICAgICAgIHRoaXMuc2V0QWxsQ29sdW1uUHJvcGVydGllcyhjb2xQcm9wZXJ0aWVzKTtcbiAgICAgICAgbWVtZW50by5jb2x1bW5Qcm9wZXJ0aWVzID0gY29sUHJvcGVydGllcztcblxuICAgICAgICAvL2p1c3QgdG8gYmUgY2xvc2UvIGl0J3MgZWFzaWVyIG9uIHRoZSBleWVzXG4gICAgICAgIHRoaXMuc2V0Q29sdW1uV2lkdGgoLTEsIDI0LjE5MzM1OTM3NSk7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnJlaW5kZXgoKTtcbiAgICB9LFxuXG4gICAgc2V0QWxsQ29sdW1uUHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmNvbHVtblByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICB0aGlzLmNsZWFyT2JqZWN0UHJvcGVydGllcyhjdXJyZW50LCBmYWxzZSk7XG4gICAgICAgICAgICBfKGN1cnJlbnQpLmV4dGVuZE93bihwcm9wZXJ0aWVzW2ldKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0Q29sdW1uT3JkZXI6IGZ1bmN0aW9uKGNvbHVtbkluZGV4ZXMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29sdW1uSW5kZXhlcykpe1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLmxlbmd0aCA9IGNvbHVtbkluZGV4ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29sdW1uSW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGluZGV4LCBpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5zW2ldID0gdGhpcy5hbGxDb2x1bW5zW2luZGV4XTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZWJ1aWxkIHRoZSBjb2x1bW4gb3JkZXIgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbHVtbkluZGV4ZXMgLSBsaXN0IG9mIGNvbHVtbiBpbmRleGVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2lsZW50PWZhbHNlXSAtIHdoZXRoZXIgdG8gdHJpZ2dlciBjb2x1bW4gY2hhbmdlZCBldmVudFxuICAgICAqL1xuICAgIHNldENvbHVtbkluZGV4ZXM6IGZ1bmN0aW9uKGNvbHVtbkluZGV4ZXMsIHNpbGVudCkge1xuICAgICAgICB2YXIgdGFibGVTdGF0ZSA9IHRoaXMuZ3JpZC5wcm9wZXJ0aWVzO1xuICAgICAgICB0aGlzLl9zZXRDb2x1bW5PcmRlcihjb2x1bW5JbmRleGVzKTtcbiAgICAgICAgdGFibGVTdGF0ZS5jb2x1bW5JbmRleGVzID0gY29sdW1uSW5kZXhlcztcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuZmlyZVN5bnRoZXRpY09uQ29sdW1uc0NoYW5nZWRFdmVudCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNob3cgaW5hY3RpdmUgY29sdW1uKHMpIG9yIG1vdmUgYWN0aXZlIGNvbHVtbihzKS5cbiAgICAgKlxuICAgICAqIEBkZXNjIEFkZHMgb25lIG9yIHNldmVyYWwgY29sdW1ucyB0byB0aGUgXCJhY3RpdmVcIiBjb2x1bW4gbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzQWN0aXZlQ29sdW1uSW5kZXhlcz1mYWxzZV0gLSBXaGljaCBsaXN0IGBjb2x1bW5JbmRleGVzYCByZWZlcnMgdG86XG4gICAgICogKiBgdHJ1ZWAgLSBUaGUgYWN0aXZlIGNvbHVtbiBsaXN0LiBUaGlzIGNhbiBvbmx5IG1vdmUgY29sdW1ucyBhcm91bmQgd2l0aGluIHRoZSBhY3RpdmUgY29sdW1uIGxpc3Q7IGl0IGNhbm5vdCBhZGQgaW5hY3RpdmUgY29sdW1ucyAoYmVjYXVzZSBpdCBjYW4gb25seSByZWZlciB0byBjb2x1bW5zIGluIHRoZSBhY3RpdmUgY29sdW1uIGxpc3QpLlxuICAgICAqICogYGZhbHNlYCAtIFRoZSBmdWxsIGNvbHVtbiBsaXN0IChhcyBwZXIgY29sdW1uIHNjaGVtYSBhcnJheSkuIFRoaXMgaW5zZXJ0cyBjb2x1bW5zIGZyb20gdGhlIFwiaW5hY3RpdmVcIiBjb2x1bW4gbGlzdCwgbW92aW5nIGNvbHVtbnMgdGhhdCBhcmUgYWxyZWFkeSBhY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gY29sdW1uSW5kZXhlcyAtIENvbHVtbiBpbmRleChlcykgaW50byBsaXN0IGFzIGRldGVybWluZWQgYnkgYGlzQWN0aXZlQ29sdW1uSW5kZXhlc2AuIE9uZSBvZjpcbiAgICAgKiAqICoqU2NhbGFyIGNvbHVtbiBpbmRleCoqIC0gQWRkcyBzaW5nbGUgY29sdW1uIGF0IGluc2VydGlvbiBwb2ludC5cbiAgICAgKiAqICoqQXJyYXkgb2YgY29sdW1uIGluZGV4ZXMqKiAtIEFkZHMgbXVsdGlwbGUgY29uc2VjdXRpdmUgY29sdW1ucyBhdCBpbnNlcnRpb24gcG9pbnQuXG4gICAgICpcbiAgICAgKiBfVGhpcyByZXF1aXJlZCBwYXJhbWV0ZXIgaXMgcHJvbW90ZWQgbGVmdCBvbmUgYXJnIHBvc2l0aW9uIHdoZW4gYGlzQWN0aXZlQ29sdW1uSW5kZXhlc2Agb21pdHRlZC5fXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JlZmVyZW5jZUluZGV4PXRoaXMuY29sdW1ucy5sZW5ndGhdIC0gSW5zZXJ0aW9uIHBvaW50LCBfaS5lLixfIHRoZSBlbGVtZW50IHRvIGluc2VydCBiZWZvcmUuIEEgbmVnYXRpdmUgdmFsdWVzIHNraXBzIHRoZSByZWluc2VydC4gRGVmYXVsdCBpcyB0byBpbnNlcnQgbmV3IGNvbHVtbnMgYXQgZW5kIG9mIGFjdGl2ZSBjb2x1bW4gbGlzdC5cbiAgICAgKlxuICAgICAqIF9Qcm9tb3RlZCBsZWZ0IG9uZSBhcmcgcG9zaXRpb24gd2hlbiBgaXNBY3RpdmVDb2x1bW5JbmRleGVzYCBvbWl0dGVkLl9cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FsbG93RHVwbGljYXRlQ29sdW1ucz1mYWxzZV0gLSBVbmxlc3MgdHJ1ZSwgYWxyZWFkeSB2aXNpYmxlIGNvbHVtbnMgYXJlIHJlbW92ZWQgZmlyc3QuXG4gICAgICpcbiAgICAgKiBfUHJvbW90ZWQgbGVmdCBvbmUgYXJnIHBvc2l0aW9uIHdoZW4gYGlzQWN0aXZlQ29sdW1uSW5kZXhlc2Agb21pdHRlZCArIG9uZSBwb3NpdGlvbiB3aGVuIGByZWZlcmVuY2VJbmRleGAgb21pdHRlZC5fXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgc2hvd0NvbHVtbnM6IGZ1bmN0aW9uKGlzQWN0aXZlQ29sdW1uSW5kZXhlcywgY29sdW1uSW5kZXhlcywgcmVmZXJlbmNlSW5kZXgsIGFsbG93RHVwbGljYXRlQ29sdW1ucykge1xuICAgICAgICAvLyBQcm9tb3RlIGFyZ3Mgd2hlbiBpc0FjdGl2ZUNvbHVtbkluZGV4ZXMgb21pdHRlZFxuICAgICAgICBpZiAodHlwZW9mIGlzQWN0aXZlQ29sdW1uSW5kZXhlcyA9PT0gJ251bWJlcicgfHwgQXJyYXkuaXNBcnJheShpc0FjdGl2ZUNvbHVtbkluZGV4ZXMpKSB7XG4gICAgICAgICAgICBhbGxvd0R1cGxpY2F0ZUNvbHVtbnMgPSByZWZlcmVuY2VJbmRleDtcbiAgICAgICAgICAgIHJlZmVyZW5jZUluZGV4ID0gY29sdW1uSW5kZXhlcztcbiAgICAgICAgICAgIGNvbHVtbkluZGV4ZXMgPSBpc0FjdGl2ZUNvbHVtbkluZGV4ZXM7XG4gICAgICAgICAgICBpc0FjdGl2ZUNvbHVtbkluZGV4ZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY3RpdmVDb2x1bW5zID0gdGhpcy5jb2x1bW5zLFxuICAgICAgICAgICAgc291cmNlQ29sdW1uTGlzdCA9IGlzQWN0aXZlQ29sdW1uSW5kZXhlcyA/IGFjdGl2ZUNvbHVtbnMgOiB0aGlzLmFsbENvbHVtbnM7XG5cbiAgICAgICAgLy8gTmVzdCBzY2FsYXIgaW5kZXhcbiAgICAgICAgaWYgKHR5cGVvZiBjb2x1bW5JbmRleGVzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29sdW1uSW5kZXhlcyA9IFtjb2x1bW5JbmRleGVzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdDb2x1bW5zID0gY29sdW1uSW5kZXhlc1xuICAgICAgICAgICAgLy8gTG9vayB1cCBjb2x1bW5zIHVzaW5nIHByb3ZpZGVkIGluZGV4ZXNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaW5kZXgpIHsgcmV0dXJuIHNvdXJjZUNvbHVtbkxpc3RbaW5kZXhdOyB9KVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSB1bmRlZmluZWQgY29sdW1uc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihjb2x1bW4pIHsgcmV0dXJuIGNvbHVtbjsgfSk7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBpbnNlcnRpb24gcG9pbnQgaXMgZW5kIChpLmUuLCBiZWZvcmUgKGxhc3QrMSl0aCBlbGVtZW50KVxuICAgICAgICBpZiAodHlwZW9mIHJlZmVyZW5jZUluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYWxsb3dEdXBsaWNhdGVDb2x1bW5zID0gcmVmZXJlbmNlSW5kZXg7IC8vIGFzc3VtZSByZWZlcmVuY2UgaW5kZXggd2FzIG9taXR0ZWQgd2hlbiBub3QgYSBudW1iZXJcbiAgICAgICAgICAgIHJlZmVyZW5jZUluZGV4ID0gYWN0aXZlQ29sdW1ucy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgYWxyZWFkeSB2aXNpYmxlIGNvbHVtbnMgYW5kIGFkanVzdCBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgaWYgKCFhbGxvd0R1cGxpY2F0ZUNvbHVtbnMpIHtcbiAgICAgICAgICAgIG5ld0NvbHVtbnMuZm9yRWFjaChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGFjdGl2ZUNvbHVtbnMuaW5kZXhPZihjb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ29sdW1ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZlcmVuY2VJbmRleCA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0tcmVmZXJlbmNlSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluc2VydCB0aGUgbmV3IGNvbHVtbnMgYXQgdGhlIGluc2VydGlvbiBwb2ludFxuICAgICAgICBpZiAocmVmZXJlbmNlSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgYWN0aXZlQ29sdW1ucy5zcGxpY2UuYXBwbHkoYWN0aXZlQ29sdW1ucywgW3JlZmVyZW5jZUluZGV4LCAwXS5jb25jYXQobmV3Q29sdW1ucykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkLnByb3BlcnRpZXMuY29sdW1uSW5kZXhlcyA9IGFjdGl2ZUNvbHVtbnMubWFwKGZ1bmN0aW9uKGNvbHVtbikgeyByZXR1cm4gY29sdW1uLmluZGV4OyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSGlkZSBhY3RpdmUgY29sdW1uKHMpLlxuICAgICAqIEBkZXNjIFJlbW92ZXMgb25lIG9yIHNldmVyYWwgY29sdW1ucyBmcm9tIHRoZSBcImFjdGl2ZVwiIGNvbHVtbiBsaXN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzQWN0aXZlQ29sdW1uSW5kZXhlcz1mYWxzZV0gLSBXaGljaCBsaXN0IGBjb2x1bW5JbmRleGVzYCByZWZlcnMgdG86XG4gICAgICogKiBgdHJ1ZWAgLSBUaGUgYWN0aXZlIGNvbHVtbiBsaXN0LlxuICAgICAqICogYGZhbHNlYCAtIFRoZSBmdWxsIGNvbHVtbiBsaXN0IChhcyBwZXIgY29sdW1uIHNjaGVtYSBhcnJheSkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IGNvbHVtbkluZGV4ZXMgLSBDb2x1bW4gaW5kZXgoZXMpIGludG8gbGlzdCBhcyBkZXRlcm1pbmVkIGJ5IGBpc0FjdGl2ZUNvbHVtbkluZGV4ZXNgLiBPbmUgb2Y6XG4gICAgICogKiAqKlNjYWxhciBjb2x1bW4gaW5kZXgqKiAtIEFkZHMgc2luZ2xlIGNvbHVtbiBhdCBpbnNlcnRpb24gcG9pbnQuXG4gICAgICogKiAqKkFycmF5IG9mIGNvbHVtbiBpbmRleGVzKiogLSBBZGRzIG11bHRpcGxlIGNvbnNlY3V0aXZlIGNvbHVtbnMgYXQgaW5zZXJ0aW9uIHBvaW50LlxuICAgICAqXG4gICAgICogX1RoaXMgcmVxdWlyZWQgcGFyYW1ldGVyIGlzIHByb21vdGVkIGxlZnQgb25lIGFyZyBwb3NpdGlvbiB3aGVuIGBpc0FjdGl2ZUNvbHVtbkluZGV4ZXNgIG9taXR0ZWQuX1xuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoaWRlQ29sdW1uczogZnVuY3Rpb24oaXNBY3RpdmVDb2x1bW5JbmRleGVzLCBjb2x1bW5JbmRleGVzKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgLy8gQ29udmVydCB0byBhcnJheSBzbyB3ZSBjYW4gYWRkIGFuIGFyZ3VtZW50IChlbGVtZW50KVxuICAgICAgICBhcmdzLnB1c2goLTEpOyAvLyBSZW1vdmUgb25seTsgZG8gbm90IHJlaW5zZXJ0LlxuICAgICAgICB0aGlzLnNob3dDb2x1bW5zLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZmV0Y2ggdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IGtleVxuICAgICAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgb2YgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBhIHByb3BlcnR5IG5hbWVcbiAgICAgKi9cbiAgICByZXNvbHZlUHJvcGVydHk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAvLyB0b2RvOiByZW1vdmUgd2hlbiB3ZSByZW1vdmUgdGhlIGRlcHJlY2F0ZWQgZ3JpZC5yZXNvbHZlUHJvcGVydHlcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoa2V5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEEgc3BlY2lmaWMgY2VsbCB3YXMgY2xpY2tlZDsgeW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gYWxsIGV2ZW50IGluZm9ybWF0aW9uXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2xpY2tlZCBpbiBhIGRyaWxsLWRvd24gY29sdW1uLlxuICAgICAqL1xuICAgIGNlbGxDbGlja2VkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnY2VsbENsaWNrZWQoY2VsbCwgZXZlbnQpJywgJ2NlbGxDbGlja2VkKGV2ZW50KScsICcxLjIuMCcsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmNlbGxDbGlja2VkKGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEEgc3BlY2lmaWMgY2VsbCB3YXMgbGUgZG91YmxlLWNsaWNrZWQ7IHlvdSd2ZSBiZWVuIG5vdGlmaWVkLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBwb2ludCBvZiBjZWxsIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gYWxsIGV2ZW50IGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgY2VsbERvdWJsZUNsaWNrZWQ6IGZ1bmN0aW9uKGNlbGwsIGV2ZW50KSB7XG5cbiAgICB9LFxuXG4gICAgbG9va3VwRmVhdHVyZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVNYXBba2V5XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4T3JDZWxsRXZlbnQgLSBHcmlkIGNvbHVtbiBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gLSBHcmlkIHJvdyBjb29yZGluYXRlLiBPbWl0IGlmIGB4T3JDZWxsRXZlbnRgIGlzIGEgQ2VsbEV2ZW50LlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeE9yQ2VsbEV2ZW50LCB5KSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiB4T3JDZWxsRXZlbnQudmFsdWU7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLkNlbGxFdmVudCh4T3JDZWxsRXZlbnQsIHkpLnZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFVuZmlsdGVyZWRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRBY3RpdmVDb2x1bW4oeCk7XG4gICAgICAgIHJldHVybiBjb2x1bW4gJiYgY29sdW1uLmdldFVuZmlsdGVyZWRWYWx1ZSh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgZGF0YSBhdCBwb2ludCB4LCB5IHdpdGggdmFsdWVcbiAgICAgKiBAcmV0dXJuIFRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fG51bWJlcn0geE9yQ2VsbEV2ZW50IC0gR3JpZCBjb2x1bW4gY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gT21pdCBpZiBgeE9yQ2VsbEV2ZW50YCBpcyBhIENlbGxFdmVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdXNlLiBfV2hlbiBgeWAgb21pdHRlZCwgcHJvbW90ZWQgdG8gMm5kIGFyZy5fXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ29uc3VtZWQuXG4gICAgICovXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHhPckNlbGxFdmVudCwgeSwgdmFsdWUpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDM6IHhPckNlbGxFdmVudCA9IG5ldyB0aGlzLkNlbGxFdmVudCh4T3JDZWxsRXZlbnQsIHkpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjogdmFsdWUgPSB5OyBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHhPckNlbGxFdmVudC52YWx1ZSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXREYXRhVmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0RGF0YVZhbHVlKHgsIHksIHZhbHVlKScsICdkYXRhTW9kZWwuZ2V0VmFsdWUoeCwgeSwgdmFsdWUpJywgJzEuMS4wJywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgc2V0RGF0YVZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdzZXREYXRhVmFsdWUoeCwgeSwgdmFsdWUpJywgJ2RhdGFNb2RlbC5zZXRWYWx1ZSh4LCB5LCB2YWx1ZSknLCAnMS4xLjAnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGNlbGwncyBvd24gcHJvcGVydGllcyBvYmplY3QuXG4gICAgICogQGRlc2MgTWF5IGJlIHVuZGVmaW5lZCBiZWNhdXNlIGNlbGxzIG9ubHkgaGF2ZSB0aGVpciBvd24gcHJvcGVydGllcyBvYmplY3Qgd2hlbiBhdCBsZXN0IG9uZSBvd24gcHJvcGVydHkgaGFzIGJlZW4gc2V0LlxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fG51bWJlcn0geE9yQ2VsbEV2ZW50IC0gRGF0YSB4IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5XSAtIEdyaWQgcm93IGNvb3JkaW5hdGUuIF9PbWl0IHdoZW4gYHhPckNlbGxFdmVudGAgaXMgYSBgQ2VsbEV2ZW50YC5fXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZHxvYmplY3R9IFRoZSBcIm93blwiIHByb3BlcnRpZXMgb2YgdGhlIGNlbGwgYXQgeCx5IGluIHRoZSBncmlkLiBJZiB0aGUgY2VsbCBkb2VzIG5vdCBvd24gYSBwcm9wZXJ0aWVzIG9iamVjdCwgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Q2VsbE93blByb3BlcnRpZXM6IGZ1bmN0aW9uKHhPckNlbGxFdmVudCwgeSkge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4geE9yQ2VsbEV2ZW50LmNvbHVtbiAvLyB4T3JDZWxsRXZlbnQgaXMgY2VsbEV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC5nZXRDZWxsT3duUHJvcGVydGllcyh4T3JDZWxsRXZlbnQuZGF0YUNlbGwueSwgeE9yQ2VsbEV2ZW50LnZpc2libGVSb3cuc3ViZ3JpZCk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uKHhPckNlbGxFdmVudCkgLy8geE9yQ2VsbEV2ZW50IGlzIHhcbiAgICAgICAgICAgICAgICAgICAgLmdldENlbGxPd25Qcm9wZXJ0aWVzKHkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgcHJvcGVydGllcyBvYmplY3QgZm9yIGNlbGwuXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgY2VsbCdzIG93biBwcm9wZXJ0aWVzIG9iamVjdCBpZiBmb3VuZCBlbHNlIHRoZSBjb2x1bW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogSWYgeW91IGFyZSBzZWVraW5nIGEgc2luZ2xlIHNwZWNpZmljIHByb3BlcnR5LCBjb25zaWRlciBjYWxsaW5nIHtAbGluayBCZWhhdmlvciNnZXRDZWxsUHJvcGVydHl9IGluc3RlYWQuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4T3JDZWxsRXZlbnQgLSBEYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gX09taXQgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBhIGBDZWxsRXZlbnRgLl9cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBjZWxsIGF0IHgseSBpbiB0aGUgZ3JpZC5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Q2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHhPckNlbGxFdmVudCwgeSkge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4geE9yQ2VsbEV2ZW50LmNvbHVtbiAvLyB4T3JDZWxsRXZlbnQgaXMgY2VsbEV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC5nZXRDZWxsUHJvcGVydGllcyh4T3JDZWxsRXZlbnQuZGF0YUNlbGwueSwgeE9yQ2VsbEV2ZW50LnZpc2libGVSb3cuc3ViZ3JpZCk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uKHhPckNlbGxFdmVudCkgLy8geE9yQ2VsbEV2ZW50IGlzIHhcbiAgICAgICAgICAgICAgICAgICAgLmdldENlbGxQcm9wZXJ0aWVzKHkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJldHVybiBhIHNwZWNpZmljIGNlbGwgcHJvcGVydHkuXG4gICAgICogQGRlc2MgSWYgdGhlcmUgaXMgbm8gY2VsbCBwcm9wZXJ0aWVzIG9iamVjdCwgZGVmZXJzIHRvIGNvbHVtbiBwcm9wZXJ0aWVzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0NlbGxFdmVudHxudW1iZXJ9IHhPckNlbGxFdmVudCAtIERhdGEgeCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gLSBHcmlkIHJvdyBjb29yZGluYXRlLl8gT21pdCB3aGVuIGB4T3JDZWxsRXZlbnRgIGlzIGEgYENlbGxFdmVudGAuX1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBOYW1lIG9mIHByb3BlcnR5IHRvIGdldC4gX1doZW4gYHlgIG9taXR0ZWQsIHRoaXMgcGFyYW0gcHJvbW90ZWQgdG8gMm5kIGFyZy5fXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgc3BlY2lmaWVkIHByb3BlcnR5IGZvciB0aGUgY2VsbCBhdCB4LHkgaW4gdGhlIGdyaWQuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldENlbGxQcm9wZXJ0eTogZnVuY3Rpb24oeE9yQ2VsbEV2ZW50LCB5LCBrZXkpIHtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhPckNlbGxFdmVudC5jb2x1bW4gLy8geE9yQ2VsbEV2ZW50IGlzIGNlbGxFdmVudFxuICAgICAgICAgICAgICAgICAgICAuZ2V0Q2VsbFByb3BlcnR5KHhPckNlbGxFdmVudC5kYXRhQ2VsbC55LCB5LCB4T3JDZWxsRXZlbnQudmlzaWJsZVJvdy5zdWJncmlkKTsgLy8geSBvbWl0dGVkIHNvIHkgaGVyZSBpcyBhY3R1YWxseSBrZXlcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW4oeE9yQ2VsbEV2ZW50KSAvLyB4T3JDZWxsRXZlbnQgaXMgeFxuICAgICAgICAgICAgICAgICAgICAuZ2V0Q2VsbFByb3BlcnR5KHksIGtleSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgZGF0YSBhdCBwb2ludCB4LCB5IHdpdGggdmFsdWVcbiAgICAgKiBAcGFyYW0ge0NlbGxFdmVudHxudW1iZXJ9IHhPckNlbGxFdmVudCAtIERhdGEgeCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gLSBHcmlkIHJvdyBjb29yZGluYXRlLiBfT21pdCB3aGVuIGB4T3JDZWxsRXZlbnRgIGlzIGEgYENlbGxFdmVudGAuX1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gSGFzaCBvZiBjZWxsIHByb3BlcnRpZXMuIF9XaGVuIGB5YCBvbWl0dGVkLCB0aGlzIHBhcmFtIHByb21vdGVkIHRvIDJuZCBhcmcuX1xuICAgICAqL1xuICAgIHNldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih4T3JDZWxsRXZlbnQsIHksIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgeE9yQ2VsbEV2ZW50LmNvbHVtbiAvLyB4T3JDZWxsRXZlbnQgaXMgY2VsbEV2ZW50XG4gICAgICAgICAgICAgICAgLnNldENlbGxQcm9wZXJ0aWVzKHhPckNlbGxFdmVudC5kYXRhQ2VsbC55LCB5LCB4T3JDZWxsRXZlbnQudmlzaWJsZVJvdy5zdWJncmlkKTsgLy8geSBvbWl0dGVkIHNvIHkgaGVyZSBpcyBhY3R1YWxseSBwcm9wZXJ0aWVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdldENvbHVtbih4T3JDZWxsRXZlbnQpIC8vIHhPckNlbGxFdmVudCBpcyB4XG4gICAgICAgICAgICAgICAgLnNldENlbGxQcm9wZXJ0aWVzKHksIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGRhdGEgYXQgcG9pbnQgeCwgeSB3aXRoIHZhbHVlXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4T3JDZWxsRXZlbnQgLSBEYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gX09taXQgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBhIGBDZWxsRXZlbnRgLl9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIEhhc2ggb2YgY2VsbCBwcm9wZXJ0aWVzLiBfV2hlbiBgeWAgb21pdHRlZCwgdGhpcyBwYXJhbSBwcm9tb3RlZCB0byAybmQgYXJnLl9cbiAgICAgKi9cbiAgICBhZGRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeE9yQ2VsbEV2ZW50LCB5LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHhPckNlbGxFdmVudC5jb2x1bW4gLy8geE9yQ2VsbEV2ZW50IGlzIGNlbGxFdmVudFxuICAgICAgICAgICAgICAgIC5hZGRDZWxsUHJvcGVydGllcyh4T3JDZWxsRXZlbnQuZGF0YUNlbGwueSwgeSwgeE9yQ2VsbEV2ZW50LnZpc2libGVSb3cuc3ViZ3JpZCk7IC8vIHkgb21pdHRlZCBzbyB5IGhlcmUgaXMgYWN0dWFsbHkgcHJvcGVydGllc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nZXRDb2x1bW4oeE9yQ2VsbEV2ZW50KSAvLyB4T3JDZWxsRXZlbnQgaXMgeFxuICAgICAgICAgICAgICAgIC5hZGRDZWxsUHJvcGVydGllcyh5LCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTZXQgYSBzcGVjaWZpYyBjZWxsIHByb3BlcnR5LlxuICAgICAqIEBkZXNjIElmIHRoZXJlIGlzIG5vIGNlbGwgcHJvcGVydGllcyBvYmplY3QsIGRlZmVycyB0byBjb2x1bW4gcHJvcGVydGllcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4T3JDZWxsRXZlbnQgLSBEYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldIC0gR3JpZCByb3cgY29vcmRpbmF0ZS4gX09taXQgd2hlbiBgeE9yQ2VsbEV2ZW50YCBpcyBhIGBDZWxsRXZlbnRgLl9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gTmFtZSBvZiBwcm9wZXJ0eSB0byBnZXQuIF9XaGVuIGB5YCBvbWl0dGVkLCB0aGlzIHBhcmFtIHByb21vdGVkIHRvIDJuZCBhcmcuX1xuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRDZWxsUHJvcGVydHk6IGZ1bmN0aW9uKHhPckNlbGxFdmVudCwgeSwga2V5LCB2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4geE9yQ2VsbEV2ZW50LmNvbHVtbiAvLyB4T3JDZWxsRXZlbnQgaXMgY2VsbEV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC5zZXRDZWxsUHJvcGVydHkoeE9yQ2VsbEV2ZW50LmRhdGFDZWxsLnksIHksIGtleSwgeE9yQ2VsbEV2ZW50LnZpc2libGVSb3cuc3ViZ3JpZCk7IC8vIHkgb21pdHRlZCBzbyB5IGhlcmUgaXMgYWN0dWFsbHkga2V5IGFuZCBrZXkgaXMgYWN0dWFsbHkgdmFsdWVcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW4oeE9yQ2VsbEV2ZW50KSAvLyB4T3JDZWxsRXZlbnQgaXMgeFxuICAgICAgICAgICAgICAgICAgICAuc2V0Q2VsbFByb3BlcnR5KHksIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldHMgdGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBoeXBlcmdyaWQuXG4gICAgICogQGRzYyBEZWZpbmVkIGFzIHRoZSBzdW0gb2YgYWxsIHJvd3MgZnJvbSBhbGwgc3ViZ3JpZHMuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViZ3JpZHMucmVkdWNlKGZ1bmN0aW9uKHN1bSwgc3ViZ3JpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1bSArIHN1YmdyaWQuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfSxcblxuICAgIGdldFVuZmlsdGVyZWRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldFVuZmlsdGVyZWRSb3dDb3VudCgpJywgbnVsbCwgJzEuMi4wJywgYXJndW1lbnRzLCAnTm8gbG9uZ2VyIHN1cHBvcnRlZCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGVpZ2h0IGluIHBpeGVscyBvZiB0aGUgZml4ZWQgcm93cyBhcmVhICBvZiB0aGUgaHlwZXJncmlkLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93c0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuICAgICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsICs9IHRoaXMuZ2V0Um93SGVpZ2h0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIERhdGEgcm93IGNvb3JkaW5hdGUgbG9jYWwgdG8gZGF0c01vZGVsLlxuICAgICAqIEBwYXJhbSB7RGF0YU1vZGVsfSBbZGF0YU1vZGVsPXRoaXMuZGF0YU1vZGVsXVxuICAgICAqL1xuICAgIGdldFJvd0hlaWdodDogZnVuY3Rpb24ocm93SW5kZXgsIGRhdGFNb2RlbCkge1xuICAgICAgICB2YXIgcm93RGF0YSA9IChkYXRhTW9kZWwgfHwgdGhpcy5kYXRhTW9kZWwpLmdldFJvdyhyb3dJbmRleCk7XG4gICAgICAgIHJldHVybiByb3dEYXRhICYmIHJvd0RhdGEuX19ST1dfSEVJR0hUIHx8IHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmRlZmF1bHRSb3dIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgdmFsdWUgaXMgbGF6aWx5IGluaXRpYWxpemVkIGFuZCBjb21lcyBmcm9tIHRoZSBwcm9wZXJ0aWVzIG1lY2hhbmlzbSBmb3IgJ2BkZWZhdWx0Um93SGVpZ2h0YCcsIHdoaWNoIHNob3VsZCBiZSB+MjBweC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IGhlaWdodCBpbiBwaXhlbHMuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFJvd0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldERlZmF1bHRSb3dIZWlnaHQnLCAnZ3JpZC5wcm9wZXJ0aWVzLmRlZmF1bHRSb3dIZWlnaHQnLCAnMS4yLjAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgcGl4ZWwgaGVpZ2h0IG9mIGEgc3BlY2lmaWMgcm93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gRGF0YSByb3cgY29vcmRpbmF0ZSBsb2NhbCB0byBkYXRzTW9kZWwuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHBpeGVsIGhlaWdodFxuICAgICAqIEBwYXJhbSB7RGF0YU1vZGVsfSBbZGF0YU1vZGVsPXRoaXMuZGF0YU1vZGVsXVxuICAgICAqL1xuICAgIHNldFJvd0hlaWdodDogZnVuY3Rpb24ocm93SW5kZXgsIGhlaWdodCwgZGF0YU1vZGVsKSB7XG4gICAgICAgIHZhciByb3dEYXRhID0gKGRhdGFNb2RlbCB8fCB0aGlzLmRhdGFNb2RlbCkuZ2V0Um93KHJvd0luZGV4KTtcbiAgICAgICAgaWYgKHJvd0RhdGEpIHtcbiAgICAgICAgICAgIHJvd0RhdGEuX19ST1dfSEVJR0hUID0gTWF0aC5tYXgoNSwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoaXMgd2lsbCBhbGxvdyAnZmxvYXRpbmcnIGZpeGVkIHJvd3MuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbWF4aW11bSBoZWlnaHQgb2YgdGhlIGZpeGVkIHJvd3MgYXJlYSBpbiB0aGUgaHlwZXJncmlkLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93c01heEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpeGVkUm93c0hlaWdodCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGZpeGVkIGNvbHVtbiBhcmVhIGluIHRoZSBoeXBlcmdyaWQuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5zV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkpIHtcbiAgICAgICAgICAgIHRvdGFsID0gdGhpcy5nZXRDb2x1bW5XaWR0aCgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbCArPSB0aGlzLmdldENvbHVtbldpZHRoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoaXMgZXhpc3RzIHRvIHN1cHBvcnQgXCJmbG9hdGluZ1wiIGNvbHVtbnMuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdG90YWwgd2lkdGggb2YgdGhlIGZpeGVkIGNvbHVtbnMgYXJlYS5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbnNNYXhXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpeGVkQ29sdW1uc1dpZHRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB2ZXJ0aWNhbCBkaW1lbnNpb24gYW5kIG5vdGlmeSBsaXN0ZW5lcnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgbmV3IHkgdmFsdWVcbiAgICAgKi9cbiAgICBfc2V0U2Nyb2xsUG9zaXRpb25ZOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsUG9zaXRpb25ZKHkpO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIGhvcml6b250YWwgZGltZW5zaW9uIGFuZCBub3RpZnkgbGlzdGVuZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIG5ldyB4IHZhbHVlXG4gICAgICovXG4gICAgX3NldFNjcm9sbFBvc2l0aW9uWDogZnVuY3Rpb24oeCkge1xuICAgICAgICB0aGlzLnNldFNjcm9sbFBvc2l0aW9uWCh4KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZml4ZWQgcm93IGFyZWEgaGFzIGJlZW4gY2xpY2tlZCwgbWFzc2FnZSB0aGUgZGV0YWlscyBhbmQgY2FsbCB0aGUgcmVhbCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBfZml4ZWRSb3dDbGlja2VkOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICB2YXIgeCA9IHRoaXMudHJhbnNsYXRlQ29sdW1uSW5kZXgodGhpcy5nZXRTY3JvbGxQb3NpdGlvblgoKSArIG1vdXNlLmdyaWRDZWxsLnggLSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKSk7XG4gICAgICAgIHZhciB0cmFuc2xhdGVkUG9pbnQgPSBuZXcgUG9pbnQoeCwgbW91c2UuZ3JpZENlbGwueSk7XG4gICAgICAgIG1vdXNlLmdyaWRDZWxsID0gdHJhbnNsYXRlZFBvaW50O1xuICAgICAgICB0aGlzLmZpeGVkUm93Q2xpY2tlZChncmlkLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZml4ZWQgY29sdW1uIGFyZWEgaGFzIGJlZW4gY2xpY2tlZCwgbWFzc2FnZSB0aGUgZGV0YWlscyBhbmQgY2FsbCB0aGUgcmVhbCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBfZml4ZWRDb2x1bW5DbGlja2VkOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICB2YXIgdHJhbnNsYXRlZFBvaW50ID0gbmV3IFBvaW50KG1vdXNlLmdyaWRDZWxsLngsIHRoaXMuZ2V0U2Nyb2xsUG9zaXRpb25ZKCkgKyBtb3VzZS5ncmlkQ2VsbC55IC0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCkpO1xuICAgICAgICBtb3VzZS5ncmlkQ2VsbCA9IHRyYW5zbGF0ZWRQb2ludDtcbiAgICAgICAgdGhpcy5maXhlZENvbHVtbkNsaWNrZWQoZ3JpZCwgbW91c2UpO1xuICAgIH0sXG5cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbihncmlkLCB4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4ubW92ZVNpbmdsZVNlbGVjdChncmlkLCB4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBzZXR0aW5nIHRoZSBjdXJzb3IgdXAgdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHNldEN1cnNvcjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBncmlkLnVwZGF0ZUN1cnNvcigpO1xuICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSBtb3ZlIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgdGFwIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIHRhcCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbkNvbnRleHRNZW51OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgcHJvY2VlZCA9IGdyaWQuZmlyZVN5bnRoZXRpY0NvbnRleHRNZW51RXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAocHJvY2VlZCAmJiB0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlQ29udGV4dE1lbnUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIHdoZWVsIG1vdmVkIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uV2hlZWxNb3ZlZDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVXaGVlbE1vdmVkKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSB1cCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbk1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgZHJhZyB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbk1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIGtleSBkb3duIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBrZXkgdXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25LZXlVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVLZXlVcChncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgZG91YmxlIGNsaWNrIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIGRvdWJsZSBjbGljayB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29wdGlvbnNdIC0gRm9yd2FyZGVkIHRvIGRpYWxvZyBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBvcGVuRGlhbG9nOiBmdW5jdGlvbihkaWFsb2dOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgZGlhbG9nc1tkaWFsb2dOYW1lXSh0aGlzLmdyaWQsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgZG93biB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSBleGl0IHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRXhpdDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVNb3VzZUV4aXQoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEkndmUgYmVlbiBub3RpZmllZCB0aGF0IHRoZSBiZWhhdmlvciBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBjaGFuZ2VkOiBmdW5jdGlvbigpIHsgdGhpcy5ncmlkLmJlaGF2aW9yQ2hhbmdlZCgpOyB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBncmlkIGRhdGEgaGF2ZSBjaGFuZ2VkLiBZb3UndmUgYmVlbiBub3RpZmllZC5cbiAgICAgKi9cbiAgICBzaGFwZUNoYW5nZWQ6IGZ1bmN0aW9uKCkgeyB0aGlzLmdyaWQuYmVoYXZpb3JTaGFwZUNoYW5nZWQoKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZ3JpZCBkYXRhIGhhdmUgY2hhbmdlZC4gWW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgc3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHsgdGhpcy5ncmlkLmJlaGF2aW9yU3RhdGVDaGFuZ2VkKCk7IH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIHJlLW9yZGVyIGNvbHVtbnMuXG4gICAgICovXG4gICAgaXNDb2x1bW5SZW9yZGVyYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucHJvcGVydGllcy5jb2x1bW5zUmVvcmRlcmFibGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW5kZXh9IHggLSBEYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwcm9wZXJ0aWVzIGZvciBhIHNwZWNpZmljIGNvbHVtbi5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRDb2x1bW4oeCk7XG4gICAgICAgIHJldHVybiBjb2x1bW4gJiYgY29sdW1uLnByb3BlcnRpZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7aW5kZXh9IHggLSBEYXRhIHggY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwcm9wZXJ0aWVzIGZvciBhIHNwZWNpZmljIGNvbHVtbi5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oeCwgcHJvcGVydGllcykge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRDb2x1bW4oeCk7XG4gICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgY29sdW1uLic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IF8oY29sdW1uLnByb3BlcnRpZXMpLmV4dGVuZE93bihwcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgY2VsbCBwcm9wZXJ0aWVzIG9mIGdpdmVuIGNvbHVtbiBvciBvZiBhbGwgY29sdW1ucy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3hdIC0gT21pdCBmb3IgYWxsIGNvbHVtbnMuXG4gICAgICovXG4gICAgY2xlYXJBbGxDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0b2RvOiBNb3JlIGVmZmljaWVudCBtaWdodCBiZSB0byB1bmRlZmluZSBgZGF0YU1vZGVsLmdldERhdGEoKikuX19NRVRBYC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmFsbENvbHVtbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENvbHVtbihpKS5jbGVhckFsbENlbGxQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRDb2x1bW4oaSk7XG4gICAgICAgICAgICBpZiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uLmNsZWFyQWxsQ2VsbFByb3BlcnRpZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7c3RyaW5nW119IEFsbCB0aGUgY3VycmVudGx5IGhpZGRlbiBjb2x1bW4gaGVhZGVyIGxhYmVscy5cbiAgICAgKi9cbiAgICBnZXRIaWRkZW5Db2x1bW5EZXNjcmlwdG9yczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5ncmlkLnByb3BlcnRpZXM7XG4gICAgICAgIHZhciBpbmRleGVzID0gdGFibGVTdGF0ZS5jb2x1bW5JbmRleGVzO1xuICAgICAgICB2YXIgbGFiZWxzID0gW107XG4gICAgICAgIHZhciBjb2x1bW5Db3VudCA9IHRoaXMuZ2V0QWN0aXZlQ29sdW1uQ291bnQoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldEFjdGl2ZUNvbHVtbihpKTtcbiAgICAgICAgICAgICAgICBsYWJlbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IGNvbHVtbi5oZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBjb2x1bW4ubmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucHJvcGVydGllcy5maXhlZENvbHVtbkNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBudW1iZXIgb2YgZml4ZWQgY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gdGhlIGludGVnZXIgY291bnQgb2YgaG93IG1hbnkgY29sdW1ucyB0byBiZSBmaXhlZFxuICAgICAqL1xuICAgIHNldEZpeGVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5ncmlkLnByb3BlcnRpZXMuZml4ZWRDb2x1bW5Db3VudCA9IG47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIHJvd3MuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKSArXG4gICAgICAgICAgICB0aGlzLmdyaWQucHJvcGVydGllcy5maXhlZFJvd0NvdW50XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIG51bWJlciBvZiBmaXhlZCByb3dzLCB3aGljaCBpbmNsdWRlcyAodG9wIHRvIGJvdHRvbSBvcmRlcik6XG4gICAgICogMS4gVGhlIGhlYWRlciByb3dzXG4gICAgICogICAgMS4gVGhlIGhlYWRlciBsYWJlbHMgcm93IChvcHRpb25hbClcbiAgICAgKiAgICAyLiBUaGUgZmlsdGVyIHJvdyAob3B0aW9uYWwpXG4gICAgICogICAgMy4gVGhlIHRvcCB0b3RhbCByb3dzICgwIG9yIG1vcmUpXG4gICAgICogMi4gVGhlIG5vbi1zY3JvbGxpbmcgcm93cyAoZXh0ZXJuYWxseSBjYWxsZWQgXCJ0aGUgZml4ZWQgcm93c1wiKVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn0gU3VtIG9mIHRoZSBhYm92ZSBvciAwIGlmIG5vbmUgb2YgdGhlIGFib3ZlIGFyZSBpbiB1c2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gVGhlIG51bWJlciBvZiByb3dzLlxuICAgICAqL1xuICAgIHNldEZpeGVkUm93Q291bnQ6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5ncmlkLnByb3BlcnRpZXMuZml4ZWRSb3dDb3VudCA9IG47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldHMgdGhlIG51bWJlciBvZiBcImhlYWRlciByb3dzXCIuXG4gICAgICogQGRlc2MgRGVmaW5lZCBhcyB0aGUgc3VtIG9mIGFsbCByb3dzIG9mIGFsbCBzdWJncmlkcyBiZWZvcmUgdGhlIChmaXJzdCkgZGF0YSBzdWJncmlkLlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuXG4gICAgICAgIHRoaXMuc3ViZ3JpZHMuZmluZChmdW5jdGlvbihzdWJncmlkKSB7XG4gICAgICAgICAgICBpZiAoIXN1YmdyaWQudHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBzdG9wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gc3ViZ3JpZC5nZXRSb3dDb3VudCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgYSBkbmQgY29sdW1uIGhhcyBqdXN0IGJlZW4gZHJvcHBlZCwgd2UndmUgYmVlbiBub3RpZmllZFxuICAgICAqL1xuICAgIGVuZERyYWdDb2x1bW5Ob3RpZmljYXRpb246IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVsbH0gdGhlIGN1cnNvciBhdCBhIHNwZWNpZmljIHgseSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ2V0Q3Vyc29yQXQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBfdmlzaWJsZV8gY29sdW1ucy5cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdG90YWwgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0QWN0aXZlQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zLmxlbmd0aDtcbiAgICB9LFxuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0Q29sdW1uQ291bnQoKScsICdnZXRBY3RpdmVDb2x1bW5Db3VudCgpJywgJzEuMC42JywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ29sdW1uIGFsaWdubWVudCBvZiBnaXZlbiBncmlkIGNvbHVtbi5cbiAgICAgKiBAZGVzYyBPbmUgb2Y6XG4gICAgICogKiBgJ2xlZnQnYFxuICAgICAqICogYCdjZW50ZXInYFxuICAgICAqICogYCdyaWdodCdgXG4gICAgICpcbiAgICAgKiBDYXNjYWRlcyB0byBncmlkLlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBRdWlldGx5IHNldCB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgbmV3IHBvc2l0aW9uIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBzZXRTY3JvbGxQb3NpdGlvblg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb25YID0geDtcbiAgICB9LFxuXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb25YOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUG9zaXRpb25YO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgUXVpZXRseSBzZXQgdGhlIHZlcnRpY2FsIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBuZXcgcG9zaXRpb24gaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHNldFNjcm9sbFBvc2l0aW9uWTogZnVuY3Rpb24oeSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvblkgPSB5O1xuICAgIH0sXG5cbiAgICBnZXRTY3JvbGxQb3NpdGlvblk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxQb3NpdGlvblk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtjZWxsRWRpdG9yfSBUaGUgY2VsbCBlZGl0b3IgZm9yIHRoZSBjZWxsIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge0NlbGxFdmVudH0gZWRpdFBvaW50IC0gVGhlIGdyaWQgY2VsbCBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5pc0dyaWRDb2x1bW4gJiYgKFxuICAgICAgICAgICAgZXZlbnQuaXNGaWx0ZXJDZWxsXG4gICAgICAgICAgICAgICAgPyB0aGlzLmdyaWQuY2VsbEVkaXRvcnMuY3JlYXRlKCdmaWx0ZXJib3gnLCBldmVudClcbiAgICAgICAgICAgICAgICA6IGV2ZW50LmNvbHVtbi5nZXRDZWxsRWRpdG9yQXQoZXZlbnQpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgd2Ugc2hvdWxkIGhpZ2hsaWdodCBvbiBob3ZlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNDb2x1bW5Ib3ZlcmVkIC0gdGhlIGNvbHVtbiBpcyBob3ZlcmVkIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSb3dIb3ZlcmVkIC0gdGhlIHJvdyBpcyBob3ZlcmVkIG9yIG5vdFxuICAgICAqL1xuICAgIGhpZ2hsaWdodENlbGxPbkhvdmVyOiBmdW5jdGlvbihpc0NvbHVtbkhvdmVyZWQsIGlzUm93SG92ZXJlZCkge1xuICAgICAgICByZXR1cm4gaXNDb2x1bW5Ib3ZlcmVkICYmIGlzUm93SG92ZXJlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgYSBob29rIGFuZCBpcyBjYWxsZWQganVzdCBiZWZvcmUgdGhlIHBhaW50aW5nIG9mIGEgY2VsbCBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXIuUG9pbnR9IGNlbGxcbiAgICAgKi9cbiAgICBjZWxsUHJvcGVydGllc1ByZVBhaW50Tm90aWZpY2F0aW9uOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgYSBob29rIGFuZCBpcyBjYWxsZWQganVzdCBiZWZvcmUgdGhlIHBhaW50aW5nIG9mIGEgZml4ZWQgcm93IGNlbGwgb2NjdXJzXG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbEZpeGVkUm93UHJlUGFpbnROb3RpZmljYXRpb246IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyBhIGhvb2sgYW5kIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFpbnRpbmcgb2YgYSBmaXhlZCBjb2x1bW4gY2VsbCBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXIuUG9pbnR9IGNlbGxcbiAgICAgKi9cbiAgICBjZWxsRml4ZWRDb2x1bW5QcmVQYWludE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIHRvcCBsZWZ0IGNlbGwgb2NjdXJzXG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbFRvcExlZnRQcmVQYWludE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGVuaGFuY2UgdGhlIGRvdWJsZSBjbGljayBldmVudCBqdXN0IGJlZm9yZSBpdCdzIGJyb2FkY2FzdCB0byBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBldmVudCB0byBlbmhhbmNlXG4gICAgICovXG4gICAgZW5oYW5jZURvdWJsZUNsaWNrRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzd2FwIHNyYyBhbmQgdGFyIGNvbHVtbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjIC0gY29sdW1uIGluZGV4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhciAtIGNvbHVtbiBpbmRleFxuICAgICAqL1xuICAgIHN3YXBDb2x1bW5zOiBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCkge1xuICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMuY29sdW1ucztcbiAgICAgICAgdmFyIHRtcCA9IGNvbHVtbnNbc291cmNlXTtcbiAgICAgICAgY29sdW1uc1tzb3VyY2VdID0gY29sdW1uc1t0YXJnZXRdO1xuICAgICAgICBjb2x1bW5zW3RhcmdldF0gPSB0bXA7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5FZGdlOiBmdW5jdGlvbihjLCByZW5kZXJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0Q29sdW1uRWRnZShjLCByZW5kZXJlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBvYmplY3QgYXQgeSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSByb3cgaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFJvdyh5KTtcbiAgICB9LFxuXG4gICAgY29udmVydFZpZXdQb2ludFRvRGF0YVBvaW50OiBmdW5jdGlvbih1bnNjcm9sbGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICB0aGlzLmdldEFjdGl2ZUNvbHVtbih1bnNjcm9sbGVkLngpLmluZGV4LFxuICAgICAgICAgICAgdW5zY3JvbGxlZC55XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uTWF0cml4RnVuY3Rpb246IGZ1bmN0aW9uKHNlbGVjdGVkUm93cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXV0b3NpemVBbGxDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jaGVja0NvbHVtbkF1dG9zaXppbmcodHJ1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBjaGVja0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIGZvcmNlID0gZm9yY2UgPT09IHRydWU7XG4gICAgICAgIHRoaXMuYXV0b1NpemVSb3dOdW1iZXJDb2x1bW4oKTtcbiAgICAgICAgdmFyIGF1dG9TaXplZCA9IHRoaXMuYWxsQ29sdW1uc1stMl0uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKGZvcmNlKTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICBhdXRvU2l6ZWQgPSBjb2x1bW4uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKGZvcmNlKSB8fCBhdXRvU2l6ZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXV0b1NpemVkO1xuICAgIH0sXG5cbiAgICBhdXRvU2l6ZVJvd051bWJlckNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuaXNSb3dOdW1iZXJBdXRvc2l6aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsQ29sdW1uc1stMV0uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IF9HZXR0ZXJfXG4gICAgICogQG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtkYXRhU291cmNlSGVscGVyQVBJfSBUaGUgZ3JpZCdzIGN1cnJlbnRseSBhc3NpZ25lZCBmaWx0ZXIuXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCBmaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5maWx0ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IF9TZXR0ZXI6XyBBc3NpZ24gYSBmaWx0ZXIgdG8gdGhlIGdyaWQuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7ZGF0YVNvdXJjZUhlbHBlckFQSXx1bmRlZmluZWR8bnVsbH0gZmlsdGVyIC0gT25lIG9mOlxuICAgICAqICogQSBmaWx0ZXIgb2JqZWN0LCB0dXJuaW5nIGZpbHRlciAqT04qLlxuICAgICAqICogSWYgYHVuZGVmaW5lZGAgb3IgYG51bGxgLCB0aGUgbnVsbCBmaWx0ZXIgaXMgcmVhc3NpZ25lZCB0byB0aGUgZ3JpZCwgdHVybmluZyBmaWx0ZXJpbmcgKk9GRiouXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBmaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLmZpbHRlciA9IGZpbHRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgX0dldHRlcl9cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHJldHVybnMge3NvcnRlckFQSX0gVGhlIGdyaWQncyBjdXJyZW50bHkgYXNzaWduZWQgc29ydGVyLlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IHNvcnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLnNvcnRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgX1NldHRlcjpfIEFzc2lnbiBhIHNvcnRlciB0byB0aGUgZ3JpZC5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtzb3J0ZXJBUEl8dW5kZWZpbmVkfG51bGx9IHNvcnRlciAtIE9uZSBvZjpcbiAgICAgKiAqIEEgc29ydGVyIG9iamVjdCwgdHVybmluZyBzb3J0aW5nICpPTiouXG4gICAgICogKiBJZiBgdW5kZWZpbmVkYCBvciBgbnVsbGAsIHRoZSB7QGxpbmsgZGF0YU1vZGVscy5KU09Ofm51bGxTb3J0ZXJ8bnVsbFNvcnRlcn0gaXMgcmVhc3NpZ25lZCB0byB0aGUgZ3JpZCwgdHVybmluZyBzb3J0aW5nICpPRkYuKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IHNvcnRlcihzb3J0ZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc29ydGVyID0gc29ydGVyO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkUm93cygpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIGdldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0RGF0YSgpO1xuICAgIH0sXG5cbiAgICBnZXRGaWx0ZXJlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRJbmRleGVkRGF0YSgpJywgJ2dldEluZGV4ZWREYXRhJywgJzEuMi4wJywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGdldEluZGV4ZWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICB0aGlzLmRhdGFNb2RlbC5nZXRJbmRleGVkRGF0YSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSB3aGVyZSBlYWNoIGVsZW1lbnQgcmVwcmVzZW50cyBhIHN1YmdyaWQgdG8gYmUgcmVuZGVyZWQgaW4gdGhlIGh5cGVyZ3JpZC5cbiAgICAgKlxuICAgICAqIFRoZSBsaXN0IHNob3VsZCBhbHdheXMgaW5jbHVkZSBhdCBsZWFzdCBvbmUgXCJkYXRhXCIgc3ViZ3JpZCwgdHlwaWNhbGx5IHtAbGluayBCZWhhdmlvciNkYXRhTW9kZWx8ZGF0YU1vZGVsfS5cbiAgICAgKiBJdCBtYXkgYWxzbyBpbmNsdWRlIHplcm8gb3IgbW9yZSBvdGhlciB0eXBlcyBvZiBzdWJncmlkcyBzdWNoIGFzIGhlYWRlciwgZmlsdGVyLCBhbmQgc3VtbWFyeSBzdWJncmlkcy5cbiAgICAgKlxuICAgICAqIFRoaXMgb2JqZWN0IGFsc28gc2VydmVzIGFzIGEgZGljdGlvbmFyeSBvZiBzZWxlY3RlZCBzdWJncmlkcyBieSBuYW1lIChpLmUuLCBmb3IgdGhvc2Ugc3ViZ3JpZHMgdGhhdCBoYXZlIGEgZGVmaW5lZCBwcm9wZXJ0eSBgbmFtZWApLlxuICAgICAqXG4gICAgICogVGhlIHNldHRlcjpcbiAgICAgKiAqIFwiRW5saXZlbnNcIiBhbnkgY29uc3RydWN0b3JzXG4gICAgICogKiBSZWNvbnN0cnVjdHMgdGhlIGRpY3Rpb25hcnlcbiAgICAgKiAqIENhbGxzIHtAbGluayBCZWhhdmlvciNzaGFwZUNoYW5nZWR8c2hwYWVDaGFuZ2VkKCl9LlxuICAgICAqXG4gICAgICogQHR5cGUge0RhdGFNb2RlbFtdfVxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXQgc3ViZ3JpZHMoc3ViZ3JpZHMpIHtcbiAgICAgICAgdGhpcy5fc3ViZ3JpZHMgPSBzdWJncmlkcyA9IHN1YmdyaWRzLm1hcChlbmxpdmVuU3ViZ3JpZHMsIHRoaXMpO1xuXG4gICAgICAgIHN1YmdyaWRzLmZvckVhY2goZnVuY3Rpb24oc3ViZ3JpZCkge1xuICAgICAgICAgICAgc3ViZ3JpZHNbc3ViZ3JpZC5uYW1lIHx8IHN1YmdyaWQudHlwZSB8fCAnZGF0YSddID0gc3ViZ3JpZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zaGFwZUNoYW5nZWQoKTtcbiAgICB9LFxuICAgIGdldCBzdWJncmlkcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YmdyaWRzO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0RhdGFNb2RlbHxBcnJheXxmdW5jdGlvbnx1bmRlZmluZWR8bnVsbH0gW3N1YmdyaWRTcGVjXSAtIE9uZSBvZjpcbiAqICogYERhdGFNb2RlbGAgLSBNYXBwZWQgdG8gc2VsZiAocGFzc2VkIHRocm91Z2ggYXMgaXMpLlxuICogKiBgQXJyYXlgIC0gTWFwcGVkIHRvIG5ld2x5IGluc3RhbnRpYXRlZCBkYXRhIG1vZGVsOiBGaXJzdCBlbGVtZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBgRGF0YU1vZGVsYCBjb25zdHJ1Y3RvciB0byBiZSBjYWxsZWQgd2l0aCBgbmV3YCBrZXl3b3JkIGFuZCBgdGhpcy5ncmlkYCBhcyBmaXJzdCBhcmcgYW5kIHJlbWFpbmluZyBlbGVtZW50cyBhcyBhZGRpdGlvbmFsIGFyZ3MuXG4gKiAqIGZ1bmN0aW9uIC0gTWFwcGVkIHRvIG5ld2x5IGluc3RhbnRpYXRlZCBkYXRhIG1vZGVsOiBBIGBEYXRhTW9kZWxgIGNvbnN0cnVjdG9yIHRvIGJlIGNhbGxlZCB3aXRoIGBuZXdgIGtleXdvcmQgYW5kIGB0aGlzLmdyaWRgIGFzIG9ubHkgYXJnLlxuICogKiBGYWxzeSB2YWx1ZSAtIE1hcHBlZCB0byB0aGUgYmVoYXZpb3IncyBkYXRhIG1vZGVsIChgdGhpcy5kYXRhTW9kZWxgKS5cbiAqIEByZXR1cm5zIHtEYXRhTW9kZWx9XG4gKi9cbmZ1bmN0aW9uIGVubGl2ZW5TdWJncmlkcyhkYXRhTW9kZWwpIHtcbiAgICBpZiAoIWRhdGFNb2RlbCkge1xuICAgICAgICBkYXRhTW9kZWwgPSB0aGlzLmRhdGFNb2RlbDtcbiAgICB9IGVsc2UgaWYgKGRhdGFNb2RlbCBpbnN0YW5jZW9mIEFycmF5ICYmIGRhdGFNb2RlbC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gZGF0YU1vZGVsWzBdLFxuICAgICAgICAgICAgYXJncyA9IGRhdGFNb2RlbC5zbGljZSgxKTtcbiAgICAgICAgZGF0YU1vZGVsID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShDb25zdHJ1Y3RvciwgW251bGwsIHRoaXMuZ3JpZF0uY29uY2F0KGFyZ3MpKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YU1vZGVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRhdGFNb2RlbCA9IG5ldyBkYXRhTW9kZWwodGhpcy5ncmlkKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgfVxuICAgIHJldHVybiBkYXRhTW9kZWw7XG59XG5cbi8qKlxuICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICovXG5CZWhhdmlvci5wcm90b3R5cGUucmVpbmRleCA9IEJlaGF2aW9yLnByb3RvdHlwZS5hcHBseUFuYWx5dGljcztcblxubW9kdWxlLmV4cG9ydHMgPSBCZWhhdmlvcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBvdmVycmlkZXIgPSByZXF1aXJlKCdvdmVycmlkZXInKTtcblxudmFyIGRlcHJlY2F0ZWQgPSByZXF1aXJlKCcuLi9saWIvZGVwcmVjYXRlZCcpO1xudmFyIEh5cGVyZ3JpZEVycm9yID0gcmVxdWlyZSgnLi4vbGliL2Vycm9yJyk7XG5cbnZhciB3YXJuZWQgPSB7fTtcblxuLyoqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBgQ29sdW1uYCBvYmplY3QuXG4gKiBAc2VlIHtAbGluayBtb2R1bGU6Q2VsbH0gaXMgbWl4ZWQgaW50byBDb2x1bW4ucHJvdG90eXBlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gYmVoYXZpb3JcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xvYmplY3R9IGluZGV4T3JPcHRpb25zIC0gT25lIG9mOlxuICogKiBJZiBhIHBvc2l0aXZlIG51bWJlciwgdmFsaWQgaW5kZXggaW50byBgZmllbGRzYCBhcnJheS5cbiAqICogSWYgYSBzdHJpbmcsIGEgbmFtZSBpbiB0aGUgYGZpZWxkc2AgYXJyYXkuXG4gKiAqIElmIGFuIG9iamVjdCwgbXVzdCBjb250YWluIGVpdGhlciBhbiBgaW5kZXhgIG9yIGEgYG5hbWVgIHByb3BlcnR5LlxuICpcbiAqIFBvc2l0aXZlIHZhbHVlcyBvZiBgaW5kZXhgIGFyZSBcInJlYWxcIiBmaWVsZHM7IHNlZSBhbHNvIHtAbGluayBDb2x1bW4jc2V0UHJvcGVydGllc3xzZXRQcm9wZXJ0aWVzfSB3aGljaCBpcyBjYWxsZWQgdG8gc2V0IHRoZSByZW1haW5pbmcgcHJvcGVydGllcyBzcGVjaWZpZWQgaW4gYG9wdGlvbnNgLlxuICpcbiAqIE5lZ2F0aXZlIHZhbHVlcyBvZiBgaW5kZXhgIGFyZSBzcGVjaWFsIGNhc2VzOlxuICogYGluZGV4YCB8IE1lYW5pbmdcbiAqIDotLS0tLTogfCAtLS0tLS0tLVxuICogICAgLTEgICB8IFJvdyBoZWFkZXIgY29sdW1uXG4gKiAgICAtMiAgIHwgVHJlZSAoZHJpbGwtZG93bikgY29sdW1uXG4gKi9cbmZ1bmN0aW9uIENvbHVtbihiZWhhdmlvciwgb3B0aW9ucykge1xuICAgIHZhciBpbmRleCwgc2NoZW1hO1xuXG4gICAgdGhpcy5iZWhhdmlvciA9IGJlaGF2aW9yO1xuICAgIHRoaXMuZGF0YU1vZGVsID0gYmVoYXZpb3IuZGF0YU1vZGVsO1xuXG4gICAgc2NoZW1hID0gdGhpcy5iZWhhdmlvci5kYXRhTW9kZWwuc2NoZW1hO1xuXG4gICAgc3dpdGNoICh0eXBlb2Ygb3B0aW9ucykge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgaW5kZXggPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICBpbmRleCA9IGdldEluZGV4RnJvbU5hbWUob3B0aW9ucyk7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGluZGV4ID0gb3B0aW9ucy5pbmRleCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmluZGV4XG4gICAgICAgICAgICAgICAgOiBnZXRJbmRleEZyb21OYW1lKG9wdGlvbnMubmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXhGcm9tTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZmluZEluZGV4KGZ1bmN0aW9uKGNvbHVtblNjaGVtYSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtblNjaGVtYS5uYW1lID09PSBuYW1lO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyAnQ29sdW1uIG5vdCBmb3VuZCBpbiBkYXRhLic7XG4gICAgfVxuXG4gICAgdGhpcy5faW5kZXggPSBpbmRleDtcblxuICAgIHRoaXMuY2xlYXJBbGxDZWxsUHJvcGVydGllcygpO1xuXG4gICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIC0yOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ2BpbmRleGAgb3V0IG9mIHJhbmdlJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gb3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5cbkNvbHVtbi5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbHVtbi5wcm90b3R5cGUuY29uc3RydWN0b3IsXG5cbiAgICBIeXBlcmdyaWRFcnJvcjogSHlwZXJncmlkRXJyb3IsXG5cbiAgICBtaXhJbjogb3ZlcnJpZGVyLm1peEluLFxuXG4gICAgZGVwcmVjYXRlZDogZGVwcmVjYXRlZCxcbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnc2V0KG9wdGlvbnMpJywgJ3NldFByb3BlcnRpZXMob3B0aW9ucyknLCAnMS4yLjAnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbmRleCBvZiB0aGlzIGNvbHVtbiBpbiB0aGUgYGZpZWxkc2AgYXJyYXkuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgaW5kZXgoKSB7IC8vIHJlYWQtb25seSAobm8gc2V0dGVyKVxuICAgICAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IE5hbWUgb2YgdGhpcyBjb2x1bW4gZnJvbSB0aGUgYGZpZWxkc2AgYXJyYXkuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHsgLy8gcmVhZC1vbmx5IChubyBzZXR0ZXIpXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5zY2hlbWFbdGhpcy5faW5kZXhdLm5hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCBvciBzZXQgdGhlIHRleHQgb2YgdGhlIGNvbHVtbidzIGhlYWRlci5cbiAgICAgKiBAZGVzYyBUaGUgX2hlYWRlcl8gaXMgdGhlIGxhYmVsIGF0IHRoZSB0b3Agb2YgdGhlIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhlIGhlYWRlciB1cGRhdGVzIGJvdGg6XG4gICAgICogKiB0aGUgYGZpZWxkc2AgKGFrYSwgaGVhZGVyKSBhcnJheSBpbiB0aGUgdW5kZXJseWluZyBkYXRhIHNvdXJjZTsgYW5kXG4gICAgICogKiB0aGUgZmlsdGVyLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgc2V0IGhlYWRlcihoZWFkZXJUZXh0KSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsLnNjaGVtYVt0aGlzLmluZGV4XS5oZWFkZXIgPSBoZWFkZXJUZXh0O1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmZpbHRlci5wcm9wKHRoaXMuaW5kZXgsICdoZWFkZXInLCBoZWFkZXJUZXh0KTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5ncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuICAgIGdldCBoZWFkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5zY2hlbWFbdGhpcy5pbmRleF0uaGVhZGVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgb3Igc2V0IHRoZSBjb21wdXRlZCBjb2x1bW4ncyBjYWxjdWxhdG9yIGZ1bmN0aW9uLlxuICAgICAqIEBkZXNjIFNldHRpbmcgdGhlIHZhbHVlIGhlcmUgdXBkYXRlcyB0aGUgY2FsY3VsYXRvciBpbiBib3RoOlxuICAgICAqICogdGhlIGBjYWxjdWxhdG9yYCBhcnJheSBpbiB0aGUgdW5kZXJseWluZyBkYXRhIHNvdXJjZTsgYW5kXG4gICAgICogKiB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogVGhlIHJlc3VsdHMgb2YgdGhlIG5ldyBjYWxjdWxhdGlvbnMgd2lsbCBhcHBlYXIgaW4gdGhlIGNvbHVtbiBjZWxscyBvbiB0aGUgbmV4dCByZXBhaW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgc2V0IGNhbGN1bGF0b3IoY2FsY3VsYXRvcikge1xuICAgICAgICB2YXIgc2NoZW1hID0gdGhpcy5kYXRhTW9kZWwuc2NoZW1hO1xuICAgICAgICBpZiAoY2FsY3VsYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgc2NoZW1hW3RoaXMuaW5kZXhdLmNhbGN1bGF0b3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2hlbWFbdGhpcy5pbmRleF0uY2FsY3VsYXRvciA9IGNhbGN1bGF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZWhhdmlvci5maWx0ZXIucHJvcCh0aGlzLmluZGV4LCAnY2FsY3VsYXRvcicsIGNhbGN1bGF0b3IpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcbiAgICBnZXQgY2FsY3VsYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLnNjaGVtYVt0aGlzLmluZGV4XS5jYWxjdWxhdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBHZXQgb3Igc2V0IHRoZSB0eXBlIG9mIHRoZSBjb2x1bW4ncyBoZWFkZXIuXG4gICAgICogQGRlc2MgU2V0dGluZyB0aGUgdHlwZSB1cGRhdGVzIHRoZSBmaWx0ZXIgd2hpY2ggdHlwaWNhbGx5IHVzZXMgdGhpcyBpbmZvcm1hdGlvbiBmb3IgcHJvcGVyIGNvbGxhdGlvbi5cbiAgICAgKlxuICAgICAqIEB0b2RvOiBJbnN0ZWFkIG9mIHVzaW5nIGB0aGlzLl90eXBlYCwgcHV0IG9uIGRhdGEgc291cmNlIGxpa2UgdGhlIG90aGVyIGVzc2VudGlhbCBwcm9wZXJ0aWVzLiBJbiB0aGlzIGNhc2UsIHNvcnRlciBjb3VsZCB1c2UgdGhlIGluZm8gdG8gY2hvb3NlIGEgY29tcGFyYXRvciBtb3JlIGludGVsbGlnZW50bHkgYW5kIGVmZmljaWVudGx5LlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgc2V0IHR5cGUodHlwZSkge1xuICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICAgICAgLy9UT0RPOiBUaGlzIGlzIGNhbGxpbmcgcmVpbmRleCBmb3IgZXZlcnkgY29sdW1uIGR1cmluZyBncmlkIGluaXQuIE1heWJlIGRlZmVyIGFsbCByZWluZGV4IGNhbGxzIHVudGlsIGFmdGVyIGFuIGdyaWQgJ3JlYWR5JyBldmVudFxuICAgICAgICB0aGlzLmJlaGF2aW9yLmZpbHRlci5wcm9wKHRoaXMuaW5kZXgsICd0eXBlJywgdHlwZSk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc29ydGVyLnByb3AodGhpcy5pbmRleCwgJ3R5cGUnLCB0eXBlKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5yZWluZGV4KCk7XG4gICAgfSxcbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfSxcblxuICAgIGdldFVuZmlsdGVyZWRWYWx1ZTogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRVbmZpbHRlcmVkVmFsdWUoeSknLCBudWxsLCAnMS4yLjAnLCBhcmd1bWVudHMsICdObyBsb25nZXIgc3VwcG9ydGVkJyk7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRWYWx1ZSh0aGlzLmluZGV4LCB5KTtcbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5zZXRWYWx1ZSh0aGlzLmluZGV4LCB5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcyAmJiB0aGlzLnByb3BlcnRpZXMud2lkdGggfHwgdGhpcy5iZWhhdmlvci5ncmlkLnByb3BlcnRpZXMuZGVmYXVsdENvbHVtbldpZHRoO1xuICAgIH0sXG5cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLndpZHRoID0gTWF0aC5tYXgoNSwgd2lkdGgpO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsUmVuZGVyZXI6IGZ1bmN0aW9uKGNvbmZpZywgY2VsbEV2ZW50KSB7XG4gICAgICAgIGNvbmZpZy51bnRyYW5zbGF0ZWRYID0gY2VsbEV2ZW50LmdyaWRDZWxsLng7XG4gICAgICAgIGNvbmZpZy55ID0gY2VsbEV2ZW50LmdyaWRDZWxsLnk7XG5cbiAgICAgICAgY29uZmlnLnggPSB0aGlzLmluZGV4O1xuICAgICAgICBjb25maWcubm9ybWFsaXplZFkgPSBjZWxsRXZlbnQuZGF0YUNlbGwueTtcblxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0Q2VsbChjb25maWcsIGNlbGxFdmVudC5nZXRDZWxsUHJvcGVydHkoJ3JlbmRlcmVyJykpO1xuICAgIH0sXG5cbiAgICBjaGVja0NvbHVtbkF1dG9zaXppbmc6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICB2YXIgYSwgYiwgZCwgYXV0b1NpemVkO1xuICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgYSA9IHByb3BlcnRpZXMud2lkdGg7XG4gICAgICAgICAgICBiID0gcHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCB8fCBhO1xuICAgICAgICAgICAgZCA9IHByb3BlcnRpZXMuY29sdW1uQXV0b3NpemVkICYmICFmb3JjZTtcbiAgICAgICAgICAgIGlmIChhICE9PSBiIHx8ICFkKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy53aWR0aCA9ICFkID8gYiA6IE1hdGgubWF4KGEsIGIpO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuY29sdW1uQXV0b3NpemVkID0gIWlzTmFOKHByb3BlcnRpZXMud2lkdGgpO1xuICAgICAgICAgICAgICAgIGF1dG9TaXplZCA9IHByb3BlcnRpZXMud2lkdGggIT09IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dG9TaXplZDtcbiAgICB9LFxuXG4gICAgZ2V0Q2VsbFR5cGU6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSh5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZU9mKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgdmFyIHR5cGUgPSBwcm9wcy50eXBlO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLmNvbXB1dGVDb2x1bW5UeXBlKCk7XG4gICAgICAgICAgICBpZiAodHlwZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfSxcblxuICAgIGNvbXB1dGVDb2x1bW5UeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5iZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5iZWhhdmlvci5nZXRSb3dDb3VudCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKGhlYWRlclJvd0NvdW50KTtcbiAgICAgICAgdmFyIGVhY2hUeXBlID0gdGhpcy50eXBlT2YodmFsdWUpO1xuICAgICAgICBpZiAoIWVhY2hUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlT2YodmFsdWUpO1xuICAgICAgICAvL3ZhciBpc051bWJlciA9ICgodHlwZW9mIHZhbHVlKSA9PT0gJ251bWJlcicpO1xuICAgICAgICBmb3IgKHZhciB5ID0gaGVhZGVyUm93Q291bnQ7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldFZhbHVlKHkpO1xuICAgICAgICAgICAgZWFjaFR5cGUgPSB0aGlzLnR5cGVPZih2YWx1ZSk7XG4gICAgICAgICAgICAvLyBpZiAodHlwZSAhPT0gZWFjaFR5cGUpIHtcbiAgICAgICAgICAgIC8vICAgICBpZiAoaXNOdW1iZXIgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIHR5cGUgPSAnZmxvYXQnO1xuICAgICAgICAgICAgLy8gICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgICAgIHJldHVybiAnbWl4ZWQnO1xuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9LFxuXG4gICAgdHlwZU9mOiBmdW5jdGlvbihzb21ldGhpbmcpIHtcbiAgICAgICAgaWYgKHNvbWV0aGluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZU9mID0gdHlwZW9mIHNvbWV0aGluZztcbiAgICAgICAgc3dpdGNoICh0eXBlT2YpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvbWV0aGluZy5jb25zdHJ1Y3Rvci5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzb21ldGhpbmcpID09PSBzb21ldGhpbmcgPyAnaW50JyA6ICdmbG9hdCc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlT2Y7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5iZWhhdmlvci5ncmlkLnByb3BlcnRpZXMsXG4gICAgICAgICAgICByZXN1bHQgPSB0YWJsZVN0YXRlLmNvbHVtblByb3BlcnRpZXNbdGhpcy5pbmRleF07XG5cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRhYmxlU3RhdGUuY29sdW1uUHJvcGVydGllc1t0aGlzLmluZGV4XSA9IHRoaXMuY3JlYXRlQ29sdW1uUHJvcGVydGllcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHNldCBwcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIGtleSwgZGVzY3JpcHRvciwgb2JqID0gdGhpcy5wcm9wZXJ0aWVzO1xuXG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICAgICAgaWYgKCFkZXNjcmlwdG9yIHx8IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICBnZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0UHJvcGVydGllcygpJywgJ3Byb3BlcnRpZXMnLCAnMS4yLjAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVzZXJ2ZT1mYWxzZV1cbiAgICAgKi9cbiAgICBzZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbihwcm9wZXJ0aWVzLCBwcmVzZXJ2ZSkge1xuICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgICBpZiAoIXdhcm5lZC5zZXRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgd2FybmVkLnNldFByb3BlcnRpZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIHByb3BlcnRpZXMgKHNldHRlcikgYXMgb2YgdjEuMi4wIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gVGhpcyBhZHZpY2Ugb25seSBwZXJ0YWlucyB0byB1c2FnZXMgb2Ygc2V0UHJvcGVydGllcyB3aGVuIGNhbGxlZCB3aXRoIGEgc2luZ2xlIHBhcmFtZXRlci4gV2hlbiBjYWxsZWQgd2l0aCBhIHRydXRoeSBzZWNvbmQgcGFyYW1ldGVyLCB1c2UgdGhlIG5ldyBhZGRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIGNhbGwgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ3NldFByb3BlcnRpZXMocHJvcGVydGllcywgcHJlc2VydmUpJywgJ2FkZFByb3BlcnRpZXMocHJvcGVydGllcyknLCAnMS4yLjAnLCBhcmd1bWVudHMsICdUaGlzIHdhcm5pbmcgcGVydGFpbnMgdG8gc2V0UHJvcGVydGllcyBvbmx5IHdoZW4gcHJlc2VydmUgaXMgdHJ1dGh5LiBXaGVuIHByZXNlcnZlIGlzIGZhdWx0eSwgdXNlIHRoZSBuZXcgcHJvcGVydGllcyBzZXR0ZXIuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkUHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICB2YXIga2V5LCBkZXNjcmlwdG9yLCBvYmogPSB0aGlzLnByb3BlcnRpZXM7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICAgICAgaWYgKCFkZXNjcmlwdG9yIHx8IGRlc2NyaXB0b3Iud3JpdGFibGUgfHwgZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBkZXRlcm1pbmVzIHRoZSBwcm9wb3NlZCBjZWxsIGVkaXRvciBuYW1lIGZyb20gdGhlIHJlbmRlciBwcm9wZXJ0aWVzLiBUaGUgYWxnb3JpdGhtIGlzOlxuICAgICAqIDEuIGBlZGl0b3JgIHJlbmRlciBwcm9wZXJ0eSAoY2VsbCBlZGl0b3IgbmFtZSlcbiAgICAgKiAyLiBgZm9ybWF0YCByZW5kZXIgcHJvcGVydHkgKGxvY2FsaXplciBuYW1lKVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IFwicmVuZGVyIHByb3BlcnR5XCIgbWVhbnMgaW4gZWFjaCBjYXNlIHRoZSBmaXJzdCBkZWZpbmVkIHByb3BlcnR5IGZvdW5kIG9uIHRoZSBjZWxsLCBjb2x1bW4sIG9yIGdyaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBncmlkIHJvdyBpbmRleC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFdpbGwgYmUgZGVjb3JhdGVkIHdpdGggYGZvcm1hdGAgYW5kIGBjb2x1bW5gLlxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBvcHRpb25zLmVkaXRQb2ludFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Q2VsbEVkaXRvcn0gRmFsc3kgdmFsdWUgbWVhbnMgZWl0aGVyIG5vIGRlY2xhcmVkIGNlbGwgZWRpdG9yIF9vcl8gaW5zdGFudGlhdGlvbiBhYm9ydGVkIGJ5IGZhbHN5IHJldHVybiByZXR1cm4gZnJvbSBmaXJlUmVxdWVzdENlbGxFZGl0LlxuICAgICAqL1xuICAgIGdldENlbGxFZGl0b3JBdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGNvbHVtbkluZGV4ID0gdGhpcy5pbmRleCxcbiAgICAgICAgICAgIHJvd0luZGV4ID0gZXZlbnQuZ3JpZENlbGwueSxcbiAgICAgICAgICAgIGVkaXRvck5hbWUgPSBldmVudC5nZXRDZWxsUHJvcGVydHkoJ2VkaXRvcicpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGV2ZW50LCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBvcHRpb25zLmZvbXJhdGAgaXMgYSBjb3B5IG9mIHRoZSBjZWxsJ3MgYGZvcm1hdGAgcHJvcGVydHkgd2hpY2ggaXM6XG4gICAgICAgICAgICAgICAgICAgIC8vIDEuIFN1YmplY3QgdG8gYWRqdXN0bWVudCBieSB0aGUgYGdldENlbGxFZGl0b3JBdGAgb3ZlcnJpZGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIDIuIFRoZW4gdXNlZCBieSB0aGUgY2VsbCBlZGl0b3IgdG8gcmVmZXJlbmNlIHRoZSBwcmVkZWZpbmVkIGxvY2FsaXplci5cbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBldmVudC5nZXRDZWxsUHJvcGVydHkoJ2Zvcm1hdCcpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlZGl0UG9pbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2FybmVkLmVkaXRQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5lZC5lZGl0UG9pbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGhlIC5lZGl0UG9pbnQgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2MS4yLjAgaW4gZmF2b3Igb2YgLmdyaWRDZWxsLiBJdCBtYXkgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZENlbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNlbGxFZGl0b3IgPSB0aGlzLmRhdGFNb2RlbC5nZXRDZWxsRWRpdG9yQXQoY29sdW1uSW5kZXgsIHJvd0luZGV4LCBlZGl0b3JOYW1lLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoY2VsbEVkaXRvciAmJiAhY2VsbEVkaXRvci5ncmlkKSB7XG4gICAgICAgICAgICAvLyBjZWxsIGVkaXRvciByZXR1cm5lZCBidXQgbm90IGZ1bGx5IGluc3RhbnRpYXRlZCAoYWJvcnRlZCBieSBmYWxzeSByZXR1cm4gZnJvbSBmaXJlUmVxdWVzdENlbGxFZGl0KVxuICAgICAgICAgICAgY2VsbEVkaXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsRWRpdG9yO1xuICAgIH0sXG5cbiAgICBnZXRGb3JtYXR0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbG9jYWxpemVyTmFtZSA9IHRoaXMucHJvcGVydGllcy5mb3JtYXQ7XG4gICAgICAgIHJldHVybiB0aGlzLmJlaGF2aW9yLmdyaWQubG9jYWxpemF0aW9uLmdldChsb2NhbGl6ZXJOYW1lKS5mb3JtYXQ7XG4gICAgfVxufTtcblxuQ29sdW1uLnByb3RvdHlwZS5taXhJbihyZXF1aXJlKCcuL2NlbGxQcm9wZXJ0aWVzJykpO1xuQ29sdW1uLnByb3RvdHlwZS5taXhJbihyZXF1aXJlKCcuL2NvbHVtblByb3BlcnRpZXMnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmVoYXZpb3IgPSByZXF1aXJlKCcuL0JlaGF2aW9yJyk7XG52YXIgRGF0YU1vZGVsSlNPTiA9IHJlcXVpcmUoJy4uL2RhdGFNb2RlbHMvSlNPTicpO1xudmFyIGZlYXR1cmVzID0gcmVxdWlyZSgnLi4vZmVhdHVyZXMnKTtcblxudmFyIFJFR0VYX0NBTUVMX0NBU0UgPSAvKFteX0EtWl0pKFtBLVpdKykvZzsgLy8gYWxsIGluc3RhbmNlcyBvZiB4WCBvciBfWCB3aXRoaW4gYSBcIndvcmRcIlxuXG4vKipcbiAqIEBuYW1lIGJlaGF2aW9ycy5KU09OXG4gKiBAZGVzYyA+IFNhbWUgcGFyYW1ldGVycyBhcyB7QGxpbmsgYmVoYXZpb3JzLkJlaGF2aW9yI2luaXRpYWxpemV8aW5pdGlhbGl6ZX0sIHdoaWNoIGlzIGNhbGxlZCBieSB0aGlzIGNvbnN0cnVjdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBCZWhhdmlvclxuICovXG52YXIgSlNPTiA9IEJlaGF2aW9yLmV4dGVuZCgnYmVoYXZpb3JzLkpTT04nLCB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb25zdHJ1Y3RvciBsb2dpYywgY2FsbGVkIF9hZnRlcl97QGxpbmsgQmVoYXZpb3IjaW5pdGlhbGl6ZXxCZWhhdmlvci5pbml0aWFsaXplKCl9LlxuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHVwb24gaW5zdGFudGlhdGlvbiBvZiB0aGlzIGNsYXNzIG9yIG9mIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgZnJvbSB0aGlzIGNsYXNzLlxuICAgICAqID4gQWxsIGBpbml0aWFsaXplKClgIG1ldGhvZHMgaW4gdGhlIGluaGVyaXRhbmNlIGNoYWluIGFyZSBjYWxsZWQsIGluIHR1cm4sIGVhY2ggd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBiZWdpbm5pbmcgd2l0aCB0aGF0IG9mIHRoZSBtb3N0IFwic2VuaW9yXCIgY2xhc3MgdGhyb3VnaCB0aGF0IG9mIHRoZSBjbGFzcyBvZiB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZXREYXRhKG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5waXBlbGluZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRQaXBlbGluZShvcHRpb25zLnBpcGVsaW5lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmZWF0dXJlczogW1xuICAgICAgICBmZWF0dXJlcy5DZWxsU2VsZWN0aW9uLFxuICAgICAgICBmZWF0dXJlcy5LZXlQYWdpbmcsXG4gICAgICAgIGZlYXR1cmVzLkNvbHVtblBpY2tlcixcbiAgICAgICAgZmVhdHVyZXMuQ29sdW1uUmVzaXppbmcsXG4gICAgICAgIGZlYXR1cmVzLlJvd1Jlc2l6aW5nLFxuICAgICAgICBmZWF0dXJlcy5GaWx0ZXJzLFxuICAgICAgICBmZWF0dXJlcy5Sb3dTZWxlY3Rpb24sXG4gICAgICAgIGZlYXR1cmVzLkNvbHVtblNlbGVjdGlvbixcbiAgICAgICAgZmVhdHVyZXMuQ29sdW1uTW92aW5nLFxuICAgICAgICBmZWF0dXJlcy5Db2x1bW5Tb3J0aW5nLFxuICAgICAgICBmZWF0dXJlcy5DZWxsQ2xpY2ssXG4gICAgICAgIGZlYXR1cmVzLkNlbGxFZGl0aW5nLFxuICAgICAgICBmZWF0dXJlcy5PbkhvdmVyXG4gICAgXSxcblxuICAgIGNyZWF0ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2NoZW1hID0gdGhpcy5kYXRhTW9kZWwuc2NoZW1hO1xuXG4gICAgICAgIHRoaXMuY2xlYXJDb2x1bW5zKCk7XG5cbiAgICAgICAgc2NoZW1hLmZvckVhY2goZnVuY3Rpb24oY29sdW1uU2NoZW1hLCBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5hZGRDb2x1bW4oe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IGNvbHVtblNjaGVtYS5oZWFkZXIsXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRvcjogY29sdW1uU2NoZW1hLmNhbGN1bGF0b3JcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmNvbHVtbkVudW1bdGhpcy5jb2x1bW5FbnVtS2V5KGNvbHVtblNjaGVtYS5uYW1lKV0gPSBpbmRleDsgLy8gdG9kbzogbW92ZSBjb2x1bW5FbnVtIGNvZGUgZnJvbSBjb3JlIHRvIGRlbW9cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFN0eWxlIGVudW0ga2V5cy5cbiAgICAgKiBAZGVzYyBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBzdHlsZSB5b3VyIGtleXMgdG8geW91ciBsaWtpbmcuXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEB0b2RvIG1vdmUgY29sdW1uRW51bSBjb2RlIGZyb20gY29yZSB0byBkZW1vXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBjb2x1bW5FbnVtS2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleS5yZXBsYWNlKFJFR0VYX0NBTUVMX0NBU0UsICckMV8kMicpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIGdldE5ld0RhdGFNb2RlbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFNb2RlbEpTT04odGhpcy5ncmlkLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIGhlYWRlciBsYWJlbHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXXxvYmplY3R9IGhlYWRlcnMgLSBUaGUgaGVhZGVyIGxhYmVscy4gT25lIG9mOlxuICAgICAqICogX0lmIGFuIGFycmF5Ol8gTXVzdCBjb250YWluIGFsbCBoZWFkZXJzIGluIGNvbHVtbiBvcmRlci5cbiAgICAgKiAqIF9JZiBhIGhhc2g6XyBNYXkgY29udGFpbiBhbnkgaGVhZGVycywga2V5ZWQgYnkgZmllbGQgbmFtZSwgaW4gYW55IG9yZGVyLlxuICAgICAqL1xuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgLy8gUmVzZXQgYWxsIGhlYWRlcnNcbiAgICAgICAgICAgIHZhciBhbGxDb2x1bW5zID0gdGhpcy5hbGxDb2x1bW5zO1xuICAgICAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBhbGxDb2x1bW5zW2luZGV4XS5oZWFkZXIgPSBoZWFkZXI7IC8vIHNldHRlciB1cGRhdGVzIGhlYWRlciBpbiBib3RoIGNvbHVtbiBhbmQgZGF0YSBzb3VyY2Ugb2JqZWN0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBBZGp1c3QganVzdCB0aGUgaGVhZGVycyBpbiB0aGUgaGFzaFxuICAgICAgICAgICAgdGhpcy5hbGxDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcnNbY29sdW1uLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5oZWFkZXIgPSBoZWFkZXJzW2NvbHVtbi5uYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCB0aGUgZmllbGRzIGFycmF5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgLSBUaGUgZmllbGQgbmFtZXMuXG4gICAgICovXG4gICAgc2V0RmllbGRzOiBmdW5jdGlvbihmaWVsZE5hbWVzKSB7XG4gICAgICAgIC8vd2VyZSBkZWZpbmluZyB0aGUgY29sdW1ucyBiYXNlZCBvbiBmaWVsZCBuYW1lcy4uLi5cbiAgICAgICAgLy93ZSBtdXN0IHJlYnVpbGQgdGhlIGNvbHVtbiBkZWZpbml0aW9uc1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRGaWVsZHMoZmllbGROYW1lcyk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBkYXRhTW9kZWxzLkpTT04jc2V0UGlwZWxpbmV9XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtEYXRhU291cmNlc10gLSBOZXcgcGlwZWxpbmUgZGVzY3JpcHRpb24uIF8oU2VlIHtAbGluayBkYXRhTW9kZWxzLkpTT04jc2V0UGlwZWxpbmV9LilfXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFRha2VzIGZpcnN0IGFyZ3VtZW50IHBvc2l0aW9uIHdoZW4gYERhdGFTb3VyY2VzYCBvbWl0dGVkLiBfKFNlZSB7QGxpbmsgZGF0YU1vZGVscy5KU09OI3NldFBpcGVsaW5lfS4pX1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXBwbHk9dHJ1ZV0gQXBwbHkgZGF0YSB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIG5ldyBkYXRhLlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRQaXBlbGluZTogZnVuY3Rpb24oRGF0YVNvdXJjZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KERhdGFTb3VyY2VzKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IERhdGFTb3VyY2VzO1xuICAgICAgICAgICAgRGF0YVNvdXJjZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXRQaXBlbGluZShEYXRhU291cmNlcywgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMuYXBwbHkgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmFwcGx5KSB7XG4gICAgICAgICAgICB0aGlzLnJlaW5kZXgoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQb3AgcGlwZWxpbmUgc3RhY2suXG4gICAgICogQHNlZSB7QGxpbmsgZGF0YU1vZGVscy5KU09OI3Vuc3Rhc2hQaXBlbGluZX1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3doaWNoU3Rhc2hdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIFRha2VzIGZpcnN0IGFyZ3VtZW50IHBvc2l0aW9uIHdoZW4gYERhdGFTb3VyY2VzYCBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXBwbHk9dHJ1ZV0gQXBwbHkgZGF0YSB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIG5ldyBkYXRhLlxuICAgICAqL1xuICAgIHVuc3Rhc2hQaXBlbGluZTogZnVuY3Rpb24oc3Rhc2gsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFzaCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBzdGFzaDtcbiAgICAgICAgICAgIHN0YXNoID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhTW9kZWwudW5zdGFzaFBpcGVsaW5lKHN0YXNoKTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5hcHBseSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuYXBwbHkpIHtcbiAgICAgICAgICAgIHRoaXMucmVpbmRleCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBkYXRhIGZpZWxkLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0W119IFtkYXRhUm93cz1vcHRpb25zLmRhdGFdIC0gQXJyYXkgb2YgdW5pZm9ybSBkYXRhIHJvdyBvYmplY3RzIG9yIGZ1bmN0aW9uIHJldHVybmluZyBzYW1lLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBUYWtlcyBmaXJzdCBhcmd1bWVudCBwb3NpdGlvbiB3aGVuIGBkYXRhUm93c2Agb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdH0gW29wdGlvbnMuZGF0YV0gLSBBcnJheSBvZiB1bmlmb3JtIGRhdGEgcm93IG9iamVjdHMgb3IgZnVuY3Rpb24gcmV0dXJuaW5nIHNhbWUuXG4gICAgICogUGFzc2VkIGFzIDFzdCBwYXJhbSB0byB7QGxpbmsgZGF0YU1vZGVsLkpTT04jc2V0RGF0YX0uIElmIGZhbHN5LCBtZXRob2QgYWJvcnRlZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdH0gW29wdGlvbnMuZmllbGRzXSAtIEFycmF5IG9mIGZpZWxkIG5hbWVzIG9yIGZ1bmN0aW9uIHJldHVybmluZyBzYW1lLlxuICAgICAqIFBhc3NlZCBhcyAybmQgcGFyYW0gdG8ge0BsaW5rIGRhdGFNb2RlbC5KU09OI3NldERhdGF9LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0fSBbb3B0aW9ucy5jYWxjdWxhdG9yc10gLSBBcnJheSBvZiBjYWxjdWxhdG9ycyBvciBmdW5jdGlvbiByZXR1cm5pbmcgc2FtZS5cbiAgICAgKiBQYXNzZWQgYXMgM3JkIHBhcmFtIHRvIHtAbGluayBkYXRhTW9kZWwuSlNPTiNzZXREYXRhfS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFwcGx5PXRydWVdIEFwcGx5IGRhdGEgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBuZXcgZGF0YS5cbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhUm93cywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIShBcnJheS5pc0FycmF5KGRhdGFSb3dzKSB8fCB0eXBlb2YgZGF0YVJvd3MgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGF0YVJvd3M7XG4gICAgICAgICAgICBkYXRhUm93cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVJvd3MgPSB0aGlzLnVud3JhcChkYXRhUm93cyk7XG5cbiAgICAgICAgaWYgKGRhdGFSb3dzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhUm93cykpIHtcbiAgICAgICAgICAgIHRocm93ICdEYXRhIGlzIG5vdCBhbiBhcnJheSc7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQ7XG5cbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0RGF0YShcbiAgICAgICAgICAgIGRhdGFSb3dzLFxuICAgICAgICAgICAgdGhpcy51bndyYXAob3B0aW9ucy5zY2hlbWEpIHx8IFtdIC8vICphbHdheXMqIGRlZmluZSBhIG5ldyBzY2hlbWEgb24gcmVzZXRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoZ3JpZC5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICBncmlkLmNlbGxFZGl0b3IuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwbHkgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmFwcGx5KSB7XG4gICAgICAgICAgICB0aGlzLnJlaW5kZXgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgICAgIGlmIChzZWxmLmdyaWQuaXNDb2x1bW5BdXRvc2l6aW5nKCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hdXRvc2l6ZUFsbENvbHVtbnMoKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICBzZWxmLmdyaWQuYWxsb3dFdmVudHMoc2VsZi5kYXRhTW9kZWwuZ2V0Um93Q291bnQoKSA+IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdldENvbHVtbigtMSkuY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHNlbGYuZ3JpZC5hbGxvd0V2ZW50cyhzZWxmLmRhdGFNb2RlbC5nZXRSb3dDb3VudCgpID4gMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmViaW5kcyB0aGUgZGF0YSB3aXRob3V0IHJlc2hhcGluZyBpdC5cbiAgICAgKiBAcGFyYW0gZGF0YVJvd3NcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB1cGRhdGVEYXRhOiBmdW5jdGlvbihkYXRhUm93cywgb3B0aW9ucyl7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAoIShBcnJheS5pc0FycmF5KGRhdGFSb3dzKSB8fCB0eXBlb2YgZGF0YVJvd3MgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGF0YVJvd3M7XG4gICAgICAgICAgICBkYXRhUm93cyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFSb3dzID0gdGhpcy51bndyYXAoZGF0YVJvd3MpO1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC5zZXREYXRhKFxuICAgICAgICAgICAgZGF0YVJvd3MsXG4gICAgICAgICAgICB0aGlzLnVud3JhcChvcHRpb25zLnNjaGVtYSkgLy8gdW5kZWZpbmVkIHdpbGwgYmUgaWdub3JlZFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucmVpbmRleCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQGRlc2NyaXB0aW9uIEJ1aWxkIHRoZSBmaWVsZHMgYW5kIGhlYWRlcnMgZnJvbSB0aGUgc3VwcGxpZWQgY29sdW1uIGRlZmluaXRpb25zLlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBteUpzb25CZWhhdmlvci5zZXRDb2x1bW5zKFtcbiAgICAgKiAgICAgeyBoZWFkZXI6ICdTdG9jayBOYW1lJywgbmFtZTogJ3Nob3J0X2Rlc2NyaXB0aW9uJyB9LFxuICAgICAqICAgICB7IGhlYWRlcjogJ1N0YXR1cycsIG5hbWU6ICd0cmFkaW5nX3BoYXNlJyB9LFxuICAgICAqICAgICB7IGhlYWRlcjogJ1JlZmVyZW5jZSBQcmljZScsIG5hbWU6ICdyZWZlcmVuY2VfcHJpY2UnIH1cbiAgICAgKiBdKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjb2x1bW5EZWZpbml0aW9ucyAtIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBmaWVsZHMgJ3RpdGxlJywgYW5kICdmaWVsZCdcbiAgICAgKi9cbiAgICBzZXRDb2x1bW5zOiBmdW5jdGlvbihjb2x1bW5EZWZpbml0aW9ucykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoaXMgZnVuY3Rpb24gZG9lcyBub3QgZG8gYW55dGhpbmcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBFbmhhbmNlIHRoZSBkb3VibGUtY2xpY2sgZXZlbnQganVzdCBiZWZvcmUgaXQncyBicm9hZGNhc3QgdG8gbGlzdGVuZXJzLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGV2ZW50XG4gICAgICovXG4gICAgZW5oYW5jZURvdWJsZUNsaWNrRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnJvdyA9IHRoaXMuZ2V0Um93KGV2ZW50LmdyaWRDZWxsLnkpO1xuICAgIH0sXG5cbiAgICAvL05vdCBiZWluZyB1c2VkLiBTaG91bGQgYmUgcmVwdXJwb3NlZD8/XG4gICAgc2V0RGF0YVByb3ZpZGVyOiBmdW5jdGlvbihkYXRhUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhTW9kZWwuc2V0RGF0YVByb3ZpZGVyKGRhdGFQcm92aWRlcik7XG4gICAgfSxcblxuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5oYXNIaWVyYXJjaHlDb2x1bW4oKTtcbiAgICB9LFxuXG4gICAgZ2V0SGlkZGVuQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRIaWRkZW5Db2x1bW5zKCk7XG4gICAgfSxcblxuICAgIGdldEFjdGl2ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhTW9kZWwuZ2V0QWN0aXZlQ29sdW1ucygpO1xuICAgIH0sXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRWaXNpYmxlQ29sdW1ucygpJywgJ2dldEFjdGl2ZUNvbHVtbnMoKScsICcxLjAuNicsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGVkQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgZ2V0U29ydGVkQ29sdW1uSW5kZXhlczogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRTb3J0ZWRDb2x1bW5JbmRleGVzKCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTjtcbiIsIi8qIGVzbGludC1lbnYgYnJvIHdzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxuLyoqXG4gKiBDb2x1bW4uanMgbWl4ZXMgdGhpcyBtb2R1bGUgaW50byBpdHMgcHJvdG90eXBlLlxuICogQG1vZHVsZVxuICovXG52YXIgY2VsbCA9IHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgcHJvcGVydGllcyBvYmplY3QgZm9yIGNlbGwuXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgY2VsbCdzIG93biBwcm9wZXJ0aWVzIG9iamVjdCBpZiBmb3VuZDsgZWxzZSB0aGUgY29sdW1uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIElmIHlvdSBhcmUgc2Vla2luZyBhIHNpbmdsZSBzcGVjaWZpYyBwcm9wZXJ0eSwgY29uc2lkZXIgY2FsbGluZyB7QGxpbmsgQ29sdW1uI2dldENlbGxQcm9wZXJ0eX0gaW5zdGVhZCAod2hpY2ggY2FsbHMgdGhpcyBtZXRob2QpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIERhdGEgcm93IGNvb3JkaW5hdGUuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcHJvcGVydGllcyBvZiB0aGUgY2VsbCBhdCB4LHkgaW4gdGhlIGdyaWQuXG4gICAgICogQG1lbWJlck9mIENvbHVtbiNcbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24ocm93SW5kZXgsIGRhdGFNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDZWxsT3duUHJvcGVydGllcyhyb3dJbmRleCwgZGF0YU1vZGVsKSB8fCB0aGlzLnByb3BlcnRpZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIERhdGEgcm93IGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBIYXNoIG9mIGNlbGwgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uI1xuICAgICAqL1xuICAgIHNldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbihyb3dJbmRleCwgcHJvcGVydGllcywgZGF0YU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBfKG5ld0NlbGxQcm9wZXJ0aWVzT2JqZWN0LmNhbGwodGhpcywgcm93SW5kZXgsIGRhdGFNb2RlbCkpLmV4dGVuZE93bihwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gRGF0YSByb3cgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIEhhc2ggb2YgY2VsbCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZXNlcnZlPWZhbHNlXSAtIEZhbHN5IGNyZWF0ZXMgbmV3IG9iamVjdDsgdHJ1dGh5IGNvcGllcyBgcHJvcGVydGllc2AgbWVtYmVycyBpbnRvIGV4aXN0aW5nIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uI1xuICAgICAqL1xuICAgIGFkZENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbihyb3dJbmRleCwgcHJvcGVydGllcywgZGF0YU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBfKGdldENlbGxQcm9wZXJ0aWVzT2JqZWN0LmNhbGwodGhpcywgcm93SW5kZXgsIGRhdGFNb2RlbCkpLmV4dGVuZE93bihwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBjZWxsJ3Mgb3duIHByb3BlcnRpZXMgb2JqZWN0LlxuICAgICAqIEBkZXNjIER1ZSB0byBtZW1vcnkgY29uc3RyYWludHMsIHdlIGRvbid0IGNyZWF0ZSBhIGNlbGwgb3B0aW9ucyBwcm9wZXJ0aWVzIG9iamVjdCBmb3IgZXZlcnkgY2VsbC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBjZWxsIGhhcyBpdHMgb3duIHByb3BlcnRpZXMgb2JqZWN0LCBpdDpcbiAgICAgKiAqIHdhcyBjcmVhdGVkIGJ5IGEgcHJldmlvdXMgY2FsbCB0byBgc2V0Q2VsbFByb3BlcnRpZXNgIG9yIGBzZXRDZWxsUHJvcGVydHlgXG4gICAgICogKiBoYXMgdGhlIGNvbHVtbiBwcm9wZXJ0aWVzIG9iamVjdCBhcyBpdHMgcHJvdG90eXBlXG4gICAgICogKiBpcyByZXR1cm5lZFxuICAgICAqXG4gICAgICogSWYgdGhlIGNlbGwgZG9lcyBub3QgaGF2ZSBpdHMgb3duIHByb3BlcnRpZXMgb2JqZWN0LCB0aGlzIG1ldGhvZCBzaW1wbHkgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIENhbGwgdGhpcyBtZXRob2Qgb25seSB3aGVuIHlvdSBuZWVkIHRvIGtub3cgaWYgdGhlIHRoZSBjZWxsIGhhcyBpdHMgb3duIHByb3BlcnRpZXMgb2JqZWN0OyBvdGhlcndpc2UgY2FsbCB7QGxpbmsgQ29sdW1uI2dldENlbGxQcm9wZXJ0aWVzfGdldENlbGxQcm9wZXJ0aWVzfS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBEYXRhIHJvdyBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR8b2JqZWN0fSBUaGUgXCJvd25cIiBwcm9wZXJ0aWVzIG9mIHRoZSBjZWxsIGF0IHgseSBpbiB0aGUgZ3JpZC4gSWYgdGhlIGNlbGwgZG9lcyBub3Qgb3duIGEgcHJvcGVydGllcyBvYmplY3QsIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICogQG1lbWJlck9mIENvbHVtbiNcbiAgICAgKi9cbiAgICBnZXRDZWxsT3duUHJvcGVydGllczogZnVuY3Rpb24ocm93SW5kZXgsIGRhdGFNb2RlbCkge1xuICAgICAgICB2YXIgcm93RGF0YTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPj0gMCAmJiAvLyBubyBjZWxsIHByb3BzIG9uIHJvdyBoYW5kbGUgY2VsbHNcbiAgICAgICAgICAgIChyb3dEYXRhID0gKGRhdGFNb2RlbCB8fCB0aGlzLmRhdGFNb2RlbCkuZ2V0Um93KHJvd0luZGV4KSkgJiYgLy8gbm8gY2VsbCBwcm9wcyBvbiBub24tZXhpc3RhbnQgcm93c1xuICAgICAgICAgICAgcm93RGF0YS5fX01FVEEgJiYgcm93RGF0YS5fX01FVEFbdGhpcy5uYW1lXSAvLyB1bmRlZmluZWQgaWYgbm90IHByZXZpb3VzbHkgY3JlYXRlZFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZXR1cm4gYSBzcGVjaWZpYyBjZWxsIHByb3BlcnR5LlxuICAgICAqIEBkZXNjIElmIHRoZXJlIGlzIG5vIGNlbGwgcHJvcGVydGllcyBvYmplY3QsIGRlZmVycyB0byBjb2x1bW4gcHJvcGVydGllcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gRGF0YSByb3cgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgc3BlY2lmaWVkIHByb3BlcnR5IGZvciB0aGUgY2VsbCBhdCB4LHkgaW4gdGhlIGdyaWQuXG4gICAgICogQG1lbWJlck9mIENvbHVtbiNcbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvcGVydHk6IGZ1bmN0aW9uKHJvd0luZGV4LCBrZXksIGRhdGFNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDZWxsUHJvcGVydGllcyhyb3dJbmRleCwgZGF0YU1vZGVsKVtrZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBEYXRhIHJvdyBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW4jXG4gICAgICovXG4gICAgc2V0Q2VsbFByb3BlcnR5OiBmdW5jdGlvbihyb3dJbmRleCwga2V5LCB2YWx1ZSwgZGF0YU1vZGVsKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzT2JqZWN0ID0gZ2V0Q2VsbFByb3BlcnRpZXNPYmplY3QuY2FsbCh0aGlzLCByb3dJbmRleCwgZGF0YU1vZGVsKTtcbiAgICAgICAgcHJvcGVydGllc09iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzT2JqZWN0O1xuICAgIH0sXG5cbiAgICBjbGVhckFsbENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVW5pbXBsZW1lbnRlZCFcbiAgICAgICAgLy8gTmVlZCB0byB1bmRlZmluZSBhbGwgYGRhdGFNb2RlbC5nZXREYXRhKCopLl9fTUVUQVt0aGlzLm5hbWVdYC5cbiAgICB9XG59O1xuXG4vKipcbiAqIEB0aGlzIHtDb2x1bW59XG4gKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBEYXRhIHJvdyBjb29yZGluYXRlLlxuICogQHJldHVybnMge29iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldENlbGxQcm9wZXJ0aWVzT2JqZWN0KHJvd0luZGV4LCBkYXRhTW9kZWwpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZWxsT3duUHJvcGVydGllcyhyb3dJbmRleCwgZGF0YU1vZGVsKSB8fCBuZXdDZWxsUHJvcGVydGllc09iamVjdC5jYWxsKHRoaXMsIHJvd0luZGV4LCBkYXRhTW9kZWwpO1xufVxuXG4vKipcbiAqIEB0b2RvOiBGb3Igdjggb3B0aW1pemF0aW9uLCBjb25zaWRlciBzZXR0aW5nIHRoZSBuZXcgYF9fTUVUQWAgb2JqZWN0IHRvIGEgXCJyZWd1bGFybHkgc2hhcGVkIG9iamVjdFwiIChpLmUuLCB3aXRoIGFsbCB0aGUgY29sdW1ucykgaW5zdGVhZCBvZiBzaW1wbHkgdG8gYHt9YC4gQ29uc2lkZXJhdGlvbnMgaW5jbHVkZSBob3cgbWFueSBvZiB0aGVzZSBvYmplY3RzIGFyZSB0aGVyZSwgaG93IG9mdGVuIGFyZSB0aGV5IHJlZmVyZW5jZWQsIGV0Yy5cbiAqIEB0aGlzIHtDb2x1bW59XG4gKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBEYXRhIHJvdyBjb29yZGluYXRlLlxuICogQHJldHVybnMge29iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5ld0NlbGxQcm9wZXJ0aWVzT2JqZWN0KHJvd0luZGV4LCBkYXRhTW9kZWwpIHtcbiAgICB2YXIgcm93RGF0YSA9IChkYXRhTW9kZWwgfHwgdGhpcy5kYXRhTW9kZWwpLmdldFJvdyhyb3dJbmRleCksXG4gICAgICAgIG1ldGFEYXRhID0gcm93RGF0YS5fX01FVEEgPSByb3dEYXRhLl9fTUVUQSB8fCB7fTtcbiAgICByZXR1cm4gKG1ldGFEYXRhW3RoaXMubmFtZV0gPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvcGVydGllcykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNlbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbnxzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdG9GdW5jdGlvbihzdHJpbmcpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBzdHJpbmcpIHtcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIHN0cmluZywgZnVuY3Rpb24sIG9yIHVuZGVmaW5lZC4nO1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gc3RyaW5nLm1hdGNoKC9mdW5jdGlvblxccypcXCgoW15dKj8pXFwpLyk7XG4gICAgaWYgKCFhcmdzKSB7XG4gICAgICAgIHRocm93ICdFeHBlY3RlZCBmdW5jdGlvbiBrZXl3b3JkIHdpdGggZm9ybWFsIHBhcmFtZXRlciBsaXN0Lic7XG4gICAgfVxuICAgIGFyZ3MgPSBhcmdzWzFdLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKHMsIGkpIHtcbiAgICAgICAgcyA9IHMubWF0Y2goL1xccyooXFx3KilcXHMqLyk7IC8vIHRyaW0gZWFjaCBhcmd1bWVudFxuICAgICAgICBpZiAoIXMgJiYgaSkge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGZvcm1hbCBwYXJhbWV0ZXIuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc1sxXTtcbiAgICB9KTtcblxuICAgIHZhciBib2R5ID0gc3RyaW5nLm1hdGNoKC97XFxzKihbXl0qPylcXHMqfS8pO1xuICAgIGlmICghYm9keSkge1xuICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgZnVuY3Rpb24gYm9keS4nO1xuICAgIH1cbiAgICBib2R5ID0gYm9keVsxXTtcblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiAhYXJnc1swXSkge1xuICAgICAgICBhcmdzWzBdID0gYm9keTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhcmdzID0gYXJncy5jb25jYXQoYm9keSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG52YXIgRklFTEQgPSAnY29sdW1uUHJvcGVydGllcy5maWVsZCBpcyBkZXByZWNhdGVkIGFzIG9mIHYxLjEuMCBpbiBmYXZvciBvZiBjb2x1bW5Qcm9wZXJ0aWVzLm5hbWUuIChXaWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4pJyxcbiAgICBDT0xVTU5fTkFNRSA9ICdjb2x1bW5Qcm9wZXJ0aWVzLmNvbHVtbk5hbWUgaXMgZGVwcmVjYXRlZCBhcyBvZiB2MS4xLjAgaW4gZmF2b3Igb2YgY29sdW1uUHJvcGVydGllcy5uYW1lLiAoV2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuKSc7XG5cbi8qKlxuICogQHRoaXMge0NvbHVtbn1cbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbHVtblByb3BlcnRpZXMoKSB7XG4gICAgdmFyIGNvbHVtbiA9IHRoaXMsXG4gICAgICAgIHRhYmxlU3RhdGUgPSBjb2x1bW4uYmVoYXZpb3IuZ3JpZC5wcm9wZXJ0aWVzLFxuICAgICAgICBwcm9wZXJ0aWVzO1xuXG4gICAgcHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUodGFibGVTdGF0ZSwge1xuXG4gICAgICAgIGluZGV4OiB7IC8vIHJlYWQtb25seSAobm8gc2V0dGVyKVxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sdW1uLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG5hbWU6IHsgLy8gcmVhZC1vbmx5IChubyBzZXR0ZXIpXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmaWVsZDogeyAvLyByZWFkLW9ubHkgKG5vIHNldHRlcilcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZJRUxEKSB7IGNvbnNvbGUud2FybihGSUVMRCk7IEZJRUxEID0gdW5kZWZpbmVkOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNvbHVtbk5hbWU6IHsgLy8gcmVhZC1vbmx5IChubyBzZXR0ZXIpXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChDT0xVTU5fTkFNRSkgeyBjb25zb2xlLndhcm4oQ09MVU1OX05BTUUpOyBDT0xVTU5fTkFNRSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5oZWFkZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4uaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi50eXBlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbi50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjYWxjdWxhdG9yOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW4uY2FsY3VsYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGNhbGN1bGF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4uY2FsY3VsYXRvciA9IHRvRnVuY3Rpb24oY2FsY3VsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcGVydGllcywgJ3Jvd051bWJlcnNQcm9wZXJ0aWVzJywgeyB2YWx1ZTogT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLCB7XG4gICAgICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KX0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BlcnRpZXMsICdyb3dIZWFkZXInLCB7IHZhbHVlOiBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIHtcbiAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJGb250O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckZvbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQ29sb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm93SGVhZGVyQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJCYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQ6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkZvbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcGVydGllcywgJ2NvbHVtbkhlYWRlcicsIHsgdmFsdWU6IE9iamVjdC5jcmVhdGUocHJvcGVydGllcywge1xuICAgICAgICBmb250OiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckZvbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJDb2xvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoYWxpZ246IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVySGFsaWduO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckhhbGlnbiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSl9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wZXJ0aWVzLCAnY29sdW1uSGVhZGVyQ29sdW1uU2VsZWN0aW9uJywgeyB2YWx1ZTogT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLmNvbHVtbkhlYWRlciwge1xuICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSl9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wZXJ0aWVzLCAncm93SGVhZGVyUm93U2VsZWN0aW9uJywgeyB2YWx1ZTogT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLnJvd0hlYWRlciwge1xuICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFJvd1NlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRSb3dTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZFJvd1NlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRSb3dTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSl9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wZXJ0aWVzLCAnZmlsdGVyUHJvcGVydGllcycsIHsgdmFsdWU6IE9iamVjdC5jcmVhdGUocHJvcGVydGllcywge1xuICAgICAgICBmb250OiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckZvbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJDb2xvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoYWxpZ246IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVySGFsaWduO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckhhbGlnbiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSl9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wZXJ0aWVzLCAndHJlZUNvbHVtblByb3BlcnRpZXMnLCB7IHZhbHVlOiBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIHtcbiAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uRm9udDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uRm9udCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQ29sb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVDb2x1bW5Gb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KX0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BlcnRpZXMsICd0cmVlQ29sdW1uUHJvcGVydGllc0NvbHVtblNlbGVjdGlvbicsIHsgdmFsdWU6IE9iamVjdC5jcmVhdGUocHJvcGVydGllcy50cmVlQ29sdW1uUHJvcGVydGllcywge1xuICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uRm9yZWdyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pfSk7XG5cbiAgICByZXR1cm4gcHJvcGVydGllcztcbn1cblxubW9kdWxlLmV4cG9ydHMuY3JlYXRlQ29sdW1uUHJvcGVydGllcyA9IGNyZWF0ZUNvbHVtblByb3BlcnRpZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEJlaGF2aW9yOiByZXF1aXJlKCcuL0JlaGF2aW9yJyksIC8vIGFic3RyYWN0IGJhc2UgY2xhc3NcbiAgICBKU09OOiByZXF1aXJlKCcuL0pTT04nKSxcbiAgICBDb2x1bW46IHJlcXVpcmUoJy4vQ29sdW1uJylcbn07XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbXVzdGFjaGUgPSByZXF1aXJlKCdtdXN0YWNoZScpO1xudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vQmFzZScpO1xudmFyIGVmZmVjdHMgPSByZXF1aXJlKCcuLi9saWIvRE9NL2VmZmVjdHMnKTtcbnZhciBMb2NhbGl6YXRpb24gPSByZXF1aXJlKCcuLi9saWIvTG9jYWxpemF0aW9uJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDZWxsRWRpdG9yID0gQmFzZS5leHRlbmQoJ0NlbGxFZGl0b3InLCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Q2VsbEV2ZW50fSBvcHRpb25zIC0gUHJvcGVydGllcyBsaXN0ZWQgYmVsb3cgKyBhcmJpdHJhcnkgbXVzdGFjaGUgXCJ2YXJpYWJsZXNcIiBmb3IgbWVyZ2luZyBpbnRvIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IG9wdGlvbnMuZWRpdFBvaW50IC0gRGVwcmVjYXRlZDsgdXNlIGBvcHRpb25zLmdyaWRDZWxsYC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZm9ybWF0XSAtIE5hbWUgb2YgYSBsb2NhbGl6ZXIgd2l0aCB3aGljaCB0byBvdmVycmlkZSBwcm90b3R5cGUncyBgbG9jYWxpemVyYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIE1peCBpbiBhbGwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGZvciBtdXN0YWNoZSB1c2UuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHRoaXNba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnQgPSBvcHRpb25zO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IGdyaWQuYmVoYXZpb3IuZ2V0VmFsdWUodGhpcy5ldmVudCk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzFdOyAvL2l0J3MgYSBuZXN0ZWQgb2JqZWN0XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogbXkgaW5zdGFuY2Ugb2YgaHlwZXJncmlkXG4gICAgICAgICAqIEB0eXBlIHtIeXBlcmdyaWR9XG4gICAgICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncmlkID0gZ3JpZDtcblxuICAgICAgICB0aGlzLmdyaWQuY2VsbEVkaXRvciA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5sb2NhbGUgPSBncmlkLmxvY2FsaXphdGlvbi5sb2NhbGU7IC8vIGZvciB0ZW1wbGF0ZSdzIGBsYW5nYCBhdHRyaWJ1dGVcblxuICAgICAgICAvLyBvdmVycmlkZSBuYXRpdmUgbG9jYWxpemVyIHdpdGggbG9jYWxpemVyIG5hbWVkIGluIGZvcm1hdCBpZiBkZWZpbmVkIChmcm9tIGluc3RhbnRpYXRpb24gb3B0aW9ucylcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0KSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsaXplciA9IHRoaXMuZ3JpZC5sb2NhbGl6YXRpb24uZ2V0KG9wdGlvbnMuZm9ybWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gbXVzdGFjaGUucmVuZGVyKHRoaXMudGVtcGxhdGUsIHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG9iamVjdCdzIGlucHV0IGNvbnRyb2wsIG9uZSBvZjpcbiAgICAgICAgICogKiAqaW5wdXQgZWxlbWVudCogLSBhbiBgSFRNTEVsZW1lbnRgIHRoYXQgaGFzIGEgYHZhbHVlYCBhdHRyaWJ1dGUsIHN1Y2ggYXMgYEhUTUxJbnB1dEVsZW1lbnRgLCBgSFRNTEJ1dHRvbkVsZW1lbnRgLCBldGMuXG4gICAgICAgICAqICogKmNvbnRhaW5lciBlbGVtZW50KiAtIGFuIGBIVE1MRWxlbWVudGAgY29udGFpbmluZyBvbmUgb3IgbW9yZSBpbnB1dCBlbGVtZW50cywgb25seSBvbmUgb2Ygd2hpY2ggY29udGFpbnMgdGhlIGVkaXRvciB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIGFjY2VzcyB0byB0aGUgaW5wdXQgY29udHJvbCBpdHNlbGYgKHdoaWNoIG1heSBvciBtYXkgbm90IGJlIHRoZSBzYW1lIGFzIGB0aGlzLmVsYCksIHNlZSBgdGhpcy5pbnB1dGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWwgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcblxuICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5lbDtcblxuICAgICAgICB0aGlzLmVycm9ycyA9IDA7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5rZXl1cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljRWRpdG9yS2V5RG93bkV2ZW50KHNlbGYsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY0VkaXRvcktleVByZXNzRXZlbnQoc2VsZiwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHNlbGYub25tb3VzZWRvd24oZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBJZiB5b3Ugb3ZlcnJpZGUgdGhpcyBtZXRob2QsIGJlIHN1cmUgdG8gY2FsbCBpdCBhcyBhIGZpbmFsIHN0ZXAgKG9yIGNhbGwgc3RvcFByb3BhZ2F0aW9uIHlvdXJzZWxmKS5cbiAgICBvbm1vdXNlZG93bjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIENhdGNoIG1vdXNlb2R3biBoZXJlIGJlZm9yZSBpdCBnZXRzIHRvIHRoZSBkb2N1bWVudCBsaXN0ZW5lciBkZWZpbmVkIGluIEh5cGVyZ3JpZCgpLlxuICAgIH0sXG5cbiAgICBsb2NhbGl6ZXI6IExvY2FsaXphdGlvbi5wcm90b3R5cGUubnVsbCxcblxuICAgIHNwZWNpYWxLZXl1cHM6IHtcbiAgICAgICAgLy8weDA4OiAnY2xlYXJTdG9wRWRpdGluZycsIC8vIGJhY2tzcGFjZVxuICAgICAgICAweDA5OiAnc3RvcEVkaXRpbmcnLCAvLyB0YWJcbiAgICAgICAgMHgwZDogJ3N0b3BFZGl0aW5nJywgLy8gcmV0dXJuL2VudGVyXG4gICAgICAgIDB4MWI6ICdjYW5jZWxFZGl0aW5nJyAvLyBlc2NhcGVcbiAgICB9LFxuXG4gICAga2V5dXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIHZhciBzcGVjaWFsS2V5dXAgPSB0aGlzLnNwZWNpYWxLZXl1cHNbZS5rZXlDb2RlXTtcblxuICAgICAgICAgICAgaWYgKHNwZWNpYWxLZXl1cCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tzcGVjaWFsS2V5dXBdKDMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC50YWtlRm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZ3JpZC5maXJlU3ludGhldGljRWRpdG9yS2V5VXBFdmVudCh0aGlzLCBlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBpZiB0cnVlLCBjaGVjayB0aGF0IHRoZSBlZGl0b3IgaXMgaW4gdGhlIHJpZ2h0IGxvY2F0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjaGVja0VkaXRvclBvc2l0aW9uRmxhZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIGlzIGEgY2FsbGJhY2sgZnJvbSB0aGUgZmluLWh5cGVyZ3JpZC4gICBJdCBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCBwYWludCBvZiB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIGdyaWRSZW5kZXJlZE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tFZGl0b3IoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2Nyb2xsIHZhbHVlcyBoYXZlIGNoYW5nZWQsIHdlJ3ZlIGJlZW4gbm90aWZpZWRcbiAgICAgKi9cbiAgICBzY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoZWNrRWRpdG9yUG9zaXRpb25GbGFnID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgbW92ZSB0aGUgZWRpdG9yIHRvIHRoZSBjdXJyZW50IGVkaXRvciBwb2ludFxuICAgICAqL1xuICAgIG1vdmVFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2VsbEJvdW5kcyA9IHRoaXMuZXZlbnQuYm91bmRzO1xuXG4gICAgICAgIC8vaGFjayB0byBhY2NvbW1vZGF0ZSBib290c3RyYXAgbWFyZ2luIGlzc3Vlcy4uLlxuICAgICAgICB2YXIgeE9mZnNldCA9XG4gICAgICAgICAgICB0aGlzLmdyaWQuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuICAgICAgICAgICAgdGhpcy5ncmlkLmRpdkNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXG4gICAgICAgIGNlbGxCb3VuZHMueCAtPSB4T2Zmc2V0O1xuXG4gICAgICAgIHRoaXMuc2V0Qm91bmRzKGNlbGxCb3VuZHMpO1xuICAgIH0sXG5cbiAgICBiZWdpbkVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5ncmlkLmZpcmVSZXF1ZXN0Q2VsbEVkaXQodGhpcy5ldmVudC5ncmlkQ2VsbCwgdGhpcy5pbml0aWFsVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRWRpdG9yUG9zaXRpb25GbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tFZGl0b3IoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmVnaW5FZGl0QXQ6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2JlZ2luRWRpdEF0KHBvaW50KScsICdiZWdpbkVkaXRpbmcoKScsICcxLjAuNicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBQdXQgdGhlIHZhbHVlIGludG8gb3VyIGVkaXRvci5cbiAgICAgKiBAZGVzYyBGb3JtYXRzIHRoZSB2YWx1ZSBhbmQgZGlzcGxheXMgaXQuXG4gICAgICogVGhlIGxvY2FsaXplcidzIHtAbGluayBsb2NhbGl6ZXJJbnRlcmZhY2UjZm9ybWF0fGZvcm1hdH0gbWV0aG9kIHdpbGwgYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgeW91ciBlZGl0b3IgaGFzIGFkZGl0aW9uYWwgb3IgYWx0ZXJuYXRpdmUgR1VJIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIC0gVGhlIHJhdyB1bmZvcm1hdHRlZCB2YWx1ZSBmcm9tIHRoZSBkYXRhIHNvdXJjZSB0aGF0IHdlIHdhbnQgdG8gZWRpdC5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRFZGl0b3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9IHRoaXMubG9jYWxpemVyLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRpc3BsYXkgdGhlIGVkaXRvclxuICAgICAqL1xuICAgIHNob3dFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGlkZSB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgaGlkZUVkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFN0b3BzIGVkaXRpbmcuXG4gICAgICogQGRlc2MgQmVmb3JlIHNhdmluZywgdmFsaWRhdGVzIHRoZSBlZGl0ZWQgdmFsdWUgaW4gdHdvIHBoYXNlcyBhcyBmb2xsb3dzOlxuICAgICAqIDEuIENhbGwgYHZhbGlkYXRlRWRpdG9yVmFsdWVgLiAoQ2FsbHMgdGhlIGxvY2FsaXplcidzIGBpbnZhbGlkKClgIGZ1bmN0aW9uLCBpZiBhdmFpbGFibGUuKVxuICAgICAqIDIuIENhdGNoIGFueSBlcnJvcnMgdGhyb3duIGJ5IHRoZSB7QGxpbmsgQ2VsbEVkaXRvciNnZXRFZGl0b3JWYWx1ZXxnZXRFZGl0b3JWYWx1ZX0gbWV0aG9kLlxuICAgICAqXG4gICAgICogKipJZiB0aGUgZWRpdGVkIHZhbHVlIHBhc3NlcyBib3RoIHBoYXNlcyBvZiB0aGUgdmFsaWRhdGlvbjoqKlxuICAgICAqIFNhdmVzIHRoZSBlZGl0ZWQgdmFsdWUgYnkgY2FsbGluZyB0aGUge0BsaW5rIENlbGxFZGl0b3Ijc2F2ZUVkaXRvclZhbHVlfHNhdmVFZGl0b3JWYWx1ZX0gbWV0aG9kLlxuICAgICAqXG4gICAgICogKipPbiB2YWxpZGF0aW9uIGZhaWx1cmU6KipcbiAgICAgKiAxLiBJZiBgZmVlZGJhY2tgIHdhcyBvbWl0dGVkLCBjYW5jZWxzIGVkaXRpbmcsIGRpc2NhcmRpbmcgdGhlIGVkaXRlZCB2YWx1ZS5cbiAgICAgKiAyLiBJZiBgZmVlZGJhY2tgIHdhcyBwcm92aWRlZCwgZ2l2ZXMgdGhlIHVzZXIgc29tZSBmZWVkYmFjayAoc2VlIGBmZWVkYmFja2AsIGJlbG93KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZmVlZGJhY2tdIFdoYXQgdG8gZG8gb24gdmFsaWRhdGlvbiBmYWlsdXJlOlxuICAgICAqICogSWYgb21pdHRlZCwgc2ltcGx5IGNhbmNlbHMgZWRpdGluZyB3aXRob3V0IHNhdmluZyBlZGl0ZWQgdmFsdWUuXG4gICAgICogKiBJZiAwLCBzaG93cyB0aGUgZXJyb3IgZmVlZGJhY2sgZWZmZWN0IChzZWUgdGhlIHtAbGluayBDZWxsRWRpdG9yI2Vycm9yRWZmZWN0fGVycm9yRWZmZWN0fSBwcm9wZXJ0eSkuXG4gICAgICogKiBJZiA+IDAsIHNob3dzIHRoZSBlcnJvciBmZWVkYmFjayBlZmZlY3QgX2FuZF8gY2FsbHMgdGhlIHtAbGluayBDZWxsRWRpdG9yI2Vycm9yRWZmZWN0RW5kfGVycm9yRWZmZWN0RW5kfSBtZXRob2QpIGV2ZXJ5IGBmZWVkYmFja2AgY2FsbChzKSB0byBgc3RvcEVkaXRpbmdgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnV0aHkgbWVhbnMgc3VjY2Vzc2Z1bCBzdG9wLiBGYWxzeSBtZWFucyBzeW50YXggZXJyb3IgcHJldmVudGVkIHN0b3AuIE5vdGUgdGhhdCBlZGl0aW5nIGlzIGNhbmNlbGVkIHdoZW4gbm8gZmVlZGJhY2sgcmVxdWVzdGVkIGFuZCBzdWNjZXNzZnVsIHN0b3AgaW5jbHVkZXMgKHN1Y2Nlc3NmdWwpIGNhbmNlbC5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzdG9wRWRpdGluZzogZnVuY3Rpb24oZmVlZGJhY2spIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufHN0cmluZ3xFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGVFZGl0b3JWYWx1ZSgpO1xuXG4gICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRFZGl0b3JWYWx1ZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVycm9yICYmIHRoaXMuZ3JpZC5maXJlU3ludGhldGljRWRpdG9yRGF0YUNoYW5nZUV2ZW50KHRoaXMsIHRoaXMuaW5pdGlhbFZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlRWRpdG9yVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVFZGl0b3IoKTtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5jZWxsRWRpdG9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmVlZGJhY2sgPj0gMCkgeyAvLyBuZXZlciB0cnVlIHdoZW4gYGZlZWRiYWNrYCB1bmRlZmluZWRcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHRoaXMuZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgICAgICB0aGlzLmdyaWQuc2VsZWN0Vmlld3BvcnRDZWxsKHBvaW50LngsIHBvaW50LnkgLSB0aGlzLmdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKSk7XG4gICAgICAgICAgICB0aGlzLmVycm9yRWZmZWN0QmVnaW4oKyt0aGlzLmVycm9ycyAlIGZlZWRiYWNrID09PSAwICYmIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gaW52YWxpZCBidXQgbm8gZmVlZGJhY2tcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICFlcnJvcjtcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IENhbmNlbHMgZWRpdGluZy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gU3VjY2Vzc2Z1bC4gKENhbmNlbCBpcyBhbHdheXMgc3VjY2Vzc2Z1bC4pXG4gICAgICovXG4gICAgY2FuY2VsRWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0RWRpdG9yVmFsdWUodGhpcy5pbml0aWFsVmFsdWUpO1xuICAgICAgICB0aGlzLmhpZGVFZGl0b3IoKTtcbiAgICAgICAgdGhpcy5ncmlkLmNlbGxFZGl0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgZWZmZWN0IGZ1bmN0aW9uIGluZGljYXRlZCBpbiB0aGUge0BsaW5rIENlbGxFZGl0b3IjZXJyb3JFZmZlY3R8ZXJyb3JFZmZlY3R9IHByb3BlcnR5IHdoaWNoIHRyaWdnZXJzIGEgc2VyaWVzIG9mIENTUyB0cmFuc2l0aW9ucy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfEVycm9yfSBbZXJyb3JdIC0gSWYgZGVmaW5lZCwgY2FsbCB0aGUge0BsaW5rIENlbGxFZGl0b3IjZXJyb3JFZmZlY3RFbmR8ZXJyb3JFZmZlY3RFbmR9IG1ldGhvZCBhdCB0aGUgZW5kIG9mIHRoZSBsYXN0IGVmZmVjdCB0cmFuc2l0aW9uIHdpdGggdGhpcyBlcnJvci5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlcnJvckVmZmVjdEJlZ2luOiBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHsgY2FsbGJhY2s6IGVycm9yICYmIHRoaXMuZXJyb3JFZmZlY3RFbmQuYmluZCh0aGlzLCBlcnJvcikgfSxcbiAgICAgICAgICAgIGVmZmVjdCA9IHRoaXMuZXJyb3JFZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlZmZlY3QgPSB0aGlzLmVycm9yRWZmZWN0c1tlZmZlY3RdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBfKG9wdGlvbnMpLmV4dGVuZE93bihlZmZlY3Qub3B0aW9ucyk7XG4gICAgICAgICAgICBlZmZlY3QgPSBlZmZlY3QuZWZmZWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZWZmZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgYHRoaXMuZXJyb3JFZmZlY3RgIHRvIHJlc29sdmUgdG8gYW4gZXJyb3IgZWZmZWN0IGZ1bmN0aW9uLic7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBleHBlY3RzIHRvIGJlIHBhc3NlZCBhbiBlcnJvci4gVGhlcmUgaXMgbm8gcG9pbnQgaW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGlmIHRoZXJlIGlzIG5vIGVycm9yLiBOZXZlcnRoZWxlc3MsIGlmIGNhbGxlZCB3aXRoIGEgZmFsc3kgYGVycm9yYCwgcmV0dXJucyB3aXRob3V0IGRvaW5nIGFueXRoaW5nLlxuICAgICAqIEB0aGlzIHtDZWxsRWRpdG9yfVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd8RXJyb3J9IFtlcnJvcl1cbiAgICAgKi9cbiAgICBlcnJvckVmZmVjdEVuZDogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgbXNnID1cbiAgICAgICAgICAgICAgICAnSW52YWxpZCB2YWx1ZS4gVG8gcmVzb2x2ZSwgZG8gb25lIG9mIHRoZSBmb2xsb3dpbmc6XFxuXFxuJyArXG4gICAgICAgICAgICAgICAgJyAgICogQ29ycmVjdCB0aGUgZXJyb3IgYW5kIHRyeSBhZ2Fpbi5cXG4nICtcbiAgICAgICAgICAgICAgICAnICAgICAgICAgLSBvciAtXFxuJyArXG4gICAgICAgICAgICAgICAgJyAgICogQ2FuY2VsIGVkaXRpbmcgYnkgcHJlc3NpbmcgdGhlIFwiZXNjXCIgKGVzY2FwZSkga2V5Lic7XG5cbiAgICAgICAgICAgIGVycm9yID0gZXJyb3IubWVzc2FnZSB8fCBlcnJvcjtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5sb2NhbGl6ZXIuZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycm9yID8gZXJyb3IgKyAnXFxuJyArIHRoaXMubG9jYWxpemVyLmV4cGVjdGF0aW9uIDogdGhpcy5sb2NhbGl6ZXIuZXhwZWN0YXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICgvW1xcblxccl0vLnRlc3QoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gJ1xcbicgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvci5yZXBsYWNlKC9bXFxuXFxyXSsvZywgJ1xcblxcbiAgICogJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1zZyArPSAnXFxuXFxuQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGVycm9yOiAnICsgZXJyb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFsZXJ0KG1zZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGVkZWYgZWZmZWN0T2JqZWN0XG4gICAgICogQHByb3BlcnR5IHtlZmZlY3RGdW5jdGlvbn0gZWZmZWN0b3JcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gW29wdGlvbnNdIC0gQW4gb3B0aW9ucyBvYmplY3Qgd2l0aCB3aGljaCB0byBjYWxsIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBNYXkgYmUgb25lIG9mOlxuICAgICAqICogKipzdHJpbmcqKiAtIE5hbWUgb2YgcmVnaXN0ZXJlZCBlcnJvciBlZmZlY3QuXG4gICAgICogKiAqKmVmZmVjdEZ1bmN0aW9uKiogLSBSZWZlcmVuY2UgdG8gYW4gZWZmZWN0IGZ1bmN0aW9uLlxuICAgICAqICogKiplZmZlY3RPYmplY3QqKiAtIFJlZmVyZW5jZSB0byBhbiBlZmZlY3RPYmplY3QgY29udGFpbmluZyBhbiB7QGxpbmsgZWZmZWN0RnVuY3Rpb259IGFuZCBhbiBgb3B0aW9uc2Agb2JqZWN0IHdpdGggd2hpY2ggdG8gY2FsbCB0aGUgZnVuY3Rpb24uXG4gICAgICogQHR5cGUge3N0cmluZ3xlZmZlY3RGdW5jdGlvbnxlZmZlY3RPYmplY3R9XG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZXJyb3JFZmZlY3Q6ICdzaGFrZXInLFxuXG4gICAgLyoqXG4gICAgICogSGFzaCBvZiByZWdpc3RlcmVkIHtAbGluayBlZmZlY3RGdW5jdGlvbn1zIG9yIHtAbGluayBlZmZlY3RPYmplY3R9cy5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlcnJvckVmZmVjdHM6IHtcbiAgICAgICAgc2hha2VyOiBlZmZlY3RzLnNoYWtlcixcbiAgICAgICAgZ2xvd2VyOiBlZmZlY3RzLmdsb3dlclxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBzYXZlIHRoZSBuZXcgdmFsdWUgaW50byB0aGUgYmVoYXZpb3IgKG1vZGVsKVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBEYXRhIGNoYW5nZWQgYW5kIHByZS1jZWxsLWVkaXQgZXZlbnQgd2FzIG5vdCBjYW5jZWxlZC5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYXZlRWRpdG9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBzYXZlID1cbiAgICAgICAgICAgICEodmFsdWUgJiYgdmFsdWUgPT09IHRoaXMuaW5pdGlhbFZhbHVlKSAmJiAvLyBkYXRhIGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5maXJlQmVmb3JlQ2VsbEVkaXQodGhpcy5ldmVudC5ncmlkQ2VsbCwgdGhpcy5pbml0aWFsVmFsdWUsIHZhbHVlLCB0aGlzKTsgLy8gcHJvY2VlZFxuXG4gICAgICAgIGlmIChzYXZlKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQuYmVoYXZpb3Iuc2V0VmFsdWUodGhpcy5ldmVudCwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLmZpcmVBZnRlckNlbGxFZGl0KHRoaXMuZXZlbnQuZ3JpZENlbGwsIHRoaXMuaW5pdGlhbFZhbHVlLCB2YWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2F2ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgRXh0cmFjdCB0aGUgZWRpdGVkIHZhbHVlIGZyb20gdGhlIGVkaXRvci5cbiAgICAgKiBAZGVzYyBEZS1mb3JtYXQgdGhlIGVkaXRlZCBzdHJpbmcgYmFjayBpbnRvIGEgcHJpbWl0aXZlIHZhbHVlLlxuICAgICAqXG4gICAgICogVGhlIGxvY2FsaXplcidzIHtAbGluayBsb2NhbGl6ZXJJbnRlcmZhY2UjcGFyc2V8cGFyc2V9IG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgdGV4dCBib3ggY29udGVudHMuXG4gICAgICpcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3VyIGVkaXRvciBoYXMgYWRkaXRpb25hbCBvciBhbHRlcm5hdGl2ZSBHVUkgZWxlbWVudHMuIFRoZSBHVUkgZWxlbWVudHMgd2lsbCBpbmZsdWVuY2UgdGhlIHByaW1pdGl2ZSB2YWx1ZSwgZWl0aGVyIGJ5IGFsdGVyaW5nIHRoZSBlZGl0ZWQgc3RyaW5nIGJlZm9yZSBpdCBpcyBwYXJzZWQsIG9yIGJ5IHRyYW5zZm9ybWluZyB0aGUgcGFyc2VkIHZhbHVlIGJlZm9yZSByZXR1cm5pbmcgaXQuXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlIGN1cnJlbnQgZWRpdG9yJ3MgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRFZGl0b3JWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsaXplci5wYXJzZSh0aGlzLmlucHV0LnZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUgaXMgbm8gdmFsaWRhdG9yIG9uIHRoZSBsb2NhbGl6ZXIsIHJldHVybnMgZmFsc3kgKG5vdCBpbnZhbGlkOyBwb3NzaWJseSB2YWxpZCkuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58c3RyaW5nfSBUcnV0aHkgdmFsdWUgbWVhbnMgaW52YWxpZC4gSWYgYSBzdHJpbmcsIHRoaXMgd2lsbCBiZSBhbiBlcnJvciBtZXNzYWdlLiBJZiBub3QgYSBzdHJpbmcsIGl0IG1lcmVseSBpbmRpY2F0ZXMgYSBnZW5lcmljIGludmFsaWQgcmVzdWx0LlxuICAgICAqL1xuICAgIHZhbGlkYXRlRWRpdG9yVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6ZXIuaW52YWxpZCAmJiB0aGlzLmxvY2FsaXplci5pbnZhbGlkKHRoaXMuaW5wdXQudmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZXF1ZXN0IGZvY3VzIGZvciBteSBpbnB1dCBjb250cm9sLlxuICAgICAqIEBkZXNjIFNlZSBHUklELTk1IFwiU2Nyb2xsYmFyIG1vdmVzIGlud2FyZFwiIGZvciBpc3N1ZSBhbmQgd29yay1hcm91bmQgZXhwbGFuYXRpb24uXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgdGFrZUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgICAgICAgIGxlZnRXYXMgPSBlbC5zdHlsZS5sZWZ0LFxuICAgICAgICAgICAgdG9wV2FzID0gZWwuc3R5bGUudG9wO1xuXG4gICAgICAgIGVsLnN0eWxlLmxlZnQgPSBlbC5zdHlsZS50b3AgPSAwOyAvLyB3b3JrLWFyb3VuZDogbW92ZSB0byB1cHBlciBsZWZ0XG5cbiAgICAgICAgdmFyIHggPSB3aW5kb3cuc2Nyb2xsWCwgeSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoKTtcblxuICAgICAgICBlbC5zdHlsZS5sZWZ0ID0gbGVmdFdhcztcbiAgICAgICAgZWwuc3R5bGUudG9wID0gdG9wV2FzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZWxlY3QgZXZlcnl0aGluZ1xuICAgICAqL1xuICAgIHNlbGVjdEFsbDogbnVsbFBhdHRlcm4sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIGJvdW5kcyBvZiBteSBpbnB1dCBjb250cm9sXG4gICAgICogQHBhcmFtIHtyZWN0YW5nbGV9IHJlY3RhbmdsZSAtIHRoZSBib3VuZHMgdG8gbW92ZSB0b1xuICAgICAqL1xuICAgIHNldEJvdW5kczogZnVuY3Rpb24oY2VsbEJvdW5kcykge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xuXG4gICAgICAgIHN0eWxlLmxlZnQgPSBweChjZWxsQm91bmRzLngpO1xuICAgICAgICBzdHlsZS50b3AgPSBweChjZWxsQm91bmRzLnkpO1xuICAgICAgICBzdHlsZS53aWR0aCA9IHB4KGNlbGxCb3VuZHMud2lkdGgpO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBweChjZWxsQm91bmRzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGNoZWNrIHRoYXQgdGhlIGVkaXRvciBpcyBpbiB0aGUgY29ycmVjdCBsb2NhdGlvbiwgYW5kIGlzIHNob3dpbmcvaGlkZGVuIGFwcHJvcHJpYXRlbHlcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjaGVja0VkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrRWRpdG9yUG9zaXRpb25GbGFnKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRWRpdG9yUG9zaXRpb25GbGFnID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudC5pc0NlbGxWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFZGl0b3JWYWx1ZSh0aGlzLmluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFZGl0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRha2VGb2N1cygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVFZGl0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhdHRhY2hFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdyaWQuZGl2LmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuICAgIH0sXG5cbiAgICB0ZW1wbGF0ZTogJydcblxufSk7XG5cbmZ1bmN0aW9uIG51bGxQYXR0ZXJuKCkge31cbmZ1bmN0aW9uIHB4KG4pIHsgcmV0dXJuIG4gKyAncHgnOyB9XG5cblxuQ2VsbEVkaXRvci5hYnN0cmFjdCA9IHRydWU7IC8vIGRvbid0IGluc3RhbnRpYXRlIGRpcmVjdGx5XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsRWRpdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpO1xuXG4vKipcbiAqIEFzIG9mIHNwcmluZyAyMDE2OlxuICogRnVuY3Rpb25zIHdlbGwgaW4gQ2hyb21lIGFuZCBGaXJlZm94OyB1bmltcGxlbWVudGVkIGluIFNhZmFyaS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbEVkaXRvclxuICovXG52YXIgQ29sb3IgPSBDZWxsRWRpdG9yLmV4dGVuZCgnQ29sb3InLCB7XG5cbiAgICB0ZW1wbGF0ZTogJzxpbnB1dCB0eXBlPVwiY29sb3JcIiBsYW5nPVwie3tsb2NhbGV9fVwiIHN0eWxlPVwie3tzdHlsZX19XCI+J1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcbiIsIi8vIENvbWJvQm94LmpzIC0gQSBjb21iby1ib3ggaXMgYSBjb21iaW5hdGlvbiBvZiBhIHRleHQtYm94IGFuZCBhIGRyb3AtZG93bi5cbi8vIFVzZXIgbWF5IHR5cGUgaW50byBpdCBhbmQvb3Igc2VsZWN0IGFuIGl0ZW0gZnJvbSB0aGUgZHJvcC1kb3duIChieSBjbGlja2luZyBvbiB0aGUgdHJpYW5nbGUgYXQgdGhlIHJpZ2h0KS5cbi8vIFRoZSBkcm9wLWRvd24gaGFzIHNlY3Rpb25zIHdoaWNoIGFyZSB0b2dnbGVkIGZyb20gYSBjb250cm9sIGFyZWEgYmV0d2VlbiB0aGUgdGV4dC1ib3ggYW5kIHRoZSBkcm9wLWRvd24uXG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUZXh0ZmllbGQgPSByZXF1aXJlKCcuL1RleHRmaWVsZCcpO1xudmFyIHByb3RvdHlwZSA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpLnByb3RvdHlwZTtcbnZhciBRdWV1ZWxlc3MgPSByZXF1aXJlKCcuLi9saWIvRE9NL3F1ZXVlbGVzcycpO1xudmFyIGVsZm9yID0gcmVxdWlyZSgnLi4vbGliL0RPTS9lbGZvcicpO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBUT0dHTEVfTU9ERV9QUkVGSVggPSAndG9nZ2xlLW1vZGUtJztcblxudmFyIHN0YXRlVG9BY3Rpb25NYXAgPSB7XG4gICAgaGlkZGVuOiBzbGlkZURvd24sXG4gICAgdmlzaWJsZTogc2xpZGVVcFxufTtcblxuLyoqXG4gKiBBIGNvbWJvIGJveCBpcyBhIHRleHQgYm94IHRoYXQgYWxzbyBoYXMgYSBkcm9wLWRvd24gY29udGFpbmluZyBvcHRpb25zLiBUaGUgZHJvcC1kb3duIGNvbnNpc3RzIG9mIGFuIGFjdHVhbCBkcm9wLWRvd24gbGlzdCAoYSBgPHNlbGVjdD5gIGxpc3QpIHBsdXMgYSBfY29udHJvbCBhcmVhXyBhYm92ZSBpdCBjb250YWluaW5nIHRvZ2dsZXMuIFRoZSB0b2dnbGVzIGNvbnRyb2wgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHZhcmlvdXMgXCJtb2RlIGxpc3RzLlwiXG4gKlxuICogRnVuY3Rpb25zIHdlbGwgaW4gQ2hyb21lLCBTYWZhcmksIEZpcmVmb3gsIGFuZCBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgVGV4dGZpZWxkXG4gKi9cbnZhciBDb21ib0JveCA9IFRleHRmaWVsZC5leHRlbmQoJ0NvbWJvQm94Jywge1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICAgICAgdGhpcy5pbnB1dCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuZHJvcHBlciA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ3NwYW4nKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZWwucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gICAgICAgIHRoaXMuY29udHJvbHMgPSB0aGlzLm9wdGlvbnMucXVlcnlTZWxlY3RvcignZGl2Jyk7XG4gICAgICAgIHRoaXMuZHJvcGRvd24gPSB0aGlzLm9wdGlvbnMucXVlcnlTZWxlY3Rvcignc2VsZWN0Jyk7XG5cbiAgICAgICAgdGhpcy5jb250cm9sbGFibGUgPSB0aGlzLm1vZGVzLmxlbmd0aCA+IDE7XG5cbiAgICAgICAgLy8gc2V0IHVwIGEgdHJhbnNpdGlvbiBlbmQgY29udHJvbGxlclxuICAgICAgICB0aGlzLm9wdGlvbnNUcmFuc2l0aW9uID0gbmV3IFF1ZXVlbGVzcyh0aGlzLm9wdGlvbnMsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMubWVudU1vZGVzU291cmNlID0gdGhpcy5jb2x1bW4ubWVudU1vZGVzIHx8IHsgZGlzdGluY3RWYWx1ZXM6IHRydWUgfTtcblxuICAgICAgICAvLyB3aXJlLXVwc1xuICAgICAgICB0aGlzLmRyb3BwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy50b2dnbGVEcm9wRG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5kcm9wZG93bi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgZnVuY3Rpb24oZSkgeyBlLnN0b3BQcm9wYWdhdGlvbigpOyB9KTtcbiAgICAgICAgdGhpcy5kcm9wZG93bi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmluc2VydFRleHQuYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIHRlbXBsYXRlOiBbXG4nPGRpdiBjbGFzcz1cImh5cGVyZ3JpZC1jb21ib2JveFwiIHRpdGxlPVwiXCI+JyxcbicgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbGFuZz1cInt7bG9jYWxlfX1cIiBzdHlsZT1cInt7c3R5bGV9fVwiPicsXG4nICAgIDxzcGFuIHRpdGxlPVwiQ2xpY2sgZm9yIG9wdGlvbnNcIj48L3NwYW4+JyxcbicgICAgPGRpdj4nLFxuJyAgICAgICAgPGRpdj48L2Rpdj4nLFxuJyAgICAgICAgPHNlbGVjdCBzaXplPVwiMTVcIiBsYW5nPVwie3tsb2NhbGV9fVwiPjwvc2VsZWN0PicsXG4nICAgIDwvZGl2PicsXG4nPC9kaXY+J1xuICAgIF0uam9pbignXFxuJyksXG5cbiAgICBtb2RlczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnZGlzdGluY3RWYWx1ZXMnLFxuICAgICAgICAgICAgYXBwZW5kT3B0aW9uczogZnVuY3Rpb24ob3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGRpc3RpbmN0IGNvbHVtbiB2YWx1ZXMgYW5kIHNvcnQgdGhlbVxuICAgICAgICAgICAgICAgIHZhciBkaXN0aW5jdCA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBkID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbk5hbWUgPSB0aGlzLmNvbHVtbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIgPSB0aGlzLmNvbHVtbi5nZXRGb3JtYXR0ZXIoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5iZWhhdmlvci5nZXREYXRhKCkuZm9yRWFjaChmdW5jdGlvbihkYXRhUm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBmb3JtYXR0ZXIoZGF0YVJvd1tjb2x1bW5OYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RpbmN0W3ZhbF0gPSAoZGlzdGluY3RbdmFsXSB8fCAwKSArIDE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGlzdGluY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9wdGdyb3VwLmZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLmZpcnN0RWxlbWVudENoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGQuc29ydCgpLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBuZXcgT3B0aW9uKHZhbCArICcgKCcgKyBkaXN0aW5jdFt2YWxdICsgJyknLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSxcblxuICAgIHNob3dFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWVudU1vZGVzU291cmNlID0gdGhpcy5tZW51TW9kZXNTb3VyY2UsXG4gICAgICAgICAgICBtZW51TW9kZXMgPSB0aGlzLm1lbnVNb2RlcyA9IHt9O1xuXG4gICAgICAgIC8vIGJ1aWxkIHRoZSBwcm94eVxuICAgICAgICB0aGlzLm1vZGVzLmZvckVhY2goZnVuY3Rpb24obW9kZSkge1xuICAgICAgICAgICAgdmFyIG1vZGVOYW1lID0gbW9kZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1vZGVOYW1lIGluIG1lbnVNb2Rlc1NvdXJjZSkge1xuICAgICAgICAgICAgICAgIG1lbnVNb2Rlc1ttb2RlTmFtZV0gPSBtZW51TW9kZXNTb3VyY2VbbW9kZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3aXJlLXVwc1xuICAgICAgICBpZiAodGhpcy5jb250cm9sbGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbk1vZGVJY29uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIG1vZGUgdG9nZ2xlc1xuICAgICAgICB0aGlzLm1vZGVzLmZvckVhY2goZnVuY3Rpb24obW9kZSkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgdG9nZ2xlXG4gICAgICAgICAgICB2YXIgdG9nZ2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbGxhYmxlKSB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLmNsYXNzTmFtZSA9IFRPR0dMRV9NT0RFX1BSRUZJWCArIG1vZGUubmFtZTtcbiAgICAgICAgICAgICAgICB0b2dnbGUudGl0bGUgPSAnVG9nZ2xlICcgKyAobW9kZS5sYWJlbCB8fCBtb2RlLm5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnRleHRDb250ZW50ID0gbW9kZS5zeW1ib2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLmFwcGVuZENoaWxkKHRvZ2dsZSk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbmQgbGFiZWwgYSBuZXcgb3B0Z3JvdXBcbiAgICAgICAgICAgIGlmIChtb2RlLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0Z3JvdXAnKTtcbiAgICAgICAgICAgICAgICBvcHRncm91cC5sYWJlbCA9IG1vZGUubGFiZWw7XG4gICAgICAgICAgICAgICAgb3B0Z3JvdXAuY2xhc3NOYW1lID0gJ3N1Ym1lbnUtJyArIG1vZGUubmFtZTtcbiAgICAgICAgICAgICAgICBvcHRncm91cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBtb2RlLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duLmFkZChvcHRncm91cCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldE1vZGVJY29uQW5kT3B0Z3JvdXAuY2FsbCh0aGlzLCB0b2dnbGUsIG1vZGUubmFtZSwgbWVudU1vZGVzW21vZGUubmFtZV0pO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHByb3RvdHlwZS5zaG93RWRpdG9yLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIGhpZGVFZGl0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB0aGlzIGlzIHdoZXJlIHlvdSB3b3VsZCBwZXJzaXN0IHRoaXMubWVudU1vZGVzXG4gICAgICAgIHByb3RvdHlwZS5oaWRlRWRpdG9yLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIHRvZ2dsZURyb3BEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNUcmFuc2l0aW9uLnRyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZHJvcGRvd24pLnZpc2liaWxpdHk7XG4gICAgICAgICAgICBzdGF0ZVRvQWN0aW9uTWFwW3N0YXRlXS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluc2VydFRleHQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgaW5wdXQgdGV4dCB3aXRoIHRoZSBkcm9wLWRvd24gdGV4dFxuICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSB0aGlzLmRyb3Bkb3duLnZhbHVlO1xuICAgICAgICB0aGlzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKDAsIHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoKTtcblxuICAgICAgICAvLyBjbG9zZSB0aGUgZHJvcC1kb3duXG4gICAgICAgIHRoaXMudG9nZ2xlRHJvcERvd24oKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gb25Nb2RlSWNvbkNsaWNrKGUpIHtcbiAgICB2YXIgY3RybCA9IGUudGFyZ2V0O1xuXG4gICAgaWYgKGN0cmwudGFnTmFtZSA9PT0gJ1NQQU4nKSB7XG4gICAgICAgIC8vIGV4dHJhIGN0IHRoZSBtb2RlIG5hbWUgZnJvbSB0aGUgdG9nZ2xlIGNvbnRyb2wncyBjbGFzcyBuYW1lXG4gICAgICAgIHZhciBtb2RlQ2xhc3NOYW1lID0gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChjdHJsLmNsYXNzTGlzdCwgZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzTmFtZS5pbmRleE9mKFRPR0dMRV9NT0RFX1BSRUZJWCkgPT09IDA7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1vZGVOYW1lID0gbW9kZUNsYXNzTmFtZS5zdWJzdHIoVE9HR0xFX01PREVfUFJFRklYLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gdG9nZ2xlIG1vZGUgaW4gdGhlIGZpbHRlclxuICAgICAgICB2YXIgbW9kZVN0YXRlID0gdGhpcy5tZW51TW9kZXNbbW9kZU5hbWVdIF49IDE7XG5cbiAgICAgICAgc2V0TW9kZUljb25BbmRPcHRncm91cC5jYWxsKHRoaXMsIGN0cmwsIG1vZGVOYW1lLCBtb2RlU3RhdGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0TW9kZUljb25BbmRPcHRncm91cChjdHJsLCBuYW1lLCBzdGF0ZSkge1xuICAgIHZhciBzdHlsZSwgb3B0Z3JvdXAsIHN1bSwgZGlzcGxheSxcbiAgICAgICAgZHJvcGRvd24gPSB0aGlzLmRyb3Bkb3duLFxuICAgICAgICBtb2RlID0gdGhpcy5tb2Rlcy5maW5kKGZ1bmN0aW9uKG1vZGUpIHsgcmV0dXJuIG1vZGUubmFtZSA9PT0gbmFtZTsgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2hhZG93XG5cbiAgICAvLyBzZXQgaWNvbiBzdGF0ZSAoY29sb3IpXG4gICAgY3RybC5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnLCAhIXN0YXRlKTtcblxuICAgIC8vIGVtcHR5IHRoZSBvcHRncm91cCBpZiBoaWRpbmc7IHJlYnVpbGQgaXQgaWYgc2hvd2luZ1xuICAgIGlmIChzdGF0ZSkgeyAvLyByZWJ1aWxkIGl0XG4gICAgICAgIC8vIHNob3cgcHJvZ3Jlc3MgY3Vyc29yIGZvciAoYXQgbGVhc3QpIDEvMyBzZWNvbmRcbiAgICAgICAgc3R5bGUgPSB0aGlzLmVsLnN0eWxlO1xuICAgICAgICBzdHlsZS5jdXJzb3IgPSAncHJvZ3Jlc3MnO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBzdHlsZS5jdXJzb3IgPSBudWxsOyB9LCAzMzMpO1xuXG4gICAgICAgIGlmIChtb2RlLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICBvcHRncm91cCA9IGRyb3Bkb3duLnF1ZXJ5U2VsZWN0b3IobW9kZS5zZWxlY3Rvcik7XG4gICAgICAgICAgICBzdW0gPSBtb2RlLmFwcGVuZE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRncm91cCk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzdW1cbiAgICAgICAgICAgIG9wdGdyb3VwLmxhYmVsID0gb3B0Z3JvdXAubGFiZWwucmVwbGFjZSgvIFxcKFxcZCtcXCkkLywgJycpOyAvLyByZW1vdmUgb2xkIHN1bVxuICAgICAgICAgICAgb3B0Z3JvdXAubGFiZWwgKz0gJyAoJyArIHN1bSArICcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1bSA9IG1vZGUuYXBwZW5kT3B0aW9ucy5jYWxsKHRoaXMsIGRyb3Bkb3duKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250cm9sbGFibGUpIHtcbiAgICAgICAgICAgICAgICBjdHJsLnRleHRDb250ZW50ID0gc3VtICsgJyB2YWx1ZXMnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGlzcGxheSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGxheSA9ICdub25lJztcbiAgICB9XG5cbiAgICAvLyBoaWRlL3Nob3cgdGhlIGdyb3VwXG4gICAgdmFyIHNlbGVjdG9yID0gbW9kZS5zZWxlY3RvcjtcbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHNlbGVjdG9yID0gJ29wdGlvbixvcHRncm91cDpub3QoW2NsYXNzXSknO1xuICAgICAgICB2YXIgbXVzdEJlQ2hpbGRyZW4gPSB0cnVlOyAvLyB3b3JrLWFyb3VuZCBmb3IgJzpzY29wZT5vcHRpb24sLi4uJyBub3QgYXZhaWwgaW4gSUUxMVxuICAgIH1cbiAgICBlbGZvci5lYWNoKHNlbGVjdG9yLCBpdGVyYXRlZSwgZHJvcGRvd24pO1xuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWUoZWwpIHtcbiAgICAgICAgaWYgKCFtdXN0QmVDaGlsZHJlbiB8fCBlbC5wYXJlbnRFbGVtZW50ID09PSBkcm9wZG93bikge1xuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBSZXNldCB0aGUgd2lkdGggb2YgdGhpcy5vcHRpb25zIHRvIHRoZSBuYXR1cmFsIHdpZHRoIG9mIHRoaXMuZHJvcGRvd24uIFRvIGRvIHRoaXMsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBsYXR0ZXIncyBcIndpZHRoOiAxMDAlXCIgZnJvbSB0aGUgQ1NTIGFuZCB0aGVuIHNldCBhbiBleHBsaWNpdCB0aGlzLm9wdGlvbnMuc3R5bGUud2lkdGggYmFzZWQgb24gdGhlIGNvbXB1dGVkIHdpZHRoIG9mIHRoaXMuZHJvcGRvd24uIFRoaXMgaXMgY29tcGxpY2F0ZWQgYnkgdGhlIGZhY3QgdGhhdCBpdCBjYW5ub3QgYmUgZG9uZSBiZWZvcmUgaXQgaXMgaW4gdGhlIERPTS5cbn1cblxuZnVuY3Rpb24gc2xpZGVEb3duKCkge1xuICAgIC8vIHByZXNlcnZlIHRoZSB0ZXh0IGJveCdzIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24sIHdoaWNoIGlzIGFib3V0IHRvIGJlIGxvc3RcbiAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gdGhpcy5pbnB1dC5zZWxlY3Rpb25TdGFydDtcbiAgICB0aGlzLnNlbGVjdGlvbkVuZCA9IHRoaXMuaW5wdXQuc2VsZWN0aW9uRW5kO1xuXG4gICAgLy8gY2xlYW4gdXAgdGhlIHNlbGVjdCBsaXN0IGZyb20gbGFzdCB1c2FnZVxuICAgIHRoaXMuZHJvcGRvd24uc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBiZSBraW5kIChyZW1vdmUgcHJldmlvdXMgc2VsZWN0aW9uKVxuICAgIHRoaXMuZHJvcGRvd24uc3R5bGUuc2Nyb2xsVG9wID0gMDsgLy8gcmV3aW5kXG5cbiAgICAvLyBzaG93IHRoZSBkcm9wLWRvd24gc2xpZGUgZG93biBlZmZlY3RcbiAgICB0aGlzLm9wdGlvbnMuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB2YXIgZHJvcERvd25Ub3BNYXJnaW4gPSBnZXRGbG9hdCh0aGlzLmRyb3Bkb3duLCAnbWFyZ2luVG9wJyksXG4gICAgICAgIGRyb3BEb3duUm93cyA9IHRoaXMuZHJvcGRvd24uc2l6ZSxcbiAgICAgICAgb3B0aW9uSGVpZ2h0ID0gTWF0aC5jZWlsKCh0aGlzLmRyb3Bkb3duLmxlbmd0aCA/IGdldEZsb2F0KHRoaXMuZHJvcGRvd25bMF0sICdoZWlnaHQnKSA6IDEzLjE4NzUpICogMikgLyAyICsgMTtcbiAgICB0aGlzLm9wdGlvbnMuc3R5bGUuaGVpZ2h0ID0gZHJvcERvd25Ub3BNYXJnaW4gKyBvcHRpb25IZWlnaHQgKiBkcm9wRG93blJvd3MgKyAncHgnOyAvLyBzdGFydHMgdGhlIHNsaWRlIGRvd24gZWZmZWN0XG5cbiAgICAvLyB3aGlsZSBpbiBkcm9wLWRvd24sIGxpc3RlbiBmb3IgY2xpY2tzIGluIHRleHQgYm94IHdoaWNoIG1lYW5zIGFicHJ0XG4gICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLnNsaWRlVXBCb3VuZCA9IHNsaWRlVXAuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3YWl0IGZvciB0cmFuc2l0aW9uIHRvIGVuZFxuICAgIHRoaXMub3B0aW9uc1RyYW5zaXRpb24uYmVnaW4oKTtcbn1cblxuZnVuY3Rpb24gc2xpZGVVcCgpIHtcbiAgICAvLyBzdG9wIGxpc3RlbmluZyB0byBpbnB1dCBjbGlja3NcbiAgICB0aGlzLmlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuc2xpZGVVcEJvdW5kKTtcblxuICAgIC8vIHN0YXJ0IHRoZSBzbGlkZSB1cCBlZmZlY3RcbiAgICB0aGlzLm9wdGlvbnMuc3R5bGUuaGVpZ2h0ID0gMDtcblxuICAgIC8vIHNjaGVkdWxlIHRoZSBoaWRlIHRvIG9jY3VyIGFmdGVyIHRoZSBzbGlkZSB1cCBlZmZlY3RcbiAgICB0aGlzLm9wdGlvbnNUcmFuc2l0aW9uLmJlZ2luKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRGbG9hdChlbCwgc3R5bGUpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbClbc3R5bGVdKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbWJvQm94O1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxFZGl0b3IgPSByZXF1aXJlKCcuL0NlbGxFZGl0b3InKTtcblxudmFyIGlzQ2hyb21pdW0gPSB3aW5kb3cuY2hyb21lLFxuICAgIHdpbk5hdiA9IHdpbmRvdy5uYXZpZ2F0b3IsXG4gICAgdmVuZG9yTmFtZSA9IHdpbk5hdi52ZW5kb3IsXG4gICAgaXNPcGVyYSA9IHdpbk5hdi51c2VyQWdlbnQuaW5kZXhPZignT1BSJykgPiAtMSxcbiAgICBpc0lFZWRnZSA9IHdpbk5hdi51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID4gLTEsXG4gICAgaXNJT1NDaHJvbWUgPSB3aW5OYXYudXNlckFnZW50Lm1hdGNoKCdDcmlPUycpLFxuICAgIGlzQ2hyb21lID0gIWlzSU9TQ2hyb21lICYmXG4gICAgICAgIGlzQ2hyb21pdW0gIT09IG51bGwgJiZcbiAgICAgICAgaXNDaHJvbWl1bSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHZlbmRvck5hbWUgPT09ICdHb29nbGUgSW5jLicgJiZcbiAgICAgICAgaXNPcGVyYSA9PSBmYWxzZSAmJiBpc0lFZWRnZSA9PSBmYWxzZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblxuLyoqXG4gKiBBcyBvZiBzcHJpbmcgMjAxNjpcbiAqIEZ1bmN0aW9ucyB3ZWxsIGluIENocm9tZSBleGNlcHQgbm8gbG9jYWxpemF0aW9uIChkYXksIG1vbnRoIG5hbWVzOyBkYXRlIGZvcm1hdCkuXG4gKiBVbmltcGxlbWVudGVkIGluIFNhZmFyaSwgRmlyZWZveCwgSW50ZXJuZXQgRXhwbG9yZXIuXG4gKiBUaGlzIGlzIGEgXCJzbm1hcnRcIiBjb250cm9sLiBJdCBkZXRlY3RzIENocm9tZTpcbiAqICogSWYgQ2hyb21lLCB1c2VzIGNocm9tZURhdGUgb3ZlcnJpZGVzIGZvcm1hdCB0byB0aGF0IHJlcXVpcmVkIGJ5IHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIHl5eXktbW0tZGQuIChOb3RlIHRoYXQgdGhpcyBpcyBub3QgdGhlIGZvcm1hdCBkaXNwbGF5ZWQgaW4gdGhlIGNvbnRyb2wsIHdoaWNoIGlzIGFsd2F5cyBtbS9kZC95eXl5LilcbiAqICogT3RoZXJ3aXNlIHVzZXMgbG9jYWxpemVkIGRhdGUgZm9ybWF0IF9idXRfIGZhbGxzIGJhY2sgdG8gYSByZWd1bGFyIHRleHQgYm94LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsRWRpdG9yXG4gKi9cbnZhciBEYXRlID0gQ2VsbEVkaXRvci5leHRlbmQoJ0RhdGUnLCB7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7XG5cbiAgICAgICAgdmFyIGxvY2FsaXplck5hbWUsXG4gICAgICAgICAgICB1c2VzRGF0ZUlucHV0Q29udHJvbCA9IGlzQ2hyb21lO1xuXG4gICAgICAgIGlmICh1c2VzRGF0ZUlucHV0Q29udHJvbCkge1xuICAgICAgICAgICAgbG9jYWxpemVyTmFtZSA9ICdjaHJvbWVEYXRlJztcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSAnPGlucHV0IHR5cGU9XCJkYXRlXCI+JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvY2FsaXplck5hbWUgPSAnZGF0ZSc7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gJzxpbnB1dCB0eXBlPVwidGV4dFwiIGxhbmc9XCJ7e2xvY2FsZX19XCI+JztcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3RBbGwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdENoYXJQbHVzT25lID0gdGhpcy5nZXRFZGl0b3JWYWx1ZSgpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKDAsIGxhc3RDaGFyUGx1c09uZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sb2NhbGl6ZXIgPSBncmlkLmxvY2FsaXphdGlvbi5nZXQobG9jYWxpemVyTmFtZSk7XG4gICAgfVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRlO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBvcE1lbnUgPSByZXF1aXJlKCdwb3AtbWVudScpO1xuXG52YXIgQ29tYm9Cb3ggPSByZXF1aXJlKCcuL0NvbWJvQm94Jyk7XG52YXIgcHJvdG90eXBlID0gcmVxdWlyZSgnLi9DZWxsRWRpdG9yJykucHJvdG90eXBlO1xuXG5cbi8qKlxuICogVGhlIHNlbGVjdCBsaXN0IGNvbnNpc3RzIG9mIHRoZSBmb2xsb3dpbmcgc2V0cyBvZiBkcm9wLWRvd24gaXRlbXM6XG4gKiAqIGBvcGVyYXRvcnNgIChpY29uICombHQ7KikgVGhlIHBhcnRpY3VsYXIgc2VsZWN0aW9uIG9mIG9wZXJhdG9ycyBmb3IgdGhpcyBjb2x1bW4uIENvbWVzIGZyb20gdGhlIGZpbHRlciB0cmVlLlxuICogKiBgZGlzdGluY3RWYWx1ZXNgIChpY29uICojKikgTGlzdCBvZiBkaXN0aW5jdCBjb2x1bW4gdmFsdWVzLiBDYWxjdWxhdGVkIGZyb20gaW5zcGVjdGlvbiBvZiBjb2x1bW4gdmFsdWVzIG9uIF9hbmRfIG9uIGljb24gY2xpY2suXG4gKiAqIGBjb2x1bW5OYW1lc2AgKGljb24gKlQqKSBMaXN0IG90aGVyIGNvbHVtbiBuYW1lcy4gQ2FsY3VsYXRlZCBmcm9tIGluc3BlY3Rpb24gb2YgY29sdW1uIHZhbHVlcyBvbiBfYW5kXyBvbiBpY29uIGNsaWNrLlxuICpcbiAqIFRoZSBjb250cm9sIGFyZWEgcmVmbGVjdHMgdGhlIGB0aGlzLm1vZGVzYCBhcnJheSAoYWJvdmUpLiBJdCBpcyBtb2RlbGVkIGJ5IGEgJ21lbnVNb2Rlc2Agb2JqZWN0LCBhIGhhc2ggd2l0aCBib29sZWFuIHByb3BlcnRpZXMgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiBlYWNoIG9mIHRoZSBzZXRzIG9mIG1lbnUgaXRlbXMgb3V0bGluZWQgYWJvdmUuIE1pc3NpbmcgcHJvcGVydGllcyBhcmUgZmFsc3kgYnkgaW1wbGljYXRpb24uIFRoZSBzdGF0ZSBzZW1hbnRpY3MgYXJlOlxuICogICAqIGAxYCBvciBgdHJ1ZWAgbWVhbnMgYWRkcyBDU1MgY2xhc3MgYGFjdGl2ZWAgdG8gaWNvbiBfYW5kXyBzaG93cyBzZXQncyBpdGVtcyBpbiBkcm9wLWRvd24uXG4gKiAgICogYDBgIG9yIGBmYWxzZWAgbWVhbnMgcmVtb3ZlcyAoQ1NTIGNsYXNzIGBhY3RpdmVgIGZyb20gaWNvbiBfYW5kXyBoaWRlcyBzZXQncyBpdGVtcyBpbiBkcm9wLWRvd24uXG4gKlxuICogKlBlcnNpc3RpbmcgY2hhbmdlczoqIFRoZSBvbmx5IGNoYW5nZSB0aGlzIFVJIHN1cHBvcnRzIChiZXNpZGVzIHRoZSBmaWx0ZXIgdGV4dCBpdHNlbGYpIGlzIHRoZSBtZW51IG1vZGUgc3RhdGVzLCB3aGljaCBhcmUgZXhwZWN0ZWQgdG8gYmUgXCJzdGlja3kuXCIgVGhhdCBpcywgdGhleSBhcmUgXCJwZXJzaXN0ZWRcIiAod3JpdHRlbiBiYWNrKSB0byB0aGUgZmlsdGVyLiBIb3dldmVyLCB0aGVyZSBpcyBhIHByb2JsZW06IFdoZW4gdGhlIGNvbHVtbiBmaWx0ZXIgaXMgYmxhbmsgaXQgZG9lc24ndCBhY3R1YWxseSBleGlzdCB5ZXQgaW4gdGhlIGZpbHRlciwgc28gdGhlcmUgaXMgbm93aGVyZSB0byBzYXZlIGl0LiBUaGUgc29sdXRpb24gaXMgdG8gcmVhZCB0aGUgYG1lbnVNb2Rlc2AgaGFzaCBfZnJvbV8gdGhlIGZpbHRlciB0cmVlIGJ1dCBkb24ndCBtb2RpZnkgaXQgdW50aWwgZW5kIG9mIGVkaXRpbmcuIFJlYWRpbmcgaXQgZnJvbSB0aGUgZmlsdGVyIHRyZWUgcGlja3MgdXAgcHJldmlvdXMgc2V0dGluZyBpZiB0aGVyZSB3YXMgYW4gZXh0YW50IGNvbHVtbiBmaWx0ZXIgb3IgdGhlIGRlZmF1bHQgaWYgdGhlcmUgd2FzIG5vdC4gQnV0IHRoZW4sIHJhdGhlciB0aGFuIG1vZGlmeWluZyB0aGlzIHN0cnVjdHVyZSAoYmVjYXVzZSBpdCBtaWdodCBiZSB0aGUgZGVmYXVsdCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgdGhhdCksIHdlIGhhbmcgYSBwcm94eSBjb3B5IG9mZiB0aGUgYmVoYXZpb3IncyBjb2x1bW4gb2JqZWN0IGZvciB0aGlzIGNvbHVtbi4gVGhpcyB3aWxsIHBlcnNpc3QgaXQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYXBwIHNlc3Npb24uIEF0IGVuZCBvZiBlZGl0aW5nLCBpZiBhbmQgb25seSBpZiB0aGVyZSBpcyBub3cgYSBjb2x1bW4gZmlsdGVyICh0ZXh0IGlzIG5vdCBibGFuayksIHdlIGNvcHkgaXQgdG8gdGhlIGNvbHVtbiBmaWx0ZXIncyBzdWJ0cmVlIG5vZGUgaW4gdGhlIGZpbHRlciB0cmVlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ29tYm9Cb3hcbiAqL1xudmFyIEZpbHRlckJveCA9IENvbWJvQm94LmV4dGVuZCgnRmlsdGVyQm94Jywge1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gbG9vayBpbiB0aGUgZmlsdGVyLCB1bmRlciBjb2x1bW4gZmlsdGVycywgZm9yIGEgY29sdW1uIGZpbHRlciBmb3IgdGhpcyBjb2x1bW5cbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmdyaWQuYmVoYXZpb3IuZmlsdGVyLFxuICAgICAgICAgICAgY29sdW1uRmlsdGVycyA9IHJvb3QgJiYgcm9vdC5jb2x1bW5GaWx0ZXJzO1xuXG4gICAgICAgIGlmICghY29sdW1uRmlsdGVycykge1xuICAgICAgICAgICAgdGhyb3cgJ0NvbHVtbiBmaWx0ZXJzIG5vdCBhdmFpbGFibGUuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2x1bW5OYW1lID0gdGhpcy5jb2x1bW4ubmFtZSxcbiAgICAgICAgICAgIGNvbHVtbkZpbHRlclN1YnRyZWUgPSByb290LmdldENvbHVtbkZpbHRlcihjb2x1bW5OYW1lKSB8fCB7fSxcbiAgICAgICAgICAgIGNvbHVtblNjaGVtYSA9IHJvb3Quc2NoZW1hLmxvb2t1cChjb2x1bW5OYW1lKSB8fCB7fTtcblxuXG4gICAgICAgIC8vIGdldCB0aGUgb3BlcmF0b3IgbGlzdCBmcm9tIHRoZSBub2RlLCBzY2hlbWEsIHR5cGVPcE1hcCwgb3Igcm9vdDpcbiAgICAgICAgLy8gKFRoaXMgbWltaWNzIHRoZSBjb2RlIGluIEZpbHRlckxlYWYuanMncyBgZ2V0T3BNZW51YCBmdW5jdGlvbiBiZWNhdXNlIHRoZSBub2RlIG1heSBub3QgZXhpc3QgeWV0LilcbiAgICAgICAgdGhpcy5vcE1lbnUgPVxuXG4gICAgICAgICAgICAvLyBwdWxsIG9wZXJhdG9yIGxpc3QgZnJvbSBjb2x1bW4gc2NoZW1hIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgY29sdW1uU2NoZW1hLm9wTWVudSB8fFxuXG4gICAgICAgICAgICAvLyBvcGVyYXRvciBsaXN0IGZvciB0aGUgY29sdW1uJ3MgdHlwZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIHJvb3QudHlwZU9wTWFwICYmIHJvb3QudHlwZU9wTWFwW2NvbHVtblNjaGVtYS50eXBlIHx8IGNvbHVtbkZpbHRlclN1YnRyZWUudHlwZV0gfHxcblxuICAgICAgICAgICAgLy8gZGVmYXVsdCBvcGVyYXRvciBsaXN0ICh3aGljaCBpdHNlbGYgZGVmYXVsdHMgdG8gYENvbmRpdGlvbmFscy5kZWZhdWx0T3BNZW51YClcbiAgICAgICAgICAgIHJvb3Qub3BNZW51O1xuXG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjb2x1bW4gZmlsdGVyJ3MgYG1lbnVNb2Rlc2Agb2JqZWN0IC0tIGNvbnRhaW5zIHRoZSBzdGF0ZXMgb2YgdGhlIGRyb3AtZG93biBvcHRpb24gaWNvbnM6XG4gICAgICAgIHRoaXMubWVudU1vZGVzU291cmNlID1cblxuICAgICAgICAgICAgLy8gZmlyc3QgdHJ5IHByb3h5IGZyb20gbGFzdCB0aW1lIChiZWNhdXNlIGVkaXRpbmcgbWF5IGhhdmUgZW5kZWQgd2l0aG91dCBhIGNvbHVtbiBmaWx0ZXIgdG8gcHV0IGluIHRoZSBmaWx0ZXIgdHJlZSlcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLm1lbnVNb2RlcyB8fFxuXG4gICAgICAgICAgICAvLyBFTFNFIHRyeSBjb2x1bW4gZmlsdGVyJ3MgYG1lbnVNb2Rlc2AgV0hFTiBhdmFpbGFibGVcbiAgICAgICAgICAgIGNvbHVtbkZpbHRlclN1YnRyZWUubWVudU1vZGVzIHx8XG5cbiAgICAgICAgICAgIC8vIHRyeSB1c2UgY29sdW1uIHNjaGVtYSdzIGBtZW51TW9kZXNgIHdoZW4gZGVmaW5lZFxuICAgICAgICAgICAgY29sdW1uU2NoZW1hLm1lbnVNb2RlcyB8fFxuXG4gICAgICAgICAgICAvLyBFTFNFIHRyeSB0aGUgZmlsdGVyIGRlZmF1bHQgKHdoaWNoIGl0c2VsZiBkZWZhdWx0cyB0byBvcGVyYXRvcnMgT04sIG90aGVycyBPRkY7IHNlZSBkZWZpbml0aW9uIGF0IHRvcCBvZiBEZWZhdWx0RmlsdGVyLmpzKVxuICAgICAgICAgICAgY29sdW1uRmlsdGVycy5tZW51TW9kZXM7XG5cbiAgICB9LFxuXG4gICAgYWJvcnRFZGl0aW5nOiBwcm90b3R5cGUuY2FuY2VsRWRpdGluZyxcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlcmUncyBvbmx5IG9uZSBtb2RlIGRlZmluZWQgaGVyZSwgdGhlIGNvbnRyb2wgYXJlYSBwb3J0aW9uIG9mIHRoZSBVSSBpcyBoaWRkZW4uXG4gICAgICovXG4gICAgbW9kZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ29wZXJhdG9ycycsXG4gICAgICAgICAgICBzeW1ib2w6ICc8JyxcbiAgICAgICAgICAgIGFwcGVuZE9wdGlvbnM6IGZ1bmN0aW9uKGRyb3Bkb3duKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkcm9wZG93bi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFyaW91cyAgb3BlcmF0b3Igb3B0aW9ucyBhbmQvb3Igb3B0Z3JvdXBzIHZhcnkgcGVyIGNvbHVtbiBiYXNlZCBvbiBgb3BNZW51YC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wTWVudUdyb3VwcyA9IHRoaXMuZ3JpZC5iZWhhdmlvci5maWx0ZXIub3BNZW51R3JvdXBzO1xuICAgICAgICAgICAgICAgICAgICBwb3BNZW51LmJ1aWxkKGRyb3Bkb3duLCB0aGlzLm9wTWVudSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IGZ1bmN0aW9uKGdyb3VwTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcE1lbnVHcm91cHNbZ3JvdXBOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9tcHQ6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbGlzdCBvZiBjb25qdW5jdGlvbnMgaXMgYW4gZXh0cmEgYW5kIGlzIGZvciBhbGwgY29sdW1ucy4gQWxsIG9wZXJhdG9yIG9wdGdyb3VwcyBhcmUgY2xhc3NsZXNzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0Z3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRncm91cCcpO1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cC5sYWJlbCA9ICdDb25qdW5jdGlvbnMnO1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cC5hcHBlbmRDaGlsZChuZXcgT3B0aW9uKCdhbmQnLCAnIGFuZCAnKSk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLmFwcGVuZENoaWxkKG5ldyBPcHRpb24oJ29yJywgJyBvciAnKSk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwLmFwcGVuZENoaWxkKG5ldyBPcHRpb24oJ25vcicsICcgbm9yICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6ICdjb2x1bW5OYW1lcycsXG4gICAgICAgICAgICBsYWJlbDogJ0NvbHVtbiBOYW1lcycsXG4gICAgICAgICAgICBzZWxlY3RvcjogJ29wdGdyb3VwLnN1Ym1lbnUtY29sdW1uTmFtZXMnLFxuICAgICAgICAgICAgc3ltYm9sOiAnQScsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZWZmJyxcbiAgICAgICAgICAgIGFwcGVuZE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmdyaWQuYmVoYXZpb3IuY29sdW1ucyxcbiAgICAgICAgICAgICAgICAgICAgeCA9IHRoaXMuZXZlbnQuZ3JpZENlbGwueDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChvcHRncm91cC5maXJzdEVsZW1lbnRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cC5maXJzdEVsZW1lbnRDaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gY29sdW1uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gbmV3IE9wdGlvbihuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi50aXRsZSA9ICdbJyArIG5hbWUgKyAnXVxcclwiJyArIGNvbHVtbi5oZWFkZXIgKyAnXCInO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXAuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogJ2Rpc3RpbmN0VmFsdWVzJyxcbiAgICAgICAgICAgIGxhYmVsOiAnRGlzdGluY3QgVmFsdWVzJyxcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnb3B0Z3JvdXAuc3VibWVudS1kaXN0aW5jdFZhbHVlcycsXG4gICAgICAgICAgICBzeW1ib2w6ICcjJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZWYnLFxuICAgICAgICAgICAgYXBwZW5kT3B0aW9uczogQ29tYm9Cb3gucHJvdG90eXBlLm1vZGVzWzBdLmFwcGVuZE9wdGlvbnNcbiAgICAgICAgfVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGUgYG1lbnVNb2Rlc2AgcHJveHkgdG8gdGhlIGZpbHRlciB0cmVlJ3MgY29sdW1uIGZpbHRlciBzdWJ0cmVlIG5vZGUuXG4gICAgICogV2UgbG9vayB1cCB0aGUgbm9kZSBhZ2FpbiBoZXJlIGJlY2F1c2UgaXQgbWlnaHQgYmUgbmV3OyBvciBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQgJiByZWNyZWF0ZWQgZHVyaW5nIGVkaXRpbmcuXG4gICAgICovXG4gICAgaGlkZUVkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGxvb2sgaW4gdGhlIGZpbHRlciwgdW5kZXIgY29sdW1uIGZpbHRlcnMsIGZvciBhIGNvbHVtbiBmaWx0ZXIgZm9yIHRoaXMgY29sdW1uXG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmdyaWQuYmVoYXZpb3IuZmlsdGVyLFxuICAgICAgICAgICAgY29sdW1uTmFtZSA9IHRoaXMuY29sdW1uLm5hbWUsXG4gICAgICAgICAgICBjb2x1bW5GaWx0ZXJTdWJ0cmVlID0gZmlsdGVyLmdldENvbHVtbkZpbHRlcihjb2x1bW5OYW1lKTtcblxuICAgICAgICBpZiAoY29sdW1uRmlsdGVyU3VidHJlZSkge1xuICAgICAgICAgICAgLy8gd3JpdGUgYmFjayB0byBmaWx0ZXItdHJlZSBub2RlIGZvciBwZXJzaXN0aW5nIHdpdGggZ2V0U3RhdGVcbiAgICAgICAgICAgIGNvbHVtbkZpbHRlclN1YnRyZWUubWVudU1vZGVzID0gdGhpcy5tZW51TW9kZXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbHVtbi5tZW51TW9kZXMgPSB0aGlzLm1lbnVNb2RlcztcblxuICAgICAgICBDb21ib0JveC5wcm90b3R5cGUuaGlkZUVkaXRvci5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICBrZXl1cDogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgcHJvdG90eXBlLmtleXVwLmNhbGwodGhpcywgZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmdyaWQucHJvcGVydGllcy5maWx0ZXJpbmdNb2RlID09PSAnaW1tZWRpYXRlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2F2ZUVkaXRvclZhbHVlKHRoaXMuZ2V0RWRpdG9yVmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlRWRpdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5zZXJ0VGV4dDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgZW5kID0gdGhpcy5zZWxlY3Rpb25FbmQsXG4gICAgICAgICAgICBkcm9wZG93biA9IHRoaXMuZHJvcGRvd24sXG4gICAgICAgICAgICBvcGVyYXRvciA9IGRyb3Bkb3duLnZhbHVlLFxuICAgICAgICAgICAgb3B0aW9uID0gZHJvcGRvd24ub3B0aW9uc1tkcm9wZG93bi5zZWxlY3RlZEluZGV4XSxcbiAgICAgICAgICAgIG9wdGdyb3VwID0gb3B0aW9uLnBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICBpc09wZXJhdG9yID0gIShvcHRncm91cC50YWdOYW1lID09PSAnT1BUR1JPVVAnICYmIG9wdGdyb3VwLmNsYXNzTmFtZSk7XG5cbiAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuXG4gICAgICAgIGlmIChzdGFydCA9PT0gZW5kICYmIGlzT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZXIgPSB0aGlzLmdyaWQuYmVoYXZpb3IuZmlsdGVyLnBhcnNlckNRTCxcbiAgICAgICAgICAgICAgICBjcWwgPSB0aGlzLmlucHV0LnZhbHVlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcGFyc2VyLmdldE9wZXJhdG9yUG9zaXRpb24oY3FsLCB0aGlzLnNlbGVjdGlvblN0YXJ0LCBvcGVyYXRvcik7XG5cbiAgICAgICAgICAgIHN0YXJ0ID0gcG9zaXRpb24uc3RhcnQ7XG4gICAgICAgICAgICBlbmQgPSBwb3NpdGlvbi5lbmQ7XG5cbiAgICAgICAgICAgIC8vIHByZXBlbmQgc3BhY2UgdG8gb3BlcmF0b3IgYXMgbmVlZGVkXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RhcnQgPiAwICYmIC8vIG5vdCBhdCB2ZXJ5IGJlZ2lubmluZz8gYW5kLi4uXG4gICAgICAgICAgICAgICAgIS9cXHMvLnRlc3QoY3FsW3N0YXJ0IC0gMV0pIC8vIG5vIHdoaXRlIHNwYWNlIGJlZm9yZSBvcGVyYXRvcj9cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gJyAnICsgb3BlcmF0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFwcGVuZCBzcGFjZSB0byBvcGVyYXRvciBhcyBuZWVkZWRcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBlbmQgPT09IGNxbC5sZW5ndGggfHwgLy8gYXQgdmVyeSBlbmQ/IG9yLi4uXG4gICAgICAgICAgICAgICAgIS9cXHMvLnRlc3QoY3FsW2VuZF0pIC8vIG5vIHdoaXRlIHNwYWNlIGFmdGVyIG9wZXJhdG9yP1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgKz0gJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5zZXJ0IHRoZSBkcm9wLWRvd24gdGV4dCBhdCB0aGUgaW5zZXJ0aW9uIHBvaW50IG9yIG92ZXIgdGhlIHNlbGVjdGVkIHRleHRcbiAgICAgICAgdGhpcy5pbnB1dC5zZXRSYW5nZVRleHQob3BlcmF0b3IsIHN0YXJ0LCBlbmQsICdlbmQnKTtcblxuICAgICAgICAvLyBjbG9zZSB0aGUgZHJvcC1kb3duXG4gICAgICAgIHRoaXMudG9nZ2xlRHJvcERvd24oKTtcbiAgICB9LFxuXG4gICAgc2F2ZUVkaXRvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBwcm90b3R5cGUuc2F2ZUVkaXRvclZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICB0aGlzLmdyaWQuYmVoYXZpb3IuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9XG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyQm94O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgVGV4dGZpZWxkID0gcmVxdWlyZSgnLi9UZXh0ZmllbGQnKTtcblxuLyoqXG4gKiBGdW5jdGlvbnMgd2VsbCBpbiBDaHJvbWUsIFNhZmFyaSwgRmlyZWZveCwgYW5kIEludGVybmV0IEV4cGxvcmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBUZXh0ZmllbGRcbiAqL1xudmFyIE51bWJlciA9IFRleHRmaWVsZC5leHRlbmQoJ051bWJlcicsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5sb2NhbGl6ZXIgPSBncmlkLmxvY2FsaXphdGlvbi5nZXQoJ251bWJlcicpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbEVkaXRvclxuICovXG52YXIgU2xpZGVyID0gQ2VsbEVkaXRvci5leHRlbmQoJ1NsaWRlcicsIHtcblxuICAgIHRlbXBsYXRlOiAnPGlucHV0IHR5cGU9XCJyYW5nZVwiIGxhbmc9XCJ7e2xvY2FsZX19XCIgc3R5bGU9XCJ7e3N0eWxlfX1cIj4nXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNsaWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxFZGl0b3IgPSByZXF1aXJlKCcuL0NlbGxFZGl0b3InKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxFZGl0b3JcbiAqL1xudmFyIFNwaW5uZXIgPSBDZWxsRWRpdG9yLmV4dGVuZCgnU3Bpbm5lcicsIHtcblxuICAgIHRlbXBsYXRlOiAnPGlucHV0IHR5cGU9XCJudW1iZXJcIiBsYW5nPVwie3tsb2NhbGV9fVwiIHN0eWxlPVwie3tzdHlsZX19XCI+J1xuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcGlubmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbEVkaXRvciA9IHJlcXVpcmUoJy4vQ2VsbEVkaXRvcicpO1xudmFyIExvY2FsaXphdGlvbiA9IHJlcXVpcmUoJy4uL2xpYi9Mb2NhbGl6YXRpb24nKTtcblxuXG4vKipcbiAqIEFzIG9mIHNwcmluZyAyMDE2OlxuICogRnVuY3Rpb25zIHdlbGwgaW4gQ2hyb21lLCBTYWZhcmksIEZpcmVmb3gsIGFuZCBJbnRlcm5ldCBFeHBsb3Jlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbEVkaXRvclxuICovXG52YXIgVGV4dGZpZWxkID0gQ2VsbEVkaXRvci5leHRlbmQoJ1RleHRmaWVsZCcsIHtcblxuICAgIHRlbXBsYXRlOiAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbGFuZz1cInt7bG9jYWxlfX1cIiBjbGFzcz1cImh5cGVyZ3JpZC10ZXh0ZmllbGRcIiBzdHlsZT1cInt7c3R5bGV9fVwiPicsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5zdHlsZS50ZXh0QWxpZ24gPSB0aGlzLmV2ZW50LmdldENlbGxQcm9wZXJ0eSgnaGFsaWduJyk7XG4gICAgfSxcblxuICAgIGxvY2FsaXplcjogTG9jYWxpemF0aW9uLnByb3RvdHlwZS5zdHJpbmcsXG5cbiAgICBzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKDAsIHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0ZmllbGQ7XG4iLCIvKipcbiAqIEBtb2R1bGUgY2VsbEVkaXRvcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcml2YXRlUmVnaXN0cnk9ZmFsc2VdIC0gVGhpcyBpbnN0YW5jZSB3aWxsIHVzZSBhIHByaXZhdGUgcmVnaXN0cnkuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ2VsbEVkaXRvcnMoZ3JpZCwgcHJpdmF0ZVJlZ2lzdHJ5KSB7XG4gICAgdGhpcy5ncmlkID0gZ3JpZDtcblxuICAgIGlmIChwcml2YXRlUmVnaXN0cnkpIHtcbiAgICAgICAgdGhpcy5lZGl0b3JzID0ge307XG4gICAgfVxuXG4gICAgLy8gcHJlcmVnaXN0ZXIgdGhlIHN0YW5kYXJkIGNlbGwgZWRpdG9yc1xuICAgIGlmIChwcml2YXRlUmVnaXN0cnkgfHwgIXRoaXMuZ2V0KCdjZWxsZWRpdG9yJykpIHtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9DZWxsRWRpdG9yJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0NvbWJvQm94JykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0NvbG9yJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0RhdGUnKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vRmlsdGVyQm94JykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL051bWJlcicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9TbGlkZXInKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vU3Bpbm5lcicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9UZXh0ZmllbGQnKSk7XG4gICAgfVxufVxuXG5DZWxsRWRpdG9ycy5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENlbGxFZGl0b3JzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciwgLy8gcHJlc2VydmUgY29uc3RydWN0b3JcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIGEgY2VsbCBlZGl0b3IgY29uc3RydWN0b3IuXG4gICAgICogQGRlc2MgQWRkcyBhIGN1c3RvbSBjZWxsIGVkaXRvciBjb25zdHJ1Y3RvciB0byB0aGUgYGVkaXRvcnNgIGhhc2ggdXNpbmcgdGhlIHByb3ZpZGVkIG5hbWUgKG9yIHRoZSBjbGFzcyBuYW1lKSwgY29udmVydGVkIHRvIGFsbCBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogPiBBbGwgbmF0aXZlIGNlbGwgZWRpdG9ycyBhcmUgXCJwcmVyZWdpc3RlcmVkXCIgaW4gYGVkaXRvcnNgLi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSBDYXNlLWluc2Vuc2l0aXZlIGVkaXRvciBrZXkuIElmIG5vdCBnaXZlbiwgYFlvdXJDZWxsRWRpdG9yLnByb3RvdHlwZS4kJENMQVNTX05BTUVgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1lvdXJDZWxsRWRpdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcn0gQ29uc3RydWN0b3IgLSBBIGNvbnN0cnVjdG9yLCB0eXBpY2FsbHkgZXh0ZW5kZWQgZnJvbSBgQ2VsbEVkaXRvcmAgKG9yIGEgZGVzY2VuZGFudCB0aGVyZWZyb20pLlxuICAgICAqXG4gICAgICogPiBOb3RlOiBgJCRDTEFTU19OQU1FYCBjYW4gYmUgZWFzaWx5IHNldCB1cCBieSBwcm92aWRpbmcgYSBzdHJpbmcgYXMgdGhlIChvcHRpb25hbCkgZmlyc3QgcGFyYW1ldGVyIChgYWxpYXNgKSBpbiB5b3VyIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9leHRlbmQtbWV8Q2VsbEVkaXRvci5leHRlbmR9IGNhbGwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q2VsbEVkaXRvcn0gQSBuZXdseSByZWdpc3RlcmVkIGNvbnN0cnVjdG9yIGV4dGVuZGVkIGZyb20ge0BsaW5rIENlbGxFZGl0b3J9LlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpjZWxsRWRpdG9yc1xuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24obmFtZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBDb25zdHJ1Y3RvciA9IG5hbWU7XG4gICAgICAgICAgICBuYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgQ29uc3RydWN0b3IucHJvdG90eXBlLiQkQ0xBU1NfTkFNRTtcbiAgICAgICAgbmFtZSA9IG5hbWUgJiYgbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLmVkaXRvcnNbbmFtZV0gPSBDb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBSZWdpc3RlciBhIHN5bm9ueW0gZm9yIGFuIGV4aXN0aW5nIGNlbGwgZWRpdG9yIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzeW5vbnltTmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleGlzdGluZ05hbWVcbiAgICAgKiBAcmV0dXJucyB7Q2VsbEVkaXRvcn0gVGhlIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciB0aGlzIG5ldyBzeW5vbnltIHBvaW50cyB0by5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgYWRkU3lub255bTogZnVuY3Rpb24oc3lub255bU5hbWUsIGV4aXN0aW5nTmFtZSkge1xuICAgICAgICB2YXIgY2VsbEVkaXRvciA9IHRoaXMuZ2V0KGV4aXN0aW5nTmFtZSk7XG4gICAgICAgIHJldHVybiAodGhpcy5lZGl0b3JzW3N5bm9ueW1OYW1lXSA9IGNlbGxFZGl0b3IpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgYSByZWdpc3RlcmVkIGVkaXRvci5cbiAgICAgKiBAcmV0dXJucyB7Q2VsbEVkaXRvcn0gQSByZWdpc3RlcmVkIGNvbnN0cnVjdG9yIGV4dGVuZGVkIGZyb20ge0BsaW5rIENlbGxFZGl0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9ycy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yc1tuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IExvb2t1cCByZWdpc3RlcmVkIGNlbGwgZWRpdG9yIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2UgdGhlcmVvZi5cbiAgICAgKiBAZGVzYyBOb3RlOiBNdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBIeXBlcmdyaWQgb2JqZWN0IGFzIGNvbnRleHQhXG4gICAgICogQHJldHVybnMge0NlbGxFZGl0b3J9IE5ldyBpbnN0YW5jZSBvZiB0aGUgbmFtZWQgY2VsbCBlZGl0b3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIGEgcmVnaXN0ZXJlZCBlZGl0b3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zXSAtIFByb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSBpbnN0YW50aWF0ZWQgZWRpdG9yIHByaW1hcmlseSBmb3IgbXVzdGFjaGUncyB1c2UuXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3JzLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNyZWF0ZTogZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY2VsbEVkaXRvcixcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gdGhpcy5nZXQobmFtZSk7XG5cbiAgICAgICAgaWYgKENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoQ29uc3RydWN0b3IuYWJzdHJhY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnQXR0ZW1wdCB0byBpbnN0YW50aWF0ZSBhbiBcImFic3RyYWN0XCIgY2VsbCBlZGl0b3IgY2xhc3MuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbGxFZGl0b3IgPSBuZXcgQ29uc3RydWN0b3IodGhpcy5ncmlkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxsRWRpdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2VsbCBlZGl0b3IgcmVnaXN0cnkgY29udGFpbmluZyBhbGwgdGhlIFwicHJlcmVnaXN0ZXJlZFwiIGNlbGwgZWRpdG9yIGNvbnN0cnVjdG9ycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9ycy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlZGl0b3JzOiB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsRWRpdG9ycztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsUmVuZGVyZXJcbiAqL1xudmFyIEJ1dHRvbiA9IENlbGxSZW5kZXJlci5leHRlbmQoJ0J1dHRvbicsIHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFRoZSBkZWZhdWx0IGNlbGwgcmVuZGVyaW5nIGZ1bmN0aW9uIGZvciBhIGJ1dHRvbiBjZWxsLlxuICAgICAqIEBpbXBsZW1lbnRzIHBhaW50RnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgQnV0dG9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhaW50OiBmdW5jdGlvbihnYywgY29uZmlnKSB7XG4gICAgICAgIHZhciB2YWwgPSBjb25maWcudmFsdWUsXG4gICAgICAgICAgICBjID0gY29uZmlnLngsXG4gICAgICAgICAgICByID0gY29uZmlnLnksXG4gICAgICAgICAgICBib3VuZHMgPSBjb25maWcuYm91bmRzLFxuICAgICAgICAgICAgeCA9IGJvdW5kcy54ICsgMSxcbiAgICAgICAgICAgIHkgPSBib3VuZHMueSArIDEsXG4gICAgICAgICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCAtIDEgLSBjb25maWcubGluZVdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodCAtIDEgLSBjb25maWcubGluZVdpZHRoLFxuICAgICAgICAgICAgcmFkaXVzID0gaGVpZ2h0IC8gMixcbiAgICAgICAgICAgIGFyY0dyYWRpZW50ID0gZ2MuY3JlYXRlTGluZWFyR3JhZGllbnQoeCwgeSwgeCwgeSArIGhlaWdodCk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5tb3VzZURvd24pIHtcbiAgICAgICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAnI0I1Q0JFRCcpO1xuICAgICAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjNGQ3NGVhJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyNmZmZmZmYnKTtcbiAgICAgICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnI2FhYWFhYScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgYmFja2dyb3VuZFxuICAgICAgICBnYy5maWxsU3R5bGUgPSBjb25maWcuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBnYy5maWxsUmVjdChib3VuZHMueCwgYm91bmRzLnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgY2Fwc3VsZVxuICAgICAgICBnYy5maWxsU3R5bGUgPSBhcmNHcmFkaWVudDtcbiAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSAnIzAwMDAwMCc7XG4gICAgICAgIHRoaXMucm91bmRSZWN0KGdjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMsIGFyY0dyYWRpZW50LCB0cnVlKTtcblxuICAgICAgICB2YXIgb3ggPSAod2lkdGggLSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCB2YWwpKSAvIDI7XG4gICAgICAgIHZhciBveSA9IChoZWlnaHQgLSBjb25maWcuZ2V0VGV4dEhlaWdodChnYy5mb250KS5kZXNjZW50KSAvIDI7XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgdGV4dFxuICAgICAgICBnYy50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gJyMzMzMzMzMnO1xuICAgICAgICBnYy5mb250ID0gaGVpZ2h0IC0gMiArICdweCBzYW5zLXNlcmlmJztcbiAgICAgICAgY29uZmlnLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgZ2MuZmlsbFRleHQodmFsLCB4ICsgb3gsIHkgKyBveSk7XG5cbiAgICAgICAgLy9pZGVudGlmeSB0aGF0IHdlIGFyZSBhIGJ1dHRvblxuICAgICAgICBjb25maWcuYnV0dG9uQ2VsbHNbYyArICcsJyArIHJdID0gdHJ1ZTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdXR0b247XG5cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL0Jhc2UnKTtcblxuLyoqIEB0eXBlZGVmIHBhaW50RnVuY3Rpb25cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEB0aGlzIHtDZWxsRWRpdG9yfVxuICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0ge1JlY3RhbmdsZX0gY29uZmlnLmJvdW5kcyAtIFRoZSBjbGlwcGluZyByZWN0IG9mIHRoZSBjZWxsIHRvIGJlIHJlbmRlcmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy54IC0gdGhlIFwidHJhbnNsYXRlZFwiIGluZGV4IGludG8gdGhlIGBiZWhhdmlvci5hbGxDb2x1bW5zYCBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5ub3JtYWxpemVkWSAtIHRoZSB2ZXJ0aWNhbCBncmlkIGNvb3JkaW5hdGUgbm9ybWFsaXplZCB0byBmaXJzdCBkYXRhIHJvd1xuICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy51bnRyYW5zbGF0ZWRYIC0gdGhlIGhvcml6b250YWwgZ3JpZCBjb29yZGluYXRlIG1lYXN1cmVkIGZyb20gZmlyc3QgZGF0YSBjb2x1bW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcueSAtIHRoZSB2ZXJ0aWNhbCBncmlkIGNvb3JkaW5hdGUgbWVhc3VyZWQgZnJvbSB0b3AgaGVhZGVyIHJvd1xuICovXG5cbi8qKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjIEluc3RhbmNlcyBvZiBgQ2VsbFJlbmRlcmVyYCBhcmUgdXNlZCB0byByZW5kZXIgdGhlIDJEIGdyYXBoaWNzIGNvbnRleHQgd2l0aGluIHRoZSBib3VuZCBvZiBhIGNlbGwuIEV4dGVuZCB0aGlzIGJhc2UgY2xhc3MgdG8gaW1wbGVtZW50IHlvdXIgb3duIGNlbGwgcmVuZGVyZXJcbiAqXG4gKlxuICogU2VlIGFsc28ge0B0dXRvcmlhbCBjZWxsLXJlbmRlcmVyfS5cbiAqL1xudmFyIENlbGxSZW5kZXJlciA9IEJhc2UuZXh0ZW5kKCdDZWxsUmVuZGVyZXInLCB7XG4gICAgLyoqXG4gICAgICogQGRlc2MgQW4gZW1wdHkgaW1wbGVtZW50YXRpb24gb2YgYSBjZWxsIHJlbmRlcmVyLCBzZWUgW3RoZSBudWxsIG9iamVjdCBwYXR0ZXJuXShodHRwOi8vYzIuY29tL2NnaS93aWtpP051bGxPYmplY3QpLlxuICAgICAqIEBpbXBsZW1lbnRzIHBhaW50RnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhaW50OiBmdW5jdGlvbihnYywgY29uZmlnKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIHJvdW5kaW5nIGEgY2VsbC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc0dyYXBoaWNzQ29udGV4dH0gZ2NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IGdyaWQgY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSB5IGdyaWQgY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmlsbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJva2VcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJvdW5kUmVjdDogZnVuY3Rpb24oZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgZmlsbCwgc3Ryb2tlKSB7XG5cbiAgICAgICAgaWYgKCFzdHJva2UpIHtcbiAgICAgICAgICAgIHN0cm9rZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYWRpdXMpIHtcbiAgICAgICAgICAgIHJhZGl1cyA9IDU7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIGdjLm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcbiAgICAgICAgZ2MubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gICAgICAgIGdjLnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuICAgICAgICBnYy5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgZ2MucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgICAgIGdjLmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgZ2MucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICAgICAgZ2MubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgICAgICBnYy5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgIGdjLmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICB9XG59KTtcblxuQ2VsbFJlbmRlcmVyLmFic3RyYWN0ID0gdHJ1ZTsgLy8gZG9uJ3QgaW5zdGFudGlhdGUgZGlyZWN0bHlcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsUmVuZGVyZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBFcnJvckNlbGwgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdFcnJvckNlbGwnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBXcml0ZXMgZXJyb3IgbWVzc2FnZSBpbnRvIGNlbGwuXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgY2FsbGVkIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogZ2Muc2F2ZSgpO1xuICAgICAqIGdjLmJlZ2luUGF0aCgpO1xuICAgICAqIGdjLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICogZ2MuY2xpcCgpO1xuICAgICAqIGJlaGF2aW9yLmdldENlbGxQcm92aWRlcigpLnJlbmRlckNlbGxFcnJvcihnYywgbWVzc2FnZSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICogZ2MucmVzdG9yZSgpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UsIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGNsZWFyIHRoZSBjZWxsIGJ5IHNldHRpbmcgYGdjLmZpbGxTdHlsZWAgYW5kIGNhbGxpbmcgYGdjLmZpbGwoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc0dyYXBoaWNzQ29udGV4dH0gZ2NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbmZpZy5ib3VuZHMgLSBUaGUgY2xpcHBpbmcgcmVjdCBvZiB0aGUgY2VsbCB0byBiZSByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29uZmlnLnggLSB0aGUgXCJ0cmFuc2xhdGVkXCIgaW5kZXggaW50byB0aGUgYGJlaGF2aW9yLmFsbENvbHVtbnNgIGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy5ub3JtYWxpemVkWSAtIHRoZSB2ZXJ0aWNhbCBncmlkIGNvb3JkaW5hdGUgbm9ybWFsaXplZCB0byBmaXJzdCBkYXRhIHJvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb25maWcudW50cmFuc2xhdGVkWCAtIHRoZSBob3Jpem9udGFsIGdyaWQgY29vcmRpbmF0ZSBtZWFzdXJlZCBmcm9tIGZpcnN0IGRhdGEgY29sdW1uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbmZpZy55IC0gdGhlIHZlcnRpY2FsIGdyaWQgY29vcmRpbmF0ZSBtZWFzdXJlZCBmcm9tIHRvcCBoZWFkZXIgcm93XG4gICAgICogQG1lbWJlck9mIEVycm9yQ2VsbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZywgbWVzc2FnZSkge1xuICAgICAgICAvL3ZhciBpbWFnZXMgPSByZXF1aXJlKCcuLi8uLi9pbWFnZXMvaW5kZXgnKTtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGNlbGxcbiAgICAgICAgLy8gKHRoaXMgbWFrZXMgdXNlIG9mIHRoZSByZWN0IHBhdGggZGVmaW5lZCBieSB0aGUgY2FsbGVyKVxuICAgICAgICBnYy5maWxsU3R5bGUgPSAnI0ZGRDUwMCc7XG4gICAgICAgIGdjLmZpbGwoKTtcbiAgICAgICAgLy8gcmVuZGVyIGNlbGwgYm9yZGVyXG4gICAgICAgIC8vZ2Muc3Ryb2tlU3R5bGUgPSBnYy5jcmVhdGVQYXR0ZXJuKGltYWdlcy5jYXV0aW9uLCAncmVwZWF0Jyk7IC8vIENhdXNlcyBFcnJvclxuICAgICAgICBnYy5saW5lV2lkdGggPSA1O1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2MubW92ZVRvKHgsIHkpOyAvLyBjYXV0aW9uOiBkbyBub3QgdXNlIHJlY3QoKSBoZXJlIGJlY2F1c2UgQ2hyb21lIGRvZXMgbm90IGNsaXAgaXRzIHN0cm9rZSBwcm9wZXJseVxuICAgICAgICBnYy5saW5lVG8oeCArIHdpZHRoLCB5KTtcbiAgICAgICAgZ2MubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIGdjLmxpbmVUbyh4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgZ2MubGluZVRvKHgsIHkpO1xuICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgLy8gYWRqdXN0IGNsaXAgcmVnaW9uIHRvIHByZXZlbnQgdGV4dCBmcm9tIHJlbmRlcmluZyBvdmVyIHJpZ2h0IGJvcmRlciBzaG91bGQgaXQgb3ZlcmZsb3dcbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIGdjLnJlY3QoeCwgeSwgd2lkdGggLSAyLCBoZWlnaHQpO1xuICAgICAgICBnYy5jbGlwKCk7XG4gICAgICAgIC8vIHJlbmRlciBtZXNzYWdlIHRleHRcbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gJyNBMDAnO1xuICAgICAgICBnYy50ZXh0QWxpZ24gPSAnc3RhcnQnO1xuICAgICAgICBnYy50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgZ2MuZm9udCA9ICdib2xkIDZwdCBcImFyaWFsIG5hcnJvd1wiLCB2ZXJkYW5hLCBnZW5ldmEnO1xuICAgICAgICBnYy5maWxsVGV4dChtZXNzYWdlLCB4ICsgNCwgeSArIGhlaWdodCAvIDIgKyAwLjUpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVycm9yQ2VsbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENlbGxSZW5kZXJlciA9IHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDZWxsUmVuZGVyZXJcbiAqL1xudmFyIExhc3RTZWxlY3Rpb24gPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdMYXN0U2VsZWN0aW9uJywge1xuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQSByZW5kZXJpbmcgb2YgdGhlIGxhc3QgU2VsZWN0aW9uIE1vZGVsXG4gICAgICogQGltcGxlbWVudHMgcGFpbnRGdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBMYXN0U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHBhaW50OiBmdW5jdGlvbihnYywgY29uZmlnKSB7XG4gICAgICAgIHZhciB4ID0gY29uZmlnLmJvdW5kcy54LFxuICAgICAgICAgICAgeSA9IGNvbmZpZy5ib3VuZHMueSxcbiAgICAgICAgICAgIHdpZHRoID0gY29uZmlnLmJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmZpZy5ib3VuZHMuaGVpZ2h0O1xuXG4gICAgICAgIC8vIHZhciBmb2N1c0xpbmVTdGVwID0gIFtcbiAgICAgICAgLy8gICAgIFs1LCA1XSxcbiAgICAgICAgLy8gICAgIFswLCAxLCA1LCA0XSxcbiAgICAgICAgLy8gICAgIFswLCAyLCA1LCAzXSxcbiAgICAgICAgLy8gICAgIFswLCAzLCA1LCAyXSxcbiAgICAgICAgLy8gICAgIFswLCA0LCA1LCAxXSxcbiAgICAgICAgLy8gICAgIFswLCA1LCA1LCAwXSxcbiAgICAgICAgLy8gICAgIFsxLCA1LCA0LCAwXSxcbiAgICAgICAgLy8gICAgIFsyLCA1LCAzLCAwXSxcbiAgICAgICAgLy8gICAgIFszLCA1LCAyLCAwXSxcbiAgICAgICAgLy8gICAgIFs0LCA1LCAxLCAwXVxuICAgICAgICAvLyBdO1xuICAgICAgICBnYy5yZWN0KHggKyAxLCB5LCB3aWR0aCAtIDIsIGhlaWdodCAtIDIpO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBjb25maWcuc2VsZWN0aW9uUmVnaW9uT3ZlcmxheUNvbG9yO1xuICAgICAgICBnYy5maWxsKCk7XG4gICAgICAgIGdjLmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGdjLnN0cm9rZVN0eWxlID0gY29uZmlnLnNlbGVjdGlvblJlZ2lvbk91dGxpbmVDb2xvcjtcblxuICAgICAgICAvLyBhbmltYXRlIHRoZSBkYXNoZWQgbGluZSBhIGJpdCBoZXJlIGZvciBmdW5cblxuICAgICAgICBnYy5zdHJva2UoKTtcblxuICAgICAgICAvLyBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvL1xuICAgICAgICAvLyBnYy5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIC8vYW5pbWF0ZSB0aGUgZGFzaGVkIGxpbmUgYSBiaXQgaGVyZSBmb3IgZnVuXG4gICAgICAgIC8vIGdjLnNldExpbmVEYXNoKGZvY3VzTGluZVN0ZXBbTWF0aC5mbG9vcigxMCAqIChEYXRlLm5vdygpIC8gMzAwICUgMSkpICUgZm9jdXNMaW5lU3RlcC5sZW5ndGhdKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gZ2Muc3Ryb2tlKCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGFzdFNlbGVjdGlvbjtcblxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBTaW1wbGVDZWxsID0gQ2VsbFJlbmRlcmVyLmV4dGVuZCgnU2ltcGxlQ2VsbCcsIHtcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFRoZSBkZWZhdWx0IGNlbGwgcmVuZGVyaW5nIGZ1bmN0aW9uIGZvciByZW5kZXJpbmcgYSB2YW5pbGxhIGNlbGwuXG4gICAgICogQGRlc2MgR3JlYXQgY2FyZSBoYXMgYmVlbiB0YWtlbiBpbiBjcmFmdGluZyB0aGlzIGZ1bmN0aW9uIGFzIGl0IG5lZWRzIHRvIHBlcmZvcm0gZXh0cmVtZWx5IGZhc3QuIFJlYWRzIG9uIHRoZSBnYyBvYmplY3QgYXJlIGV4cGVuc2l2ZSBidXQgbm90IHF1aXRlIGFzIGV4cGVuc2l2ZSBhcyB3cml0ZXMgdG8gaXQuIFdlIGRvIG91ciBiZXN0IHRvIGF2b2lkIHdyaXRlcywgdGhlbiBhdm9pZCByZWFkcy4gQ2xpcHBpbmcgYm91bmRzIGFyZSBub3Qgc2V0IGhlcmUgYXMgdGhpcyBpcyBhbHNvIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24uIEluc3RlYWQsIHdlIHRydW5jYXRlIG92ZXJmbG93aW5nIHRleHQgYW5kIGNvbnRlbnQgYnkgZmlsbGluZyBhIHJlY3RhbmdsZSB3aXRoIGJhY2tncm91bmQgY29sb3IgY29sdW1uIGJ5IGNvbHVtbiBpbnN0ZWFkIG9mIGNlbGwgYnkgY2VsbC4gIFRoaXMgY29sdW1uIGJ5IGNvbHVtbiBmaWxsIGhhcHBlbnMgaGlnaGVyIHVwIG9uIHRoZSBzdGFjayBpbiBhIGNhbGxpbmcgZnVuY3Rpb24gZnJvbSBmaW4taHlwZXJncmlkLXJlbmRlcmVyLiAgVGFrZSBub3RlIHdlIGRvIG5vdCBkbyBjZWxsIGJ5IGNlbGwgYm9yZGVyIHJlbmRlcmVyaW5nIGFzIHRoYXQgaXMgZXhwZW5zaXZlLiAgSW5zdGVhZCB3ZSByZW5kZXIgbWFueSBmZXdlciBncmlkbGluZXMgYWZ0ZXIgYWxsIGNlbGxzIGFyZSByZW5kZXJlZC5cbiAgICAgKiBAaW1wbGVtZW50cyBwYWludEZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFNpbXBsZUNlbGwucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHZhbCA9IGNvbmZpZy52YWx1ZSxcbiAgICAgICAgICAgIGJvdW5kcyA9IGNvbmZpZy5ib3VuZHMsXG4gICAgICAgICAgICB4ID0gYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gYm91bmRzLnksXG4gICAgICAgICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICBsZWZ0UGFkZGluZyA9IDI7IC8vVE9ETzogZml4IHRoaXNcblxuICAgICAgICB2YXIgbGVmdEljb24sIHJpZ2h0SWNvbiwgY2VudGVySWNvbiwgaXhvZmZzZXQsIGl5b2Zmc2V0LCBmb250O1xuXG4gICAgICAgIC8vIHNldHRpbmcgZ2MgcHJvcGVydGllcyBhcmUgZXhwZW5zaXZlLCBsZXQncyBub3QgZG8gaXQgbmVlZGxlc3NseVxuXG4gICAgICAgIGlmICh2YWwgJiYgdmFsLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgbGVmdEljb24gPSB2YWxbMF07XG4gICAgICAgICAgICByaWdodEljb24gPSB2YWxbMl07XG4gICAgICAgICAgICB2YWwgPSB2YWxbMV07XG4gICAgICAgICAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnSFRNTEltYWdlRWxlbWVudCcpIHsgLy8gbXVzdCBiZSBhbiBpbWFnZVxuICAgICAgICAgICAgICAgICAgICBjZW50ZXJJY29uID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0SWNvbiAmJiBsZWZ0SWNvbi5ub2RlTmFtZSAhPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICBsZWZ0SWNvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmlnaHRJY29uICYmIHJpZ2h0SWNvbi5ub2RlTmFtZSAhPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICByaWdodEljb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbnRlckljb24gJiYgY2VudGVySWNvbi5ub2RlTmFtZSAhPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICBjZW50ZXJJY29uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuaXNVc2VyRGF0YUFyZWEpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbE9yRnVuYyh2YWwsIGNvbmZpZywgY29uZmlnLmNhbGN1bGF0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsID0gY29uZmlnLmZvcm1hdFZhbHVlKHZhbCk7XG5cbiAgICAgICAgZm9udCA9IGNvbmZpZy5pc1NlbGVjdGVkID8gY29uZmlnLmZvcmVncm91bmRTZWxlY3Rpb25Gb250IDogY29uZmlnLmZvbnQ7XG5cbiAgICAgICAgaWYgKGdjLmZvbnQgIT09IGZvbnQpIHtcbiAgICAgICAgICAgIGdjLmZvbnQgPSBmb250O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdjLnRleHRBbGlnbiAhPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBnYy50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdjLnRleHRCYXNlbGluZSAhPT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgIGdjLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsbCBiYWNrZ3JvdW5kIG9ubHkgaWYgb3VyIGJnQ29sb3IgaXMgcG9wdWxhdGVkIG9yIHdlIGFyZSBhIHNlbGVjdGVkIGNlbGxcbiAgICAgICAgdmFyIGJhY2tncm91bmRDb2xvciwgaG92ZXIsIGhvdmVyQ29sb3IsIHNlbGVjdENvbG9yLFxuICAgICAgICAgICAgY29sb3JzID0gW107XG5cbiAgICAgICAgaWYgKGNvbmZpZy5pc0NlbGxIb3ZlcmVkICYmIGNvbmZpZy5ob3ZlckNlbGxIaWdobGlnaHQuZW5hYmxlZCkge1xuICAgICAgICAgICAgaG92ZXJDb2xvciA9IGNvbmZpZy5ob3ZlckNlbGxIaWdobGlnaHQuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5pc1Jvd0hvdmVyZWQgJiYgKGhvdmVyID0gY29uZmlnLmhvdmVyUm93SGlnaGxpZ2h0KS5lbmFibGVkKSB7XG4gICAgICAgICAgICBob3ZlckNvbG9yID0gY29uZmlnLmlzR3JpZENvbHVtbiB8fCAhaG92ZXIuaGVhZGVyIHx8IGhvdmVyLmhlYWRlci5iYWNrZ3JvdW5kQ29sb3IgPT09IHVuZGVmaW5lZCA/IGhvdmVyLmJhY2tncm91bmRDb2xvciA6IGhvdmVyLmhlYWRlci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmlzQ29sdW1uSG92ZXJlZCAmJiAoaG92ZXIgPSBjb25maWcuaG92ZXJDb2x1bW5IaWdobGlnaHQpLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGhvdmVyQ29sb3IgPSBjb25maWcuaXNHcmlkUm93IHx8ICFob3Zlci5oZWFkZXIgfHwgaG92ZXIuaGVhZGVyLmJhY2tncm91bmRDb2xvciA9PT0gdW5kZWZpbmVkID8gaG92ZXIuYmFja2dyb3VuZENvbG9yIDogaG92ZXIuaGVhZGVyLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxwaGEoaG92ZXJDb2xvcikgPCAxKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RDb2xvciA9IHZhbE9yRnVuYyhjb25maWcuYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yLCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFscGhhKHNlbGVjdENvbG9yKSA8IDEpIHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSB2YWxPckZ1bmMoY29uZmlnLmJhY2tncm91bmRDb2xvciwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEoYmFja2dyb3VuZENvbG9yKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JzLnB1c2goYmFja2dyb3VuZENvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0Q29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbG9ycy5wdXNoKHNlbGVjdENvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaG92ZXJDb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2xvcnMucHVzaChob3ZlckNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBsYXllckNvbG9ycyhnYywgY29sb3JzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvLyBkcmF3IHRleHRcbiAgICAgICAgdmFyIHRoZUNvbG9yID0gdmFsT3JGdW5jKGNvbmZpZy5pc1NlbGVjdGVkID8gY29uZmlnLmZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA6IGNvbmZpZy5jb2xvciwgY29uZmlnKTtcbiAgICAgICAgaWYgKGdjLmZpbGxTdHlsZSAhPT0gdGhlQ29sb3IpIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoZUNvbG9yO1xuICAgICAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSB0aGVDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuaXNIZWFkZXJSb3cgJiYgY29uZmlnLmhlYWRlclRleHRXcmFwcGluZykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJNdWx0aUxpbmVUZXh0KGdjLCBjb25maWcsIHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclNpbmdsZUxpbmVUZXh0KGdjLCBjb25maWcsIHZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWNvbldpZHRoID0gMDtcbiAgICAgICAgaWYgKGxlZnRJY29uKSB7XG4gICAgICAgICAgICBpeW9mZnNldCA9IE1hdGgucm91bmQoKGhlaWdodCAtIGxlZnRJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGdjLmRyYXdJbWFnZShsZWZ0SWNvbiwgeCArIGxlZnRQYWRkaW5nLCB5ICsgaXlvZmZzZXQpO1xuICAgICAgICAgICAgaWNvbldpZHRoID0gTWF0aC5tYXgobGVmdEljb24ud2lkdGggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmlnaHRJY29uICYmIHdpZHRoID4gMS43NSAqIGhlaWdodCkge1xuICAgICAgICAgICAgaXlvZmZzZXQgPSBNYXRoLnJvdW5kKChoZWlnaHQgLSByaWdodEljb24uaGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0WCA9IHggKyB3aWR0aCAtIHJpZ2h0SWNvbi53aWR0aDtcbiAgICAgICAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxheWVyQ29sb3JzKGdjLCBjb2xvcnMsIHJpZ2h0WCwgeSwgcmlnaHRJY29uLndpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnYy5jbGVhclJlY3QocmlnaHRYLCB5LCByaWdodEljb24ud2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYy5kcmF3SW1hZ2UocmlnaHRJY29uLCByaWdodFgsIHkgKyBpeW9mZnNldCk7XG4gICAgICAgICAgICBpY29uV2lkdGggPSBNYXRoLm1heChyaWdodEljb24ud2lkdGggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VudGVySWNvbikge1xuICAgICAgICAgICAgaXlvZmZzZXQgPSBNYXRoLnJvdW5kKChoZWlnaHQgLSBjZW50ZXJJY29uLmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgIGl4b2Zmc2V0ID0gTWF0aC5yb3VuZCgod2lkdGggLSBjZW50ZXJJY29uLndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgZ2MuZHJhd0ltYWdlKGNlbnRlckljb24sIHggKyB3aWR0aCAtIGl4b2Zmc2V0IC0gY2VudGVySWNvbi53aWR0aCwgeSArIGl5b2Zmc2V0KTtcbiAgICAgICAgICAgIGljb25XaWR0aCA9IE1hdGgubWF4KGNlbnRlckljb24ud2lkdGggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmNlbGxCb3JkZXJUaGlja25lc3MpIHtcbiAgICAgICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgZ2MucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGdjLmxpbmVXaWR0aCA9IGNvbmZpZy5jZWxsQm9yZGVyVGhpY2tuZXNzO1xuICAgICAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSBjb25maWcuY2VsbEJvcmRlclN0eWxlO1xuXG4gICAgICAgICAgICAvLyBhbmltYXRlIHRoZSBkYXNoZWQgbGluZSBhIGJpdCBoZXJlIGZvciBmdW5cblxuICAgICAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcubWluV2lkdGggPSBjb25maWcubWluV2lkdGggKyAyICogKGljb25XaWR0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlbmRlcnMgc2luZ2xlIGxpbmUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc0dyYXBoaWNzQ29udGV4dH0gZ2NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbmZpZy5ib3VuZHMgLSBUaGUgY2xpcHBpbmcgcmVjdCBvZiB0aGUgY2VsbCB0byBiZSByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbCAtIFRoZSB0ZXh0IHRvIHJlbmRlciBpbiB0aGUgY2VsbC5cbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlQ2VsbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZW5kZXJNdWx0aUxpbmVUZXh0OiBmdW5jdGlvbihnYywgY29uZmlnLCB2YWwpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG4gICAgICAgIHZhciBsaW5lcyA9IGZpdFRleHQoZ2MsIGNvbmZpZywgdmFsLCB3aWR0aCk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclNpbmdsZUxpbmVUZXh0KGdjLCBjb25maWcsIHNxdWVlemUodmFsKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sSEVkZ2VPZmZzZXQgPSBjb25maWcuY2VsbFBhZGRpbmcsXG4gICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSAwLFxuICAgICAgICAgICAgdmFsaWduT2Zmc2V0ID0gY29uZmlnLnZvZmZzZXQsXG4gICAgICAgICAgICBoYWxpZ24gPSBjb25maWcuaGFsaWduLFxuICAgICAgICAgICAgdGV4dEhlaWdodCA9IGNvbmZpZy5nZXRUZXh0SGVpZ2h0KGNvbmZpZy5mb250KS5oZWlnaHQ7XG5cbiAgICAgICAgc3dpdGNoIChoYWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSB3aWR0aCAtIGNvbEhFZGdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSBjb2xIRWRnZU9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoTWluID0gMCwgdk1pbiA9IE1hdGguY2VpbCh0ZXh0SGVpZ2h0IC8gMik7XG5cbiAgICAgICAgdmFsaWduT2Zmc2V0ICs9IE1hdGguY2VpbCgoaGVpZ2h0IC0gKGxpbmVzLmxlbmd0aCAtIDEpICogdGV4dEhlaWdodCkgLyAyKTtcblxuICAgICAgICBoYWxpZ25PZmZzZXQgPSBNYXRoLm1heChoTWluLCBoYWxpZ25PZmZzZXQpO1xuICAgICAgICB2YWxpZ25PZmZzZXQgPSBNYXRoLm1heCh2TWluLCB2YWxpZ25PZmZzZXQpO1xuXG4gICAgICAgIGdjLnNhdmUoKTsgLy8gZGVmaW5lIGEgY2xpcHBpbmcgcmVnaW9uIGZvciBjZWxsXG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICBnYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBnYy5jbGlwKCk7XG5cbiAgICAgICAgZ2MudGV4dEFsaWduID0gaGFsaWduO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdjLmZpbGxUZXh0KGxpbmVzW2ldLCB4ICsgaGFsaWduT2Zmc2V0LCB5ICsgdmFsaWduT2Zmc2V0ICsgKGkgKiB0ZXh0SGVpZ2h0KSk7XG4gICAgICAgIH1cblxuICAgICAgICBnYy5yZXN0b3JlKCk7IC8vIGRpc2NhcmQgY2xpcHBpbmcgcmVnaW9uXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlbmRlcnMgc2luZ2xlIGxpbmUgdGV4dC5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc0dyYXBoaWNzQ29udGV4dH0gZ2NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGNvbmZpZy5ib3VuZHMgLSBUaGUgY2xpcHBpbmcgcmVjdCBvZiB0aGUgY2VsbCB0byBiZSByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbCAtIFRoZSB0ZXh0IHRvIHJlbmRlciBpbiB0aGUgY2VsbC5cbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlQ2VsbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZW5kZXJTaW5nbGVMaW5lVGV4dDogZnVuY3Rpb24oZ2MsIGNvbmZpZywgdmFsKSB7XG4gICAgICAgIHZhciB4ID0gY29uZmlnLmJvdW5kcy54LFxuICAgICAgICAgICAgeSA9IGNvbmZpZy5ib3VuZHMueSxcbiAgICAgICAgICAgIHdpZHRoID0gY29uZmlnLmJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbmZpZy5ib3VuZHMuaGVpZ2h0O1xuICAgICAgICB2YXIgY29sSEVkZ2VPZmZzZXQgPSBjb25maWcuY2VsbFBhZGRpbmcsXG4gICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSAwLFxuICAgICAgICAgICAgdmFsaWduT2Zmc2V0ID0gY29uZmlnLnZvZmZzZXQsXG4gICAgICAgICAgICBoYWxpZ24gPSBjb25maWcuaGFsaWduLFxuICAgICAgICAgICAgaXNDZWxsSG92ZXJlZCA9IGNvbmZpZy5pc0NlbGxIb3ZlcmVkLFxuICAgICAgICAgICAgaXNMaW5rID0gY29uZmlnLmxpbms7XG5cbiAgICAgICAgdmFyIGZvbnRNZXRyaWNzID0gY29uZmlnLmdldFRleHRIZWlnaHQoY29uZmlnLmZvbnQpO1xuICAgICAgICB2YXIgdGV4dFdpZHRoID0gY29uZmlnLmdldFRleHRXaWR0aChnYywgdmFsKTtcblxuICAgICAgICAvL3dlIG11c3Qgc2V0IHRoaXMgaW4gb3JkZXIgdG8gY29tcHV0ZSB0aGUgbWluaW11bSB3aWR0aFxuICAgICAgICAvL2ZvciBjb2x1bW4gYXV0b3NpemluZyBwdXJwb3Nlc1xuICAgICAgICBjb25maWcubWluV2lkdGggPSB0ZXh0V2lkdGggKyAoMiAqIGNvbEhFZGdlT2Zmc2V0KTtcblxuICAgICAgICBzd2l0Y2ggKGhhbGlnbikge1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIC8vdGV4dFdpZHRoID0gY29uZmlnLmdldFRleHRXaWR0aChnYywgY29uZmlnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSB3aWR0aCAtIGNvbEhFZGdlT2Zmc2V0IC0gdGV4dFdpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAvL3RleHRXaWR0aCA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIGNvbmZpZy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaGFsaWduT2Zmc2V0ID0gKHdpZHRoIC0gdGV4dFdpZHRoKSAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSBjb2xIRWRnZU9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbGlnbk9mZnNldCA9IE1hdGgubWF4KDAsIGhhbGlnbk9mZnNldCk7XG4gICAgICAgIHZhbGlnbk9mZnNldCArPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZ2MuZmlsbFRleHQodmFsLCB4ICsgaGFsaWduT2Zmc2V0LCB5ICsgdmFsaWduT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NlbGxIb3ZlcmVkKSB7XG4gICAgICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmIChpc0xpbmspIHtcbiAgICAgICAgICAgICAgICB1bmRlcmxpbmUoY29uZmlnLCBnYywgdmFsLCB4ICsgaGFsaWduT2Zmc2V0LCB5ICsgdmFsaWduT2Zmc2V0ICsgTWF0aC5mbG9vcihmb250TWV0cmljcy5oZWlnaHQgLyAyKSwgMSk7XG4gICAgICAgICAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnN0cmlrZVRocm91Z2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgc3RyaWtlVGhyb3VnaChjb25maWcsIGdjLCB2YWwsIHggKyBoYWxpZ25PZmZzZXQsIHkgKyB2YWxpZ25PZmZzZXQgKyBNYXRoLmZsb29yKGZvbnRNZXRyaWNzLmhlaWdodCAvIDIpLCAxKTtcbiAgICAgICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG5mdW5jdGlvbiBmaXRUZXh0KGdjLCBjb25maWcsIHN0cmluZywgd2lkdGgpIHtcbiAgICByZXR1cm4gZmluZExpbmVzKGdjLCBjb25maWcsIHNxdWVlemUoc3RyaW5nKS5zcGxpdCgnICcpLCB3aWR0aCk7XG59XG5cbmZ1bmN0aW9uIGZpbmRMaW5lcyhnYywgY29uZmlnLCB3b3Jkcywgd2lkdGgpIHtcblxuICAgIGlmICh3b3Jkcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHdvcmRzO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0aW5nIHdpdGgganVzdCB0aGUgZmlyc3Qgd29yZOKAplxuICAgIHZhciBzdGlsbEZpdHMsIGxpbmUgPSBbd29yZHMuc2hpZnQoKV07XG4gICAgd2hpbGUgKFxuICAgICAgICAvLyBzbyBsb25lIGFzIGxpbmUgc3RpbGwgZml0cyB3aXRoaW4gY3VycmVudCBjb2x1bW7igKZcbiAgICAoc3RpbGxGaXRzID0gY29uZmlnLmdldFRleHRXaWR0aChnYywgbGluZS5qb2luKCcgJykpIDwgd2lkdGgpXG4gICAgLy8g4oCmQU5EIHRoZXJlIGFyZSBtb3JlIHdvcmRzIGF2YWlsYWJsZeKAplxuICAgICYmIHdvcmRzLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgLy8g4oCmYWRkIGFub3RoZXIgd29yZCB0byBlbmQgb2YgbGluZSBhbmQgcmV0ZXN0XG4gICAgICAgIGxpbmUucHVzaCh3b3Jkcy5zaGlmdCgpKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgICFzdGlsbEZpdHMgLy8gaWYgbGluZSBpcyBub3cgdG9vIGxvbmfigKZcbiAgICAgICAgJiYgbGluZS5sZW5ndGggPiAxIC8vIOKApkFORCBpcyBtdWx0aXBsZSB3b3Jkc+KAplxuICAgICkge1xuICAgICAgICB3b3Jkcy51bnNoaWZ0KGxpbmUucG9wKCkpOyAvLyDigKZiYWNrIG9mZiBieSAoaS5lLiwgcmVtb3ZlKSBvbmUgd29yZFxuICAgIH1cblxuICAgIGxpbmUgPSBbbGluZS5qb2luKCcgJyldO1xuXG4gICAgaWYgKHdvcmRzLmxlbmd0aCkgeyAvLyBpZiB0aGVyZSdzIGFueXRoaW5nIGxlZnTigKZcbiAgICAgICAgbGluZSA9IGxpbmUuY29uY2F0KGZpbmRMaW5lcyhnYywgY29uZmlnLCB3b3Jkcywgd2lkdGgpKTsgLy8g4oCmYnJlYWsgaXQgdXAgYXMgd2VsbFxuICAgIH1cblxuICAgIHJldHVybiBsaW5lO1xufVxuXG4vLyB0cmltIHN0cmluZzsgdGhlbiByZWR1Y2UgYWxsIHJ1bnMgb2YgbXVsdGlwbGUgc3BhY2VzIHRvIGEgc2luZ2xlIHNwYWNlXG5mdW5jdGlvbiBzcXVlZXplKHN0cmluZykge1xuICAgIHJldHVybiAoc3RyaW5nICsgJycpLnRyaW0oKS5yZXBsYWNlKC9cXHNcXHMrL2csICcgJyk7XG59XG5cbmZ1bmN0aW9uIHN0cmlrZVRocm91Z2goY29uZmlnLCBnYywgdGV4dCwgeCwgeSwgdGhpY2tuZXNzKSB7XG4gICAgdmFyIGZvbnRNZXRyaWNzID0gY29uZmlnLmdldFRleHRIZWlnaHQoY29uZmlnLmZvbnQpO1xuICAgIHZhciB3aWR0aCA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIHRleHQpO1xuICAgIHkgLT0gZm9udE1ldHJpY3MuaGVpZ2h0ICogMC40O1xuXG4gICAgc3dpdGNoIChnYy50ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHggLT0gd2lkdGggLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHggLT0gd2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvL2djLmJlZ2luUGF0aCgpO1xuICAgIGdjLmxpbmVXaWR0aCA9IHRoaWNrbmVzcztcbiAgICBnYy5tb3ZlVG8oeCArIDAuNSwgeSArIDAuNSk7XG4gICAgZ2MubGluZVRvKHggKyB3aWR0aCArIDAuNSwgeSArIDAuNSk7XG59XG5cbmZ1bmN0aW9uIHVuZGVybGluZShjb25maWcsIGdjLCB0ZXh0LCB4LCB5LCB0aGlja25lc3MpIHtcbiAgICB2YXIgd2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCB0ZXh0KTtcblxuICAgIHN3aXRjaCAoZ2MudGV4dEFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICB4IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICB4IC09IHdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy9nYy5iZWdpblBhdGgoKTtcbiAgICBnYy5saW5lV2lkdGggPSB0aGlja25lc3M7XG4gICAgZ2MubW92ZVRvKHggKyAwLjUsIHkgKyAwLjUpO1xuICAgIGdjLmxpbmVUbyh4ICsgd2lkdGggKyAwLjUsIHkgKyAwLjUpO1xufVxuXG5mdW5jdGlvbiBsYXllckNvbG9ycyhnYywgY29sb3JzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29sb3JzLmZvckVhY2goZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICAgIGdjLmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB2YWxPckZ1bmModmYsIGNvbmZpZywgY2FsY3VsYXRvcikge1xuICAgIHZhciByZXN1bHQgPSB2ZjtcbiAgICBpZiAoY29uZmlnLmlzR3JpZENvbHVtbiAmJiBjb25maWcuaXNHcmlkUm93ICYmIGNvbmZpZy5kYXRhUm93KSB7XG4gICAgICAgIGNhbGN1bGF0b3IgPSAodHlwZW9mIHZmKVswXSA9PT0gJ2YnICYmIHZmIHx8IGNhbGN1bGF0b3I7XG4gICAgICAgIGlmIChjYWxjdWxhdG9yKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxjdWxhdG9yKGNvbmZpZy5kYXRhUm93LCBjb25maWcubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCB8fCByZXN1bHQgPT09IDAgfHwgcmVzdWx0ID09PSBmYWxzZSA/IHJlc3VsdCA6ICcnO1xufVxuXG5mdW5jdGlvbiBhbHBoYShjc3NDb2xvclNwZWMpIHtcbiAgICBpZiAoY3NzQ29sb3JTcGVjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkIHNvIG5vdCB2aXNpYmxlOyB0cmVhdCBhcyB0cmFuc3BhcmVudFxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlcyA9IGNzc0NvbG9yU3BlYy5tYXRjaChhbHBoYS5yZWdleCk7XG5cbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBhbiBvcGFxdWUgY29sb3IgKGEgY29sb3Igc3BlYyB3aXRoIG5vIGFscGhhIGNoYW5uZWwpXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHZhciBBID0gbWF0Y2hlc1s0XTtcblxuICAgIGlmIChBID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gY3NzQ29sb3JTcGVjIG11c3QgaGF2ZSBiZWVuICd0cmFuc3BhcmVudCdcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIE51bWJlcihBKTtcbn1cblxuYWxwaGEucmVnZXggPSAvXih0cmFuc3BhcmVudHwoKFJHQnxIU0wpQVxcKC4qLFxccyooW1xcZFxcLl0rKVxcKSkpJC9pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUNlbGw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBTbGlkZXIgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdTbGlkZXInLCB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBFbWVyc29uJ3MgcGFpbnQgZnVuY3Rpb24gZm9yIGEgc2xpZGVyIGJ1dHRvbi4gY3VycmVudGx5IHRoZSB1c2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIGl0XG4gICAgICogQGltcGxlbWVudHMgcGFpbnRGdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBTbGlkZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG4gICAgICAgIGdjLnN0cm9rZVN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgdmFyIHZhbCA9IGNvbmZpZy52YWx1ZTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGhlaWdodCAvIDI7XG4gICAgICAgIHZhciBvZmZzZXQgPSB3aWR0aCAqIHZhbDtcbiAgICAgICAgdmFyIGJnQ29sb3IgPSBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgOiAnIzMzMzMzMyc7XG4gICAgICAgIHZhciBidG5HcmFkaWVudCA9IGdjLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICBidG5HcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgYmdDb2xvcik7XG4gICAgICAgIGJ0bkdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzY2NjY2NicpO1xuICAgICAgICB2YXIgYXJjR3JhZGllbnQgPSBnYy5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjYWFhYWFhJyk7XG4gICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzc3Nzc3NycpO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBidG5HcmFkaWVudDtcbiAgICAgICAgdGhpcy5yb3VuZFJlY3QoZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgYnRuR3JhZGllbnQpO1xuICAgICAgICBpZiAodmFsIDwgMS4wKSB7XG4gICAgICAgICAgICBnYy5maWxsU3R5bGUgPSBhcmNHcmFkaWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9ICcjZWVlZWVlJztcbiAgICAgICAgfVxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2MuYXJjKHggKyBNYXRoLm1heChvZmZzZXQgLSByYWRpdXMsIHJhZGl1cyksIHkgKyByYWRpdXMsIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBnYy5maWxsKCk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICBjb25maWcubWluV2lkdGggPSAxMDA7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2xpZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DZWxsUmVuZGVyZXInKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxSZW5kZXJlclxuICovXG52YXIgU3BhcmtCYXIgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdTcGFya0JhcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIGEgc3BhcmtsaW5lLCBiZWNhdXNlIGl0J3MgYSBiYXJjaGFydCB3ZSd2ZSBjaGFuZ2VkIHRoZSBuYW1lIDspLlxuICAgICAqIEBpbXBsZW1lbnRzIHBhaW50RnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgU3BhcmtCYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciB2YWwgPSBjb25maWcudmFsdWU7XG4gICAgICAgIGlmICghdmFsIHx8ICF2YWwubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvdW50ID0gdmFsLmxlbmd0aDtcbiAgICAgICAgdmFyIGVXaWR0aCA9IHdpZHRoIC8gY291bnQ7XG4gICAgICAgIHZhciBmZ0NvbG9yID0gY29uZmlnLmlzU2VsZWN0ZWQgPyBjb25maWcuZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yIDogY29uZmlnLmNvbG9yO1xuICAgICAgICBpZiAoY29uZmlnLmJhY2tncm91bmRDb2xvciB8fCBjb25maWcuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gY29uZmlnLmlzU2VsZWN0ZWQgPyAnYmx1ZScgOiBjb25maWcuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiYXJoZWlnaHQgPSB2YWxbaV0gLyAxMTAgKiBoZWlnaHQ7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4ICsgNSwgeSArIGhlaWdodCAtIGJhcmhlaWdodCwgZVdpZHRoICogMC42NjY2LCBiYXJoZWlnaHQpO1xuICAgICAgICAgICAgeCArPSBlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbmZpZy5taW5XaWR0aCA9IGNvdW50ICogMTA7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3BhcmtCYXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsUmVuZGVyZXIgPSByZXF1aXJlKCcuL0NlbGxSZW5kZXJlcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQ2VsbFJlbmRlcmVyXG4gKi9cbnZhciBTcGFya0xpbmUgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdTcGFya0xpbmUnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBBIHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHNwYXJrbGluZS4gIHNlZSBbRWR3YXJkIFR1ZnRlIHNwYXJrbGluZV0oaHR0cDovL3d3dy5lZHdhcmR0dWZ0ZS5jb20vYmJvYXJkL3EtYW5kLWEtZmV0Y2gtbXNnP21zZ19pZD0wMDAxT1IpXG4gICAgICogQGltcGxlbWVudHMgcGFpbnRGdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBTcGFya0xpbmUucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciB2YWwgPSBjb25maWcudmFsdWU7XG4gICAgICAgIGlmICghdmFsIHx8ICF2YWwubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvdW50ID0gdmFsLmxlbmd0aDtcbiAgICAgICAgdmFyIGVXaWR0aCA9IHdpZHRoIC8gY291bnQ7XG5cbiAgICAgICAgdmFyIGZnQ29sb3IgPSBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5mb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgOiBjb25maWcuY29sb3I7XG4gICAgICAgIGlmIChjb25maWcuYmFja2dyb3VuZENvbG9yIHx8IGNvbmZpZy5pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBnYy5maWxsU3R5bGUgPSBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5iYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgOiBjb25maWcuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSBmZ0NvbG9yO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBmZ0NvbG9yO1xuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmFyaGVpZ2h0ID0gdmFsW2ldIC8gMTEwICogaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IGJhcmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdjLmxpbmVUbyh4ICsgNSwgeSArIGhlaWdodCAtIGJhcmhlaWdodCk7XG4gICAgICAgICAgICBnYy5hcmMoeCArIDUsIHkgKyBoZWlnaHQgLSBiYXJoZWlnaHQsIDEsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICAgICAgICB4ICs9IGVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcubWluV2lkdGggPSBjb3VudCAqIDEwO1xuICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3BhcmtMaW5lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2VsbFJlbmRlcmVyID0gcmVxdWlyZSgnLi9DZWxsUmVuZGVyZXInKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENlbGxSZW5kZXJlclxuICovXG52YXIgVHJlZUNlbGwgPSBDZWxsUmVuZGVyZXIuZXh0ZW5kKCdUcmVlQ2VsbCcsIHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIGEgdHJlZSBjZWxsIHJlbmRlcmVyIGZvciB1c2UgbWFpbmx5IHdpdGggdGhlIHF0cmVlLlxuICAgICAqIEBpbXBsZW1lbnRzIHBhaW50RnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgVHJlZUNlbGwucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnQ6IGZ1bmN0aW9uKGdjLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHggPSBjb25maWcuYm91bmRzLngsXG4gICAgICAgICAgICB5ID0gY29uZmlnLmJvdW5kcy55LFxuICAgICAgICAgICAgd2lkdGggPSBjb25maWcuYm91bmRzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmJvdW5kcy5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHZhbCA9IGNvbmZpZy52YWx1ZS5kYXRhO1xuICAgICAgICB2YXIgaW5kZW50ID0gY29uZmlnLnZhbHVlLmluZGVudDtcbiAgICAgICAgdmFyIGljb24gPSBjb25maWcudmFsdWUuaWNvbjtcblxuICAgICAgICAvL2ZpbGwgYmFja2dyb3VuZCBvbmx5IGlmIG91ciBiZ0NvbG9yIGlzIHBvcHVsYXRlZCBvciB3ZSBhcmUgYSBzZWxlY3RlZCBjZWxsXG4gICAgICAgIGlmIChjb25maWcuYmFja2dyb3VuZENvbG9yIHx8IGNvbmZpZy5pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBnYy5maWxsU3R5bGUgPSBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3IgOiBjb25maWcuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZhbCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZ25PZmZzZXQgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gY29uZmlnLmlzU2VsZWN0ZWQgPyBjb25maWcuYmFja2dyb3VuZENvbG9yIDogY29uZmlnLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgZ2MuZmlsbFRleHQoaWNvbiArIHZhbCwgeCArIGluZGVudCwgeSArIHZhbGlnbk9mZnNldCk7XG5cbiAgICAgICAgdmFyIHRleHRXaWR0aCA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIGljb24gKyB2YWwpO1xuICAgICAgICB2YXIgbWluV2lkdGggPSB4ICsgaW5kZW50ICsgdGV4dFdpZHRoICsgMTA7XG4gICAgICAgIGNvbmZpZy5taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyZWVDZWxsO1xuIiwiLyoqXG4gKiBAc3VtbWFyeSBBUEkgb2YgY2VsbCByZW5kZXJlciBvYmplY3QgY29uc3RydWN0b3JzLCBwbHVzIHNvbWUgYWNjZXNzIG1ldGhvZHMuXG4gKiBAbW9kdWxlIGNlbGxSZW5kZXJlcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBbcHJpdmF0ZVJlZ2lzdHJ5PWZhbHNlXSAtIFRoaXMgaW5zdGFuY2Ugd2lsbCB1c2UgYSBwcml2YXRlIHJlZ2lzdHJ5LlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENlbGxSZW5kZXJlcnMocHJpdmF0ZVJlZ2lzdHJ5KSB7XG4gICAgaWYgKHByaXZhdGVSZWdpc3RyeSkge1xuICAgICAgICB0aGlzLnNpbmdsZXRvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBwcmVyZWdpc3RlciB0aGUgc3RhbmRhcmQgY2VsbCByZW5kZXJlcnNcbiAgICBpZiAocHJpdmF0ZVJlZ2lzdHJ5IHx8ICF0aGlzLmdldCgnZW1wdHljZWxsJykpIHtcbiAgICAgICAgdGhpcy5hZGQoJ0VtcHR5Q2VsbCcsIHJlcXVpcmUoJy4vQ2VsbFJlbmRlcmVyJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL0J1dHRvbicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9TaW1wbGVDZWxsJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL1NsaWRlckNlbGwnKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vU3BhcmtCYXInKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vTGFzdFNlbGVjdGlvbicpKTtcbiAgICAgICAgdGhpcy5hZGQocmVxdWlyZSgnLi9TcGFya0xpbmUnKSk7XG4gICAgICAgIHRoaXMuYWRkKHJlcXVpcmUoJy4vRXJyb3JDZWxsJykpO1xuICAgICAgICB0aGlzLmFkZChyZXF1aXJlKCcuL1RyZWVDZWxsJykpO1xuICAgIH1cbn1cblxuQ2VsbFJlbmRlcmVycy5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENlbGxSZW5kZXJlcnMucHJvdG90eXBlLmNvbnN0cnVjdG9yLCAvLyBwcmVzZXJ2ZSBjb25zdHJ1Y3RvclxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgYW5kIGluc3RhbnRpYXRlIGEgY2VsbCByZW5kZXJlciBzaW5nbGV0b24uXG4gICAgICogQGRlc2MgQWRkcyBhIGN1c3RvbSBjZWxsIHJlbmRlcmVyIHRvIHRoZSBgc2luZ2xldG9uc2AgaGFzaCB1c2luZyB0aGUgcHJvdmlkZWQgbmFtZSAob3IgdGhlIGNsYXNzIG5hbWUpLCBjb252ZXJ0ZWQgdG8gYWxsIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiA+IEFsbCBuYXRpdmUgY2VsbCByZW5kZXJlcnMgYXJlIFwicHJlcmVnaXN0ZXJlZFwiIGluIGBzaW5nbGV0b25zYC4gQWRkIG1vcmUgYnkgY2FsbGluZyBgZ2V0YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gLSBDYXNlLWluc2Vuc2l0aXZlIHJlbmRlcmVyIGtleS4gSWYgbm90IGdpdmVuLCBgWW91ckNlbGxSZW5kZXJlci5wcm90b3R5cGUuJCRDTEFTU19OQU1FYCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDZWxsUmVuZGVyZXJ9IENvbnN0cnVjdG9yIC0gQSBjb25zdHJ1Y3RvciwgdHlwaWNhbGx5IGV4dGVuZGVkIGZyb20gYENlbGxSZW5kZXJlcmAgKG9yIGEgZGVzY2VuZGFudCB0aGVyZWZyb20pLlxuICAgICAqXG4gICAgICogPiBOb3RlOiBgJCRDTEFTU19OQU1FYCBjYW4gYmUgZWFzaWx5IHNldCB1cCBieSBwcm92aWRpbmcgYSBzdHJpbmcgYXMgdGhlIChvcHRpb25hbCkgZmlyc3QgcGFyYW1ldGVyIChgYWxpYXNgKSBpbiB5b3VyIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9leHRlbmQtbWV8Q2VsbEVkaXRvci5leHRlbmR9IGNhbGwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q2VsbFJlbmRlcmVyc30gQSBuZXdseSByZWdpc3RlcmVkIGNvbnN0cnVjdG9yIGV4dGVuZGVkIGZyb20ge0BsaW5rIENlbGxSZW5kZXJlcnN9LlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihuYW1lLCBDb25zdHJ1Y3Rvcikge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gbmFtZSB8fCBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuJCRDTEFTU19OQU1FO1xuICAgICAgICBuYW1lID0gbmFtZSAmJiBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiAodGhpcy5zaW5nbGV0b25zW25hbWVdID0gbmV3IENvbnN0cnVjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVnaXN0ZXIgYSBzeW5vbnltIGZvciBhbiBleGlzdGluZyBjZWxsIHJlbmRlcmVyIHNpbmdsZXRvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3lub255bU5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhpc3RpbmdOYW1lXG4gICAgICogQHJldHVybnMge0NlbGxSZW5kZXJlcnN9IFRoZSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgY29uc3RydWN0b3IgdGhpcyBuZXcgc3lub255bSBwb2ludHMgdG8uXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgYWRkU3lub255bTogZnVuY3Rpb24oc3lub255bU5hbWUsIGV4aXN0aW5nTmFtZSkge1xuICAgICAgICB2YXIgY2VsbFJlbmRlcmVyID0gdGhpcy5nZXQoZXhpc3RpbmdOYW1lKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNpbmdsZXRvbnNbc3lub255bU5hbWVdID0gY2VsbFJlbmRlcmVyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSByZWdpc3RlcmVkIGNlbGwgcmVuZGVyZXIgc2luZ2xldG9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge0NlbGxSZW5kZXJlcnN9IEEgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciBleHRlbmRlZCBmcm9tIHtAbGluayBDZWxsUmVuZGVyZXJzfS5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFJlbmRlcmVycy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2luZ2xldG9uc1tuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjZWxsIGVkaXRvciByZWdpc3RyeSBjb250YWluaW5nIGFsbCB0aGUgXCJwcmVyZWdpc3RlcmVkXCIgY2VsbCByZW5kZXJlciBzaW5nbGV0b25zLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlck9mIENlbGxSZW5kZXJlcnMucHJvdG90eXBlXG4gICAgICovXG4gICAgc2luZ2xldG9uczoge31cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsUmVuZGVyZXJzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4uL0Jhc2UnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERhdGFNb2RlbCA9IEJhc2UuZXh0ZW5kKCdEYXRhTW9kZWwnLCB7XG4gICAgZ3JpZDogbnVsbCxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgfSxcblxuICAgIGNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRlcHJlY2F0ZWQoJ2NoYW5nZWQoKScsICdncmlkLmJlaGF2aW9yLmNoYW5nZWQoKScsICcxLjEuMCcpO1xuICAgIH0sXG5cbiAgICBnZXRQcml2YXRlU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRQcml2YXRlU3RhdGUoKScsICdncmlkLnByb3BlcnRpZXMnLCAnMS4yLjAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZWNsYXJlZFJlbmRlcmVyTmFtZSAtIFRoZSBwcm9wb3NlZCBjZWxsIHJlbmRlcmVyIG5hbWUgKGZvcm0gdGhlIHJlbmRlciBwcm9wZXJ0aWVzKS5cbiAgICAgKiBAcmV0dXJucyB7Q2VsbFJlbmRlcmVyfVxuICAgICAqIEBtZW1iZXJPZiBEYXRhTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Q2VsbDogZnVuY3Rpb24oY29uZmlnLCBkZWNsYXJlZFJlbmRlcmVyTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmNlbGxSZW5kZXJlcnMuZ2V0KGRlY2xhcmVkUmVuZGVyZXJOYW1lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgSW5zdGFudGlhdGUgYSBuZXcgY2VsbCBlZGl0b3IuXG4gICAgICogQGRlc2MgVGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG86XG4gICAgICogKiBJbnN0YW50aWF0ZSBhbmQgcmV0dXJuIGFuIGFyYml0cmFyeSBjZWxsIGVkaXRvci4gVGhlIGdlbmVyaWMgaW1wbGVtZW50YXRpb24gaGVyZSBzaW1wbHkgcmV0dXJucyB0aGUgZGVjbGFyZWQgY2VsbCBlZGl0b3IuIFRoaXMgaXMgYHVuZGVmaW5lZGAgd2hlbiB0aGVyZSB3YXMgbm8gc3VjaCBkZWNsYXJhdGlvbiwgb3IgaWYgdGhlIG5hbWVkIGNlbGwgZWRpdG9yIHdhcyBub3QgcmVnaXN0ZXJlZC5cbiAgICAgKiAqIFJldHVybiBgdW5kZWZpbmVkYCBmb3Igbm8gY2VsbCBlZGl0b3IgYXQgYWxsLiBUaGUgY2VsbCB3aWxsIG5vdCBiZSBlZGl0YWJsZS5cbiAgICAgKiAqIFNldCBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZSBieSBwYXNzaW5nIHRoZW0gaW4gdGhlIGBvcHRpb25zYCBvYmplY3QuIFRoZXNlIGFyZSBhcHBsaWVkIHRvIHRoZSBuZXcgY2VsbCBlZGl0b3Igb2JqZWN0IGFmdGVyIGluc3RhbnRpYXRpb24gYnV0IGJlZm9yZSByZW5kZXJpbmcuXG4gICAgICogKiBNYW5pcHVsYXRlIHRoZSBjZWxsIGVkaXRvciBvYmplY3QgKGluY2x1ZGluZyBpdHMgRE9NIGVsZW1lbnRzKSBhZnRlciByZW5kZXJpbmcgYnV0IGJlZm9yZSBET00gaW5zZXJ0aW9uLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGluZyB0aGlzIG1ldGhvZCB3aXRoIGEgbnVsbCBmdW5jdGlvbiAodGhhdCBhbHdheXMgcmV0dXJucyBgdW5kZWZpbmVkYCkgd2lsbCBoYXZlIHRoZSBlZmZlY3Qgb2YgbWFraW5nIGFsbCBjZWxscyB1bmVkaXRhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gQWJzb2x1dGUgY29sdW1uIGluZGV4LiBJLmUuLCB0aGUgcG9zaXRpb24gb2YgdGhlIGNvbHVtbiBpbiB0aGUgZGF0YSBzb3VyY2UncyBvcmlnaW5hbCBgZmllbGRzYCBhcnJheSwgYXMgZWNob2VkIGluIGBiZWhhdmlvci5hbGxDb2x1bW5zW11gLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFJvdyBpbmRleCBvZiB0aGUgZGF0YSByb3cgaW4gdGhlIGN1cnJlbnRseSBmaWx0ZXJlZCBhbmQgc29ydGVkIGxpc3Qgb2Ygcm93cywgcmVnYXJkbGVzcyBvZiB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb24sIG9mZnNldCBieSB0aGUgbnVtYmVyIG9mIGhlYWRlciByb3dzIChhbGwgdGhlIHJvd3MgYWJvdmUgdGhlIGZpcnN0IGRhdGEgcm93IGluY2x1ZGluZyB0aGUgZmlsdGVyIHJvdykuIEkuZS4sIGFmdGVyIHN1YnRyYWN0aW5nIG91dCB0aGUgbnVtYmVyIG9mIGhlYWRlciByb3dzLCB0aGlzIGlzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGF0YSByb3cgaW4gdGhlIGBpbmRleGAgYXJyYXkgb2YgdGhlIGRhdGEgc291cmNlIChpLmUuLCB0aGUgbGFzdCBkYXRhIHNvdXJjZSBwaXBlbGluZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlY2xhcmVkRWRpdG9yTmFtZSAtIFRoZSBwcm9wb3NlZCBjZWxsIGVkaXRvciBuYW1lIChmcm9tIHRoZSByZW5kZXIgcHJvcGVydGllcykuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBQcm9wZXJ0aWVzIHRvIGNvcHkgdG8gdGhlIG5ldyBjZWxsIGVkaXRvciBwcmltYXJpbHkgZm9yIG11c3RhY2hlJ3MgdXNlLiBBZGRpdGlvbmFsbHksIGFsd2F5cyBpbmNsdWRlcyB0aGUgZm9sbG93aW5nOlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmZvcm1hdCAtIFRoZSB2YWx1ZSBvZiB0aGUgYGZvcm1hdGAgcmVuZGVyIHByb3AuIE1heSBiZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jb2x1bW4gLSBGb3IgY29udmVuaWVuY2UsIHRoZSBjb2x1bW4gb2JqZWN0IGluIGBiZWhhdmlvci5hbGxDb2x1bW5zW11gIHRvIHdoaWNoIGBjb2x1bW5JbmRleGAgcmVmZXJzLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IG9wdGlvbnMuZWRpdFBvaW50IC0gRGVwcmVjYXRlZDsgdXNlIGBvcHRpb25zLmdyaWRDZWxsYC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBvcHRpb25zLmdyaWRDZWxsIC0gVGhlIGdyaWQgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbGwgdG8gZWRpdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5ncmlkQ2VsbC54IC0gVGhlIGhvcml6b250YWwgbW9kZWwgY29vcmRpbmF0ZSBvZiB0aGUgY2VsbCB0byBlZGl0LiBUaGlzIGlzIHRoZSBncmlkIGNvb3JkaW5hdGUgcmVnYXJkbGVzcyBvZiBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbi4gSS5lLiwgdGhlIHBvc2l0aW9uIG9mIHRoZSBjb2x1bW4gaW4gdGhlIG9yZGVyZWQgbGlzdCBvZiBzZWxlY3RlZCBjb2x1bW5zIChgYmVoYXZpb3IuY29sdW1uc1tdYCkuIChUaGlzIGlzIHRoZSBjb29yZGluYXRlIHJlcXVpcmVkIGJ5IHtAbGluayBIeXBlcmdyaWQjZWRpdEF0fGVkaXRBdH0uKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmdyaWRDZWxsLnkgLSBTYW1lIGFzIGByb3dJbmRleGAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfENlbGxFZGl0b3J9IEFuIG9iamVjdCBpbnN0YW50aWF0ZWQgZnJvbSB0aGUgcmVnaXN0ZXJlZCBjZWxsIGVkaXRvciBjb25zdHJ1Y3RvciBuYW1lZCBpbiBgZGVjbGFyZWRFZGl0b3JOYW1lYC4gQSBmYWxzeSByZXR1cm4gbWVhbnMgdGhlIGNlbGwgaXMgbm90IGVkaXRhYmxlIGJlY2F1c2UgdGhlIGBkZWNsYXJlZEVkaXRvck5hbWVgIHdhcyBub3QgcmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Q2VsbEVkaXRvckF0OiBmdW5jdGlvbihjb2x1bW5JbmRleCwgcm93SW5kZXgsIGRlY2xhcmVkRWRpdG9yTmFtZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmNlbGxFZGl0b3JzLmNyZWF0ZShkZWNsYXJlZEVkaXRvck5hbWUsIG9wdGlvbnMpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU1vZGVsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1hZ2VzID0gcmVxdWlyZSgnLi4vLi4vaW1hZ2VzJyk7XG5cbmZ1bmN0aW9uIEZpbHRlclJvdyhncmlkKSB7XG4gICAgdGhpcy5ncmlkID0gZ3JpZDtcbiAgICB0aGlzLmJlaGF2aW9yID0gZ3JpZC5iZWhhdmlvcjtcbiAgICB0aGlzLmRhdGFSb3cgPSB7fTsgLy8gZm9yIG1ldGEgZGF0YSAoX19IRUlHSFQpXG59XG5cbkZpbHRlclJvdy5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IEZpbHRlclJvdy5wcm90b3R5cGUuY29uc3RydWN0b3IsXG5cbiAgICB0eXBlOiAnZmlsdGVyJyxcblxuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5pc1Nob3dGaWx0ZXJSb3coKSA/IDEgOiAwO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBjaGVja0ZvckNvbHVtbkZpbHRlcnMuY2FsbCh0aGlzKTtcblxuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5iZWhhdmlvci5nZXRDb2x1bW4oeCksXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmJlaGF2aW9yLmZpbHRlci5nZXRDb2x1bW5GaWx0ZXJTdGF0ZShjb2x1bW4ubmFtZSkgfHwgJyc7XG5cbiAgICAgICAgcmVzdWx0ID0gW251bGwsIHJlc3VsdCwgaW1hZ2VzLmZpbHRlcihyZXN1bHQubGVuZ3RoKV07XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIGNoZWNrRm9yQ29sdW1uRmlsdGVycy5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmJlaGF2aW9yLmdldENvbHVtbih4KTtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5maWx0ZXIuc2V0Q29sdW1uRmlsdGVyU3RhdGUoY29sdW1uLm5hbWUsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFSb3c7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gY2hlY2tGb3JDb2x1bW5GaWx0ZXJzKCkge1xuICAgIGlmICghdGhpcy5iZWhhdmlvci5maWx0ZXIuZ2V0Q29sdW1uRmlsdGVyU3RhdGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IHRoaXMuYmVoYXZpb3IuSHlwZXJncmlkRXJyb3IoJ0NvbHVtbiBmaWx0ZXJzIG5vdCBhdmFpbGFibGUuJyk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlclJvdztcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gSGVhZGVyUm93KGdyaWQpIHtcbiAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgIHRoaXMuYmVoYXZpb3IgPSBncmlkLmJlaGF2aW9yO1xuICAgIHRoaXMuZGF0YVJvdyA9IHt9OyAvLyBmb3IgbWV0YSBkYXRhIChfX0hFSUdIVClcbn1cblxuSGVhZGVyUm93LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogSGVhZGVyUm93LnByb3RvdHlwZS5jb25zdHJ1Y3RvcixcblxuICAgIHR5cGU6ICdoZWFkZXInLFxuXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmlzU2hvd0hlYWRlclJvdygpID8gMSA6IDA7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmJlaGF2aW9yLmdldENvbHVtbih4KSxcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbHVtbi5oZWFkZXIgfHwgY29sdW1uLm5hbWUsIC8vIHVzZXMgZmllbGQgbmFtZSB3aGVuIGhlYWRlciB1bmRlZmluZWRcbiAgICAgICAgICAgIHNvcnRTdHJpbmcgPSB0aGlzLmJlaGF2aW9yLmRhdGFNb2RlbC5nZXRTb3J0SW1hZ2VGb3JDb2x1bW4oeCksXG4gICAgICAgICAgICBncm91cHM7XG5cbiAgICAgICAgaWYgKHNvcnRTdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIGlmIGdyb3VwZWQgaGVhZGVyLCBwcmVwZW5kIGdyb3VwIGhlYWRlcnMgdG8gc29ydCBkaXJlY3Rpb24gaW5kaWNhdG9yXG4gICAgICAgICAgICBpZiAoKGdyb3VwcyA9IHJlc3VsdC5sYXN0SW5kZXhPZih0aGlzLmJlaGF2aW9yLmdyb3VwSGVhZGVyRGVsaW1pdGVyKSArIDEpKSB7XG4gICAgICAgICAgICAgICAgc29ydFN0cmluZyA9IHJlc3VsdC5zdWJzdHIoMCwgZ3JvdXBzKSArIHNvcnRTdHJpbmc7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cihncm91cHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwcmVwZW5kIHNvcnQgZGlyZWN0aW9uIGluZGljYXRvciB0byBjb2x1bW4gaGVhZGVyXG4gICAgICAgICAgICByZXN1bHQgPSBzb3J0U3RyaW5nICsgcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3IuZ2V0Q29sdW1uKHgpLmhlYWRlciA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVJvdztcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYWRlclJvdztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFNb2RlbCA9IHJlcXVpcmUoJy4vRGF0YU1vZGVsJyk7XG52YXIgRGF0YVNvdXJjZU9yaWdpbiA9IHJlcXVpcmUoJy4uL2RhdGFTb3VyY2VzL0RhdGFTb3VyY2VPcmlnaW4nKTtcblxuLyoqIEB0eXBlZGVmIHtvYmplY3R9IGRhdGFTb3VyY2VQaXBlbGluZU9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgLSBBIFwiRGF0YVNvdXJjZU9yaWdpblwiIHN0eWxlIGNvbnN0cnVjdG9yIG5hbWUuXG4gKiBAcHJvcGVydHkgeyp9IFtvcHRpb25zXSAtIFdoZW4gZGVmaW5lZCwgcGFzc2VkIGFzIDJuZCBhcmd1bWVudCB0byBjb25zdHJ1Y3Rvci5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGFyZW50XSAtIERlZmluZXMgYSBicmFuY2ggb2ZmIHRoZSBtYWluIHNlcXVlbmNlLlxuICovXG5cbi8qKlxuICogQGltcGxlbWVudHMgZGF0YVNvdXJjZUhlbHBlckFQSVxuICogQGRlc2MgVGhpcyBpcyBhIHNpbXBsZSBcIm51bGxcIiBoZWxwZXIgQVBJIGltcGxlbWVudGF0aW9uIHdpdGggb25seSBhIG51bGwgYHByb3BlcnRpZXNgIG1ldGhvZCBpcyBkZWZpbmVkLlxuICogQHNlZSB7QGxpbmsgaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9OdWxsT2JqZWN0fVxuICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTlxuICogQGlubmVyXG4gKi9cbnZhciBudWxsRGF0YVNvdXJjZUhlbHBlckFQSSA9IHtcbiAgICBwcm9wZXJ0aWVzOiBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgICBpc0dldHRlciA9ICdnZXRQcm9wTmFtZScgaW4gcHJvcGVydGllcztcblxuICAgICAgICBpZiAoaXNHZXR0ZXIpIHtcbiAgICAgICAgICAgIC8vIEFsbCBwcm9wcyBhcmUgdW5kZWZpbmVkIGluIHRoaXMgbnVsbCBBUEkgcmVnYXJkbGVzcyBvZiB0aGVpciBuYW1lOyBhbmRcbiAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBwcm9wcyByZXR1cm4gYG51bGxgIGFzIHBlciBpbnRlcmZhY2UgZGVmaW5pdGlvbi5cbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbi8qKlxuICogQG5hbWUgZGF0YU1vZGVscy5KU09OXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERhdGFNb2RlbFxuICovXG52YXIgSlNPTiA9IERhdGFNb2RlbC5leHRlbmQoJ2RhdGFNb2RlbHMuSlNPTicsIHtcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldChvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdG8gdXNlIGEgZGlmZmVyZW50IG9yaWdpbi5cbiAgICAgKiBAdHlwZShEYXRhU291cmNlQmFzZX1cbiAgICAgKi9cbiAgICBEYXRhU291cmNlT3JpZ2luOiBEYXRhU291cmNlT3JpZ2luLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2RhdGFTb3VyY2VQaXBlbGluZU9iamVjdFtdW119XG4gICAgICogQHN1bW1hcnkgUGlwZWxpbmUgc3Rhc2ggcHVzaC1kb3duIGxpc3QuXG4gICAgICogQGRlc2MgVGhlIHBpcGVsaW5lIHN0YXNoIG1heSBiZSBzaGFyZWQgb3IgaW5zdGFuY2VkLiBUaGlzIGlzIHRoZSBzaGFyZWQgc3Rhc2guIEFuIGluc3RhbmNlIG1heSBvdmVycmlkZSB0aGlzIHdpdGggYW4gaW5zdGFuY2Ugc3Rhc2ggdmFyaWFibGUgKG9mIHRoZSBzYW1lIG5hbWUpLiBTZWUge0BsaW5rIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGUjZ2V0UGlwZWxpbmVTY2hlbWFTdGFzaH0uXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBwaXBlbGluZVNjaGVtYVN0YXNoOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWREYXRhID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IEhhc2ggb2YgZGF0YSBzb3VyY2UgaGVscGVyIEFQSXMuXG4gICAgICAgICAqIEBkZXNjIEtleWVkIGJ5IGRhdGEgc291cmNlIHR5cGUuIEFuIEFQSSBpcyByZXF1aXJlZCBieSBkYXRhIHNvdXJjZXMgd2l0aCBhbiBgYXBpYCBwcm9wZXJ0eS5cbiAgICAgICAgICogQHNlZSB7QGxpbmsgZGF0YU1vZGVscy5KU09OL3VwZGF0ZURhdGFTb3VyY2VzfVxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcGkgPSB7fTtcblxuICAgICAgICBkZWxldGUgdGhpcy5waXBlbGluZVNjaGVtYVN0YXNoOyAvLyByZW1vdmUgZXhpc3RpbmcgXCJvd25cIiB2ZXJzaW9uIGlmIGFueVxuXG4gICAgICAgIHRoaXMuc291cmNlID0gbmV3IHRoaXMuRGF0YVNvdXJjZU9yaWdpbihvcHRpb25zLmRhdGEsIG9wdGlvbnMuc2NoZW1hKTtcblxuICAgICAgICB0aGlzLnNldFBpcGVsaW5lKCk7XG4gICAgICAgIC8vUmVnaXN0ZXIgRGVmYXVsdHNcbiAgICAgICAgdGhpcy5yZWdpc3RlckhlbHBlckFQSSgnZmlsdGVyJyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJIZWxwZXJBUEkoJ3NvcnRlcicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgZGVmYXVsdCBkYXRhIHNvdXJjZXMgZm9yIGEgbmV3IHBpcGVsaW5lIHdoZW4gbm9uZSBhcmUgZ2l2ZS5cbiAgICAgKiBAZGVzYyBGb3Igbm93IEZpbHRlcmluZyBpcyBoYXJkY29kZWQgaW4gdGhlIGdyaWQuXG4gICAgICogSW4gdGhlIGZ1dHVyZSwgdGhpcyB3aWxsIGxpa2VseSBiZSBlbXB0eSAodW5sZXNzIG92ZXJyaWRkZW4gYnkgYXBwbGljYXRpb24gZGV2ZWxvcGVyIGZvciBoaXMgb3duIHB1cnBvc2VzKS5cbiAgICAgKiBAdHlwZSB7cGlwZWxpbmVTY2hlbWF9XG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkZWZhdWx0UGlwZWxpbmVTY2hlbWE6IFtdLFxuXG4gICAgY2xlYXJTZWxlY3RlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0YS5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBBcyBvZiB2MS4wLjcsIHJlZmVyZW5jZSB0aGUgYGRhdGFTb3VyY2VgIHByb3BlcnR5IGluc3RlYWQuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0RGF0YVNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldERhdGFTb3VyY2UoKScsICdkYXRhU291cmNlJywgJzEuMC43Jyk7XG4gICAgfSxcblxuICAgIGdldERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgQXMgb2YgdjEuMS4wLCB1c2UgZ2V0SW5kZXhlZERhdGFcbiAgICAgKi9cbiAgICBnZXRGaWx0ZXJlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRGaWx0ZXJlZERhdGEoKScsICdnZXRJbmRleGVkRGF0YSgpJywgJzEuMi4wJywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgZ2V0SW5kZXhlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZHMgPSB0aGlzLmRhdGFTb3VyY2U7XG4gICAgICAgIHZhciBjb3VudCA9IGRzLmdldFJvd0NvdW50KCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNvdW50OyB5KyspIHtcbiAgICAgICAgICAgIHJlc3VsdFt5XSA9IGRzLmdldFJvdyh5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIERhdGEgY29sdW1uIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBEYXRhIHJvdyBjb29yZGluYXRlLlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzSGllcmFyY2h5Q29sdW1uKCkpIHtcbiAgICAgICAgICAgIGlmICh4ID09PSAtMikge1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEcmlsbERvd24oKSkge1xuICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0VmFsdWUoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gRGF0YSByb3cgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXREYXRhSW5kZXgoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBEYXRhIGNvbHVtbiBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByIC0gR3JpZCByb3cgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzSGllcmFyY2h5Q29sdW1uKCkpIHtcbiAgICAgICAgICAgIGlmICh4ID09PSAtMikge1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNEcmlsbERvd24oKSkge1xuICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXRWYWx1ZSh4LCByLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEFzIG9mIHYxLjEuMCwgdXNlIGB0aGlzLmdyaWQuYmVoYXZpb3IuZ2V0Q29sdW1uUHJvcGVydGllcyh4KWAgaW5zdGVhZC5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gRGF0YSBjb2x1bW4gY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIC8vYWNjZXNzIGRpcmVjdGx5IGJlY2F1c2Ugd2Ugd2FudCBpdCBvcmRlcmVkXG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldENvbHVtblByb3BlcnRpZXMoeCknLCAnZ3JpZC5iZWhhdmlvci5nZXRDb2x1bW5Qcm9wZXJ0aWVzKHgpJywgJzEuMi4wJywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNob3dUcmVlID0gdGhpcy5ncmlkLnByb3BlcnRpZXMuc2hvd1RyZWVDb2x1bW4gPT09IHRydWU7XG4gICAgICAgIHZhciBvZmZzZXQgPSAodGhpcy5pc0RyaWxsRG93bigpICYmICFzaG93VHJlZSkgPyAtMSA6IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Q29sdW1uQ291bnQoKSArIG9mZnNldDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFNjaGVtYVByb3BBcnIuY2FsbCh0aGlzLCAnaGVhZGVyJywgJ2dldEhlYWRlcnMnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBoZWFkZXJzXG4gICAgICovXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVycykge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc2V0SGVhZGVycyhoZWFkZXJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZHNcbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc2V0RmllbGRzKGZpZWxkcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldEZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRTY2hlbWFQcm9wQXJyLmNhbGwodGhpcywgJ25hbWUnLCAnZ2V0RmllbGRzJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIGdldENhbGN1bGF0b3JzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFNjaGVtYVByb3BBcnIuY2FsbCh0aGlzLCAnY2FsY3VsYXRvcicsICdnZXRDYWxjdWxhdG9ycycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlaW5kZXg6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgc2VsZWN0ZWREYXRhUm93c0JhY2tpbmdTZWxlY3RlZEdyaWRSb3dzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdGhpcy5waXBlbGluZS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChkYXRhU291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFTb3VyY2UuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5hcHBseShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc2VsZWN0R3JpZFJvd3NCYWNrZWRCeVNlbGVjdGVkRGF0YVJvd3MuY2FsbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgU2V0IG9yIHJlc2V0IGdyaWQgZGF0YS5cbiAgICAgKiBTZWUge0BsaW5rIERhdGFTb3VyY2VPcmlnaW4jc2V0RGF0YX0gZm9yIGRldGFpbHMuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhU291cmNlLCBzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5zb3VyY2Uuc2V0RGF0YShkYXRhU291cmNlLCBzY2hlbWEpO1xuICAgIH0sXG5cbiAgICAvKiogQHR5cGVkZWYgcGlwZWxpbmVTY2hlbWFcbiAgICAgKiBAdHlwZSB7RGF0YVNvdXJjZUJhc2VbXX1cbiAgICAgKiBAc3VtbWFyeSBEZXNjcmliZXMgYSBuZXcgcGlwZWxpbmUuXG4gICAgICogQGRlc2MgQ29uc2lzdHMgb2YgYW4gb3JkZXJlZCBsaXN0IG9mIGRhdGEgc291cmNlIGNvbnN0cnVjdG9ycywgZGVzY2VuZGFudHMgb2YgYERhdGFTb3VyY2VCYXNlYC5cbiAgICAgKiBNYXkgY29udGFpbiBgdW5kZWZpbmVkYCBlbGVtZW50cywgd2hpY2ggYXJlIGlnbm9yZWQuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbnN0YW50aWF0ZXMgdGhlIGRhdGEgc291cmNlIHBpcGVsaW5lLlxuICAgICAqIEBkZXNjIEVhY2ggbmV3IHBpcGUgaXMgY3JlYXRlZCBmcm9tIHRoZSBsaXN0IG9mIHN1cHBsaWVkIGNvbnN0cnVjdG9ycywgZWFjaCB0YWtpbmcgYSByZWZlcmVuY2UgdG8gdGhlIHByZXZpb3VzIGRhdGEgc291cmNlIGluIHRoZSBwaXBlbGluZS5cbiAgICAgKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIGVhY2ggbmV3IHBpcGUgaXMgYWRkZWQgdG8gYHRoaXMuc291cmNlc2AgZGF0YU1vZGVsIHVzaW5nIHRoZSBwaXBlJ3MgZGVyaXZlZCBuYW1lLlxuICAgICAqXG4gICAgICogV2lsbCBjbGVhciBvdXQgYW55IGZpbHRlcmluZyBhbmQgc29ydGluZyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIFRoZSBsYXN0IHBpcGUgaXMgYXNzaWduZWQgdGhlIHN5bm9ueW0gYHRoaXMuZGF0YVNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtwaXBlbGluZVNjaGVtYX0gW0RhdGFTb3VyY2VzXSAtIE5ldyBwaXBlbGluZSBkZXNjcmlwdGlvbi4gSWYgbm90IGdpdmVuLCB1c2VzIHRoZSBkZWZhdWx0IHtAbGluayBkYXRhTW9kZWxzLkpTT04jRGF0YVNvdXJjZXN8dGhpcy5kZWZhdWx0UGlwZWxpbmVTY2hlbWF9LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBUYWtlcyBmaXJzdCBhcmd1bWVudCBwb3NpdGlvbiB3aGVuIGBEYXRhU291cmNlc2Agb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3Rhc2hdIC0gU2VlIHtAbGluayBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlI2dldFBpcGVsaW5lU2NoZW1hU3Rhc2h9LiBJZiBnaXZlbiwgc2F2ZXMgdGhlIGN1cnJlbnRseSBkZWZpbmVkIHBpcGVsaW5lIG9udG8gdGhlIGluZGljYXRlZCBzdGFzaCBzdGFjayBhbmQgdGhlbiByZXNldHMgaXQgd2l0aCB0aGUgZ2l2ZW4gYERhdGFTb3VyY2VzYC5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldFBpcGVsaW5lOiBmdW5jdGlvbihEYXRhU291cmNlcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoRGF0YVNvdXJjZXMpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gRGF0YVNvdXJjZXM7XG4gICAgICAgICAgICBEYXRhU291cmNlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3Rhc2gpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0UGlwZWxpbmVTY2hlbWFTdGFzaChvcHRpb25zLnN0YXNoKS5wdXNoKHRoaXMuRGF0YVNvdXJjZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGFTb3VyY2UgPSB0aGlzLnNvdXJjZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgQ3VycmVudGx5IGRlZmluZWQgcGlwZWxpbmUuXG4gICAgICAgICAqIEBkZXNjIEVhY2ggaW5zdGFuY2UgaGFzIGl0cyBvd24gcGlwZWxpbmUuXG4gICAgICAgICAqIChQaXBlbGluZXMgY2Fubm90IGJlIHNoYXJlZCBiZWNhdXNlIHRoZXkgY29udGFpbiBpbmRleGVzIHNwZWNpZmljIHRvIHRoZSBkYXRhIGluIHRoZSBncmlkLilcbiAgICAgICAgICogQG5hbWUgcGlwZWxpbmVcbiAgICAgICAgICogQHR5cGUge2RhdGFTb3VyY2VQaXBlbGluZU9iamVjdFtdfVxuICAgICAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5waXBlbGluZSA9IFtdO1xuXG4gICAgICAgIERhdGFTb3VyY2VzID0gRGF0YVNvdXJjZXMgfHwgdGhpcy5kZWZhdWx0UGlwZWxpbmVTY2hlbWE7XG5cbiAgICAgICAgRGF0YVNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihEYXRhU291cmNlKSB7XG4gICAgICAgICAgICBpZiAoRGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UgPSBuZXcgRGF0YVNvdXJjZShkYXRhU291cmNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpcGVsaW5lLnB1c2goZGF0YVNvdXJjZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgYSBudWxsIGhlbHBlciBBUEkgZGVmaW5lZCBmb3IgYWxsIGRhdGEgc291cmNlcyB0aGF0IHJlcXVpcmUgb25lXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFTb3VyY2UudHlwZSAmJiBkYXRhU291cmNlLnNldCAmJiAhdGhpcy5hcGlbZGF0YVNvdXJjZS50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVySGVscGVyQVBJKGRhdGFTb3VyY2UudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZURhdGFTb3VyY2VzKCk7XG5cbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcblxuICAgICAgICB0aGlzLkRhdGFTb3VyY2VzID0gRGF0YVNvdXJjZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGxhc3QgZGF0YSBzb3VyY2UgaW4gdGhlIHBpcGVsaW5lIG9mIHNwZWNpZmllZCB0eXBlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHJldHVybnMge0RhdGFTb3VyY2VCYXNlfVxuICAgICAqL1xuICAgIGZpbmREYXRhU291cmNlQnlUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHZhciBkYXRhU291cmNlO1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5waXBlbGluZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgZGF0YVNvdXJjZSA9IHRoaXMucGlwZWxpbmVbaV07XG4gICAgICAgICAgICBpZiAoZGF0YVNvdXJjZS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFTb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVXBkYXRlIGRhdGEgc291cmNlcyB3aXRoIEFQSXMgb2YgbWF0Y2hpbmcgdHlwZXMuXG4gICAgICogQGRlc2MgT25seSB1cGRhdGVzIF9xdWFsaWZpZWRfIGRhdGEgc291cmNlcywgd2hpY2ggaW5jbHVkZTpcbiAgICAgKiAqIHRob3NlIGZvciB3aGljaCBhbiBBUEkgb2YgdGhlIGRhdGEgc291cmNlJ3MgdHlwZSBpcyBkZWZpbmVkIGluIGB0aGlzLmFwaWA7IGFuZFxuICAgICAqICogdGhvc2UgdGhhdCBjYW4gYWNjZXB0IGFuIEFQSSAoaGF2ZSBhbiBgYXBpYCBwcm9wZXJ0eSB0byBzZXQpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gLSBUeXBlIG9mIGRhdGEgc291cmNlIHRvIHVwZGF0ZS4gSWYgb21pdHRlZCwgdXBkYXRlcyBhbGwgZGF0YSBzb3VyY2VzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8b2JqZWN0fSBPbmUgb2Y6XG4gICAgICogYHR5cGVgIHNwZWNpZmllZCAtIFRoZSBudW1iZXIgb2YgdXBkYXRlZCBkYXRhIHNvdXJjZXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlLlxuICAgICAqIGB0eXBlYCBvbWl0dGVkIC0gSGFzaCBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgdXBkYXRlZCBkYXRhIHNvdXJjZXMgYnkgdHlwZS5cbiAgICAgKi9cbiAgICB1cGRhdGVEYXRhU291cmNlczogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgICAgYXBpID0gdGhpcy5hcGk7XG5cbiAgICAgICAgdGhpcy5waXBlbGluZS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoIXR5cGUgfHwgZGF0YVNvdXJjZS50eXBlID09PSB0eXBlKSAmJlxuICAgICAgICAgICAgICAgIGFwaVtkYXRhU291cmNlLnR5cGVdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkYXRhU291cmNlLnNldChhcGlbZGF0YVNvdXJjZS50eXBlXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tkYXRhU291cmNlLnR5cGVdID0gKHJlc3VsdHNbZGF0YVNvdXJjZS50eXBlXSB8fCAwKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0eXBlID8gcmVzdWx0c1t0eXBlXSA6IHJlc3VsdHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFRoZSBwaXBlbGluZSBzdGFzaCBjdXJyZW50bHkgaW4gdXNlIChlaXRoZXIgc2hhcmVkIG9yIGluc3RhbmNlKS5cbiAgICAgKiBAZGVzYyBJbnN0YW5jZSBzdGFzaCBpcyBjcmVhdGVkIGhlcmUgd2hlbiByZXF1ZXN0ZWQgYW5kIGluc3RhbmNlIGRvZXNuJ3QgeWV0IGhhdmUgaXRzIFwib3duXCIgdmVyc2lvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3doaWNoU3Rhc2hdIC0gT25lIG9mOlxuICAgICAqICogYCdzaGFyZWQnYCAtIFVzZSBzaGFyZWQgc3Rhc2guXG4gICAgICogKiBgJ293bicnIG9yIGAnaW5zdGFuY2UnYCAtIFVzZSBpbnN0YW5jZSBzdGFzaCwgY3JlYXRpbmcgaXQgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAgICogKiBgJ2RlZmF1bHQnYCBvciBgdW5kZWZpbmVkYCAtIFVzZSBpbnN0YW5jZSBzdGFzaCBpZiBwcmV2aW91c2x5IGNyZWF0ZWQ7IG90aGVyd2lzZSB1c2Ugc2hhcmVkIHN0YXNoLlxuICAgICAqIEByZXR1cm5zIFRoZSBwaXBlbGluZSBzdGFzaCBwdXNoLWRvd24gbGlzdC5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldFBpcGVsaW5lU2NoZW1hU3Rhc2g6IGZ1bmN0aW9uKHdoaWNoU3Rhc2gpIHtcbiAgICAgICAgdmFyIHN0YXNoO1xuICAgICAgICBzd2l0Y2ggKHdoaWNoU3Rhc2gpIHtcblxuICAgICAgICAgICAgY2FzZSAnc2hhcmVkJzpcbiAgICAgICAgICAgICAgICBzdGFzaCA9IERhdGFNb2RlbC5wcm90b3R5cGUuc3Rhc2g7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ293bic6XG4gICAgICAgICAgICBjYXNlICdpbnN0YW5jZSc6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCdwaXBlbGluZVNjaGVtYVN0YXNoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waXBlbGluZVNjaGVtYVN0YXNoID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGlzYWJsZSBlc2xpbnQgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgc3Rhc2ggPSB0aGlzLnBpcGVsaW5lU2NoZW1hU3Rhc2g7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Rhc2g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBvcHMgdGhlIGxhc3Qgc3Rhc2hlZCBwaXBlbGluZSBvZmYgdGhlIHN0YXNoIHN0YWNrLCBtYWtpbmcgaXQgdGhlIGN1cnJlbnRseSBkZWZpbmVkIHBpcGVsaW5lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbd2hpY2hTdGFzaF0gLSBTZWUge0BsaW5rIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGUjZ2V0UGlwZWxpbmVTY2hlbWFTdGFzaH0uXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB1bnN0YXNoUGlwZWxpbmU6IGZ1bmN0aW9uKHdoaWNoU3Rhc2gpIHtcbiAgICAgICAgdmFyIHBpcGVsaW5lU2NoZW1hU3Rhc2ggPSB0aGlzLmdldFBpcGVsaW5lU2NoZW1hU3Rhc2god2hpY2hTdGFzaCk7XG4gICAgICAgIGlmIChwaXBlbGluZVNjaGVtYVN0YXNoLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zZXRQaXBlbGluZShwaXBlbGluZVNjaGVtYVN0YXNoLnBvcCgpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3TGVuZ3RoPTBdXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0cnVuY2F0ZVBpcGVsaW5lOiBmdW5jdGlvbihuZXdMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgndHJ1bmNhdGVQaXBlbGluZShuZXdMZW5ndGgpJywgJ3NldFBpcGVsaW5lKCknLCAnMS4yLjAnLCBhcmd1bWVudHMsICdCdWlsZCBhIGxvY2FsIHBpcGVsaW5lIChhcnJheSBvZiBkYXRhIHNvdXJjZSBjb25zdHJ1Y3RvcnMpIGFuZCBwYXNzIGl0IHRvIHNldFBpcGVsaW5lLicpO1xuICAgIH0sXG5cbiAgICBpc0RyaWxsRG93bjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGNvbEluZGV4ID0gZXZlbnQgJiYgZXZlbnQuZ3JpZENlbGwgJiYgZXZlbnQuZ3JpZENlbGwueDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5pc0RyaWxsRG93bihjb2xJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSB0b3AgdG90YWwgcm93KHMpLlxuICAgICAqIEBwYXJhbSB7ZGF0YVJvd09iamVjdFtdfSB0b3RhbFJvd3MgLSBBcnJheSBvZiAwIG9yIG1vcmUgcm93cyBjb250YWluaW5nIHN1bW1hcnkgZGF0YS4gT21pdCB0byBzZXQgdG8gZW1wdHkgYXJyYXkuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKHRvdGFsUm93cykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGUoJ3NldFRvcFRvdGFscyhyb3dzKScsICdncmlkLmJlaGF2aW9yLnNldFRvcFRvdGFscyhyb3dzKScsICcxLjEuMCcsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSB0b3AgdG90YWwgcm93KHMpLlxuICAgICAqIEByZXR1cm5zIHtkYXRhUm93T2JqZWN0W119XG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGUoJ2dldFRvcFRvdGFscyhyb3dzKScsICdncmlkLmJlaGF2aW9yLmdldFRvcFRvdGFscyhyb3dzKScsICcxLjEuMCcsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHN1bW1hcnkgU2V0IHRoZSBib3R0b20gdG90YWwgcm93KHMpLlxuICAgICAqIEBwYXJhbSB7ZGF0YVJvd09iamVjdFtdfSB0b3RhbFJvd3MgLSBBcnJheSBvZiAwIG9yIG1vcmUgcm93cyBjb250YWluaW5nIHN1bW1hcnkgZGF0YS4gT21pdCB0byBzZXQgdG8gZW1wdHkgYXJyYXkuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRCb3R0b21Ub3RhbHM6IGZ1bmN0aW9uKHRvdGFsUm93cykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGUoJ3NldEJvdHRvbVRvdGFscyhyb3dzKScsICdncmlkLmJlaGF2aW9yLnNldEJvdHRvbVRvdGFscyhyb3dzKScsICcxLjEuMCcsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBib3R0b20gdG90YWwgcm93KHMpLlxuICAgICAqIEByZXR1cm5zIHtkYXRhUm93T2JqZWN0W119XG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRCb3R0b21Ub3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGUoJ2dldEJvdHRvbVRvdGFscyhyb3dzKScsICdncmlkLmJlaGF2aW9yLmdldEJvdHRvbVRvdGFscyhyb3dzKScsICcxLjEuMCcsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEFjdGl2ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmJlaGF2aW9yLmNvbHVtbnMuZmlsdGVyKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbHVtbi5uYW1lICE9PSAndHJlZSc7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBBcyBvZiB2MS4wLjYsIHVzZSBgdGhpcy5nZXRBY3RpdmVDb2x1bW5zYCBpbnN0ZWFkLlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnZ2V0VmlzaWJsZUNvbHVtbnMoKScsICdnZXRBY3RpdmVDb2x1bW5zKCknLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRIaWRkZW5Db2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZpc2libGUgPSB0aGlzLmdyaWQuYmVoYXZpb3IuY29sdW1ucztcbiAgICAgICAgdmFyIGFsbCA9IHRoaXMuZ3JpZC5iZWhhdmlvci5hbGxDb2x1bW5zO1xuICAgICAgICB2YXIgaGlkZGVuID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodmlzaWJsZS5pbmRleE9mKGFsbFtpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuLnB1c2goYWxsW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoaWRkZW4uc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5oZWFkZXIgPCBiLmhlYWRlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoaWRkZW47XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzaG93VHJlZSA9IHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLnNob3dUcmVlQ29sdW1uID09PSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0RyaWxsRG93bigpICYmIHNob3dUcmVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBpbmRleFxuICAgICAqIEBwYXJhbSByZXR1cm5Bc1N0cmluZ1xuICAgICAqIEBkZXNjIFByb3ZpZGVzIHRoZSB1bmljb2RlIGNoYXJhY3RlciB1c2VkIHRvIGRlbm90ZSB2aXN1YWxseSBpZiBhIGNvbHVtbiBpcyBhIHNvcnRlZCBzdGF0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFNvcnRJbWFnZUZvckNvbHVtbjogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgLy9Ob3QgaW1wbGVtZW50ZWRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNlbGxcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBDbGlja2VkIGluIGEgZHJpbGwtZG93biBjb2x1bW4uXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjZWxsQ2xpY2tlZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2NlbGxDbGlja2VkKGNlbGwsIGV2ZW50KScsICdjZWxsQ2xpY2tlZChldmVudCknLCAnMS4yLjAnLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZVJvdyhldmVudC5kYXRhQ2VsbC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVG9nZ2xlIHRoZSBkcmlsbC1kb3duIGNvbnRyb2wgb2YgYSB0aGUgc3BlY2lmaWVkIHJvdy5cbiAgICAgKiBAZGVzYyBPcGVyYXRlcyBvbmx5IG9uIHRoZSBmb2xsb3dpbmcgcm93czpcbiAgICAgKiAqIEV4cGFuZGFibGUgcm93cyAtIFJvd3Mgd2l0aCBhIGRyaWxsLWRvd24gY29udHJvbC5cbiAgICAgKiAqIFJldmVhbGVkIHJvd3MgLSBSb3dzIG5vdCBoaWRkZW4gaW5zaWRlIG9mIGNvbGxhcHNlZCBkcmlsbC1kb3ducy5cbiAgICAgKiBAcGFyYW0geSAtIFJldmVhbGVkIHJvdyBudW1iZXIuIChUaGlzIGlzIG5vdCB0aGUgcm93IElELilcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBhbmRdIC0gT25lIG9mOlxuICAgICAqICogYHRydWVgIC0gRXhwYW5kIHJvdy5cbiAgICAgKiAqIGBmYWxzZWAgLSBDb2xsYXBzZSByb3cuXG4gICAgICogKiBgdW5kZWZpbmVkYCAob3Igb21pdHRlZCkgLSBUb2dnbGUgc3RhdGUgb2Ygcm93LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gQ2hhbmdlZC4gU3BlY2lmaWNhbGx5LCBvbmUgb2Y6XG4gICAgICogKiBgdW5kZWZpbmVkYCByb3cgaGFkIG5vIGRyaWxsLWRvd24gY29udHJvbFxuICAgICAqICogYHRydWVgIGRyaWxsLWRvd24gY2hhbmdlZFxuICAgICAqICogYGZhbHNlYCBkcmlsbC1kb3duIHVuY2hhbmdlZCAod2FzIGFscmVhZHkgaW4gcmVxdWVzdGVkIHN0YXRlKVxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgdG9nZ2xlUm93OiBmdW5jdGlvbih5LCBleHBhbmQpIHtcbiAgICAgICAgLy9UT0RPOiBmaXJlIGEgcm93IHRvZ2dsZSBldmVudFxuICAgICAgICB2YXIgY2hhbmdlZDtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmlsbERvd24oKSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuZGF0YVNvdXJjZS5jbGljayh5LCBleHBhbmQpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlaW5kZXgoe3Jvd0NsaWNrOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLmJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHIgLSBEYXRhIHJvdyBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8dW5kZWZpbmVkfSBSZXR1cm5zIGRhdGEgcm93IG9iamVjdCBvciBgdW5kZWZpbmVkYCBpZiBhIGhlYWRlciByb3cuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3cocik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IF9HZXR0ZXI6XyBSZXR1cm4gdGhlIGZpbHRlciBmcm9tIHRoZSBkYXRhIG1vZGVsLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7ZGF0YVNvdXJjZUhlbHBlckFQSX0gVGhlIGdyaWQncyBjdXJyZW50bHkgYXNzaWduZWQgZmlsdGVyLlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0IGZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmZpbHRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgX1NldHRlcjpfIEFzc2lnbiBhIGZpbHRlciB0byB0aGUgZGF0YSBtb2RlbC5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtkYXRhU291cmNlSGVscGVyQVBJfHVuZGVmaW5lZHxudWxsfSBmaWx0ZXIgLSBPbmUgb2Y6XG4gICAgICogKiBBIGZpbHRlciBvYmplY3QgLSBUdXJucyB0aGUgZmlsdGVyICpPTiouXG4gICAgICogKiBgdW5kZWZpbmVkYCBvciBgbnVsbGAgLSBUdXJucyB0aGUgZmlsdGVyICpPRkYuKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IGZpbHRlcihmaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckhlbHBlckFQSSgnZmlsdGVyJywgZmlsdGVyKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IF9HZXR0ZXJfXG4gICAgICogQG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtzb3J0ZXJBUEl9IFRoZSBncmlkJ3MgY3VycmVudGx5IGFzc2lnbmVkIHNvcnRlci5cbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldCBzb3J0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5zb3J0ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IF9TZXR0ZXI6XyBBc3NpZ24gYSBzb3J0ZXIgdG8gdGhlIGdyaWQuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7c29ydGVyQVBJfHVuZGVmaW5lZHxudWxsfSBzb3J0ZXIgLSBPbmUgb2Y6XG4gICAgICogKiBBIHNvcnRlciBvYmplY3QsIHR1cm5pbmcgc29ydGluZyAqT04qLlxuICAgICAqICogSWYgYHVuZGVmaW5lZGAgb3IgYG51bGxgLCB0aGUge0BsaW5rIGRhdGFNb2RlbHMuSlNPTn5udWxsU29ydGVyfG51bGxTb3J0ZXJ9IGlzIHJlYXNzaWduZWQgdG8gdGhlIGdyaWQsIHR1cm5pbmcgc29ydGluZyAqT0ZGLipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBzb3J0ZXIoc29ydGVyKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJIZWxwZXJBUEkoJ3NvcnRlcicsIHNvcnRlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIHRoZSBkYXRhIHNvdXJjZSBoZWxwZXIgQVBJLlxuICAgICAqIEBkZXNjIFRoZSBBUEkgaXMgaW1tZWRpYXRlbHkgYXBwbGllZCB0byBhbGwgZGF0YSBzb3VyY2VzIGluIHRoZSBwaXBlbGluZSBvZiB0aGUgZ2l2ZW4gdHlwZTsgYW5kIHJlYXNzaWduZWQgbGF0ZXIgd2hlbmV2ZXIgdGhlIHBpcGVsaW5lIGlzIHJlc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhU291cmNlVHlwZVxuICAgICAqIEBwYXJhbSB7ZGF0YVNvdXJjZUhlbHBlckFQSXx1bmRlZmluZWR8bnVsbH0gaGVscGVyIC0gT25lIG9mOlxuICAgICAqICogQSBmaWx0ZXIgb2JqZWN0IC0gVHVybnMgdGhlIGRhdGEgc291cmNlICpPTiouXG4gICAgICogKiBgdW5kZWZpbmVkYCBvciBgbnVsbGAgLSBUdXJucyB0aGUgZGF0YSBzb3VyY2UgKk9GRi4qXG4gICAgICogKiBBIGhlbHBlciBBUEkuIFR1cm5zIHRoZSBkYXRhIHNvdXJjZSAqT04qLlxuICAgICAqL1xuICAgIHJlZ2lzdGVySGVscGVyQVBJOiBmdW5jdGlvbihkYXRhU291cmNlVHlwZSwgaGVscGVyKSB7XG4gICAgICAgIHRoaXMuYXBpW2RhdGFTb3VyY2VUeXBlXSA9IGhlbHBlciA9IGhlbHBlciB8fCBudWxsRGF0YVNvdXJjZUhlbHBlckFQSTtcblxuICAgICAgICBpZiAodHlwZW9mIGhlbHBlci5wcm9wZXJ0aWVzID09PSAnZnVuY3Rpb24nICYmIGhlbHBlci5wcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaGVscGVyLnByb3AgPSBwcm9wUHJlcC5iaW5kKGhlbHBlciwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy51cGRhdGVEYXRhU291cmNlcyhkYXRhU291cmNlVHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVpbmRleCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEFzIG9mIHYxLjEuMCwgdXNlIGB0aGlzLnJlaW5kZXhgIGluc3RlYWQuXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhcHBseVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnYXBwbHlTdGF0ZSgpJywgJ3JlaW5kZXgoKScsICcxLjIuMCcsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIGdldFVuZmlsdGVyZWRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXByZWNhdGVkKCdnZXRVbmZpbHRlcmVkVmFsdWUoeCwgeSknLCBudWxsLCAnMS4yLjAnLCBhcmd1bWVudHMsICdObyBsb25nZXIgc3VwcG9ydGVkJyk7XG4gICAgfSxcblxuICAgIGdldFVuZmlsdGVyZWRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZWQoJ2dldFVuZmlsdGVyZWRWYWx1ZSh4LCB5KScsIG51bGwsICcxLjIuMCcsIGFyZ3VtZW50cywgJ05vIGxvbmdlciBzdXBwb3J0ZWQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQWRkIGEgbmV3IGRhdGEgcm93IHRvIHRoZSBncmlkLlxuICAgICAqIEBkZXNjIElmIGRhdGEgc291cmNlIHBpcGVsaW5lIGluIHVzZSwgdG8gc2VlIHRoZSBuZXcgcm93IGluIHRoZSBncmlkLCB5b3UgbXVzdCBldmVudHVhbGx5IGNhbGw6XG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5iZWhhdmlvci5yZWluZGV4KCk7XG4gICAgICogdGhpcy5ncmlkLmJlaGF2aW9yQ2hhbmdlZCgpO1xuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdEYXRhUm93XG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIG5ldyByb3cgb2JqZWN0LlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgYWRkUm93OiBmdW5jdGlvbihuZXdEYXRhUm93KSB7XG4gICAgICAgIHRoaXMuZ2V0RGF0YSgpLnB1c2gobmV3RGF0YVJvdyk7XG4gICAgICAgIHJldHVybiBuZXdEYXRhUm93O1xuICAgIH0sXG5cbiAgICBnZXQgc2NoZW1hKCkgeyByZXR1cm4gdGhpcy5zb3VyY2Uuc2NoZW1hOyB9LFxuXG4gICAgc2V0IHNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5zb3VyY2Uuc2V0U2NoZW1hKHNjaGVtYSk7XG4gICAgfVxufSk7XG5cbi8vIExPQ0FMIE1FVEhPRFMgLS0gdG8gYmUgY2FsbGVkIHdpdGggYC5jYWxsKHRoaXNgXG5cbi8qKlxuICogQWNjdW11bGF0ZSBhY3R1YWwgZGF0YSByb3cgb2JqZWN0cyBiYWNraW5nIGN1cnJlbnQgZ3JpZCByb3cgc2VsZWN0aW9ucy5cbiAqIFRoaXMgY2FsbCBzaG91bGQgYmUgcGFpcmVkIHdpdGggYSBzdWJzZXF1ZW50IGNhbGwgdG8gYHJlc2VsZWN0R3JpZFJvd3NCYWNrZWRCeVNlbGVjdGVkRGF0YVJvd3NgLlxuICogQHByaXZhdGVcbiAqIEB0aGlzIHtkYXRhTW9kZWxzLkpTT059XG4gKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICovXG5mdW5jdGlvbiBzZWxlY3RlZERhdGFSb3dzQmFja2luZ1NlbGVjdGVkR3JpZFJvd3MoKSB7XG4gICAgdmFyIHNlbGVjdGVkRGF0YSA9IHRoaXMuc2VsZWN0ZWREYXRhLFxuICAgICAgICBoYXNSb3dTZWxlY3Rpb25zID0gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLmhhc1Jvd1NlbGVjdGlvbnMoKSxcbiAgICAgICAgbmVlZEluZGV4ZWREYXRhTGlzdCA9IHNlbGVjdGVkRGF0YS5sZW5ndGggfHwgaGFzUm93U2VsZWN0aW9ucztcblxuICAgIGlmIChuZWVkSW5kZXhlZERhdGFMaXN0KSB7XG4gICAgICAgIHZhciBpbmRleGVkRGF0YSA9IHRoaXMuZ2V0SW5kZXhlZERhdGEoKTtcbiAgICB9XG5cbiAgICAvLyBTVEVQIDE6IFJlbW92ZSBhbnkgZmlsdGVyZWQgZGF0YSByb3dzIGZyb20gdGhlIHJlY2VudGx5IHNlbGVjdGVkIGxpc3QuXG4gICAgc2VsZWN0ZWREYXRhLmZvckVhY2goZnVuY3Rpb24oZGF0YVJvdywgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ZWREYXRhLmluZGV4T2YoZGF0YVJvdykgPj0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGVkRGF0YVtpbmRleF07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNURVAgMjogQWNjdW11bGF0ZSB0aGUgZGF0YSByb3dzIGJhY2tpbmcgYW55IGN1cnJlbnRseSBzZWxlY3RlZCBncmlkIHJvd3MgaW4gYHRoaXMuc2VsZWN0ZWREYXRhYC5cbiAgICBpZiAoaGFzUm93U2VsZWN0aW9ucykgeyAvLyBhbnkgY3VycmVudCBncmlkIHJvdyBzZWxlY3Rpb25zP1xuICAgICAgICB0aGlzLmdyaWQuZ2V0U2VsZWN0ZWRSb3dzKCkuZm9yRWFjaChmdW5jdGlvbihzZWxlY3RlZFJvd0luZGV4KSB7XG4gICAgICAgICAgICB2YXIgZGF0YVJvdyA9IGluZGV4ZWREYXRhW3NlbGVjdGVkUm93SW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkRGF0YS5pbmRleE9mKGRhdGFSb3cpIDwgMCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkRGF0YS5wdXNoKGRhdGFSb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogUmUtZXN0YWJsaXNoIGdyaWQgcm93IHNlbGVjdGlvbnMgYmFzZWQgb24gYWN0dWFsIGRhdGEgcm93IG9iamVjdHMgYWNjdW11bGF0ZWQgYnkgYHNlbGVjdGVkRGF0YVJvd3NCYWNraW5nU2VsZWN0ZWRHcmlkUm93c2Agd2hpY2ggc2hvdWxkIGJlIGNhbGxlZCBmaXJzdC5cbiAqIEBwcml2YXRlXG4gKiBAdGhpcyB7ZGF0YU1vZGVscy5KU09OfVxuICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAqL1xuZnVuY3Rpb24gcmVzZWxlY3RHcmlkUm93c0JhY2tlZEJ5U2VsZWN0ZWREYXRhUm93cygpIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZERhdGEubGVuZ3RoKSB7IC8vIGFueSBkYXRhIHJvdyBvYmplY3RzIGFkZGVkIGZyb20gcHJldmlvdXMgZ3JpZCByb3cgc2VsZWN0aW9ucz9cbiAgICAgICAgdmFyIHNlbGVjdGlvbk1vZGVsID0gdGhpcy5ncmlkLnNlbGVjdGlvbk1vZGVsLFxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5ncmlkLmdldEhlYWRlclJvd0NvdW50KCksXG4gICAgICAgICAgICBmaWx0ZXJlZERhdGEgPSB0aGlzLmdldEluZGV4ZWREYXRhKCk7XG5cbiAgICAgICAgc2VsZWN0aW9uTW9kZWwuY2xlYXJSb3dTZWxlY3Rpb24oKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkRGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFSb3cpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGZpbHRlcmVkRGF0YS5pbmRleE9mKGRhdGFSb3cpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlbC5zZWxlY3RSb3cob2Zmc2V0ICsgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGlubmVyXG4gKiBAc3VtbWFyeSBEaWdlc3RzIGAoY29sdW1uSW5kZXgsIHByb3BOYW1lLCB2YWx1ZSlgIGFuZCBjYWxscyBgcHJvcGVydGllc2AuXG4gKiBAZGVzYyBEaWdlc3RzIHRoZSB0aHJlZSBwYXJhbWV0ZXJzIGAoY29sdW1uSW5kZXgsIHByb3BOYW1lLCB2YWx1ZSlgIGRldGFpbGVkIGJlbG93LCBjcmVhdGluZyBhIHNpbmdsZSBvYmplY3Qgd2l0aCB3aGljaCBpdCB0aGVuIGNhbGxzIHRoZSBoZWxwZXIgQVBJIGBwcm9wZXJ0aWVzYCBtZXRob2QuXG4gKlxuICogQSBoZWxwZXIgQVBJIGBwcm9wZXJ0aWVzYCBtZXRob2Q6XG4gKiAqIFN1cHBvcnRzIHR3byB0eXBlcyBvZiBhY3Rpb25zOlxuICogICAqICoqR2V0dGVyKiogY2FsbCB3aGVyZSB5b3Ugc3VwcGx5IGp1c3QgdGhlIHByb3BlcnR5IG5hbWUuIFRoZSBtZXRob2QgZ2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgZnJvbSB0aGUgQVBJIGFuZCByZXR1cm5zIGl0LlxuICogICAqICoqU2V0dGVyKiogY2FsbCB3aGVyZSB5b3Ugc3VwcGx5IGEgdmFsdWUgYWxvbmcgd2l0aCB0aGUgcHJvcGVydHkgbmFtZTsgb3IgeW91IHN1cHBseSBhIGhhc2ggb2YgcHJvcGVydHkgbmFtZS92YWx1ZSBwYWlycy4gVGhlIG1ldGhvZCBzZXRzIHRoZSBwcm9wZXJ0eSBvbiB0aGUgQVBJIGFuZCByZXR1cm5zIG5vdGhpbmcuIEFsbCB2YWx1ZXMgYXJlIHZhbGlkIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgdW5kZWZpbmVkYCB3aGljaCBkZWxldGVzIHRoZSBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gbmFtZSByYXRoZXIgdGhhbiBzZXR0aW5nIGl0IHRvIGB1bmRlZmluZWRgLlxuICogKiBTdXBwb3J0cyB0d28gdHlwZXMgb2YgcHJvcGVydGllczpcbiAqICAgKiAqKkdsb2JhbCBwcm9wZXJ0aWVzKiogYWZmZWN0IHRoZSBBUEkgZ2xvYmFsbHkuXG4gKiAgICogKipDb2x1bW4gcHJvcGVydGllcyoqIHBlcnRhaW4gdG8gc3BlY2lmaWMgY29sdW1ucy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBvdmVybG9hZGVkLiBUaGUgd2F5IGl0IGlzIGNhbGxlZCBhcyBleHBsYWluZWQgaW4gdGhlIFBhcmFtZXRlcnMgc2VjdGlvbiBiZWxvdyBkZXRlcm1pbmVzIGJvdGggdGhlIHR5cGUgb2YgYWN0aW9uIChnZXR0ZXIsIHNldHRlcikgYW5kIHRoZSBraW5kIG9mIHByb3BlcnR5IChnbG9iYWwsIGNvbHVtbikuXG4gKlxuICogTm90ZTogTm90IGFsbCBBUEkgcHJvcGVydGllcyBhcmUgZHluYW1pYzsgc29tZSBhcmUgc3RhdGljIGFuZCB1cGRhdGluZyB0aGVtIGxhdGVyIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gKlxuICogQHRoaXMge2RhdGFTb3VyY2VIZWxwZXJBUEl9XG4gKlxuICogQHBhcmFtIHtEYXRhU291cmNlQmFzZX0gZGF0YU1vZGVsIC0gVGhlIGRhdGEgbW9kZWwuIFRoaXMgcGFyYW1ldGVyIGlzIGJvdW5kIHRvIHRoZSBjYWxsIGJ5IHtAbGluayBkYXRhTW9kZWxzLkpTT04jc2V0SGVscGVyQVBJfHNldEhlbHBlckFQSX0uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb2x1bW5JbmRleF0gLSBJZiBnaXZlbiwgdGhpcyBpcyBhIHByb3BlcnR5IG9uIGEgc3BlY2lmaWMgY29sdW1uLiBJZiBvbWl0dGVkLCB0aGlzIGlzIGEgcHJvcGVydHkgb24gdGhlIHdob2xlIEFQSSBwcm9wZXJ0aWVzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHByb3BlcnR5IC0gX0lmIGBjb2x1bW5JbmRleGAgaXMgb21pdHRlZCwgdGhpcyBhcmcgdGFrZXMgaXRzIHBsYWNlLl9cbiAqXG4gKiBPbmUgb2YgdGhlc2UgdHlwZXM6XG4gKiAqICoqc3RyaW5nKiogLSBQcm9wZXJ0eSBuYW1lLiBUaGUgbmFtZSBvZiB0aGUgZXhwbGljaXQgcHJvcGVydHkgdG8gZWl0aGVyIGdldCBvciAoaWYgYHZhbHVlYCBhbHNvIGdpdmVuKSBzZXQgb24gdGhlIHByb3BlcnRpZXMgb2JqZWN0LlxuICogKiAqKm9iamVjdCoqIC0gSGFzaCBvZiBwcm9wZXJ0aWVzIHRvIHNldCBvbiB0aGUgcHJvcGVydGllcyBvYmplY3QuXG4gKlxuICogQHBhcmFtIFt2YWx1ZV0gLSBfSWYgYGNvbHVtbkluZGV4YCBpcyBvbWl0dGVkLCB0aGlzIGFyZyB0YWtlcyBpdHMgcGxhY2UuX1xuICpcbiAqIE9uZSBvZjpcbiAqICogT21pdHRlZCAod2hlbiBgcHJvcGVydHlgIGlzIGEgc3RyaW5nKSwgdGhpcyBpcyB0aGUgXCJnZXR0ZXJcIiBhY3Rpb246IFJldHVybiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvcGVydGllcyBvYmplY3Qgb2YgdGhlIGtleSBpbiBgcHJvcGVydHlgLlxuICogKiBXaGVuIGBwcm9wZXJ0eWAgaXMgYSBzdHJpbmcgYW5kIGB2YWx1ZWAgaXMgZ2l2ZW4sIHRoaXMgaXMgdGhlIFwic2V0dGVyXCIgYWN0aW9uOiBDb3B5IHRoaXMgdmFsdWUgdG8gcHJvcGVydGllcyBvYmplY3QgdXNpbmcgdGhlIGtleSBpbiBgcHJvcGVydHlgLlxuICogKiBXaGVuIGBwcm9wZXJ0eWAgaXMgYSBoYXNoIGFuZCBgdmFsdWVgIGlzIGdpdmVuOiBVbmV4cGVjdGVkOyB0aHJvd3MgYW4gZXJyb3IuXG4gKlxuICogQHJldHVybnMge3Byb3BPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHByb3BQcmVwKGRhdGFNb2RlbCwgY29sdW1uSW5kZXgsIHByb3BOYW1lLCB2YWx1ZSkge1xuICAgIHZhciBpbnZhbGlkLFxuICAgICAgICBwcm9wZXJ0aWVzID0ge30sXG4gICAgICAgIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIGlmICh0eXBlb2YgY29sdW1uSW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgIGFyZ0NvdW50LS07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBwcm9wTmFtZTtcbiAgICAgICAgcHJvcE5hbWUgPSBjb2x1bW5JbmRleDtcbiAgICAgICAgY29sdW1uSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgc3dpdGNoIChhcmdDb3VudCkge1xuXG4gICAgICAgIGNhc2UgMjogLy8gZ2V0dGVyIHByb3BOYW1lIG5hbWUgb3Igc2V0dGVyIGhhc2hcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcE5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHByb3BOYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmdldFByb3BOYW1lID0gcHJvcE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6IC8vIHNldHRlciBmb3IgdmFsdWVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcE5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OiAvLyB0b28gZmV3IG9yIHRvbyBtYW55IGFyZ3NcbiAgICAgICAgICAgIGludmFsaWQgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgICAgdGhyb3cgJ0ludmFsaWQgb3ZlcmxvYWQuJztcbiAgICB9XG5cbiAgICBpZiAoY29sdW1uSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBub24tZW51bWVyYWJsZSBwcm9wTmFtZTpcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BlcnRpZXMsICdjb2x1bW4nLCB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGluZGV4OiBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgICAgICBuYW1lOiBkYXRhTW9kZWwuc291cmNlLnNjaGVtYVtjb2x1bW5JbmRleF0ubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xufVxuXG52YXIgd2FybmVkID0ge307XG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcE5hbWVcbiAqIEB0aGlzIERhdGFTb3VyY2VPcmlnaW4jXG4gKiBAcmV0dXJucyB7KltdfVxuICovXG5mdW5jdGlvbiBnZXRTY2hlbWFQcm9wQXJyKHByb3BOYW1lLCBkZXByZWNhdGVkTWV0aG9kTmFtZSkge1xuICAgIGlmICghd2FybmVkW2RlcHJlY2F0ZWRNZXRob2ROYW1lXSkge1xuICAgICAgICBjb25zb2xlLndhcm4oZGVwcmVjYXRlZE1ldGhvZE5hbWUgKyAnKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2MS4yLjAgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSByZWxlYXNlLiBDb25zdHJ1Y3RzIGxpa2UgJyArIGRlcHJlY2F0ZWRNZXRob2ROYW1lICsgJygpW2ldIHNob3VsZCBiZSBjaGFuZ2VkIHRvIHNjaGVtYVtpXS4gKFRoaXMgZGVwcmVjYXRlZCBtZXRob2Qgbm93IHJldHVybnMgYSBuZXcgYXJyYXkgZGVyaXZlZCBmcm9tIHNjaGVtYS4pJyk7XG4gICAgICAgIHdhcm5lZFtkZXByZWNhdGVkTWV0aG9kTmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zY2hlbWEubWFwKGZ1bmN0aW9uKGNvbHVtblNjaGVtYSkge1xuICAgICAgICByZXR1cm4gY29sdW1uU2NoZW1hW3Byb3BOYW1lXTtcbiAgICB9LCB0aGlzKTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAqL1xuSlNPTi5wcm90b3R5cGUuYXBwbHlBbmFseXRpY3MgPSBKU09OLnByb3RvdHlwZS5yZWluZGV4OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dGVuZC1uYXRpdmVcblxubW9kdWxlLmV4cG9ydHMgPSBKU09OO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBTdW1tYXJ5Um93KGdyaWQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmJlaGF2aW9yID0gZ3JpZC5iZWhhdmlvcjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtkYXRhUm93T2JqZWN0W119XG4gICAgICovXG4gICAgdGhpcy5kYXRhID0gW107XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIH1cbn1cblxuU3VtbWFyeVJvdy5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IFN1bW1hcnlSb3cucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgdHlwZTogJ3N1bW1hcnknLFxuXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhKCkubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBnZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZGF0YU1vZGVsLmRhdGFTb3VyY2UuZ2V0R3JhbmRUb3RhbHMoKSB8fCB0aGlzLmRhdGE7XG4gICAgfSxcblxuICAgIHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YSB8fCBbXTtcbiAgICB9LFxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt5XVt4XTtcbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGF0YVt4XSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt5XTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN1bW1hcnlSb3c7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIERhdGFNb2RlbDogcmVxdWlyZSgnLi9EYXRhTW9kZWwnKSwgLy8gYWJzdHJhY3QgYmFzZSBjbGFzc1xuICAgIEpTT046IHJlcXVpcmUoJy4vSlNPTicpLFxuICAgIEhlYWRlclN1YmdyaWQ6IHJlcXVpcmUoJy4vSGVhZGVyU3ViZ3JpZCcpLFxuICAgIEZpbHRlclN1YmdyaWQ6IHJlcXVpcmUoJy4vRmlsdGVyU3ViZ3JpZCcpLFxuICAgIFN1bW1hcnlTdWJncmlkOiByZXF1aXJlKCcuL1N1bW1hcnlTdWJncmlkJylcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlQmFzZSA9IHJlcXVpcmUoJ2Zpbi1oeXBlcmdyaWQtZGF0YS1zb3VyY2UtYmFzZScpO1xuXG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YVNvdXJjZU9yaWdpbiNpbml0aWFsaXplfSBmb3IgY29uc3RydWN0b3IgcGFyYW1ldGVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRGF0YVNvdXJjZU9yaWdpbiA9IERhdGFTb3VyY2VCYXNlLmV4dGVuZCgnRGF0YVNvdXJjZU9yaWdpbicsICB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50bHkgYSBzeW5vbnltIGZvciB7QGxpbmsgRGF0YVNvdXJjZU9yaWdpbiNzZXREYXRhfSAoc2VlKS5cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhLCBzY2hlbWEpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVNvdXJjZTsgLy8gYWRkZWQgYnkgRGF0YVNvdXJjZUJhc2UjaW5pdGlhbGl6ZSBidXQgd2UgZG9uJ3Qgd2FudCBoZXJlXG4gICAgICAgIHRoaXMuc2V0RGF0YS5jYWxsKHRoaXMsIGRhdGEsIHNjaGVtYSB8fCBbXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlT3JpZ2luI1xuICAgICAqL1xuICAgIHNldERhdGE6IHNldERhdGEsXG5cbiAgICBnZXQgc2NoZW1hKCkgeyByZXR1cm4gdGhpcy5fc2NoZW1hOyB9LFxuICAgIHNldCBzY2hlbWEoc2NoZW1hKSB7IHRoaXMuX3NjaGVtYSA9IHNjaGVtYTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlT3JpZ2luI1xuICAgICAqIEByZXR1cm5zIHtjb2x1bW5TY2hlbWFPYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRTY2hlbWE6ICBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NoZW1hO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VPcmlnaW4jXG4gICAgICogQ2F2ZWF0OiBEbyBub3QgY2FsbCBvbiBhIGRhdGEgdXBkYXRlIHdoZW4geW91IGV4cGVjdCB0byByZXVzZSB0aGUgZXhpc3Rpbmcgc2NoZW1hLlxuICAgICAqIEBwYXJhbSBzY2hlbWFcbiAgICAgKi9cbiAgICBzZXRTY2hlbWE6IGZ1bmN0aW9uKHNjaGVtYSl7XG4gICAgICAgIGlmICghc2NoZW1hLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IGNvbXB1dGVGaWVsZE5hbWVzKHRoaXMuZGF0YVswXSk7XG5cbiAgICAgICAgICAgIHNjaGVtYSA9IEFycmF5KGZpZWxkcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNjaGVtYVtpXSA9IHsgbmFtZTogZmllbGRzW2ldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgVGhlIGFycmF5IG9mIGNvbHVtbiBzY2hlbWEgb2JqZWN0cy5cbiAgICAgICAgICogQG5hbWUgc2NoZW1hXG4gICAgICAgICAqIEB0eXBlIHtjb2x1bW5TY2hlbWFPYmplY3RbXX1cbiAgICAgICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VPcmlnaW4jXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zY2hlbWEgPSBzY2hlbWE7XG4gICAgfSxcblxuICAgIGlzTnVsbE9iamVjdDogZmFsc2UsXG5cbiAgICBnZXREYXRhSW5kZXg6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlT3JpZ2luI1xuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge2RhdGFSb3dPYmplY3R9XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbeV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEZpbmQsIHJlcGxhY2UsIG9yIHVwZGF0ZSBhIHJvdyBieSBpdCdzIHByaW1hcnkga2V5IGNvbHVtbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGNvbHVtbk5hbWUgLSBPbmUgb2Y6XG4gICAgICogKiBfc3RyaW5nXyAtIENvbHVtbiBuYW1lLiBTZWUgYHZhbHVlYC5cbiAgICAgKiAqIF9vYmplY3RfIC0gSGFzaCBvZiAwIG9yIG1vcmUga2V5LXZhbHVlIHBhaXJzIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXXwqfSBbdmFsdWVdIC0gT25lIG9mOlxuICAgICAqIF9vbWl0dGVkXyAtIFdoZW4gYGNvbHVtbk5hbWVgIGlzIGEgaGFzaCBhbmQgeW91IHdhbnQgdG8gc2VhcmNoIGFsbCBpdHMga2V5cy5cbiAgICAgKiBfc3RyaW5nW11fIC0gV2hlbiBgY29sdW1uTmFtZWAgaXMgYSBoYXNoIGJ1dCB5b3Ugb25seSB3YW50IHRvIHNlYXJjaCBjZXJ0YWluIGtleXMuXG4gICAgICogX290aGVyd2lzZV8gLSBXaGVuIGBjb2x1bW5OYW1lYCBpcyBhIHN0cmluZy4gVmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBOb3RlIHRoYXQgYG51bGxgIGlzIGEgdmFsaWQgc2VhcmNoIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx8dW5kZWZpbmVkfSBbcmVwbGFjZW1lbnRdIC0gT25lIG9mOlxuICAgICAqICogX29taXR0ZWRfIC0gSWdub3JlZC5cbiAgICAgKiAqIF9vYmplY3RfIC0gUmVwbGFjZW1lbnQgZm9yIHRoZSBkYXRhIHJvdyBpZiBmb3VuZC5cbiAgICAgKiAqIGBudWxsYCAtIEZsYWcgdG8gZGVsZXRlIHRoZSBkYXRhIHJvdyBpZiBmb3VuZC4gVGhlIGZvdW5kIGRhdGEgcm93IGlzIG5vbmV0aGVsZXNzIHJldHVybmVkLlxuICAgICAqICogYHVuZGVmaW5lZGAgLSBGbGFnIHRvIHJldHVybiBpbmRleCBvZiBmb3VuZCByb3cgaW5zdGVhZCBvZiByb3cgb2JqZWN0IGl0c2VsZi5cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bWJlcnx1bmRlZmluZWR9IE9uZSBvZjpcbiAgICAgKiAqIGB1bmRlZmluZWRgIC0gZGF0YSByb3cgbm90IGZvdW5kXG4gICAgICogKiBfb2JqZWN0XyAtIGZvdW5kIGRhdGEgcm93IG9iamVjdCAod2lsbCBoYXZlIGJlZW4gZGVsZXRlZCBpZiBgcmVwbGFjZW1lbnRgIHdhcyBgbnVsbGApXG4gICAgICogKiBfbnVtYmVyXyAtIGluZGV4IG9mIGZvdW5kIGRhdGEgcm93IG9iamVjdCBpbiBgdGhpcy5kYXRhYCAoaWYgYHJlcGxhY2VtZW50YCB3YXMgYHVuZGVmaW5lZGApXG4gICAgICogQHRvZG8gVXNlIGEgYmluYXJ5IHNlYXJjaCAocmF0aGVyIHRoYW4gYEFycmF5Li5maW5kYCkgd2hlbiBjb2x1bW4gaXMga25vd24gdG8gYmUgaW5kZXhlZCAoc29ydGVkKS5cbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZU9yaWdpbiNcbiAgICAgKi9cbiAgICBmaW5kUm93OiBmdW5jdGlvbiBmaW5kUm93KGNvbHVtbk5hbWUsIHZhbHVlLCByZXBsYWNlbWVudCkge1xuICAgICAgICB2YXIgcmVzdWx0LCBpbmRleCwga2V5cywgaGFzaCwgYXJncztcblxuICAgICAgICBpZiAodHlwZW9mIGNvbHVtbk5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBoYXNoID0gY29sdW1uTmFtZTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcmdzID0gMjtcbiAgICAgICAgICAgICAgICBrZXlzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMucmVkdWNlKGZ1bmN0aW9uKHN1bSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIGhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdW0rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgICAgICAgICAgIH0sIDApICE9PSBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgYWxsIGtleXMgZ2l2ZW4gaW4gMm5kIGFyZyB0byBiZSBmb3VuZCBpbiBoYXNoIGdpdmVuIGluIDFzdCBhcmcuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3MgPSAxO1xuICAgICAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhoYXNoKTtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHZhbHVlOyAvLyBwcm9tb3RlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbk5hbWUgPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaGFzaFtjb2x1bW5OYW1lXTtcbiAgICAgICAgICAgICAgICBoYXNoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZGF0YS5maW5kKGZ1bmN0aW9uKHJvdywgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpZHg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5OYW1lID0ga2V5c1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd1tjb2x1bW5OYW1lXSAhPT0gaGFzaFtjb2x1bW5OYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gYmFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBmb3VuZCFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBhdCBsZWFzdCAyIGFyZ3VtZW50cyB3aGVuIGZpcnN0IGFyZ3VtZW50IG5vdCBvYmplY3QgYnV0IGZvdW5kICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncyA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhc2gpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZGF0YS5maW5kKGZ1bmN0aW9uKHJvdywgaWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyb3cpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpZHg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvd1tjb2x1bW5OYW1lXSA9PT0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuZm91bmRSb3dJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgbnVsbCwgdW5kZWZpbmVkLCBvciBvYmplY3QgYnV0IGZvdW5kICcgKyB0eXBlb2YgcmVwbGFjZW1lbnQgKyAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvdW5kUm93SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBGaW5kLCByZXBsYWNlLCBvciB1cGRhdGUgYSByb3cgYnkgaXQncyBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBSb3cgaW5kZXggdGhhdCBpcyBiZWluZyBhY2Nlc3NlZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fG51bGx8dW5kZWZpbmVkfSBbcmVwbGFjZW1lbnRdIC0gT25lIG9mOlxuICAgICAqICogX29taXR0ZWRfIC0gSWdub3JlZC5cbiAgICAgKiAqIF9vYmplY3RfIC0gUmVwbGFjZW1lbnQgZm9yIHRoZSBkYXRhIHJvdyBpZiBmb3VuZC5cbiAgICAgKiAqIGBudWxsYCAtIEZsYWcgdG8gZGVsZXRlIHRoZSBkYXRhIHJvdyBpZiBmb3VuZC4gVGhlIGZvdW5kIGRhdGEgcm93IGlzIG5vbmV0aGVsZXNzIHJldHVybmVkLlxuICAgICAqICogYHVuZGVmaW5lZGAgLSBGbGFnIHRvIGRlbGV0ZSB0aGUgcm93IGF0IHRoYXQgaW5kZXguXG4gICAgICogQHJldHVybnMge29iamVjdHxudW1iZXJ8dW5kZWZpbmVkfSBPbmUgb2Y6XG4gICAgICogKiBgdW5kZWZpbmVkYCAtIGRhdGEgcm93IG5vdCBmb3VuZFxuICAgICAqICogX29iamVjdF8gLSBmb3VuZCBkYXRhIHJvdyBvYmplY3QgKHdpbGwgaGF2ZSBiZWVuIGRlbGV0ZWQgaWYgYHJlcGxhY2VtZW50YCB3YXMgYG51bGxgKVxuICAgICAqIEB0b2RvIFVzZSBhIGJpbmFyeSBzZWFyY2ggKHJhdGhlciB0aGFuIGBBcnJheS4uZmluZGApIHdoZW4gY29sdW1uIGlzIGtub3duIHRvIGJlIGluZGV4ZWQgKHNvcnRlZCkuXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VPcmlnaW4jXG4gICAgICovXG4gICAgZmluZFJvd0J5SW5kZXg6IGZ1bmN0aW9uIGZpbmRSb3coaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgYXQgbGVhc3QgMSBhcmd1bWVudCBidXQgZm91bmQgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnLic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGF0IGluZGV4IHRvIGJlIGEgbnVtYmVyIGJ1dCBnb3QgJyArIGluZGV4ICsgJy4nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gdGhpcy5kYXRhW2luZGV4XTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlcGxhY2VtZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCAmJiBhcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5kYXRhW2luZGV4XTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVwbGFjZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBudWxsLCB1bmRlZmluZWQsIG9yIG9iamVjdCBidXQgZm91bmQgJyArIHR5cGVvZiByZXBsYWNlbWVudCArICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VPcmlnaW4jXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmdldFJvdyh5KTtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dbdGhpcy5zY2hlbWFbeF0ubmFtZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlT3JpZ2luI1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRSb3coeSlbdGhpcy5zY2hlbWFbeF0ubmFtZV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VPcmlnaW4jXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZU9yaWdpbiNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VPcmlnaW4jXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqL1xuICAgIGdldEZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYS5tYXAoZnVuY3Rpb24oY29sdW1uU2NoZW1hKSB7IHJldHVybiBjb2x1bW5TY2hlbWEubmFtZTsgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBEYXRhU291cmNlT3JpZ2luI1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hLm1hcChmdW5jdGlvbihjb2x1bW5TY2hlbWEpIHsgcmV0dXJuIGNvbHVtblNjaGVtYS5oZWFkZXI7IH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZU9yaWdpbiNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZHNcbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgICBpZiAoIShBcnJheS5pc0FycmF5KGZpZWxkcykgJiYgZmllbGRzLmxlbmd0aCA9PT0gdGhpcy5zY2hlbWEubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHRoaXMuRGF0YVNvdXJjZUVycm9yKCdFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBhcnJheSB3aXRoIGNvcnJlY3QgbGVuZ3RoLicpO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBpKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYVtpXS5maWVsZCA9IGZpZWxkO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIERhdGFTb3VyY2VPcmlnaW4jXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW2hlYWRlcnNdIC0gSWYgb21pdHRlZCwgaGVhZGVycyB3aWxsIGJlIHJlc2V0IHRvIHRoZWlyIGRlcml2ZWQgZGVmYXVsdHMgb24gbmV4dCBjYWxsIHRvIGBnZXRIZWFkZXJzYC5cbiAgICAgKi9cbiAgICBzZXRIZWFkZXJzOiBmdW5jdGlvbihoZWFkZXJzKSB7XG4gICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkoaGVhZGVycykgJiYgaGVhZGVycy5sZW5ndGggPT09IHRoaXMuc2NoZW1hLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB0aGlzLkRhdGFTb3VyY2VFcnJvcignRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gYXJyYXkgd2l0aCBjb3JyZWN0IGxlbmd0aC4nKTtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyLCBpKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVtYVtpXS5oZWFkZXIgPSBoZWFkZXI7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn0pO1xuXG4vKiogQHR5cGVkZWYge29iamVjdH0gY29sdW1uU2NoZW1hT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSByZXF1aXJlZCBjb2x1bW4gbmFtZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaGVhZGVyXSAtIEFuIG92ZXJyaWRlIGZvciBkZXJpdmVkIGhlYWRlclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2NhbGN1bGF0b3JdIC0gQSBmdW5jdGlvbiBmb3IgYSBjb21wdXRlZCBjb2x1bW4uIFVuZGVmaW5lZCBmb3Igbm9ybWFsIGRhdGEgY29sdW1ucy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdHlwZV0gLSBVc2VkIGZvciBzb3J0aW5nIHdoZW4gYW5kIG9ubHkgd2hlbiBjb21wYXJhdG9yIG5vdCBnaXZlbi5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbY29tcGFyYXRvcl0gLSBGb3Igc29ydGluZywgYm90aCBvZiBmb2xsb3dpbmcgcmVxdWlyZWQ6XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBjb21wYXJhdG9yLmFzYyAtIGFzY2VuZGluZyBjb21wYXJhdG9yXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBjb21wYXJhdG9yLmRlc2MgLSBkZXNjZW5kaW5nIGNvbXBhcmF0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0W119IFtkYXRhPVtdXSAtIEFycmF5IG9mIHVuaWZvcm0gb2JqZWN0cyBjb250YWluaW5nIHRoZSBncmlkIGRhdGEuXG4gKiBAcGFyYW0ge2NvbHVtblNjaGVtYU9iamVjdFtdfSBbc2NoZW1hPVtdXVxuICogQG1lbWJlck9mIERhdGFTb3VyY2VPcmlnaW4jXG4gKi9cbmZ1bmN0aW9uIHNldERhdGEoZGF0YSwgc2NoZW1hKSB7XG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVGhlIGFycmF5IG9mIHVuaWZvcm0gZGF0YSBvYmplY3RzLlxuICAgICAqIEBuYW1lIHNjaGVtYVxuICAgICAqIEB0eXBlIHtjb2x1bW5TY2hlbWFPYmplY3RbXX1cbiAgICAgKiBAbWVtYmVyT2YgRGF0YVNvdXJjZU9yaWdpbiNcbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IFtdO1xuXG4gICAgaWYgKHNjaGVtYSkge1xuICAgICAgICB0aGlzLnNldFNjaGVtYShzY2hlbWEpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge3N0cmluZ1tdfVxuICovXG5mdW5jdGlvbiBjb21wdXRlRmllbGROYW1lcyhvYmplY3QpIHtcbiAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QgfHwgW10pLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBlLnN1YnN0cigwLCAyKSAhPT0gJ19fJztcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlT3JpZ2luO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkYXRhU291cmNlT3JpZ2luOiByZXF1aXJlKCcuL0RhdGFTb3VyY2VPcmlnaW4nKSxcbiAgICBEYXRhU291cmNlQmFzZTogcmVxdWlyZSgnZmluLWh5cGVyZ3JpZC1kYXRhLXNvdXJjZS1iYXNlJylcbn07XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTFJVQ2FjaGUgPSByZXF1aXJlKCdscnUtY2FjaGUnKTtcblxuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGxpc3RzIHRoZSBwcm9wZXJ0aWVzIHRoYXQgY2FuIGJlIHNldCBvbiBhIHtAbGluayBIeXBlcmdyaWR9IGFsb25nIHdpdGggdGhlaXIgZGVmYXVsdCB2YWx1ZXMuXG4gKiBFZGl0IHRoaXMgZmlsZSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdHMuXG4gKiBAbW9kdWxlIGRlZmF1bHRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9udCBmb3IgZGF0YSBjZWxscy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgbm9EYXRhTWVzc2FnZTogJycsXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBmb250IGZvciBkYXRhIGNlbGxzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0ZvbnR9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZm9udDogJzEzcHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogRm9udCBjb2xvciBmb3IgZGF0YSBjZWxscy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBmb3IgZGF0YSBjZWxscy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiKDI0MSwgMjQxLCAyNDEpJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgc3R5bGUgZm9yIHNlbGVjdGVkIGNlbGwocykuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Gb250OiAnYm9sZCAxM3B4IFRhaG9tYSwgR2VuZXZhLCBzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEZvbnQgY29sb3IgZm9yIHNlbGVjdGVkIGNlbGwocykuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYigwLCAwLCAxMjgpJyxcbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNvcnRPbkhpZGRlbkNvbHVtbnM6IHRydWUsXG4gICAgLyoqXG4gICAgICogQmFja2dyb3VuZCBjb2xvciBmb3Igc2VsZWN0ZWQgY2VsbChzKS5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiYSgxNDcsIDE4NSwgMjU1LCAwLjYyNSknLFxuXG5cbiAgICAvKioqKioqKioqKiBTRUNUSU9OOiBDT0xVTU4gSEVBREVSIENPTE9SUyAqKioqKioqKioqL1xuXG4gICAgLy8gSU1QT1JUQU5UIENBVkVBVDogVGhlIGNvZGUgaXMgaW5jb25zaXN0ZW50IHJlZ2FyZGluZyB0aGUgdGVybWlub2xvZ3kuIElzIHRoZSBcImNvbHVtbiBoZWFkZXJcIiBzZWN0aW9uIF90aGUgcm93XyBvZiBjZWxscyBhdCB0aGUgdG9wICh0aGF0IGFjdCBhcyBoZWFkZXJzIGZvciBlYWNoIGNvbHVtbikgb3IgaXMgaXQgX3RoZSBjb2x1bW5fIG9mIGNlbGxzICh0aGF0IGFjdCBhcyBoZWFkZXJzIGZvciBlYWNoIHJvdyk/IE9oIG15LlxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzRm9udH1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJGb250OiAnMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJDb2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIGZvciBzZWxlY3RlZCBjb2x1bW5zJyBoZWFkZXJzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDogJ2JvbGQgMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoMjIzLCAyMjcsIDIzMiknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDgwLCA4MCwgODApJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYmEoMjU1LCAyMjAsIDk3LCAwLjQ1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb2x1bW5IZWFkZXJGb3JlZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yOiAncmdiKDI1NSwgMTgwLCAwKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVySGFsaWduOiAnY2VudGVyJyxcblxuXG4gICAgLyoqKioqKioqKiogU0VDVElPTjogUk9XIEhFQURFUiBDT0xPUlMgKioqKioqKioqKi9cblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0ZvbnR9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93SGVhZGVyRm9udDogJzEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93SGVhZGVyQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93SGVhZGVyQmFja2dyb3VuZENvbG9yOiAncmdiKDIyMywgMjI3LCAyMzIpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYig4MCwgODAsIDgwKScsXG5cbiAgICAvKipcbiAgICAgKiBGb250IHN0eWxlIGZvciBzZWxlY3RlZCByb3dzJyBoZWFkZXJzLlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uRm9udDogJ2JvbGQgMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByb3dIZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2JhKDI1NSwgMjIwLCA5NywgMC40NSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcm93SGVhZGVyRm9yZWdyb3VuZFJvd1NlbGVjdGlvbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd0hlYWRlckJhY2tncm91bmRSb3dTZWxlY3Rpb25Db2xvcjogJ3JnYigyNTUsIDE4MCwgMCknLFxuXG5cbiAgICAvKioqKioqKioqKiBTRUNUSU9OOiBGSUxURVIgUk9XIENPTE9SUyAqKioqKioqKioqL1xuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzRm9udH1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJGb250OiAnMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJDb2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJCYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZmlsdGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1NSwgMjIwLCA5NyknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZpbHRlckhhbGlnbjogJ2NlbnRlcicsXG5cblxuICAgIC8qKioqKioqKioqIFNFQ1RJT046IFRSRUUgQ09MVU1OIENPTE9SUyAqKioqKioqKioqL1xuICAgIC8vIFRoZSBcInRyZWUgY29sdW1uXCIgY29udGFpbnMgdGhlIGhpZXJhcmNoaWNhbCBkcmlsbC1kb3duIGNvbnRyb2xzLlxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzRm9udH1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0cmVlQ29sdW1uRm9udDogJzEycHggVGFob21hLCBHZW5ldmEsIHNhbnMtc2VyaWYnLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdHJlZUNvbHVtbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoMjIzLCAyMjcsIDIzMiknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdHJlZUNvbHVtbkZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtjc3NDb2xvcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB0cmVlQ29sdW1uQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiYSgyNTUsIDIyMCwgOTcsIDAuNDUpJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHRyZWVDb2x1bW5Gb3JlZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdHJlZUNvbHVtbkJhY2tncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjogJ3JnYigyNTUsIDE4MCwgMCknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Y3NzQ29sb3J9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgYmFja2dyb3VuZENvbG9yMjogJ3JnYigyMDEsIDIwMSwgMjAxKScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdm9mZnNldDogMCxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzY3JvbGxiYXJIb3Zlck92ZXI6ICd2aXNpYmxlJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzY3JvbGxiYXJIb3Zlck9mZjogJ2hpZGRlbicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNjcm9sbGluZ0VuYWJsZWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgdlNjcm9sbGJhckNsYXNzUHJlZml4OiAnJyxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBoU2Nyb2xsYmFyQ2xhc3NQcmVmaXg6ICcnLFxuXG4gICAgLy90aGVzZSB1c2VkIHRvIGJlIGluIHRoZSBjb25zdGFudHMgZWxlbWVudFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZpeGVkUm93QWxpZ246ICdjZW50ZXInLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZpeGVkQ29sQWxpZ246ICdjZW50ZXInLFxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBoYWxpZ246ICdjZW50ZXInLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNlbGxQYWRkaW5nOiA1LFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBncmlkTGluZXNIOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBncmlkTGluZXNWOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZ3JpZExpbmVzVk92ZXJmbG93OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGxpbmVDb2xvcjogJ3JnYigxOTksIDE5OSwgMTk5KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgbGluZVdpZHRoOiAxLFxuXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZGVmYXVsdFJvd0hlaWdodDogMTUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZGVmYXVsdENvbHVtbldpZHRoOiAxMDAsXG5cbiAgICAvL2ZvciBpbW1lZGlhdGUgcGFpbnRpbmcsIHNldCB0aGVzZSB2YWx1ZXMgdG8gMCwgdHJ1ZSByZXNwZWN0aXZlbHlcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICByZXBhaW50SW50ZXJ2YWxSYXRlOiA2MCxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcmVwYWludEltbWVkaWF0ZWx5OiBmYWxzZSxcblxuICAgIC8vZW5hYmxlIG9yIGRpc2FibGUgZG91YmxlIGJ1ZmZlcmluZ1xuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB1c2VCaXRCbGl0OiBmYWxzZSxcblxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICB1c2VIaURQSTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IFsnYWx0JywgJ2VzYyddXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBlZGl0b3JBY3RpdmF0aW9uS2V5czogWydhbHQnLCAnZXNjJ10sXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJlYWRPbmx5OiBmYWxzZSxcblxuICAgIC8vIGluaGVyaXRlZCBieSBjZWxsIHJlbmRlcmVyc1xuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHQgYGdldFRleHRXaWR0aGBcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0VGV4dFdpZHRoOiBnZXRUZXh0V2lkdGgsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdCBgZ2V0VGV4dEhlaWdodGBcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZ2V0VGV4dEhlaWdodDogZ2V0VGV4dEhlaWdodCxcblxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZpeGVkQ29sdW1uQ291bnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZml4ZWRSb3dDb3VudDogMCxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc2hvd1Jvd051bWJlcnM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNob3dUcmVlQ29sdW1uOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzaG93SGVhZGVyUm93OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzaG93RmlsdGVyUm93OiBmYWxzZSxcblxuXG4gICAgLyoqIENsaWNraW5nIGluIGEgY2VsbCBcInNlbGVjdHNcIiBpdDsgaXQgaXMgYWRkZWQgdG8gdGhlIHNlbGVjdCByZWdpb24gYW5kIHJlcGFpbnRlZCB3aXRoIFwiY2VsbCBzZWxlY3Rpb25cIiBjb2xvcnMuXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjZWxsU2VsZWN0aW9uOiB0cnVlLFxuXG4gICAgLyoqIENsaWNraW5nIGluIGEgY29sdW1uIGhlYWRlciAodG9wIHJvdykgXCJzZWxlY3RzXCIgdGhlIGNvbHVtbjsgdGhlIGVudGlyZSBjb2x1bW4gaXMgYWRkZWQgdG8gdGhlIHNlbGVjdCByZWdpb24gYW5kIHJlcGFpbnRlZCB3aXRoIFwiY29sdW1uIHNlbGVjdGlvblwiIGNvbG9ycy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtblNlbGVjdGlvbjogdHJ1ZSxcblxuICAgIC8qKiBDbGlja2luZyBpbiBhIHJvdyBoZWFkZXIgKGxlZnRtb3N0IGNvbHVtbikgXCJzZWxlY3RzXCIgdGhlIHJvdzsgdGhlIGVudGlyZSByb3cgaXMgYWRkZWQgdG8gdGhlIHNlbGVjdCByZWdpb24gYW5kIHJlcGFpbnRlZCB3aXRoIFwicm93IHNlbGVjdGlvblwiIGNvbG9ycy5cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd1NlbGVjdGlvbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgc2luZ2xlUm93U2VsZWN0aW9uTW9kZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge2Nzc0NvbG9yfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNlbGVjdGlvblJlZ2lvbk92ZXJsYXlDb2xvcjogJ3JnYmEoMCwgMCwgNDgsIDAuMiknLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNlbGVjdGlvblJlZ2lvbk91dGxpbmVDb2xvcjogJ3JnYig2OSwgNjksIDY5KScsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtbkF1dG9zaXppbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd051bWJlckF1dG9zaXppbmc6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGhlYWRlclRleHRXcmFwcGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJvd1Jlc2l6ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGVkaXRhYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmaWx0ZXJhYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBlZGl0T25Eb3VibGVDbGljazogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBkb3VibGVDbGlja0RlbGF5OiAzMjUsXG5cbiAgICAvKipcbiAgICAgKiBHcmlkLWxldmVsIHByb3BlcnR5LlxuICAgICAqIFdoZW4gdXNlciBwcmVzc2VzIGEgcHJpbnRhYmxlIGNoYXJhY3RlciBrZXkgX29yXyBCQUNLU1BBQ0UgX29yXyBERUxFVEU6XG4gICAgICogMS4gQWN0aXZhdGUgY2VsbCBlZGl0b3Igb24gY3VycmVudCBjZWxsIChpLmUuLCBvcmlnaW4gb2YgbW9zdCByZWNlbnQgc2VsZWN0aW9uKS5cbiAgICAgKiAyLiBJZiBjZWxsIGVkaXRvciBpcyBhIHRleHQgZWRpdG9yOlxuICAgICAqICAgIDEuIFJlcGxhY2UgY3VycmVudCB2YWx1ZSB3aXRoIHRoZSBjaGFyYWN0ZXIgdGhlIHVzZXIgdHlwZWQ7IG9yXG4gICAgICogICAgMi4gQ2xlYXIgaXQgb24gQkFDS1NQQUNFLCBERUxFVEUsIG9yIG90aGVyIGludmFsaWQgY2hhcmFjdGVyIChfZS5nLl8gd2hlbiB1c2VyIHR5cGVzIGEgbGV0dGVyIGJ1dCB0aGUgY2VsbCBlZGl0b3Igb25seSBhY2NlcHRzIGRpZ2l0cykuXG4gICAgICpcbiAgICAgKiA+IEluIGludm9rZWQsIHVzZXIgaGFzIHRoZSBvcHRpb24gdG8gYmFjayBvdXQgYnkgcHJlc3NpbmcgdGhlIEVTQ0FQRSBrZXkuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGVkaXRPbktleWRvd246IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNoZWNrYm94T25seVJvd1NlbGVjdGlvbnM6IGZhbHNlLFxuXG4gICAgLyoqIEBzdW1tYXJ5IE5hbWUgb2YgYSBmb3JtYXR0ZXIgZm9yIGNlbGwgdGV4dC5cbiAgICAgKiBAZGVzYyBUaGUgZGVmYXVsdCAoYHVuZGVmaW5lZGApIGZhbGxzIGJhY2sgdG8gYGNvbHVtbi50eXBlYC5cbiAgICAgKiBUaGUgdmFsdWUgYG51bGxgIGRvZXMgbm8gZm9ybWF0dGluZy5cbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgKiBAdHlwZSB7dW5kZWZpbmVkfG51bGx8c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEB0dXRvcmlhbCBsb2NhbGl6YXRpb25cbiAgICAgKi9cbiAgICBmb3JtYXQ6IHVuZGVmaW5lZCxcblxuICAgIC8qKiBAc3VtbWFyeSBOYW1lIG9mIGEgY2VsbCBlZGl0b3IgZnJvbSB0aGUge0BsaW5rIG1vZHVsZTpjZWxsRWRpdG9yc3xjZWxsRWRpdG9ycyBBUEl9Li5cbiAgICAgKiBAZGVzYyBOb3QgZWRpdGFibGUgaWYgbmFtZWQgZWRpdG9yIGlzIGRvZXMgbm90IGV4aXN0LlxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEB0eXBlIHt1bmRlZmluZWR8bnVsbHxzdHJpbmd9XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHR1dG9yaWFsIGNlbGwtZWRpdG9yc1xuICAgICAqL1xuICAgIGVkaXRvcjogdW5kZWZpbmVkLFxuXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiBjZWxsIHJlbmRlcmVyIGZyb20gdGhlIHtAbGluayBtb2R1bGU6Y2VsbFJlbmRlcmVyc3xjZWxsUmVuZGVyZXJzIEFQSX0uXG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHJlbmRlcmVyOiAnU2ltcGxlQ2VsbCcsXG5cbiAgICAvKioqKioqKioqKiBIT1ZFUiBDT0xPUlMgKioqKioqKioqKi9cblxuICAgIC8qKiBAdHlwZWRlZiBob3ZlckNvbG9yc1xuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VuYWJsZT1mYWxzZV0gLSBgZmFsc2VgIG1lYW5zIG5vdCBoaWxpdGUgb24gaG92ZXJcbiAgICAgKiBAcHJvcGVydHkge2Nzc0NvbG9yfSBiYWNrZ3JvdW5kQ29sb3IgLSBjZWxsLCByb3csIG9yIGNvbHVtbiBiYWNrZ3JvdW5kIGNvbG9yLiBBbHBoYSBjaGFubmVsIHdpbGwgYmUgcmVzcGVjdGVkIGFuZCBpZiBnaXZlbiB3aWxsIGJlIHBhaW50ZWQgb3ZlciB0aGUgY2VsbHMgcHJlZGV0ZXJtaW5lZCBjb2xvci5cbiAgICAgKiBAcHJvcGVydHkge2Nzc0NvbG9yfSBbaGVhZGVyLmJhY2tncm91bmRDb2xvcj1iYWNrZ3JvdW5kQ29sb3JdIC0gZm9yIGNvbHVtbnMgYW5kIHJvd3MsIHRoaXMgaXMgdGhlIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIGNvbHVtbiBvciByb3cgXCJoYW5kbGVcIiAoaGVhZGVyIHJvd3Mgb3IgY29sdW1ucywgcmVzcGVjdGl2ZWx5KS4gKE5vdCB1c2VkIGZvciBjZWxscy4pXG4gICAgICovXG5cbiAgICAvKiogT24gbW91c2UgaG92ZXIsIHdoZXRoZXIgdG8gcmVwYWludCB0aGUgY2VsbCBiYWNrZ3JvdW5kIGFuZCBob3cuXG4gICAgICogQHR5cGUge2hvdmVyQ29sb3JzfVxuICAgICAqIEBkZWZhdWx0ICd7IGVuYWJsZWQ6IHRydWUsIGJhY2tncm91bmQ6IHJnYmEoMTYwLCAxNjAsIDQwLCAwLjMwKSB9J1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGhvdmVyQ2VsbEhpZ2hsaWdodDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDE2MCwgMTYwLCA0MCwgMC40NSknXG4gICAgfSxcblxuICAgIC8qKiBPbiBtb3VzZSBob3Zlciwgd2hldGhlciB0byByZXBhaW50IHRoZSByb3cgYmFja2dyb3VuZCBhbmQgaG93LlxuICAgICAqIEB0eXBlIHtob3ZlckNvbG9yc31cbiAgICAgKiBAZGVmYXVsdCAneyBlbmFibGVkOiB0cnVlLCBiYWNrZ3JvdW5kOiByZ2JhKDEwMCwgMTAwLCAyNSwgMC4xNSkgfSdcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBob3ZlclJvd0hpZ2hsaWdodDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDEwMCwgMTAwLCAyNSwgMC4zMCknXG5cbiAgICB9LFxuXG4gICAgLyoqIE9uIG1vdXNlIGhvdmVyLCB3aGV0aGVyIHRvIHJlcGFpbnQgdGhlIGNvbHVtbiBiYWNrZ3JvdW5kIGFuZCBob3cuXG4gICAgICogQHR5cGUge2hvdmVyQ29sb3JzfVxuICAgICAqIEBkZWZhdWx0ICd7IGVuYWJsZWQ6IHRydWUsIGJhY2tncm91bmQ6IHJnYmEoNjAsIDYwLCAxNSwgMC4xNSkgfSdcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBob3ZlckNvbHVtbkhpZ2hsaWdodDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDYwLCA2MCwgMTUsIDAuMTUpJ1xuICAgIH0sXG5cblxuICAgIC8qKiBEaXNwbGF5IGNlbGwgZm9udCB3aXRoIHVuZGVyLXNjb3JlIGxpbmUgZHJhd24gb3ZlciBpdC5cbiAgICAgKiA+IEltcGxlbWVudGF0aW9uIG9mIGxpbmtzIHJpZ2h0IG5vdyBpcyBub3QgYXV0b21hdGljOyB5b3UgbXVzdCBhdHRhY2ggYSAnZmluLWNsaWNrJyBsaXN0ZW5lciB0byB0aGUgaHlwZXJncmlkIG9iamVjdCwgZXRjLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgbGluazogZmFsc2UsXG5cbiAgICAvKiogRGlzcGxheSBjZWxsIGZvbnQgd2l0aCBzdHJpa2UtdGhyb3VnaCBsaW5lIGRyYXduIG92ZXIgaXQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzdHJpa2VUaHJvdWdoOiBmYWxzZSxcblxuICAgIC8qKiBJZ25vcmUgc29ydCBpbnRlcmFjdGlvbiAoZG91YmxlLWNsaWNrKS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIHVuc29ydGFibGU6IGZhbHNlLFxuXG4gICAgLyoqIEFsbG93IG11bHRpcGxlIGNlbGwgcmVnaW9uIHNlbGVjdGlvbnMuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHRcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBtdWx0aXBsZVNlbGVjdGlvbnM6IGZhbHNlLFxuXG4gICAgLyoqIEBzdW1tYXJ5IFJlLXJlbmRlciBncmlkIGF0IG1heGltdW0gc3BlZWQuXG4gICAgICogQGRlc2MgSW4gdGhpcyBtb2RlOlxuICAgICAqICogVGhlIFwiZGlydHlcIiBmbGFnLCBzZXQgYnkgY2FsbGluZyBgZ3JpZC5yZXBhaW50KClgLCBpcyBpZ25vcmVkLlxuICAgICAqICogYGdyaWQuZ2V0Q2FudmFzKCkuY3VycmVudEZQU2AgaXMgYSBtZWFzdXJlIG9mIHRoZSBudW1iZXIgdGltZXMgdGhlIGdyaWQgaXMgYmVpbmcgcmUtcmVuZGVyZWQgZWFjaCBzZWNvbmQuXG4gICAgICogKiBUaGUgSHlwZXJncmlkIHJlbmRlcmVyIGdvYmJsZXMgdXAgQ1BVIHRpbWUgZXZlbiB3aGVuIHRoZSBncmlkIGFwcGVhcnMgaWRsZSAodGhlIHZlcnkgc2NlbmFyaW8gYHJlcGFpbnQoKWAgaXMgZGVzaWduZWQgdG8gYXZvaWQpLiBGb3IgdGhpcyByZWFzb24sIHdlIGVtcGhhdGljYWxseSBhZHZpc2UgYWdhaW5zdCBzaGlwcGluZyBhcHBsaWNhdGlvbnMgdXNpbmcgdGhpcyBtb2RlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgZW5hYmxlQ29udGludW91c1JlcGFpbnQ6IGZhbHNlLFxuXG4gICAgLyoqIEBzdW1tYXJ5IEFsbG93IHVzZXIgdG8gbW92ZSBjb2x1bW5zIC5cbiAgICAgKiBAZGVzYyBDb2x1bW5zIGNhbiBiZSByZW9yZGVyZWQgdGhyb3VnaCBlaXRoZXIgb2YgdHdvIGludGVyZmFjZXM6XG4gICAgICogKiBDb2x1bW4gRHJhZ2dpbmcgZmVhdHVyZVxuICAgICAqICogQ29sdW1uIFBpY2tlciBkaWFsb2dcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtbnNSZW9yZGVyYWJsZTogdHJ1ZSxcblxuICAgIC8qKiBAc3VtbWFyeSBBcHBseSBjZWxsIHByb3BlcnRpZXMgYmVmb3JlIGBnZXRDZWxsYC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGFwcGx5Q2VsbFByb3BlcnRpZXM6IHRydWUsXG5cbiAgICAvKiogQHN1bW1hcnkgUmVhcHBseSBjZWxsIHByb3BlcnRpZXMgYWZ0ZXIgYGdldENlbGxgLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gICAgcmVhcHBseUNlbGxQcm9wZXJ0aWVzOiBmYWxzZSxcblxuICAgIC8qKiBAc3VtbWFyeSBDb2x1bW4gZ3JhYiB3aXRoaW4gdGhpcyBudW1iZXIgb2YgcGl4ZWxzIGZyb20gdG9wIG9mIGNlbGwuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdFxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbHVtbkdyYWJNYXJnaW46IDVcbn07XG5cbi8qKiBAdHlwZWRlZiB7c3RyaW5nfSBjc3NDb2xvclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWVcbiAqL1xuLyoqIEB0eXBlZGVmIHtzdHJpbmd9IGNzc0ZvbnRcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcbiAqL1xuXG52YXIgdGV4dFdpZHRoQ2FjaGUgPSBuZXcgTFJVQ2FjaGUoMjAwMCk7XG5cbmZ1bmN0aW9uIGdldFRleHRXaWR0aChnYywgc3RyaW5nKSB7XG4gICAgaWYgKHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgc3RyaW5nICs9ICcnO1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIga2V5ID0gZ2MuZm9udCArIHN0cmluZztcbiAgICB2YXIgd2lkdGggPSB0ZXh0V2lkdGhDYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoIXdpZHRoKSB7XG4gICAgICAgIHdpZHRoID0gZ2MubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcbiAgICAgICAgdGV4dFdpZHRoQ2FjaGUuc2V0KGtleSwgd2lkdGgpO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG59XG5cbnZhciBmb250RGF0YSA9IHt9O1xuXG5mdW5jdGlvbiBnZXRUZXh0SGVpZ2h0KGZvbnQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZm9udERhdGFbZm9udF07XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgICB2YXIgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgdGV4dC50ZXh0Q29udGVudCA9ICdIZyc7XG4gICAgICAgIHRleHQuc3R5bGUuZm9udCA9IGZvbnQ7XG5cbiAgICAgICAgdmFyIGJsb2NrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJsb2NrLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgYmxvY2suc3R5bGUud2lkdGggPSAnMXB4JztcbiAgICAgICAgYmxvY2suc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG5cbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChibG9jayk7XG5cbiAgICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIGJsb2NrLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAnYmFzZWxpbmUnO1xuXG4gICAgICAgICAgICB2YXIgYmxvY2tSZWN0ID0gYmxvY2suZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgdGV4dFJlY3QgPSB0ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICByZXN1bHQuYXNjZW50ID0gYmxvY2tSZWN0LnRvcCAtIHRleHRSZWN0LnRvcDtcblxuICAgICAgICAgICAgYmxvY2suc3R5bGUudmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgICAgICAgcmVzdWx0LmhlaWdodCA9IGJsb2NrUmVjdC50b3AgLSB0ZXh0UmVjdC50b3A7XG5cbiAgICAgICAgICAgIHJlc3VsdC5kZXNjZW50ID0gcmVzdWx0LmhlaWdodCAtIHJlc3VsdC5hc2NlbnQ7XG5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LmhlaWdodCAhPT0gMCkge1xuICAgICAgICAgICAgZm9udERhdGFbZm9udF0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpc3REcmFnb24gPSByZXF1aXJlKCdsaXN0LWRyYWdvbicpO1xuXG52YXIgRGlhbG9nID0gcmVxdWlyZSgnLi9EaWFsb2cnKTtcbnZhciBzdHlsZXNoZWV0ID0gcmVxdWlyZSgnLi4vbGliL3N0eWxlc2hlZXQnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERpYWxvZ1xuICovXG52YXIgQ29sdW1uUGlja2VyID0gRGlhbG9nLmV4dGVuZCgnQ29sdW1uUGlja2VyJywge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE1heSBpbmNsdWRlIGBEaWFsb2dgIG9wdGlvbnMuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSBncmlkLmJlaGF2aW9yO1xuXG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICAgICAgaWYgKGJlaGF2aW9yLmlzQ29sdW1uUmVvcmRlcmFibGUoKSkge1xuICAgICAgICAgICAgLy8gcGFyc2UgJiBhZGQgdGhlIGRyYWctYW5kLWRyb3Agc3R5bGVzaGVldCBhZGRlbmR1bVxuICAgICAgICAgICAgdmFyIHN0eWxlc2hlZXRBZGRlbmR1bSA9IHN0eWxlc2hlZXQuaW5qZWN0KCdsaXN0LWRyYWdvbi1hZGRlbmR1bScpO1xuXG4gICAgICAgICAgICAvLyBncmFiIHRoZSBncm91cCBsaXN0cyBmcm9tIHRoZSBiZWhhdmlvclxuICAgICAgICAgICAgaWYgKGJlaGF2aW9yLnNldEdyb3Vwcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHcm91cHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnR3JvdXBzJyxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxzOiBiZWhhdmlvci5nZXRHcm91cHMoKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmF2YWlsYWJsZUdyb3VwcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdBdmFpbGFibGUgR3JvdXBzJyxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxzOiBiZWhhdmlvci5nZXRBdmFpbGFibGVHcm91cHMoKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBQaWNrZXIgPSBuZXcgTGlzdERyYWdvbihbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRHcm91cHMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlR3JvdXBzXG4gICAgICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGRyYWctYW5kLWRyb3Agc2V0cyB0byB0aGUgZGlhbG9nXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQoZ3JvdXBQaWNrZXIubW9kZWxMaXN0c1swXS5jb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGdyb3VwUGlja2VyLm1vZGVsTGlzdHNbMV0uY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZ3JhYiB0aGUgY29sdW1uIGxpc3RzIGZyb20gdGhlIGJlaGF2aW9yXG4gICAgICAgICAgICB0aGlzLmluYWN0aXZlQ29sdW1ucyA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0luYWN0aXZlIENvbHVtbnMnLFxuICAgICAgICAgICAgICAgIG1vZGVsczogYmVoYXZpb3IuZ2V0SGlkZGVuQ29sdW1ucygpLnNvcnQoY29tcGFyZUJ5TmFtZSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29sdW1ucyA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0FjdGl2ZSBDb2x1bW5zJyxcbiAgICAgICAgICAgICAgICBtb2RlbHM6IGJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbnMoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5zb3J0T25IaWRkZW5Db2x1bW5zID0gdGhpcy53YXNTb3J0T25IaWRkZW5Db2x1bW5zID0gZ3JpZC5wcm9wZXJ0aWVzLnNvcnRPbkhpZGRlbkNvbHVtbnM7XG5cbiAgICAgICAgICAgIHZhciBjb2x1bW5QaWNrZXIgPSBuZXcgTGlzdERyYWdvbihbXG4gICAgICAgICAgICAgICAgdGhpcy5pbmFjdGl2ZUNvbHVtbnMsXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVDb2x1bW5zXG4gICAgICAgICAgICBdLCB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBsaXN0LWRyYWdvbi1iYXNlIHN0eWxlc2hlZXQgcmlnaHQgYmVmb3JlIHRoZSBhZGRlbmR1bVxuICAgICAgICAgICAgICAgIGNzc1N0eWxlc2hlZXRSZWZlcmVuY2VFbGVtZW50OiBzdHlsZXNoZWV0QWRkZW5kdW0sXG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgbW9kZWxzIGhhdmUgYSBoZWFkZXIgcHJvcGVydHkgYXMgdGhlaXIgbGFiZWxzXG4gICAgICAgICAgICAgICAgbGFiZWw6ICd7aGVhZGVyfSdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhZGQgdGhlIGRyYWctYW5kLWRyb3Agc2V0cyB0byB0aGUgZGlhbG9nXG4gICAgICAgICAgICB0aGlzLmFwcGVuZChjb2x1bW5QaWNrZXIubW9kZWxMaXN0c1swXS5jb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQoY29sdW1uUGlja2VyLm1vZGVsTGlzdHNbMV0uY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy9MaXN0ZW4gdG8gdGhlIHZpc2libGUgY29sdW1uIGNoYW5nZXNcbiAgICAgICAgICAgIGNvbHVtblBpY2tlci5tb2RlbExpc3RzWzFdLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbGlzdGNoYW5nZWQnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNPbkNvbHVtbnNDaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnNvcnRPbkhpZGRlbkNvbHVtbnMgPSB0aGlzLmdyaWQucHJvcGVydGllcy5zb3J0T25IaWRkZW5Db2x1bW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZGl2LnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgZGl2LnN0eWxlLm1hcmdpblRvcCA9ICcyZW0nO1xuICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9ICdUaGUgc2VsZWN0aW9uIG9mIHZpc2libGUgY29sdW1ucyBpbiB0aGUgZ3JpZCBtYXkgbm90IGJlIGNoYW5nZWQuJztcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKGRpdik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgY2hlY2tib3ggdG8gY29udHJvbCBwYW5lbCBmb3Igc29ydGluZyBvbiBoaWRkZW4gZmllbGRzXG4gICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIGxhYmVsLmlubmVySFRNTCA9ICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCI+IEFsbG93IHNvcnRpbmcgb24gaGlkZGVuIGNvbHVtbnMnO1xuICAgICAgICBsYWJlbC5zdHlsZS5mb250V2VpZ2h0ID0gJ25vcm1hbCc7XG4gICAgICAgIGxhYmVsLnN0eWxlLm1hcmdpblJpZ2h0ID0gJzJlbSc7XG5cbiAgICAgICAgdmFyIGNoZWNrYm94ID0gbGFiZWwucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRoaXMuc29ydE9uSGlkZGVuQ29sdW1ucztcbiAgICAgICAgY2hlY2tib3guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIHNlbGYuc29ydE9uSGlkZGVuQ29sdW1ucyA9IGNoZWNrYm94LmNoZWNrZWQ7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcGFuZWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5oeXBlcmdyaWQtZGlhbG9nLWNvbnRyb2wtcGFuZWwnKTtcbiAgICAgICAgcGFuZWwuaW5zZXJ0QmVmb3JlKGxhYmVsLCBwYW5lbC5maXJzdENoaWxkKTtcblxuICAgICAgICAvLyBhZGQgdGhlIGRpYWxvZyB0byB0aGUgRE9NXG4gICAgICAgIHRoaXMub3BlbihvcHRpb25zLmNvbnRhaW5lcik7XG4gICAgfSxcblxuICAgIG9uQ2xvc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yLFxuICAgICAgICAgICAgY29sdW1ucyA9IGJlaGF2aW9yLmNvbHVtbnM7XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ29sdW1ucykge1xuICAgICAgICAgICAgdmFyIHRyZWUgPSBjb2x1bW5zWzBdO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBicmVha2luZyBlbmNhcHN1bGF0aW9uOyBzaG91bGQgYmUgdXNpbmcgc2V0dGVycyBhbmQgZ2V0dGVycyBvbiB0aGUgYmVoYXZpb3JcbiAgICAgICAgICAgIGNvbHVtbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmICh0cmVlICYmIHRyZWUubGFiZWwgPT09ICdUcmVlJykge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMucHVzaCh0cmVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ29sdW1ucy5tb2RlbHMuZm9yRWFjaChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zb3J0T25IaWRkZW5Db2x1bW5zICE9PSB0aGlzLndhc1NvcnRPbkhpZGRlbkNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuYWRkUHJvcGVydGllcyh7IHNvcnRPbkhpZGRlbkNvbHVtbnM6IHRoaXMuc29ydE9uSGlkZGVuQ29sdW1ucyB9KTtcbiAgICAgICAgICAgICAgICBiZWhhdmlvci5zb3J0Q2hhbmdlZCh0aGlzLmluYWN0aXZlQ29sdW1ucy5tb2RlbHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiZWhhdmlvci5jaGFuZ2VkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEdyb3Vwcyl7XG4gICAgICAgICAgICB2YXIgZ3JvdXBCeXMgPSB0aGlzLnNlbGVjdGVkR3JvdXBzLm1vZGVscy5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlLmlkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiZWhhdmlvci5zZXRHcm91cHMoZ3JvdXBCeXMpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvbXBhcmVCeU5hbWUoYSwgYikge1xuICAgIGEgPSBhLmhlYWRlci50b1N0cmluZygpLnRvVXBwZXJDYXNlKCk7XG4gICAgYiA9IGIuaGVhZGVyLnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gKzEgOiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uUGlja2VyO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF1dG9tYXQgPSByZXF1aXJlKCdhdXRvbWF0Jyk7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vQmFzZScpO1xudmFyIG1hcmt1cCA9IHJlcXVpcmUoJy4uLy4uL2h0bWwnKTtcbnZhciBpbWFnZXMgPSByZXF1aXJlKCcuLi8uLi9pbWFnZXMnKTtcbnZhciBlbGZvciA9IHJlcXVpcmUoJy4uL2xpYi9ET00vZWxmb3InKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCBzZXJ2aWNlcyBhIERPTSBlbGVtZW50IHVzZWQgYXMgYSBjbnRhaW5lciBmb3IgYSBkaWFsb2cuIFRoZSBzdGFuZGFyZCBgbWFya3VwLmRpYWxvZ2AgaXMgc2ltcGx5IGEgZGl2IHdpdGggYSBfY29udHJvbCBwYW5lbF8gY29udGFpbmluZyBhIGNsb3NlIGJveCBhbmQgYSBzZXR0aW5ncyBnZWFyIGljb24uXG4gKlxuICogWW91IGNhbiBzdXBwbHkgYW4gYWx0ZXJuYXRpdmUgZGlhbG9nIHRlbXBsYXRlLiBUaGUgaW50ZXJmYWNlIGlzOlxuICogKiBDbGFzcyBuYW1lIGBoeXBlcmdyaWQtZGlhbG9nYC5cbiAqICogQXQgbGVhc3Qgb25lIGNoaWxkIGVsZW1lbnQuIENvbnRlbnQgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhpcyBmaXJzdCBjaGlsZC5cbiAqICogVHlwaWNhbGx5IGNvbnRhaW5zIGEgY2xvc2UtYm94IGVsZW1lbnQgd2l0aCBjbGFzcyBuYW1lIGBoeXBlcmdyaWQtZGlhbG9nLWNsb3NlYCBhbmQgcG9zc2libHkgb3RoZXIgY29udHJvbHMgd2l0aCBjbGFzcyBuYW1lIGBoeXBlcmdyaWQtZGlhbG9nLXh4eHhgICh3aGVyZSBfeHh4eF8gaXMgYSB1bmlxdWUgbmFtZSBmb3IgeW91ciBjb250cm9sKS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERpYWxvZyA9IEJhc2UuZXh0ZW5kKCdEaWFsb2cnLCB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzaWMgZGlhbG9nIGJveCBpbiBgdGhpcy5lbGAuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IFtvcHRpb25zLmRpYWxvZ1RlbXBsYXRlXSAtIEFuIGFsdGVybmF0ZSBkaWFsb2cgdGVtcGxhdGUuIFRoZSBsYXN0IGNoaWxkIGVsZW1lbnQgbXVzdCBiZSB0aGUgXCJjb250cm9sIHBhbmVsLlwiXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZXR0aW5ncz10cnVlXSAtIENvbnRyb2wgYm94IGhhcyBzZXR0aW5ncyBpY29uLiAoU2V0dGluZ3MgaWNvbiBtdXN0IGJlIGluY2x1ZGVkIGluIHRlbXBsYXRlLiBUaGlzIG9wdGlvbiByZW1vdmVzIGl0LiBUaGF0IGlzLCBpZiBleHBsaWNpdGx5IGBmYWxzZWAgX2FuZF8gdGhlcmUgaXMgYSBzZXR0aW5ncyBjb250cm9sLCByZW1vdmUgaXQuKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IFtvcHRpb25zLmJhY2tncm91bmRJbWFnZT1pbWFnZXMuZGlhbG9nLnNyY10gLSBBIFVSSSBmb3IgYSBiYWNrZ3JvdW5kIGltYWdlLiBJZiBleHBsaWNpdGx5IGBmYWxzZWAsIGJhY2tncm91bmQgaW1hZ2UgaXMgc3VwcHJlc3NlZC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbdGVybWluYXRlXVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGdyaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5ncmlkID0gZ3JpZDtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGJhY2tkcm9wOyBpdCBpcyBhYnNvbHV0ZS1wb3NpdGlvbmVkIGFuZCBzdHJldGNoZWRcbiAgICAgICAgdGhpcy5lbCA9IGF1dG9tYXQuZmlyc3RDaGlsZChvcHRpb25zLmRpYWxvZ1RlbXBsYXRlIHx8IG1hcmt1cC5kaWFsb2csIG9wdGlvbnMuZGlhbG9nUmVwbGFjZW1lbnRzKTtcblxuICAgICAgICB0aGlzLm9yaWdpbmFsRmlyc3RDaGlsZCA9IHRoaXMuZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2V0dGluZ3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5oeXBlcmdyaWQtZGlhbG9nLXNldHRpbmdzJyk7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBiYWNrZ3JvdW5kIGltYWdlXG4gICAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRJbWFnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybChcXCcnICsgKG9wdGlvbnMuYmFja2dyb3VuZEltYWdlIHx8IGltYWdlcy5kaWFsb2cuc3JjKSArICdcXCcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxpc3RlbiBmb3IgY2xpY2tzXG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrLmJpbmQodGhpcykpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGUgPSBvcHRpb25zLnRlcm1pbmF0ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBZGRzIERPTSBgTm9kZWBzIHRvIGRpYWxvZy5cbiAgICAgKiBAZGVzYyBJbnB1dCBjYW4gYmUgbm9kZXMgb3IgYSB0ZW1wbGF0ZSBmcm9tIHdoaWNoIHRvIGNyZWF0ZSBub2Rlcy4gVGhlIG5vZGVzIGFyZSBpbnNlcnRlZCBpbnRvIHRoZSBkaWFsb2cncyBET00gKGB0aGlzLmVsYCksIHJpZ2h0IGJlZm9yZSB0aGUgXCJjb250cm9sIHBhbmVsLlwiXG4gICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb258Tm9kZXxOb2RlW119IG5vZGVzIC0gU2VlIGBhdXRvbWF0YC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtyZXBsYWNlbWVudHNdIC0gU2VlIGBhdXRvbWF0YC5cbiAgICAgKi9cbiAgICBhcHBlbmQ6IGZ1bmN0aW9uKG5vZGVzLCByZXBsYWNlbWVudHMvKi4uLiovKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBub2RlcyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5vZGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBhcmdzLnNwbGljZSgxLCAwLCBlbCwgdGhpcy5vcmlnaW5hbEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgYXV0b21hdC5hcHBlbmQuYXBwbHkobnVsbCwgYXJncyk7XG5cbiAgICAgICAgfSBlbHNlIGlmICgnbGVuZ3RoJyBpbiBub2Rlcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGVsLmluc2VydEJlZm9yZShub2Rlc1tpXSwgdGhpcy5vcmlnaW5hbEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5pbnNlcnRCZWZvcmUobm9kZXMsIHRoaXMub3JpZ2luYWxGaXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgZGlhbG9nIGludG8gRE9NLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2NvbnRhaW5lcl0gLSBJZiB1bmRlZmluZWQsIGRpYWxvZyBpcyBhcHBlbmRlZCB0byBib2R5LlxuICAgICAqXG4gICAgICogSWYgZGVmaW5lZCwgZGlhbG9nIGlzIGFwcGVuZGVkIHRvIGNvbnRhaW5lci4gV2hlbiBjb250YWluZXIgaXMgbm90IGJvZHksIGl0IHdpbGwgYmU6XG4gICAgICogIyBtYWRlIHZpc2libGUgYmVmb3JlIGFwcGVuZCAoaXQgc2hvdWxkIGluaXRpYWxseSBiZSBoaWRkZW4pXG4gICAgICogIyBtYWRlIGhpZGRlbiBhZnRlciByZW1vdmVcbiAgICAgKi9cbiAgICBvcGVuOiBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuXG4gICAgICAgIGlmICghKHRoaXMub3BlbmVkIHx8IHRoaXMub3BlbmluZyB8fCB0aGlzLmNsb3NlZCB8fCB0aGlzLmNsb3NpbmcpKSB7XG4gICAgICAgICAgICBlcnJvciA9IHRoaXMub25PcGVuKCk7XG5cbiAgICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyLnRhZ05hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgdGhlIG5ldyBkaWFsb2cgbWFya3VwIGludG8gdGhlIERPTVxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzY2hlZHVsZSBpdCBmb3IgYSBzaG93IHRyYW5zaXRpb25cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBlbC5jbGFzc0xpc3QuYWRkKCdoeXBlcmdyaWQtZGlhbG9nLXZpc2libGUnKTsgfSwgNTApO1xuXG4gICAgICAgICAgICAgICAgLy8gYXQgZW5kIG9mIHNob3cgdHJhbnNpdGlvbiwgaGlkZSBhbGwgdGhlIGh5cGVyZ3JpZHMgYmVoaW5kIGl0IHRvIHByZXZlbnQgYW55IGtleS9tb3VzZSBldmVudHMgZnJvbSBnZXR0aW5nIHRvIHRoZW1cbiAgICAgICAgICAgICAgICAvLyB0b2RvOiBwYXVzZSBhbGwgaHlwZXJncmlkcyBzbyB0aGV5IGRvbid0IHNwaW4gdXNlbGVzc2x5XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuaGlkZUFwcEJvdW5kID0gaGlkZUFwcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGRpYWxvZyBmcm9tIERPTS5cbiAgICAgKi9cbiAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlcnJvcjtcblxuICAgICAgICBpZiAodGhpcy5vcGVuZWQgJiYgISh0aGlzLmNsb3NlZCB8fCB0aGlzLmNsb3NpbmcpKSB7XG4gICAgICAgICAgICBlcnJvciA9IHRoaXMub25DbG9zZSgpO1xuXG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyB1bmhpZGUgYWxsIHRoZSBoeXBlcmdyaWRzIGJlaGluZCB0aGUgZGlhbG9nXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBWaXNpYmxlKCd2aXNpYmxlJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhIGhpZGUgdHJhbnNpdGlvbiBvZiBkaWFsb2cgcmV2ZWFsaW5nIGdyaWRzIGJlaGluZCBpdFxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2h5cGVyZ3JpZC1kaWFsb2ctdmlzaWJsZScpO1xuXG4gICAgICAgICAgICAgICAgLy8gYXQgZW5kIG9mIGhpZGUgdHJhbnNpdGlvbiwgcmVtb3ZlIGRpYWxvZyBmcm9tIHRoZSBET01cbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5yZW1vdmVEaWFsb2dCb3VuZCA9IHJlbW92ZURpYWxvZy5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9LFxuXG4gICAgYXBwU2VsZWN0b3I6ICdjYW52YXMuaHlwZXJncmlkJyxcbiAgICBhcHBWaXNpYmxlOiBmdW5jdGlvbih2aXNpYmlsaXR5KSB7XG4gICAgICAgIGVsZm9yLmVhY2godGhpcy5hcHBTZWxlY3RvciwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLnZpc2liaWxpdHkgPSB2aXNpYmlsaXR5O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgb25PcGVuOiBudWxsUGF0dGVybixcbiAgICBvbk9wZW5lZDogbnVsbFBhdHRlcm4sXG4gICAgb25DbG9zZTogbnVsbFBhdHRlcm4sXG4gICAgb25DbG9zZWQ6IG51bGxQYXR0ZXJuLFxuICAgIHRlcm1pbmF0ZTogbnVsbFBhdHRlcm5cbn0pO1xuXG5mdW5jdGlvbiBudWxsUGF0dGVybigpIHt9XG5cbmZ1bmN0aW9uIHJlbW92ZURpYWxvZyhldnQpIHtcbiAgICBpZiAoZXZ0LnRhcmdldCA9PT0gdGhpcy5lbCAmJiBldnQucHJvcGVydHlOYW1lID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwucGFyZW50RWxlbWVudC50YWdOYW1lICE9PSAnQk9EWScpIHtcbiAgICAgICAgICAgIHRoaXMuZWwucGFyZW50RWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZWw7XG5cbiAgICAgICAgdGhpcy5vbkNsb3NlZCgpO1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZSgpO1xuICAgICAgICB0aGlzLmNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGlkZUFwcChldnQpIHtcbiAgICBpZiAoZXZ0LnRhcmdldCA9PT0gdGhpcy5lbCAmJiBldnQucHJvcGVydHlOYW1lID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgdGhpcy5hcHBWaXNpYmxlKCdoaWRkZW4nKTtcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5oaWRlQXBwQm91bmQpO1xuICAgICAgICB0aGlzLm9uT3BlbmVkKCk7XG4gICAgICAgIHRoaXMub3BlbmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9wZW5lZCA9IHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvbkNsaWNrKGV2dCkge1xuICAgIGlmICh0aGlzKSB7XG4gICAgICAgIGlmIChldnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnaHlwZXJncmlkLWRpYWxvZy1jbG9zZScpKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gaWdub3JlIGhyZWZcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGV2dC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdoeXBlcmdyaWQtZGlhbG9nLXNldHRpbmdzJykpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpZ25vcmUgaHJlZlxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MpIHsgdGhpcy5zZXR0aW5ncygpOyB9XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9uQ2xpY2sgJiYgIXRoaXMub25DbGljay5jYWxsKHRoaXMsIGV2dCkgJiYgZXZ0LnRhcmdldC50YWdOYW1lID09PSAnQScpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBpZ25vcmUgaHJlZiBvZiBoYW5kbGVkIGV2ZW50XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHRoZSBjbGljayBzdG9wcyBoZXJlLCBoYW5kbGVkIG9yIG5vdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpYWxvZztcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUYWJ6ID0gcmVxdWlyZSgndGFieicpO1xudmFyIHBvcE1lbnUgPSByZXF1aXJlKCdwb3AtbWVudScpO1xudmFyIGF1dG9tYXQgPSByZXF1aXJlKCdhdXRvbWF0Jyk7XG5cbnZhciBEaWFsb2cgPSByZXF1aXJlKCcuL0RpYWxvZycpO1xudmFyIG1hcmt1cCA9IHJlcXVpcmUoJy4uLy4uL2h0bWwnKTtcbnZhciBjb3B5SW5wdXQgPSByZXF1aXJlKCcuLi9saWIvRE9NL2NvcHktaW5wdXQnKTtcblxudmFyIHRhYlByb3BlcnRpZXMgPSB7XG4gICAgdGFibGVRQjoge1xuICAgICAgICBpc1RhYmxlRmlsdGVyOiB0cnVlXG4gICAgfSxcbiAgICB0YWJsZVNRTDoge1xuICAgICAgICBpc1RhYmxlRmlsdGVyOiB0cnVlLFxuICAgICAgICBsYW5ndWFnZTogJ1NRTCdcbiAgICB9LFxuICAgIGNvbHVtbnNRQjoge1xuICAgICAgICBpc0NvbHVtbkZpbHRlcjogdHJ1ZVxuICAgIH0sXG4gICAgY29sdW1uc1NRTDoge1xuICAgICAgICBpc0NvbHVtbkZpbHRlcjogdHJ1ZSxcbiAgICAgICAgbGFuZ3VhZ2U6ICdTUUwnXG4gICAgfSxcbiAgICBjb2x1bW5zQ1FMOiB7XG4gICAgICAgIGlzQ29sdW1uRmlsdGVyOiB0cnVlLFxuICAgICAgICBsYW5ndWFnZTogJ0NRTCdcbiAgICB9XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRGlhbG9nXG4gKi9cbnZhciBNYW5hZ2VGaWx0ZXJzID0gRGlhbG9nLmV4dGVuZCgnTWFuYWdlRmlsdGVycycsIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE1heSBpbmNsdWRlIGBEaWFsb2dgIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW29wdGlvbnMuY29udGFpbmVyPWRvY3VtZW50LmJvZHldXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZ3JpZCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmZpbHRlciA9IGdyaWQuZmlsdGVyO1xuXG4gICAgICAgIHRoaXMuYXBwZW5kKG1hcmt1cC5maWx0ZXJUcmVlcyk7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgZm9sZGVyIHRhYnNcbiAgICAgICAgdmFyIHRhYnogPSB0aGlzLnRhYnogPSBuZXcgVGFieih7XG4gICAgICAgICAgICByb290OiB0aGlzLmVsLFxuICAgICAgICAgICAgb25FbmFibGU6IHJlbmRlckZvbGRlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgb25EaXNhYmxlOiBzYXZlRm9sZGVycy5iaW5kKHRoaXMsIG51bGwpIC8vIG51bGwgb3B0aW9uc1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3aXJlLXVwIHRoZSBOZXcgQ29sdW1uIGRyb3AtZG93blxuICAgICAgICB2YXIgbmV3Q29sdW1uRHJvcERvd24gPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJyNhZGQtY29sdW1uLWZpbHRlci1zdWJleHByZXNzaW9uJyk7XG4gICAgICAgIG5ld0NvbHVtbkRyb3BEb3duLm9ubW91c2Vkb3duID0gb25OZXdDb2x1bW5Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgbmV3Q29sdW1uRHJvcERvd24ub25jaGFuZ2UgPSBvbk5ld0NvbHVtbkNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIHB1dCB0aGUgdHdvIHN1YnRyZWVzIGluIHRoZSB0d28gcGFuZWxzXG4gICAgICAgIHRhYnouZm9sZGVyKCcjdGFibGVRQicpLmFwcGVuZENoaWxkKHRoaXMuZmlsdGVyLnRhYmxlRmlsdGVyLmVsKTtcbiAgICAgICAgdGFiei5mb2xkZXIoJyNjb2x1bW5zUUInKS5hcHBlbmRDaGlsZCh0aGlzLmZpbHRlci5jb2x1bW5GaWx0ZXJzLmVsKTtcblxuICAgICAgICAvLyBjb3B5IHRoZSBTUUwgbW9yZS1pbmZvIGJsb2NrIGZyb20gdGhlIHRhYmxlIHRvIHRoZSBjb2x1bW5zIHRhYlxuICAgICAgICB2YXIgY29sdW1uU3FsRWwgPSB0YWJ6LmZvbGRlcignI2NvbHVtbnNTUUwnKTtcbiAgICAgICAgdmFyIG1vcmVTcWxJbmZvID0gdGFiei5mb2xkZXIoJyN0YWJsZVNRTCcpLmZpcnN0RWxlbWVudENoaWxkLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgY29sdW1uU3FsRWwuaW5zZXJ0QmVmb3JlKG1vcmVTcWxJbmZvLCBjb2x1bW5TcWxFbC5maXJzdENoaWxkKTtcblxuICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIERPTVxuICAgICAgICB0aGlzLm9wZW4ob3B0aW9ucy5jb250YWluZXIpO1xuXG4gICAgICAgIC8vIGZvbGxvd2luZyBuZWVkZWQgZm9yIHVuY2xlYXIgcmVhc29ucyB0byBnZXQgZHJvcC1kb3duIHRvIGRpc3BsYXkgY29ycmVjdGx5XG4gICAgICAgIG5ld0NvbHVtbkRyb3BEb3duLnNlbGVjdGVkSW5kZXggPSAwO1xuICAgIH0sXG5cbiAgICBvbkNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNhdmVGb2xkZXJzLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIG9uQ2xvc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yO1xuICAgICAgICBiZWhhdmlvci5yZWluZGV4KCk7XG4gICAgICAgIGJlaGF2aW9yLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGNsaWNrIGhhbmRsZXJzOyBjYWxsZWQgYnkgY3VydGFpbi5vbmNsaWNrIGluIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gZXZ0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgb25DbGljazogZnVuY3Rpb24oZXZ0KSB7IC8vIHRvIGJlIGNhbGxlZCB3aXRoIGZpbHRlciBvYmplY3QgYXMgc3ludGF4XG4gICAgICAgIHZhciBjdHJsID0gZXZ0LnRhcmdldDtcblxuICAgICAgICBpZiAoY3RybC5jbGFzc0xpc3QuY29udGFpbnMoJ21vcmUtaW5mbycpKSB7XG4gICAgICAgICAgICAvLyBmaW5kIGFsbCBtb3JlLWluZm8gbGlua3MgYW5kIHRoZWlyIGFkamFjZW50IGJsb2NrcyAoYmxvY2tzIGFsd2F5cyBmb2xsb3cgbGlua3MpXG4gICAgICAgICAgICB2YXIgZWxzID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCcubW9yZS1pbmZvJyk7XG5cbiAgICAgICAgICAgIC8vIGhpZGUgYWxsIG1vcmUtaW5mbyBibG9ja3MgZXhjZXB0IHRoZSBvbmUgZm9sbG93aW5nIHRoaXMgbGluayAodW5sZXNzIGl0J3MgYWxyZWFkeSB2aXNpYmxlIGluIHdoaWNoIGNhc2UgaGlkZSBpdCB0b28pLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSBlbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVsLnRhZ05hbWUgPT09ICdBJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBlbCA9PT0gY3RybDtcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0W2ZvdW5kID8gJ3RvZ2dsZScgOiAncmVtb3ZlJ10oJ2hpZGUtaW5mbycpO1xuICAgICAgICAgICAgICAgICAgICBlbCA9IGVsc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBmb3VuZCAmJiBlbC5zdHlsZS5kaXNwbGF5ICE9PSAnYmxvY2snID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChjdHJsLmNsYXNzTGlzdC5jb250YWlucygnZmlsdGVyLWNvcHknKSkge1xuICAgICAgICAgICAgdmFyIGlzQ29weUFsbCA9IGN0cmwuY2hpbGROb2Rlcy5sZW5ndGg7IC8vIGNvbnRhaW5zIFwiQWxsXCJcbiAgICAgICAgICAgIGlmIChpc0NvcHlBbGwpIHtcbiAgICAgICAgICAgICAgICBjdHJsID0gdGhpcy50YWJ6LmZvbGRlcihjdHJsKS5xdWVyeVNlbGVjdG9yKGNvcHlJbnB1dC5zZWxlY3RvclRleHRDb250cm9scyk7XG4gICAgICAgICAgICAgICAgY29weUlucHV0KGN0cmwsIHRoaXMuZmlsdGVyLmNvbHVtbkZpbHRlcnMuZ2V0U3RhdGUoeyBzeW50YXg6ICdTUUwnIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weUlucHV0KGN0cmwucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKGNvcHlJbnB1dC5zZWxlY3RvclRleHRDb250cm9scykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gbWVhbnMgdW5oYW5kbGVkXG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIHRhYlxuICogQHBhcmFtIGZvbGRlclxuICogQHBhcmFtIFtwYW5lbF0gUGFuZWwgdG8gc2F2ZSAoZnJvbSB0YWIgY2xpY2spLiBJZiBvbWl0dGVkLCBzYXZlIGJvdGggcGFuZWxzIChmcm9tIG9uY2xvc2UpLlxuICogQHJldHVybnMge2Jvb2xlYW58dW5kZWZpbmVkfHN0cmluZ31cbiAqL1xuZnVuY3Rpb24gc2F2ZUZvbGRlcnMob3B0aW9ucywgdGFiLCBmb2xkZXIsIHBhbmVsKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgKCFwYW5lbCB8fCBwYW5lbC5pZCA9PT0gJ3RhYmxlRmlsdGVyUGFuZWwnKSAmJiBzYXZlRm9sZGVyLmNhbGwodGhpcywgdGhpcy5maWx0ZXIudGFibGVGaWx0ZXIsIG9wdGlvbnMpIHx8XG4gICAgICAgICghcGFuZWwgfHwgcGFuZWwuaWQgPT09ICdjb2x1bW5GaWx0ZXJzUGFuZWwnKSAmJiBzYXZlRm9sZGVyLmNhbGwodGhpcywgdGhpcy5maWx0ZXIuY29sdW1uRmlsdGVycywgb3B0aW9ucylcbiAgICApO1xufVxuXG4vKipcbiAqIEB0aGlzIEZpbHRlclxuICogQHBhcmFtIHtEZWZhdWx0RmlsdGVyfSBzdWJ0cmVlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e2FsZXJ0OnRydWUsZm9jdXM6dHJ1ZX1dIC0gU2lkZSBlZmZlY3RzIGFzIHBlciBgRmlsdGVyVHJlZS5wcm90b3R5cGUuaW52YWxpZGAncyBgb3B0aW9uc2AnIHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8c3RyaW5nfSAtIFZhbGlkYXRpb24gZXJyb3IgdGV4dDsgZmFsc3kgbWVhbnMgdmFsaWQgKG5vIGVycm9yKS5cbiAqL1xuZnVuY3Rpb24gc2F2ZUZvbGRlcihzdWJ0cmVlLCBvcHRpb25zKSB7IC8vIHRvIGJlIGNhbGxlZCB3aXRoIGZpbHRlciBvYmplY3QgYXMgc3ludGF4XG4gICAgdmFyIGlzQ29sdW1uRmlsdGVycyA9IHN1YnRyZWUgPT09IHRoaXMuZmlsdGVyLmNvbHVtbkZpbHRlcnMsXG4gICAgICAgIHRhYlF1ZXJ5QnVpbGRlciA9IHRoaXMudGFiei50YWIoaXNDb2x1bW5GaWx0ZXJzID8gJyNjb2x1bW5zUUInIDogJyN0YWJsZVFCJyksXG4gICAgICAgIHRhYiA9IHRoaXMudGFiei5lbmFibGVkVGFiKHRhYlF1ZXJ5QnVpbGRlciksXG4gICAgICAgIGZvbGRlciA9IHRoaXMudGFiei5mb2xkZXIodGFiKSxcbiAgICAgICAgaXNRdWVyeUJ1aWxkZXIgPSB0YWIgPT09IHRhYlF1ZXJ5QnVpbGRlcixcbiAgICAgICAgZGVmYXVsdGVkT3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgYWxlcnQ6IHRydWUsXG4gICAgICAgICAgICBmb2N1czogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBlbmhhbmNlZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhbGVydDogZGVmYXVsdGVkT3B0aW9ucy5hbGVydCxcbiAgICAgICAgICAgIGZvY3VzOiBkZWZhdWx0ZWRPcHRpb25zLmZvY3VzICYmIGlzUXVlcnlCdWlsZGVyXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yLCBjdHJsO1xuXG4gICAgaWYgKGlzQ29sdW1uRmlsdGVycyB8fCBpc1F1ZXJ5QnVpbGRlcikge1xuICAgICAgICBlcnJvciA9IHN1YnRyZWUuaW52YWxpZChlbmhhbmNlZE9wdGlvbnMpO1xuICAgIH0gZWxzZSB7IC8vIHRhYmxlIGZpbHRlciBTUUwgdGFiXG4gICAgICAgIGN0cmwgPSBmb2xkZXIucXVlcnlTZWxlY3RvcigndGV4dGFyZWEnKTtcbiAgICAgICAgZXJyb3IgPSB0aGlzLmZpbHRlci5zZXRUYWJsZUZpbHRlclN0YXRlKGN0cmwudmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChlcnJvciAmJiAhaXNRdWVyeUJ1aWxkZXIpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgdmFsaWRhdGlvbiBlcnJvciwgbW92ZSB0aGUgZm9jdXMgZnJvbSB0aGUgcXVlcnkgYnVpbGRlciBjb250cm9sIHRvIHRoZSB0ZXh0IGJveCBjb250cm9sLlxuICAgICAgICBpZiAoaXNDb2x1bW5GaWx0ZXJzKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBpbiBTUUwgb3IgQ1FMIHRhYiBzbyBmaW5kIHRleHQgYm94IHRoYXQgZ29lcyB3aXRoIHRoaXMgc3ViZXhwcmVzc2lvbiBhbmQgZm9jdXMgb24gaXQgaW5zdGVhZCBvZiBRQiBjb250cm9sLlxuICAgICAgICAgICAgdmFyIGVycmFudENvbHVtbk5hbWUgPSBlcnJvci5ub2RlLmVsLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKS52YWx1ZTtcbiAgICAgICAgICAgIGN0cmwgPSBmb2xkZXIucXVlcnlTZWxlY3RvcignW25hbWU9XCInICsgZXJyYW50Q29sdW1uTmFtZSArICdcIl0nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdHJsKSB7XG4gICAgICAgIGRlY29yYXRlRmlsdGVySW5wdXQoY3RybCwgZXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVGaWx0ZXJJbnB1dChjdHJsLCBlcnJvcikge1xuICAgIGN0cmwuY2xhc3NMaXN0LnRvZ2dsZSgnZmlsdGVyLXRyZWUtZXJyb3InLCAhIWVycm9yKTtcblxuICAgIGN0cmwuZm9jdXMoKTtcblxuICAgIC8vIGZpbmQgdGhlIG5lYXJieSB3YXJuaW5nIGVsZW1lbnRcbiAgICB2YXIgd2FybmluZ0VsO1xuICAgIGRvIHtcbiAgICAgICAgY3RybCA9IGN0cmwucGFyZW50RWxlbWVudDtcbiAgICAgICAgd2FybmluZ0VsID0gY3RybC5xdWVyeVNlbGVjdG9yKCcuZmlsdGVyLXRyZWUtd2FybicpO1xuICAgIH0gd2hpbGUgKCF3YXJuaW5nRWwpO1xuXG4gICAgLy8gc2hvdyBvciBoaWRlIHRoZSBlcnJvclxuICAgIHdhcm5pbmdFbC5pbm5lckhUTUwgPSBlcnJvci5tZXNzYWdlIHx8IGVycm9yIHx8ICcnO1xufVxuXG5mdW5jdGlvbiBvbk5ld0NvbHVtbk1vdXNlRG93bihldnQpIHsgLy8gdG8gYmUgY2FsbGVkIHdpdGggZmlsdGVyIG9iamVjdCBhcyBzeW50YXhcbiAgICBpZiAoc2F2ZUZvbGRlci5jYWxsKHRoaXMsIHRoaXMuZmlsdGVyLmNvbHVtbkZpbHRlcnMpKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBkbyBub3QgZHJvcCBkb3duXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gKHJlKWJ1aWxkIHRoZSBkcm9wLWRvd24gY29udGVudHMsIHdpdGggc2FtZSBwcm9tcHQsIGJ1dCBleGNsdWRpbmcgY29sdW1ucyB3aXRoIGFjdGl2ZSBmaWx0ZXIgc3ViZXhwcmVzc2lvbnNcbiAgICAgICAgdmFyIGN0cmwgPSBldnQudGFyZ2V0LFxuICAgICAgICAgICAgcHJvbXB0ID0gY3RybC5vcHRpb25zWzBdLnRleHQucmVwbGFjZSgn4oCmJywgJycpLCAvLyB1c2Ugb3JpZ2luYWwgYnV0IHcvbyBlbGxpcHNpcyBhcyAuYnVpbGQoKSBhcHBlbmRzIG9uZVxuICAgICAgICAgICAgYmxhY2tsaXN0ID0gdGhpcy5maWx0ZXIuY29sdW1uRmlsdGVycy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY29sdW1uRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbkZpbHRlci5jaGlsZHJlbi5sZW5ndGggJiYgY29sdW1uRmlsdGVyLmNoaWxkcmVuWzBdLmNvbHVtbjtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdCxcbiAgICAgICAgICAgICAgICBibGFja2xpc3Q6IGJsYWNrbGlzdFxuICAgICAgICAgICAgfTtcblxuICAgICAgICBwb3BNZW51LmJ1aWxkKGN0cmwsIHRoaXMuZmlsdGVyLnJvb3Quc2NoZW1hLCBvcHRpb25zKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uTmV3Q29sdW1uQ2hhbmdlKGV2dCkge1xuICAgIHZhciBjdHJsID0gZXZ0LnRhcmdldCxcbiAgICAgICAgdGFiQ29sdW1uUUIgPSB0aGlzLnRhYnouZm9sZGVyKCcjdGFibGVRQicpLFxuICAgICAgICB0YWIgPSB0aGlzLnRhYnouZW5hYmxlZFRhYih0YWJDb2x1bW5RQi5wYXJlbnRFbGVtZW50KSxcbiAgICAgICAgaXNRdWVyeUJ1aWxkZXIgPSB0YWIgPT09IHRhYkNvbHVtblFCLFxuICAgICAgICB0YWJQcm9wcyA9IHRhYlByb3BlcnRpZXNbdGFiLmlkXTtcblxuICAgIHRoaXMuZmlsdGVyLmNvbHVtbkZpbHRlcnMuYWRkKHtcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb2x1bW5GaWx0ZXInLFxuICAgICAgICAgICAgY2hpbGRyZW46IFsgeyBjb2x1bW46IGN0cmwudmFsdWUgfSBdXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzOiBpc1F1ZXJ5QnVpbGRlclxuICAgIH0pO1xuXG4gICAgaWYgKHRhYlByb3BzLmlzQ29sdW1uRmlsdGVyICYmIHRhYlByb3BzLmxhbnVnYWdlKSB7XG4gICAgICAgIHJlbmRlckZvbGRlci5jYWxsKHRoaXMsIHRhYik7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFsbCBidXQgdGhlIHByb21wdCBvcHRpb24gKGZpcnN0IGNoaWxkKVxuICAgIGN0cmwuc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgd2hpbGUgKGN0cmwubGFzdENoaWxkICE9PSBjdHJsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgY3RybC5yZW1vdmVDaGlsZChjdHJsLmxhc3RDaGlsZCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJGb2xkZXIodGFiKSB7IC8vIHRvIGJlIGNhbGxlZCB3aXRoIGZpbHRlciBvYmplY3QgYXMgc3ludGF4XG4gICAgdmFyIHRhYlByb3BzID0gdGFiUHJvcGVydGllc1t0YWIuaWRdLFxuICAgICAgICBxdWVyeUxhbmd1YWdlID0gdGFiUHJvcHMubGFuZ3VhZ2U7XG5cbiAgICBpZiAocXVlcnlMYW5ndWFnZSkge1xuICAgICAgICB2YXIgZ2xvYmFsRmlsdGVyID0gdGhpcy5maWx0ZXIsXG4gICAgICAgICAgICBmb2xkZXIgPSB0aGlzLnRhYnouZm9sZGVyKHRhYik7XG5cbiAgICAgICAgaWYgKHRhYlByb3BzLmlzVGFibGVGaWx0ZXIpIHtcblxuICAgICAgICAgICAgZm9sZGVyLnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJykudmFsdWUgPSBnbG9iYWxGaWx0ZXIudGFibGVGaWx0ZXIuZ2V0U3RhdGUoeyBzeW50YXg6ICdTUUwnIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIGNvbHVtbiBmaWx0ZXJcblxuICAgICAgICAgICAgdmFyIGNvbHVtbkZpbHRlcnMgPSBnbG9iYWxGaWx0ZXIuY29sdW1uRmlsdGVycy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICBlbCA9IGZvbGRlci5sYXN0RWxlbWVudENoaWxkLFxuICAgICAgICAgICAgICAgIG1zZ0VsID0gZWwucXVlcnlTZWxlY3Rvcignc3BhbicpLFxuICAgICAgICAgICAgICAgIGxpc3RFbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ29sJyksXG4gICAgICAgICAgICAgICAgY29weUFsbExpbmsgPSBlbC5xdWVyeVNlbGVjdG9yKCdhOmZpcnN0LW9mLXR5cGUnKTtcblxuICAgICAgICAgICAgbXNnRWwuaW5uZXJIVE1MID0gYWN0aXZlRmlsdGVyc01lc3NhZ2UoY29sdW1uRmlsdGVycy5sZW5ndGgpO1xuICAgICAgICAgICAgbGlzdEVsLmlubmVySFRNTCA9ICcnO1xuXG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBjb2x1bW4gZmlsdGVyIHN1YnRyZWUsIGFwcGVuZCBhbiA8bGk+Li4uPC9saT4gZWxlbWVudCBjb250YWluaW5nOlxuICAgICAgICAgICAgLy8gY29sdW1uIHRpdGxlLCBcIihjb3B5KVwiIGxpbmssIGFuZCBlZGl0YWJsZSB0ZXh0IGlucHV0IGJveCBjb250YWluaW5nIHRoZSBzdWJleHByZXNzaW9uXG4gICAgICAgICAgICBjb2x1bW5GaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvbmFsID0gZmlsdGVyLmNoaWxkcmVuWzBdLFxuICAgICAgICAgICAgICAgICAgICBpdGVtID0gY29uZGl0aW9uYWwuc2NoZW1hWzBdLFxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gY29uZGl0aW9uYWwuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBhbGlhcyA9IGl0ZW0uYWxpYXMgfHwgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGZpbHRlci5nZXRTdGF0ZSh7IHN5bnRheDogcXVlcnlMYW5ndWFnZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgaXNOdWxsID0gZXhwcmVzc2lvbiA9PT0gJyhOVUxMIElTIE5VTEwpJyB8fCBleHByZXNzaW9uID09PSAnJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGlzTnVsbCA/ICcnIDogZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gaXNOdWxsID8gJ2ZpbHRlci10cmVlLWVycm9yJyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBsaSA9IGF1dG9tYXQuZmlyc3RDaGlsZChtYXJrdXBbcXVlcnlMYW5ndWFnZV0sIGFsaWFzLCBuYW1lLCBjb250ZW50LCBjbGFzc05hbWUpO1xuXG4gICAgICAgICAgICAgICAgbGlzdEVsLmFwcGVuZENoaWxkKGxpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb2xkZXIub25rZXl1cCA9IHNldENvbHVtbkZpbHRlclN0YXRlLmJpbmQodGhpcywgcXVlcnlMYW5ndWFnZSk7XG5cbiAgICAgICAgICAgIGlmIChjb3B5QWxsTGluaykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBcIihjb3B5IGFsbClcIiBsaW5rLCBoaWRlIGl0IGlmIG9ubHkgMCBvciAxIHN1YmV4cHJlc3Npb25zXG4gICAgICAgICAgICAgICAgY29weUFsbExpbmsuc3R5bGUuZGlzcGxheSA9IGNvbHVtbkZpbHRlcnMubGVuZ3RoID4gMSA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cbn1cblxuLy92YXIgUkVUVVJOX0tFWSA9IDB4MGQsIEVTQ0FQRV9LRVkgPSAweDFiO1xuLyoqXG4gKiBDYWxsZWQgZnJvbSBrZXktdXAgZXZlbnRzIGZyb20gYCNjb2x1bW5TUUxgIGFuZCBgI2NvbHVtbkNRTGAgdGFicy5cbiAqIEB0aGlzIEZpbHRlclxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5TGFuZ3VhZ2VcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZ0XG4gKi9cbmZ1bmN0aW9uIHNldENvbHVtbkZpbHRlclN0YXRlKHF1ZXJ5TGFuZ3VhZ2UsIGV2dCkge1xuICAgIHZhciBjdHJsID0gZXZ0LnRhcmdldDtcblxuICAgIC8vIE9ubHkgaGFuZGxlIGlmIGtleSB3YXMgcHJlc3NlZCBpbnNpZGUgYSB0ZXh0IGJveC5cbiAgICBpZiAoY3RybC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZpbHRlci10ZXh0LWJveCcpKSB7XG4gICAgICAgIC8vc3dpdGNoIChldnQua2V5Q29kZSkge1xuICAgICAgICAvLyAgICBjYXNlIEVTQ0FQRV9LRVk6XG4gICAgICAgIC8vICAgICAgICBjdHJsLnZhbHVlID0gb2xkQXJnO1xuICAgICAgICAvLyAgICBjYXNlIFJFVFVSTl9LRVk6IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgLy8gICAgICAgIGN0cmwuYmx1cigpO1xuICAgICAgICAvLyAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBlcnJvcixcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IHN5bnRheDogcXVlcnlMYW5ndWFnZSwgYWxlcnQ6IHRydWUgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXJyb3IgPSB0aGlzLmZpbHRlci5zZXRDb2x1bW5GaWx0ZXJTdGF0ZShjdHJsLm5hbWUsIGN0cmwudmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb3JhdGVGaWx0ZXJJbnB1dChjdHJsLCBlcnJvcik7XG4gICAgICAgIC8vfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWN0aXZlRmlsdGVyc01lc3NhZ2Uobikge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmVzdWx0ID0gJ1RoZXJlIGFyZSBubyBhY3RpdmUgY29sdW1uIGZpbHRlcnMuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXN1bHQgPSAnVGhlcmUgaXMgMSBhY3RpdmUgY29sdW1uIGZpbHRlcjonO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXN1bHQgPSAnVGhlcmUgYXJlICcgKyBuICsgJyBhY3RpdmUgY29sdW1uIGZpbHRlcnM6JztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlRmlsdGVycztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMuQ29sdW1uUGlja2VyID0gcmVxdWlyZSgnLi9Db2x1bW5QaWNrZXInKTtcbm1vZHVsZS5leHBvcnRzLk1hbmFnZUZpbHRlcnMgPSByZXF1aXJlKCcuL01hbmFnZUZpbHRlcnMnKTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qIE5PVEVcbiAqXG4gKiBXaGF0IHRoaXMgZmlsZSBpczpcbiAqICogVGhpcyBmaWxlIGlzIGJyb3dzZXJpZnkncyBlbnRyeSBwb2ludC5cbiAqICogVGhpcyBmaWxlIGNyZWF0ZXMgdGhlIGB3aW5kb3cuZmluLkh5cGVyZ3JpZGAgb2JqZWN0LlxuICpcbiAqIFdoYXQgdGhpcyBmaWxlIGlzIG5vdDpcbiAqICogVGhpcyBmaWxlIGlzIG5vdCBhIG5vZGUgbW9kdWxlOyBpdCBoYXMgbm8gcmVmZXJlbmNlIHRvIGBtb2R1bGUuZXhwb3J0c2Agb3IgYGV4cG9ydHNgOyBpdCBjYW5ub3QgYmUgXCJyZXF1aXJlZFwiIGJ5IGFueSBvdGhlciBmaWxlLlxuICogKiBUaGlzIGZpbGUgaXMgYmxhY2tsaXN0ZWQgaW4gLm5wbWlnbm9yZSBhbmQgaXMgbm90IHB1Ymxpc2hlZCB0byBucG0uXG4gKlxuICogTm90ZTogVGhlIG5wbSBcIm1haW5cIiBlbnRyeSBwb2ludCAoYXMgbm90ZWQgaW4gcGFja2FnZS5qc29uKSBpcyBzcmMvSHlwZXJncmlkLmpzLlxuICovXG5cbnZhciBIeXBlcmdyaWQgPSByZXF1aXJlKCcuL0h5cGVyZ3JpZCcpO1xuXG4vLyBFeHBvc2Ugc29tZSBuYW1lc3BhY2VzIHRvIHVzZXJzIG9mIHRoZSBoeXBlcmdyaWQuanMgZmlsZSB0aHJvdWdoIGBmaW4uSHlwZXJncmlkYDpcbkh5cGVyZ3JpZC5pbWFnZXMgPSByZXF1aXJlKCcuLi9pbWFnZXMnKTtcbkh5cGVyZ3JpZC5iZWhhdmlvcnMgPSByZXF1aXJlKCcuL2JlaGF2aW9ycycpO1xuSHlwZXJncmlkLmRhdGFNb2RlbHMgPSByZXF1aXJlKCcuL2RhdGFNb2RlbHMnKTtcbkh5cGVyZ3JpZC5mZWF0dXJlcyA9IHJlcXVpcmUoJy4vZmVhdHVyZXMnKTtcbkh5cGVyZ3JpZC5hbmFseXRpY3MgPSByZXF1aXJlKCcuL1NoYXJlZC5qcycpLmFuYWx5dGljcztcbkh5cGVyZ3JpZC5EYXRhU291cmNlQmFzZSA9IHJlcXVpcmUoJy4vZGF0YVNvdXJjZXMnKS5EYXRhU291cmNlQmFzZTtcbkh5cGVyZ3JpZC5yZWN0YW5ndWxhciA9IHJlcXVpcmUoJ3JlY3Rhbmd1bGFyJyk7XG5cbi8vIENyZWF0ZSB0aGUgYGZpbmAgbmFtZXNwYWNlIGFuZCB0aGUgYGZpbi5IeXBlcmdyaWRgIG9iamVjdHM6XG4od2luZG93LmZpbiA9IHdpbmRvdy5maW4gfHwge30pLkh5cGVyZ3JpZCA9IEh5cGVyZ3JpZDtcblxuLy8gQ3JlYXRlIHRoZSBgZGF0YXNhdXJgIG5hbWVzcGFjZSBhbmQgdGhlIGBkYXRhc2F1ci5iYXNlYCBvYmplY3RzOlxuKHdpbmRvdy5kYXRhc2F1ciA9IHdpbmRvdy5kYXRhc2F1ciB8fCB7fSkuYmFzZSA9IEh5cGVyZ3JpZC5EYXRhU291cmNlQmFzZTtcblxuLy8gTm90ZSB0aGF0IHdoaWxlIHVzZXJzIG9mIHRoZSBucG0gbW9kdWxlIGNhbiBhbHNvIGFjY2VzcyB0aGUgYWJvdmUgbmFtZXNwYWNlcyB0aHJvdWdoIHRoZSBIeXBlcmdyaWQgb2JqZWN0LCBpbiByZWFsaXR5IHRoZXkgYWxzbyBoYXZlIGFjY2VzcyB0byBhbnkgbmFtZXNwYWNlIHRocm91Z2ggYHJlcXVpcmVgLCBmb3IgZXhhbXBsZTpcbi8vIHZhciBiZWhhdmlvckpTT04gPSByZXF1aXJlKCdmaW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvSlNPTicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ2VsbENsaWNrID0gRmVhdHVyZS5leHRlbmQoJ0NlbGxDbGljaycsIHtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsQ2xpY2sucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgY29uc3VtZWQ7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXZlbnQuZ3JpZENlbGwueSA+PSBncmlkLmJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCkgJiZcbiAgICAgICAgICAgIGV2ZW50LmdyaWRDZWxsLnggPj0gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN1bWVkID0gZ3JpZC5jZWxsQ2xpY2tlZChldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbnN1bWVkICYmIHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxDbGljaztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcbnZhciBDZWxsRWRpdG9yID0gcmVxdWlyZSgnLi4vY2VsbEVkaXRvcnMvQ2VsbEVkaXRvcicpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ2VsbEVkaXRpbmcgPSBGZWF0dXJlLmV4dGVuZCgnQ2VsbEVkaXRpbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRpbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBncmlkLnByb3BlcnRpZXMuZWRpdE9uRG91YmxlQ2xpY2sgJiZcbiAgICAgICAgICAgIGV2ZW50LmlzR3JpZENlbGxcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBncmlkLm9uRWRpdG9yQWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWdyaWQucHJvcGVydGllcy5lZGl0T25Eb3VibGVDbGljayAmJlxuICAgICAgICAgICAgZXZlbnQuaXNHcmlkQ2VsbFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdyaWQub25FZGl0b3JBY3RpdmF0ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAbWVtYmVyT2YgS2V5UGFnaW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBjaGFyLCBpc1Zpc2libGVDaGFyLCBpc0RlbGV0ZUNoYXIsIGN1cnJlbnRDZWxsLCBlZGl0b3I7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZ3JpZC5wcm9wZXJ0aWVzLmVkaXRPbktleWRvd24gJiZcbiAgICAgICAgICAgICFncmlkLmNlbGxFZGl0b3IgJiZcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAoY2hhciA9IGV2ZW50LmRldGFpbC5jaGFyKSA9PT0gJ0YyJyB8fFxuICAgICAgICAgICAgICAgIChpc1Zpc2libGVDaGFyID0gY2hhci5sZW5ndGggPT09IDEgJiYgIShldmVudC5kZXRhaWwubWV0YSB8fCBldmVudC5kZXRhaWwuY3RybCkpIHx8XG4gICAgICAgICAgICAgICAgKGlzRGVsZXRlQ2hhciA9IGNoYXIgPT09ICdERUxFVEUnIHx8IGNoYXIgPT09ICdCQUNLU1BBQ0UnKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGN1cnJlbnRDZWxsID0gZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRMYXN0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENlbGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHNldWRvRXZlbnQgPSBuZXcgZ3JpZC5iZWhhdmlvci5DZWxsRXZlbnQoY3VycmVudENlbGwub3JpZ2luLngsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDZWxsLm9yaWdpbi55ICsgZ3JpZC5iZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpKTtcblxuICAgICAgICAgICAgICAgIGVkaXRvciA9IGdyaWQub25FZGl0b3JBY3RpdmF0ZShwc2V1ZG9FdmVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yIGluc3RhbmNlb2YgQ2VsbEVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWaXNpYmxlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmlucHV0LnZhbHVlID0gY2hhcjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0RlbGV0ZUNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRFZGl0b3JWYWx1ZSgnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGV0YWlsLnByaW1pdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsRWRpdGluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZlYXR1cmVcbiAqL1xudmFyIENlbGxTZWxlY3Rpb24gPSBGZWF0dXJlLmV4dGVuZCgnQ2VsbFNlbGVjdGlvbicsIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50RHJhZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHRoZSBjZWxsIGNvb3JkaW5hdGVzIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvblxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgbGFzdERyYWdDZWxsOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHRpbWUgYW4gYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JMYXN0QXV0bzogMCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiQXV0b1N0YXJ0OiAwLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBkeCA9IGV2ZW50LmdyaWRDZWxsLngsXG4gICAgICAgICAgICBkeSA9IGV2ZW50LmRhdGFDZWxsLnksXG4gICAgICAgICAgICBpc1NlbGVjdGFibGUgPSBncmlkLmJlaGF2aW9yLmdldENlbGxQcm9wZXJ0eShldmVudC5kYXRhQ2VsbC54LCBldmVudC5ncmlkQ2VsbC55LCAnY2VsbFNlbGVjdGlvbicpO1xuXG4gICAgICAgIGlmIChpc1NlbGVjdGFibGUgJiYgZXZlbnQuaXNHcmlkQ2VsbCAmJiAhZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaykge1xuICAgICAgICAgICAgdmFyIGRDZWxsID0gZ3JpZC5uZXdQb2ludChkeCwgZHkpLFxuICAgICAgICAgICAgICAgIHByaW1FdmVudCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICAgIGtleXMgPSBwcmltRXZlbnQuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kU2VsZWN0aW9uKGdyaWQsIGRDZWxsLCBrZXlzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nICYmIGdyaWQuaXNDZWxsU2VsZWN0aW9uKCkgJiYgIWV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYWcgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGdyaWQubmV3UG9pbnQoZXZlbnQuZ3JpZENlbGwueCwgZXZlbnQuZGF0YUNlbGwueSk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRHJhZ1Njcm9sbChncmlkLCB0aGlzLmN1cnJlbnREcmFnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCB0aGlzLmxhc3REcmFnQ2VsbCwgZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmtleXMpO1xuICAgICAgICB9IGVsc2UgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaGFuZGxlcjtcbiAgICAgICAgaWYgKChoYW5kbGVyID0gdGhpc1snaGFuZGxlJyArIGV2ZW50LmRldGFpbC5jaGFyXSkpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBncmlkLCBldmVudC5kZXRhaWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSBhIG1vdXNlZHJhZyBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgZ3JpZENlbGwsIGtleXMpIHtcbiAgICAgICAgdmFyIHggPSBNYXRoLm1heCgwLCBncmlkQ2VsbC54KSxcbiAgICAgICAgICAgIHkgPSBNYXRoLm1heCgwLCBncmlkQ2VsbC55KSxcbiAgICAgICAgICAgIHByZXZpb3VzRHJhZ0V4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpLFxuICAgICAgICAgICAgbW91c2VEb3duID0gZ3JpZC5nZXRNb3VzZURvd24oKSxcbiAgICAgICAgICAgIG5ld1ggPSB4IC0gbW91c2VEb3duLngsXG4gICAgICAgICAgICBuZXdZID0geSAtIG1vdXNlRG93bi55O1xuXG4gICAgICAgIGlmIChwcmV2aW91c0RyYWdFeHRlbnQueCA9PT0gbmV3WCAmJiBwcmV2aW91c0RyYWdFeHRlbnQueSA9PT0gbmV3WSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcblxuICAgICAgICBncmlkLnNlbGVjdChtb3VzZURvd24ueCwgbW91c2VEb3duLnksIG5ld1gsIG5ld1kpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgY2hlY2tzIHdoaWxlIHdlcmUgZHJhZ2dpbmcgaWYgd2UgZ28gb3V0c2lkZSB0aGUgdmlzaWJsZSBib3VuZHMsIGlmIHNvLCBraWNrIG9mZiB0aGUgZXh0ZXJuYWwgYXV0b3Njcm9sbCBjaGVjayBmdW5jdGlvbiAoYWJvdmUpXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGNoZWNrRHJhZ1Njcm9sbDogZnVuY3Rpb24oZ3JpZCwgbW91c2UpIHtcbiAgICAgICAgaWYgKCFncmlkLnByb3BlcnRpZXMuc2Nyb2xsaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCk7XG4gICAgICAgIHZhciBpbnNpZGUgPSBiLmNvbnRhaW5zKG1vdXNlKTtcbiAgICAgICAgaWYgKGluc2lkZSkge1xuICAgICAgICAgICAgaWYgKGdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRHJhZyhncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIG1ha2VzIHN1cmUgdGhhdCB3aGlsZSB3ZSBhcmUgZHJhZ2dpbmcgb3V0c2lkZSBvZiB0aGUgZ3JpZCB2aXNpYmxlIGJvdW5kcywgd2Ugc3Jjcm9sbCBhY2NvcmRpbmdseVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgc2Nyb2xsRHJhZzogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyYWdTdGFydGVkSW5IZWFkZXJBcmVhID0gZ3JpZC5pc01vdXNlRG93bkluSGVhZGVyQXJlYSgpLFxuICAgICAgICAgICAgbGFzdERyYWdDZWxsID0gdGhpcy5sYXN0RHJhZ0NlbGwsXG4gICAgICAgICAgICBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCksXG5cbiAgICAgICAgICAgIHhPZmZzZXQgPSAwLFxuICAgICAgICAgICAgeU9mZnNldCA9IDAsXG5cbiAgICAgICAgICAgIG51bUZpeGVkQ29sdW1ucyA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgbnVtRml4ZWRSb3dzID0gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCksXG5cbiAgICAgICAgICAgIGRyYWdFbmRJbkZpeGVkQXJlYVggPSBsYXN0RHJhZ0NlbGwueCA8IG51bUZpeGVkQ29sdW1ucyxcbiAgICAgICAgICAgIGRyYWdFbmRJbkZpeGVkQXJlYVkgPSBsYXN0RHJhZ0NlbGwueSA8IG51bUZpeGVkUm93cztcblxuICAgICAgICBpZiAoIWRyYWdTdGFydGVkSW5IZWFkZXJBcmVhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy54IDwgYi5vcmlnaW4ueCkge1xuICAgICAgICAgICAgICAgIHhPZmZzZXQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnkgPCBiLm9yaWdpbi55KSB7XG4gICAgICAgICAgICAgICAgeU9mZnNldCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnggPiBiLm9yaWdpbi54ICsgYi5leHRlbnQueCkge1xuICAgICAgICAgICAgeE9mZnNldCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueSA+IGIub3JpZ2luLnkgKyBiLmV4dGVudC55KSB7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmFnQ2VsbE9mZnNldFggPSB4T2Zmc2V0O1xuICAgICAgICB2YXIgZHJhZ0NlbGxPZmZzZXRZID0geU9mZnNldDtcblxuICAgICAgICBpZiAoZHJhZ0VuZEluRml4ZWRBcmVhWCkge1xuICAgICAgICAgICAgZHJhZ0NlbGxPZmZzZXRYID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHJhZ0VuZEluRml4ZWRBcmVhWSkge1xuICAgICAgICAgICAgZHJhZ0NlbGxPZmZzZXRZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdERyYWdDZWxsID0gbGFzdERyYWdDZWxsLnBsdXNYWShkcmFnQ2VsbE9mZnNldFgsIGRyYWdDZWxsT2Zmc2V0WSk7XG4gICAgICAgIGdyaWQuc2Nyb2xsQnkoeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCBsYXN0RHJhZ0NlbGwsIFtdKTsgLy8gdXBkYXRlIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zY3JvbGxEcmFnLmJpbmQodGhpcywgZ3JpZCksIDI1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgZXh0ZW5kIGEgc2VsZWN0aW9uIG9yIGNyZWF0ZSBvbmUgaWYgdGhlcmUgaXNudCB5ZXRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmlkQ2VsbCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBleHRlbmRTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIGdyaWRDZWxsLCBrZXlzKSB7XG4gICAgICAgIHZhciBoYXNDVFJMID0ga2V5cy5pbmRleE9mKCdDVFJMJykgPj0gMCxcbiAgICAgICAgICAgIGhhc1NISUZUID0ga2V5cy5pbmRleE9mKCdTSElGVCcpID49IDAsXG4gICAgICAgICAgICBtb3VzZVBvaW50ID0gZ3JpZC5nZXRNb3VzZURvd24oKSxcbiAgICAgICAgICAgIHggPSBncmlkQ2VsbC54LCAvLyAtIG51bUZpeGVkQ29sdW1ucyArIHNjcm9sbExlZnQ7XG4gICAgICAgICAgICB5ID0gZ3JpZENlbGwueTsgLy8gLSBudW1GaXhlZFJvd3MgKyBzY3JvbGxUb3A7XG5cbiAgICAgICAgLy93ZXJlIG91dHNpZGUgb2YgdGhlIGdyaWQgZG8gbm90aGluZ1xuICAgICAgICBpZiAoeCA8IDAgfHwgeSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vd2UgaGF2ZSByZXBlYXRlZCBhIGNsaWNrIGluIHRoZSBzYW1lIHNwb3QgZGVzbGVjdCB0aGUgdmFsdWUgZnJvbSBsYXN0IHRpbWVcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaGFzQ1RSTCAmJlxuICAgICAgICAgICAgeCA9PT0gbW91c2VQb2ludC54ICYmXG4gICAgICAgICAgICB5ID09PSBtb3VzZVBvaW50LnlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5wb3BNb3VzZURvd24oKTtcbiAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNDVFJMICYmICFoYXNTSElGVCkge1xuICAgICAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNTSElGVCkge1xuICAgICAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0KG1vdXNlUG9pbnQueCwgbW91c2VQb2ludC55LCB4IC0gbW91c2VQb2ludC54LCB5IC0gbW91c2VQb2ludC55KTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KHggLSBtb3VzZVBvaW50LngsIHkgLSBtb3VzZVBvaW50LnkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0KHgsIHksIDAsIDApO1xuICAgICAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCh4LCB5KSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgMCwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDAsIC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlRTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAtMSwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDEsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlRE9XTjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgLy9rZWVwIHRoZSBicm93c2VyIHZpZXdwb3J0IGZyb20gYXV0byBzY3JvbGxpbmcgb24ga2V5IGV2ZW50XG4gICAgICAgIGV2ZW50LnByaW1pdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uKCk7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAwLCBjb3VudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgLy9rZWVwIHRoZSBicm93c2VyIHZpZXdwb3J0IGZyb20gYXV0byBzY3JvbGxpbmcgb24ga2V5IGV2ZW50XG4gICAgICAgIGV2ZW50LnByaW1pdGl2ZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uKCk7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAwLCAtY291bnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgLTEsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlUklHSFQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIDEsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJZiB3ZSBhcmUgaG9sZGluZyBkb3duIHRoZSBzYW1lIG5hdmlnYXRpb24ga2V5LCBhY2NlbGVyYXRlIHRoZSBpbmNyZW1lbnQgd2Ugc2Nyb2xsXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDE7XG4gICAgICAgIHZhciBlbGFwc2VkID0gdGhpcy5nZXRBdXRvU2Nyb2xsRHVyYXRpb24oKSAvIDIwMDA7XG4gICAgICAgIGNvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkKSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBzdGFydCB0aW1lIHRvIHJpZ2h0IG5vdyB3aGVuIHdlIGluaXRpYXRlIGFuIGF1dG8gc2Nyb2xsXG4gICAgICovXG4gICAgc2V0QXV0b1Njcm9sbFN0YXJ0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JBdXRvU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGF1dG9zY3JvbGwgc3RhcnQgdGltZSBpZiB3ZSBoYXZlbid0IGF1dG9zY3JvbGxlZCB3aXRoaW4gdGhlIGxhc3QgNTAwbXMgb3RoZXJ3aXNlIHVwZGF0ZSB0aGUgY3VycmVudCBhdXRvc2Nyb2xsIHRpbWVcbiAgICAgKi9cbiAgICBwaW5nQXV0b1Njcm9sbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF1dG9TY3JvbGxTdGFydFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNiTGFzdEF1dG8gPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgaG93IGxvbmcgd2UgaGF2ZSBiZWVuIGF1dG8gc2Nyb2xsaW5nXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbER1cmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zYkF1dG9TdGFydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXVnbWVudCB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIGV4dGVudCBieSAob2Zmc2V0WCxvZmZzZXRZKSBhbmQgc2Nyb2xsIGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2hpZnRTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFgsIG9mZnNldFkpIHtcblxuICAgICAgICB2YXIgbWF4Q29sdW1ucyA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDEsXG4gICAgICAgICAgICBtYXhSb3dzID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gMSxcblxuICAgICAgICAgICAgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5yZW5kZXJlci52aXNpYmxlQ29sdW1ucy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgbWF4Vmlld2FibGVSb3dzID0gZ3JpZC5yZW5kZXJlci52aXNpYmxlUm93cy5sZW5ndGggLSAxLFxuXG4gICAgICAgICAgICBvcmlnaW4gPSBncmlkLmdldE1vdXNlRG93bigpLFxuICAgICAgICAgICAgZXh0ZW50ID0gZ3JpZC5nZXREcmFnRXh0ZW50KCksXG5cbiAgICAgICAgICAgIG5ld1ggPSBleHRlbnQueCArIG9mZnNldFgsXG4gICAgICAgICAgICBuZXdZID0gZXh0ZW50LnkgKyBvZmZzZXRZO1xuXG4gICAgICAgIGlmICghZ3JpZC5wcm9wZXJ0aWVzLnNjcm9sbGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICAgICAgbWF4Um93cyA9IE1hdGgubWluKG1heFJvd3MsIG1heFZpZXdhYmxlUm93cyk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucyAtIG9yaWdpbi54LCBNYXRoLm1heCgtb3JpZ2luLngsIG5ld1gpKTtcbiAgICAgICAgbmV3WSA9IE1hdGgubWluKG1heFJvd3MgLSBvcmlnaW4ueSwgTWF0aC5tYXgoLW9yaWdpbi55LCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgZ3JpZC5zZWxlY3Qob3JpZ2luLngsIG9yaWdpbi55LCBuZXdYLCBuZXdZKTtcblxuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCBuZXdZKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxDb2xJc1Zpc2libGUobmV3WCArIG9yaWdpbi54LCBvZmZzZXRYKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsUm93SXNWaXNpYmxlKG5ld1kgKyBvcmlnaW4ueSwgb2Zmc2V0WSkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcGxhY2UgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiB3aXRoIGEgc2luZ2xlIGNlbGwgc2VsZWN0aW9uIHRoYXQgaXMgbW92ZWQgKG9mZnNldFgsb2Zmc2V0WSkgZnJvbSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIGV4dGVudC5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIHZhciBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSksXG5cbiAgICAgICAgICAgIG5ld1ggPSBtb3VzZUNvcm5lci54ICsgb2Zmc2V0WCxcbiAgICAgICAgICAgIG5ld1kgPSBtb3VzZUNvcm5lci55ICsgb2Zmc2V0WSxcblxuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDEsXG4gICAgICAgICAgICBtYXhSb3dzID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gMSxcblxuICAgICAgICAgICAgbWF4Vmlld2FibGVDb2x1bW5zID0gZ3JpZC5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCkgLSAxLFxuICAgICAgICAgICAgbWF4Vmlld2FibGVSb3dzID0gZ3JpZC5nZXRWaXNpYmxlUm93c0NvdW50KCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5wcm9wZXJ0aWVzLnNjcm9sbGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICAgICAgbWF4Um93cyA9IE1hdGgubWluKG1heFJvd3MsIG1heFZpZXdhYmxlUm93cyk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucywgTWF0aC5tYXgoMCwgbmV3WCkpO1xuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cywgTWF0aC5tYXgoMCwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0KG5ld1gsIG5ld1ksIDAsIDApO1xuICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KG5ld1gsIG5ld1kpKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIGdyaWQuc2VsZWN0Q2VsbEFuZFNjcm9sbFRvTWFrZVZpc2libGUobmV3WCwgbmV3WSk7XG5cbiAgICAgICAgLy8gaWYgKGdyaWQuaW5zdXJlTW9kZWxDb2xJc1Zpc2libGUobmV3WCwgb2Zmc2V0WCkpIHtcbiAgICAgICAgLy8gICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAoZ3JpZC5pbnN1cmVNb2RlbFJvd0lzVmlzaWJsZShuZXdZLCBvZmZzZXRZKSkge1xuICAgICAgICAvLyAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxTZWxlY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBGZWF0dXJlXG4gKi9cbnZhciBDb2x1bW5BdXRvc2l6aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtbkF1dG9zaXppbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQG1lbWJlck9mIENvbHVtbkF1dG9zaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgLy92YXIgaGVhZGVyQ29sQ291bnQgPSBncmlkLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICBpZiAoZ3JpZENlbGwueSA8PSBoZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgZ3JpZC5hdXRvc2l6ZUNvbHVtbihncmlkQ2VsbC54KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbkF1dG9zaXppbmc7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qIGdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZlYXR1cmUgaXMgcmVzcG9uc2libGUgZm9yIGNvbHVtbiBkcmFnIGFuZCBkcm9wIHJlb3JkZXJpbmcuXG4vLyBUaGlzIG9iamVjdCBpcyBhIG1lc3MgYW5kIGRlc3BlcmF0ZWx5IG5lZWRzIGEgY29tcGxldGUgcmV3cml0ZS4uLi4uXG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbnZhciBjYW5EcmFnQ3Vyc29yTmFtZSA9ICctd2Via2l0LWdyYWInLFxuICAgIGRyYWdnaW5nQ3Vyc29yTmFtZSA9ICctd2Via2l0LWdyYWJiaW5nJztcblxudmFyIGNvbHVtbkFuaW1hdGlvblRpbWUgPSAxNTA7XG52YXIgZHJhZ2dlcjtcbnZhciBkcmFnZ2VyQ1RYO1xudmFyIGZsb2F0Q29sdW1uO1xudmFyIGZsb2F0Q29sdW1uQ1RYO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ29sdW1uTW92aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtbk1vdmluZycsIHtcblxuICAgIC8qKlxuICAgICAqIHF1ZXVlIHVwIHRoZSBhbmltYXRpb25zIHRoYXQgbmVlZCB0byBwbGF5IHNvIHRoZXkgYXJlIGRvbmUgc3luY2hyb25vdXNseVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmbG9hdGVyQW5pbWF0aW9uUXVldWU6IFtdLFxuXG4gICAgLyoqXG4gICAgICogYW0gSSBjdXJyZW50bHkgYXV0byBzY3JvbGxpbmcgcmlnaHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgY3VycmVudGx5IGF1dG8gc2Nyb2xsaW5nIGxlZnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogaXMgdGhlIGRyYWcgbWVjaGFuaXNtIGN1cnJlbnRseSBlbmFibGVkIChcImFybWVkXCIpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0FybWVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgZHJhZ2dpbmcgcmlnaHQgbm93XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNvbHVtbiBpbmRleCBvZiB0aGUgY3VycmVudGx5IGRyYWdnZWQgY29sdW1uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnQ29sOiAtMSxcblxuICAgIC8qKlxuICAgICAqIGFuIG9mZnNldCB0byBwb3NpdGlvbiB0aGUgZHJhZ2dlZCBpdGVtIGZyb20gdGhlIGN1cnNvclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ09mZnNldDogMCxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdpdmUgbWUgYW4gb3Bwb3J0dW5pdHkgdG8gaW5pdGlhbGl6ZSBzdHVmZiBvbiB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZU9uOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuaXNGbG9hdGluZ05vdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0KGdyaWQpO1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGluaXRpYWxpemUgYW5pbWF0aW9uIHN1cHBvcnQgb24gdGhlIGdyaWRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICghZHJhZ2dlcikge1xuICAgICAgICAgICAgZHJhZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgZHJhZ2dlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzBweCcpO1xuICAgICAgICAgICAgZHJhZ2dlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwcHgnKTtcbiAgICAgICAgICAgIGRyYWdnZXIuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRyYWdnZXIpO1xuICAgICAgICAgICAgZHJhZ2dlckNUWCA9IGRyYWdnZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZsb2F0Q29sdW1uKSB7XG4gICAgICAgICAgICBmbG9hdENvbHVtbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgZmxvYXRDb2x1bW4uc2V0QXR0cmlidXRlKCd3aWR0aCcsICcwcHgnKTtcbiAgICAgICAgICAgIGZsb2F0Q29sdW1uLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzBweCcpO1xuICAgICAgICAgICAgZmxvYXRDb2x1bW4uc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZsb2F0Q29sdW1uKTtcbiAgICAgICAgICAgIGZsb2F0Q29sdW1uQ1RYID0gZmxvYXRDb2x1bW4uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciB4O1xuICAgICAgICAvL3ZhciB5O1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5kcmFnc3RhcnQueCAtIGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS54KTtcblxuICAgICAgICBpZiAoZGlzdGFuY2UgPCAxMCB8fCBldmVudC5pc0NvbHVtbkZpeGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuaXNIZWFkZXJDZWxsICYmIHRoaXMuZHJhZ0FybWVkICYmICF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0NvbCA9IGdyaWRDZWxsLng7XG4gICAgICAgICAgICB0aGlzLmRyYWdPZmZzZXQgPSBldmVudC5tb3VzZVBvaW50Lng7XG4gICAgICAgICAgICB0aGlzLmRldGFjaENoYWluKCk7XG4gICAgICAgICAgICB4ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnggLSB0aGlzLmRyYWdPZmZzZXQ7XG4gICAgICAgICAgICAvL3kgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRHJhZ0NvbHVtbihncmlkLCB4LCB0aGlzLmRyYWdDb2wpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgeCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS54IC0gdGhpcy5kcmFnT2Zmc2V0O1xuICAgICAgICAgICAgLy95ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnk7XG4gICAgICAgICAgICB0aGlzLmRyYWdDb2x1bW4oZ3JpZCwgeCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZ3JpZC5iZWhhdmlvci5pc0NvbHVtblJlb3JkZXJhYmxlKCkgJiZcbiAgICAgICAgICAgICFldmVudC5pc0NvbHVtbkZpeGVkXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmlzSGVhZGVyQ2VsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0FybWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IGRyYWdnaW5nQ3Vyc29yTmFtZTtcbiAgICAgICAgICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICAvL3ZhciBjb2wgPSBldmVudC5ncmlkQ2VsbC54O1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgLy9kZWxheSBoZXJlIHRvIGdpdmUgb3RoZXIgZXZlbnRzIGEgY2hhbmNlIHRvIGJlIGRyb3BwZWRcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZW5kRHJhZ0NvbHVtbihncmlkKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hDaGFpbigpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdDb2wgPSAtMTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyaWQuYmVoYXZpb3IuaXNDb2x1bW5SZW9yZGVyYWJsZSgpICYmXG4gICAgICAgICAgICAhZXZlbnQuaXNDb2x1bW5GaXhlZCAmJlxuICAgICAgICAgICAgIXRoaXMuZHJhZ2dpbmcgJiZcbiAgICAgICAgICAgIGV2ZW50LmlzSGVhZGVyQ2VsbCAmJlxuICAgICAgICAgICAgZXZlbnQubW91c2VQb2ludC55IDwgZ3JpZC5wcm9wZXJ0aWVzLmNvbHVtbkdyYWJNYXJnaW5cbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IGNhbkRyYWdDdXJzb3JOYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuaXNIZWFkZXJDZWxsICYmIHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gZHJhZ2dpbmdDdXJzb3JOYW1lOyAvL21vdmUnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgaXMgdGhlIG1haW4gZXZlbnQgaGFuZGxlciB0aGF0IG1hbmFnZXMgdGhlIGRyYWdnaW5nIG9mIHRoZSBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZHJhZ2dlZFRvVGhlUmlnaHQgLSBhcmUgd2UgbW92aW5nIHRvIHRoZSByaWdodFxuICAgICAqL1xuICAgIGZsb2F0Q29sdW1uVG86IGZ1bmN0aW9uKGdyaWQsIGRyYWdnZWRUb1RoZVJpZ2h0KSB7XG4gICAgICAgIHRoaXMuZmxvYXRpbmdOb3cgPSB0cnVlO1xuXG4gICAgICAgIHZhciB2aXNpYmxlQ29sdW1ucyA9IGdyaWQucmVuZGVyZXIudmlzaWJsZUNvbHVtbnM7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIGZsb2F0ZXJJbmRleCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlci5jb2x1bW5JbmRleDtcbiAgICAgICAgdmFyIGRyYWdnZXJJbmRleCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleDtcbiAgICAgICAgdmFyIGhkcGlyYXRpbyA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5oZHBpcmF0aW87XG5cbiAgICAgICAgdmFyIGRyYWdnZXJTdGFydFg7XG4gICAgICAgIHZhciBmbG9hdGVyU3RhcnRYO1xuICAgICAgICB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgZHJhZ2dlcldpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aChkcmFnZ2VySW5kZXgpO1xuICAgICAgICB2YXIgZmxvYXRlcldpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aChmbG9hdGVySW5kZXgpO1xuXG4gICAgICAgIHZhciBtYXggPSBncmlkLmdldFZpc2libGVDb2x1bW5zQ291bnQoKTtcblxuICAgICAgICB2YXIgZG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBmb2Zmc2V0ID0gMDtcblxuICAgICAgICBpZiAoZHJhZ2dlckluZGV4ID49IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIGRvZmZzZXQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbG9hdGVySW5kZXggPj0gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgZm9mZnNldCA9IHNjcm9sbExlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhZ2dlZFRvVGhlUmlnaHQpIHtcbiAgICAgICAgICAgIGRyYWdnZXJTdGFydFggPSB2aXNpYmxlQ29sdW1uc1tNYXRoLm1pbihtYXgsIGRyYWdnZXJJbmRleCAtIGRvZmZzZXQpXS5sZWZ0O1xuICAgICAgICAgICAgZmxvYXRlclN0YXJ0WCA9IHZpc2libGVDb2x1bW5zW01hdGgubWluKG1heCwgZmxvYXRlckluZGV4IC0gZm9mZnNldCldLmxlZnQ7XG5cbiAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5zdGFydFggPSAoZHJhZ2dlclN0YXJ0WCArIGZsb2F0ZXJXaWR0aCkgKiBoZHBpcmF0aW87XG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIuc3RhcnRYID0gZHJhZ2dlclN0YXJ0WCAqIGhkcGlyYXRpbztcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxvYXRlclN0YXJ0WCA9IHZpc2libGVDb2x1bW5zW01hdGgubWluKG1heCwgZmxvYXRlckluZGV4IC0gZm9mZnNldCldLmxlZnQ7XG4gICAgICAgICAgICBkcmFnZ2VyU3RhcnRYID0gZmxvYXRlclN0YXJ0WCArIGRyYWdnZXJXaWR0aDtcblxuICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLnN0YXJ0WCA9IGZsb2F0ZXJTdGFydFggKiBoZHBpcmF0aW87XG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIuc3RhcnRYID0gZHJhZ2dlclN0YXJ0WCAqIGhkcGlyYXRpbztcbiAgICAgICAgfVxuICAgICAgICBncmlkLnN3YXBDb2x1bW5zKGRyYWdnZXJJbmRleCwgZmxvYXRlckluZGV4KTtcbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4ID0gZmxvYXRlckluZGV4O1xuICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIuY29sdW1uSW5kZXggPSBkcmFnZ2VySW5kZXg7XG5cblxuICAgICAgICB0aGlzLmZsb2F0ZXJBbmltYXRpb25RdWV1ZS51bnNoaWZ0KHRoaXMuZG9Db2x1bW5Nb3ZlQW5pbWF0aW9uKGdyaWQsIGZsb2F0ZXJTdGFydFgsIGRyYWdnZXJTdGFydFgpKTtcblxuICAgICAgICB0aGlzLmRvRmxvYXRlckFuaW1hdGlvbihncmlkKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBtYW5pZmVzdCB0aGUgY29sdW1uIGRyYWcgYW5kIGRyb3AgYW5pbWF0aW9uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmxvYXRlclN0YXJ0WCAtIHRoZSB4IHN0YXJ0IGNvb3JkaW5hdGUgb2YgdGhlIGNvbHVtbiB1bmRlcm5lYXRoIHRoYXQgZmxvYXRzIGJlaGluZCB0aGUgZHJhZ2dlZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHJhZ2dlclN0YXJ0WCAtIHRoZSB4IHN0YXJ0IGNvb3JkaW5hdGUgb2YgdGhlIGRyYWdnZWQgY29sdW1uXG4gICAgICovXG4gICAgZG9Db2x1bW5Nb3ZlQW5pbWF0aW9uOiBmdW5jdGlvbihncmlkLCBmbG9hdGVyU3RhcnRYLCBkcmFnZ2VyU3RhcnRYKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGQgPSBmbG9hdENvbHVtbjtcbiAgICAgICAgICAgIGQuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgZmxvYXRlclN0YXJ0WCArICdweCwgJyArIDAgKyAncHgpJyk7XG5cbiAgICAgICAgICAgIC8vZC5zdHlsZS53ZWJraXQtd2Via2l0LVRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIGZsb2F0ZXJTdGFydFggKyAncHgsICcgKyAwICsgJ3B4KSc7XG4gICAgICAgICAgICAvL2Quc3R5bGUud2Via2l0LXdlYmtpdC1UcmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyBmbG9hdGVyU3RhcnRYICsgJ3B4LCAnICsgMCArICdweCknO1xuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNpdGlvbicsIChzZWxmLmlzV2Via2l0ID8gJy13ZWJraXQtJyA6ICcnKSArICd0cmFuc2Zvcm0gJyArIGNvbHVtbkFuaW1hdGlvblRpbWUgKyAnbXMgZWFzZScpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGRyYWdnZXJTdGFydFggKyAncHgsICcgKyAtMiArICdweCknKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgICAgICAvL25lZWQgdG8gY2hhbmdlIHRoaXMgdG8ga2V5IGZyYW1lc1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmRvRmxvYXRlckFuaW1hdGlvbihncmlkKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pc0Zsb2F0aW5nTm93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBjb2x1bW5BbmltYXRpb25UaW1lICsgNTApO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBtYW5pZmVzdCB0aGUgZmxvYXRlciBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGRvRmxvYXRlckFuaW1hdGlvbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAodGhpcy5mbG9hdGVyQW5pbWF0aW9uUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZsb2F0aW5nTm93ID0gZmFsc2U7XG4gICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5mbG9hdGVyQW5pbWF0aW9uUXVldWUucG9wKCk7XG4gICAgICAgIGFuaW1hdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjcmVhdGUgdGhlIGZsb2F0IGNvbHVtbiBhdCBjb2x1bW5JbmRleCB1bmRlcm5lYXRoIHRoZSBkcmFnZ2VkIGNvbHVtblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCB3aWxsIGJlIGZsb2F0aW5nXG4gICAgICovXG4gICAgY3JlYXRlRmxvYXRDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGNvbHVtbkluZGV4KSB7XG5cbiAgICAgICAgdmFyIGZpeGVkQ29sdW1uQ291bnQgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIGlmIChjb2x1bW5JbmRleCA8IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbHVtbldpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCk7XG4gICAgICAgIHZhciBjb2xIZWlnaHQgPSBncmlkLmRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBkID0gZmxvYXRDb2x1bW47XG4gICAgICAgIHZhciBzdHlsZSA9IGQuc3R5bGU7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGdyaWQuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHN0eWxlLnRvcCA9IChsb2NhdGlvbi50b3AgLSAyKSArICdweCc7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBsb2NhdGlvbi5sZWZ0ICsgJ3B4JztcblxuICAgICAgICB2YXIgaGRwaVJhdGlvID0gZ3JpZC5nZXRIaURQSShmbG9hdENvbHVtbkNUWCk7XG5cbiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgTWF0aC5yb3VuZChjb2x1bW5XaWR0aCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIE1hdGgucm91bmQoY29sSGVpZ2h0ICogaGRwaVJhdGlvKSArICdweCcpO1xuICAgICAgICBzdHlsZS5ib3hTaGFkb3cgPSAnMCAxMHB4IDIwcHggcmdiYSgwLDAsMCwwLjE5KSwgMCA2cHggNnB4IHJnYmEoMCwwLDAsMC4yMyknO1xuICAgICAgICBzdHlsZS53aWR0aCA9IGNvbHVtbldpZHRoICsgJ3B4JzsgLy9NYXRoLnJvdW5kKGNvbHVtbldpZHRoIC8gaGRwaVJhdGlvKSArICdweCc7XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGNvbEhlaWdodCArICdweCc7IC8vTWF0aC5yb3VuZChjb2xIZWlnaHQgLyBoZHBpUmF0aW8pICsgJ3B4JztcbiAgICAgICAgc3R5bGUuYm9yZGVyVG9wID0gJzFweCBzb2xpZCAnICsgZ3JpZC5wcm9wZXJ0aWVzLmxpbmVDb2xvcjtcbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZ3JpZC5wcm9wZXJ0aWVzLmJhY2tncm91bmRDb2xvcjtcblxuICAgICAgICB2YXIgc3RhcnRYID0gZ3JpZC5yZW5kZXJlci52aXNpYmxlQ29sdW1uc1tjb2x1bW5JbmRleCAtIHNjcm9sbExlZnRdLmxlZnQgKiBoZHBpUmF0aW87XG5cbiAgICAgICAgZmxvYXRDb2x1bW5DVFguc2NhbGUoaGRwaVJhdGlvLCBoZHBpUmF0aW8pO1xuXG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlciA9IHtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgIGN0eDogZmxvYXRDb2x1bW5DVFgsXG4gICAgICAgICAgICBzdGFydFg6IHN0YXJ0WCxcbiAgICAgICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY29sSGVpZ2h0LFxuICAgICAgICAgICAgaGRwaXJhdGlvOiBoZHBpUmF0aW9cbiAgICAgICAgfTtcblxuICAgICAgICBzdHlsZS56SW5kZXggPSAnNCc7XG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHN0YXJ0WCArICdweCwgJyArIC0yICsgJ3B4KScpO1xuICAgICAgICBzdHlsZS5jdXJzb3IgPSBkcmFnZ2luZ0N1cnNvck5hbWU7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IGZ1bmN0aW9uIGZvciBzZXR0aW5nIGNyb3NzIGJyb3dzZXIgY3NzIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZGVzY3JpcHRvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBhc3NpZ25cbiAgICAgKi9cbiAgICBzZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eTogZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIHZhciB1UHJvcGVydHkgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ3dlYmtpdCcgKyB1UHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsICdNb3onICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnbXMnICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnTycgKyB1UHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHV0aWxpdHkgZnVuY3Rpb24gZm9yIHNldHRpbmcgcHJvcGVydGllcyBvbiBIVE1MRWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gZGVzY3JpcHRvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBhc3NpZ25cbiAgICAgKi9cbiAgICBzZXRQcm9wOiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5IGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgY3JlYXRlIHRoZSBkcmFnZ2VkIGNvbHVtbiBhdCBjb2x1bW5JbmRleCBhYm92ZSB0aGUgZmxvYXRlZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHN0YXJ0IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gdGhhdCB3aWxsIGJlIGZsb2F0aW5nXG4gICAgICovXG4gICAgY3JlYXRlRHJhZ0NvbHVtbjogZnVuY3Rpb24oZ3JpZCwgeCwgY29sdW1uSW5kZXgpIHtcblxuICAgICAgICB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgaWYgKGNvbHVtbkluZGV4IDwgZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGRwaVJhdGlvID0gZ3JpZC5nZXRIaURQSShkcmFnZ2VyQ1RYKTtcbiAgICAgICAgdmFyIGNvbHVtbldpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCk7XG4gICAgICAgIHZhciBjb2xIZWlnaHQgPSBncmlkLmRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBkID0gZHJhZ2dlcjtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gZ3JpZC5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBzdHlsZSA9IGQuc3R5bGU7XG5cbiAgICAgICAgc3R5bGUudG9wID0gbG9jYXRpb24udG9wICsgJ3B4JztcbiAgICAgICAgc3R5bGUubGVmdCA9IGxvY2F0aW9uLmxlZnQgKyAncHgnO1xuICAgICAgICBzdHlsZS5vcGFjaXR5ID0gMC44NTtcbiAgICAgICAgc3R5bGUuYm94U2hhZG93ID0gJzAgMTlweCAzOHB4IHJnYmEoMCwwLDAsMC4zMCksIDAgMTVweCAxMnB4IHJnYmEoMCwwLDAsMC4yMiknO1xuICAgICAgICAvL3N0eWxlLnpJbmRleCA9IDEwMDtcbiAgICAgICAgc3R5bGUuYm9yZGVyVG9wID0gJzFweCBzb2xpZCAnICsgZ3JpZC5wcm9wZXJ0aWVzLmxpbmVDb2xvcjtcbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZ3JpZC5wcm9wZXJ0aWVzLmJhY2tncm91bmRDb2xvcjtcblxuICAgICAgICBkLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBNYXRoLnJvdW5kKGNvbHVtbldpZHRoICogaGRwaVJhdGlvKSArICdweCcpO1xuICAgICAgICBkLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgTWF0aC5yb3VuZChjb2xIZWlnaHQgKiBoZHBpUmF0aW8pICsgJ3B4Jyk7XG5cbiAgICAgICAgc3R5bGUud2lkdGggPSBjb2x1bW5XaWR0aCArICdweCc7IC8vTWF0aC5yb3VuZChjb2x1bW5XaWR0aCAvIGhkcGlSYXRpbykgKyAncHgnO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSBjb2xIZWlnaHQgKyAncHgnOyAvL01hdGgucm91bmQoY29sSGVpZ2h0IC8gaGRwaVJhdGlvKSArICdweCc7XG5cbiAgICAgICAgdmFyIHN0YXJ0WCA9IGdyaWQucmVuZGVyZXIudmlzaWJsZUNvbHVtbnNbY29sdW1uSW5kZXggLSBzY3JvbGxMZWZ0XS5sZWZ0ICogaGRwaVJhdGlvO1xuXG4gICAgICAgIGRyYWdnZXJDVFguc2NhbGUoaGRwaVJhdGlvLCBoZHBpUmF0aW8pO1xuXG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlciA9IHtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgIHN0YXJ0SW5kZXg6IGNvbHVtbkluZGV4LFxuICAgICAgICAgICAgY3R4OiBkcmFnZ2VyQ1RYLFxuICAgICAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbEhlaWdodCxcbiAgICAgICAgICAgIGhkcGlyYXRpbzogaGRwaVJhdGlvXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeCArICdweCwgLTVweCknKTtcbiAgICAgICAgc3R5bGUuekluZGV4ID0gJzUnO1xuICAgICAgICBzdHlsZS5jdXJzb3IgPSBkcmFnZ2luZ0N1cnNvck5hbWU7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBtYWluIGRyYWdnaW5nIGxvZ2ljXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBzdGFydCBwb3NpdGlvblxuICAgICAqL1xuICAgIGRyYWdDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIHgpIHtcblxuICAgICAgICAvL1RPRE86IHRoaXMgZnVuY3Rpb24gaXMgb3Zlcmx5IGNvbXBsZXgsIHJlZmFjdG9yIHRoaXMgaW4gdG8gc29tZXRoaW5nIG1vcmUgcmVhc29uYWJsZVxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGF1dG9TY3JvbGxpbmdOb3cgPSB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nUmlnaHQgfHwgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQ7XG5cbiAgICAgICAgdmFyIGhkcGlSYXRpbyA9IGdyaWQuZ2V0SGlEUEkoZHJhZ2dlckNUWCk7XG5cbiAgICAgICAgdmFyIGRyYWdDb2x1bW5JbmRleCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleDtcblxuICAgICAgICB2YXIgbWluWCA9IDA7XG4gICAgICAgIHZhciBtYXhYID0gZ3JpZC5yZW5kZXJlci5nZXRGaW5hbFZpc2libGVDb2x1bW5Cb3VuZGFyeSgpO1xuICAgICAgICB4ID0gTWF0aC5taW4oeCwgbWF4WCArIDE1KTtcbiAgICAgICAgeCA9IE1hdGgubWF4KG1pblggLSAxNSwgeCk7XG5cbiAgICAgICAgLy9hbSBJIGF0IG15IGxvd2VyIGJvdW5kXG4gICAgICAgIHZhciBhdE1pbiA9IHggPCBtaW5YICYmIGRyYWdDb2x1bW5JbmRleCAhPT0gMDtcblxuICAgICAgICAvL2FtIEkgYXQgbXkgdXBwZXIgYm91bmRcbiAgICAgICAgdmFyIGF0TWF4ID0geCA+IG1heFg7XG5cbiAgICAgICAgdmFyIGQgPSBkcmFnZ2VyO1xuXG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zaXRpb24nLCAoc2VsZi5pc1dlYmtpdCA/ICctd2Via2l0LScgOiAnJykgKyAndHJhbnNmb3JtICcgKyAwICsgJ21zIGVhc2UsIGJveC1zaGFkb3cgJyArIGNvbHVtbkFuaW1hdGlvblRpbWUgKyAnbXMgZWFzZScpO1xuXG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHggKyAncHgsICcgKyAtMTAgKyAncHgpJyk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGQuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgb3ZlckNvbCA9IGdyaWQucmVuZGVyZXIuZ2V0Q29sdW1uRnJvbVBpeGVsWCh4ICsgKGQud2lkdGggLyAyIC8gaGRwaVJhdGlvKSk7XG5cbiAgICAgICAgaWYgKGF0TWluKSB7XG4gICAgICAgICAgICBvdmVyQ29sID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdE1heCkge1xuICAgICAgICAgICAgb3ZlckNvbCA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG9BRmxvYXQgPSBkcmFnQ29sdW1uSW5kZXggPiBvdmVyQ29sO1xuICAgICAgICBkb0FGbG9hdCA9IGRvQUZsb2F0IHx8IChvdmVyQ29sIC0gZHJhZ0NvbHVtbkluZGV4ID49IDEpO1xuXG4gICAgICAgIGlmIChkb0FGbG9hdCAmJiAhYXRNYXggJiYgIWF1dG9TY3JvbGxpbmdOb3cpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2VkVG9UaGVSaWdodCA9IGRyYWdDb2x1bW5JbmRleCA8IG92ZXJDb2w7XG4gICAgICAgICAgICAvLyBpZiAoZHJhZ2dlZFRvVGhlUmlnaHQpIHtcbiAgICAgICAgICAgIC8vICAgICBvdmVyQ29sIC09IDE7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Zsb2F0aW5nTm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmlzRmxvYXRpbmdOb3cgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGbG9hdENvbHVtbihncmlkLCBvdmVyQ29sKTtcbiAgICAgICAgICAgIHRoaXMuZmxvYXRDb2x1bW5UbyhncmlkLCBkcmFnZ2VkVG9UaGVSaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICh4IDwgbWluWCAtIDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0F1dG9TY3JvbGxUb0xlZnQoZ3JpZCwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA+IG1pblggLSAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2xldHMgY2hlY2sgZm9yIGF1dG9zY3JvbGwgdG8gcmlnaHQgaWYgd2VyZSB1cCBhZ2FpbnN0IGl0XG4gICAgICAgICAgICBpZiAoYXRNYXggfHwgeCA+IG1heFggKyAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tBdXRvU2Nyb2xsVG9SaWdodChncmlkLCB4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA8IG1heFggKyAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGF1dG9zY3JvbGwgdG8gdGhlIHJpZ2h0IGlmIG5lY2Vzc2FyeVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgc3RhcnQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBjaGVja0F1dG9TY3JvbGxUb1JpZ2h0OiBmdW5jdGlvbihncmlkLCB4KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nUmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nUmlnaHQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jaGVja0F1dG9TY3JvbGxUb1JpZ2h0KGdyaWQsIHgpO1xuICAgIH0sXG5cbiAgICBfY2hlY2tBdXRvU2Nyb2xsVG9SaWdodDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAoIXRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgaWYgKCFncmlkLmRyYWdnaW5nIHx8IHNjcm9sbExlZnQgPiAoZ3JpZC5zYkhTY3JvbGxlci5yYW5nZS5tYXggLSAyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcmFnZ2VkSW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIGdyaWQuc2Nyb2xsQnkoMSwgMCk7XG4gICAgICAgIHZhciBuZXdJbmRleCA9IGRyYWdnZWRJbmRleCArIDE7XG5cbiAgICAgICAgZ3JpZC5zd2FwQ29sdW1ucyhuZXdJbmRleCwgZHJhZ2dlZEluZGV4KTtcbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4ID0gbmV3SW5kZXg7XG5cbiAgICAgICAgc2V0VGltZW91dCh0aGlzLl9jaGVja0F1dG9TY3JvbGxUb1JpZ2h0LmJpbmQodGhpcywgZ3JpZCwgeCksIDI1MCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGF1dG9zY3JvbGwgdG8gdGhlIGxlZnQgaWYgbmVjZXNzYXJ5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBzdGFydCBwb3NpdGlvblxuICAgICAqL1xuICAgIGNoZWNrQXV0b1Njcm9sbFRvTGVmdDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NoZWNrQXV0b1Njcm9sbFRvTGVmdChncmlkLCB4KTtcbiAgICB9LFxuXG4gICAgX2NoZWNrQXV0b1Njcm9sbFRvTGVmdDogZnVuY3Rpb24oZ3JpZCwgeCkge1xuICAgICAgICBpZiAoIXRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIGlmICghZ3JpZC5kcmFnZ2luZyB8fCBzY3JvbGxMZWZ0IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcmFnZ2VkSW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIGdyaWQuc3dhcENvbHVtbnMoZHJhZ2dlZEluZGV4ICsgc2Nyb2xsTGVmdCwgZHJhZ2dlZEluZGV4ICsgc2Nyb2xsTGVmdCAtIDEpO1xuICAgICAgICBncmlkLnNjcm9sbEJ5KC0xLCAwKTtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLl9jaGVja0F1dG9TY3JvbGxUb0xlZnQuYmluZCh0aGlzLCBncmlkLCB4KSwgMjUwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgYSBjb2x1bW4gZHJhZyBoYXMgY29tcGxldGVkLCB1cGRhdGUgZGF0YSBhbmQgY2xlYW51cFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZW5kRHJhZ0NvbHVtbjogZnVuY3Rpb24oZ3JpZCkge1xuXG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICB2YXIgY29sdW1uSW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG5cbiAgICAgICAgaWYgKGNvbHVtbkluZGV4IDwgZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdGFydFggPSBncmlkLnJlbmRlcmVyLnZpc2libGVDb2x1bW5zW2NvbHVtbkluZGV4IC0gc2Nyb2xsTGVmdF0ubGVmdDtcbiAgICAgICAgdmFyIGQgPSBkcmFnZ2VyO1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5zdGFydEluZGV4ICE9PSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zaXRpb24nLCAoc2VsZi5pc1dlYmtpdCA/ICctd2Via2l0LScgOiAnJykgKyAndHJhbnNmb3JtICcgKyBjb2x1bW5BbmltYXRpb25UaW1lICsgJ21zIGVhc2UsIGJveC1zaGFkb3cgJyArIGNvbHVtbkFuaW1hdGlvblRpbWUgKyAnbXMgZWFzZScpO1xuICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBzdGFydFggKyAncHgsICcgKyAtMSArICdweCknKTtcbiAgICAgICAgZC5zdHlsZS5ib3hTaGFkb3cgPSAnMHB4IDBweCAwcHggIzg4ODg4OCc7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlciA9IG51bGw7XG4gICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgZ3JpZC5lbmREcmFnQ29sdW1uTm90aWZpY2F0aW9uKCk7IC8vaW50ZXJuYWwgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpe1xuICAgICAgICAgICAgICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNPbkNvbHVtbnNDaGFuZ2VkRXZlbnQoKTsgLy9wdWJsaWMgbm90aWZpY2F0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGNvbHVtbkFuaW1hdGlvblRpbWUgKyA1MCk7XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtbk1vdmluZztcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyogZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBGZWF0dXJlXG4gKi9cbnZhciBDb2x1bW5QaWNrZXIgPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uUGlja2VyJywge1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblBpY2tlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5VXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXkgPSBldmVudC5kZXRhaWwuY2hhci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIga2V5cyA9IGdyaWQucHJvcGVydGllcy5lZGl0b3JBY3RpdmF0aW9uS2V5cztcbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgZ3JpZC50b2dnbGVEaWFsb2coJ0NvbHVtblBpY2tlcicpO1xuICAgICAgICB9XG4gICAgfSxcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uUGlja2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRmVhdHVyZVxuICovXG52YXIgQ29sdW1uUmVzaXppbmcgPSBGZWF0dXJlLmV4dGVuZCgnQ29sdW1uUmVzaXppbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiB0aGUgaW5kZXggb2YgdGhlIGNvbHVtbiB3YWxsIHdlcmUgY3VycmVudGx5IGRyYWdnaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnSW5kZXg6IC0yLFxuXG4gICAgLyoqXG4gICAgICogdGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSB3aGVyZSB0aGUgZHJhZyB3YXMgaW5pdGlhdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnU3RhcnQ6IC0xLFxuXG4gICAgLyoqXG4gICAgICogdGhlIHN0YXJ0aW5nIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiB3ZSBhcmUgZHJhZ2dpbmdcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdJbmRleFN0YXJ0aW5nU2l6ZTogLTEsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IHRoZSBtb3VzZSB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIHRoZSBtb3VzZSBldmVudCB0byBxdWVyeVxuICAgICAqL1xuICAgIGdldE1vdXNlVmFsdWU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldCB0aGUgZ3JpZCBjZWxsIHgseSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXIuUG9pbnR9IGdyaWRDZWxsXG4gICAgICovXG4gICAgZ2V0R3JpZENlbGxWYWx1ZTogZnVuY3Rpb24oZ3JpZENlbGwpIHtcbiAgICAgICAgcmV0dXJuIGdyaWRDZWxsLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGdyaWRzIHgseSBzY3JvbGwgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiBvZiBpbnRlcmVzdFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgcm93L2NvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldEFyZWFTaXplOiBmdW5jdGlvbihncmlkLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRDb2x1bW5XaWR0aChpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiBhdCBpbmRleFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgcm93L2NvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHRoZSB3aWR0aC9oZWlnaHQgdG8gc2V0IHRvXG4gICAgICovXG4gICAgc2V0QXJlYVNpemU6IGZ1bmN0aW9uKGdyaWQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBncmlkLnNldENvbHVtbldpZHRoKGluZGV4LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIHJlY2VudGx5IHJlbmRlcmVkIGFyZWEncyB3aWR0aC9oZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRQcmV2aW91c0Fic29sdXRlU2l6ZTogZnVuY3Rpb24oZ3JpZCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0UmVuZGVyZWRXaWR0aChpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm5zIHRoZSBpbmRleCBvZiB3aGljaCBkaXZpZGVyIEknbSBvdmVyXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb3ZlckFyZWFEaXZpZGVyOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5vdmVyQ29sdW1uRGl2aWRlcihldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbSBJIG92ZXIgdGhlIGNvbHVtbi9yb3cgYXJlYVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpcnN0Rml4ZWRPdGhlckFyZWE6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRmlyc3RGaXhlZFJvdyhncmlkLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGN1cnNvciBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDdXJzb3JOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdjb2wtcmVzaXplJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdJbmRleCA+IC0yKSB7XG4gICAgICAgICAgICAvL3ZhciBmaXhlZEFyZWFDb3VudCA9IHRoaXMuZ2V0Rml4ZWRBcmVhQ291bnQoZ3JpZCk7XG4gICAgICAgICAgICAvL3ZhciBvZmZzZXQgPSB0aGlzLmdldEZpeGVkQXJlYVNpemUoZ3JpZCwgZml4ZWRBcmVhQ291bnQgKyBhcmVhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gdGhpcy5nZXRNb3VzZVZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgIHZhciBzY3JvbGxWYWx1ZSA9IHRoaXMuZ2V0U2Nyb2xsVmFsdWUoZ3JpZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnSW5kZXggPCB0aGlzLmdldEZpeGVkQXJlYUNvdW50KGdyaWQpKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5nZXRQcmV2aW91c0Fic29sdXRlU2l6ZShncmlkLCB0aGlzLmRyYWdJbmRleCAtIHNjcm9sbFZhbHVlKTtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IG1vdXNlIC0gcHJldmlvdXM7XG4gICAgICAgICAgICB0aGlzLnNldEFyZWFTaXplKGdyaWQsIHRoaXMuZHJhZ0luZGV4LCBkaXN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IHRoZSB3aWR0aC9oZWlnaHQgb2YgYSBzcGVjaWZpYyByb3cvY29sdW1uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJlYUluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRTaXplOiBmdW5jdGlvbihncmlkLCBhcmVhSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXJlYVNpemUoZ3JpZCwgYXJlYUluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgZml4ZWQgYXJlYSByb3dzL2NvbHVtbnMgY291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZ2V0T3RoZXJGaXhlZEFyZWFDb3VudDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNFbmFibGVkID0gdGhpcy5pc0VuYWJsZWQoZ3JpZCk7XG4gICAgICAgIHZhciBvdmVyQXJlYSA9IHRoaXMub3ZlckFyZWFEaXZpZGVyKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCAmJiBvdmVyQXJlYSA+IC0xICYmIHRoaXMuaXNGaXJzdEZpeGVkT3RoZXJBcmVhKGdyaWQsIGV2ZW50KSkge1xuICAgICAgICAgICAgdmFyIHNjcm9sbFZhbHVlID0gdGhpcy5nZXRTY3JvbGxWYWx1ZShncmlkKTtcbiAgICAgICAgICAgIGlmIChvdmVyQXJlYSA8IHRoaXMuZ2V0Rml4ZWRBcmVhQ291bnQoZ3JpZCkpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxWYWx1ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYWdJbmRleCA9IG92ZXJBcmVhIC0gMSArIHNjcm9sbFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnQgPSB0aGlzLmdldE1vdXNlVmFsdWUoZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5kcmFnSW5kZXhTdGFydGluZ1NpemUgPSAwO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hDaGFpbigpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNFbmFibGVkID0gdGhpcy5pc0VuYWJsZWQoZ3JpZCk7XG4gICAgICAgIGlmIChpc0VuYWJsZWQgJiYgdGhpcy5kcmFnSW5kZXggPiAtMikge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kcmFnSW5kZXggPSAtMjtcblxuICAgICAgICAgICAgZXZlbnQucHJpbWl0aXZlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAvL2RlbGF5IGhlcmUgdG8gZ2l2ZSBvdGhlciBldmVudHMgYSBjaGFuY2UgdG8gYmUgZHJvcHBlZFxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgZ3JpZC5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kYXJpZXMoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hDaGFpbigpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0luZGV4ID4gLTIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tGb3JBcmVhUmVzaXplQ3Vyc29yQ2hhbmdlKGdyaWQsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGZpbGwgdGhpcyBpblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBjaGVja0ZvckFyZWFSZXNpemVDdXJzb3JDaGFuZ2U6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc0VuYWJsZWQgPSB0aGlzLmlzRW5hYmxlZChncmlkKTtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCAmJiB0aGlzLm92ZXJBcmVhRGl2aWRlcihncmlkLCBldmVudCkgPiAtMSAmJiB0aGlzLmlzRmlyc3RGaXhlZE90aGVyQXJlYShncmlkLCBldmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gdGhpcy5nZXRDdXJzb3JOYW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Rml4ZWRBcmVhQ291bnQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCkgKyAoZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkgPyAxIDogMCkgKyAoZ3JpZC5oYXNIaWVyYXJjaHlDb2x1bW4oKSA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqIEBkZWZhdWx0IC0yXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGhhbmRsZURvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNFbmFibGVkID0gdGhpcy5pc0VuYWJsZWQoZ3JpZCk7XG4gICAgICAgIHZhciBoYXNDdXJzb3IgPSB0aGlzLm92ZXJBcmVhRGl2aWRlcihncmlkLCBldmVudCkgPiAtMTsgLy90aGlzLmN1cnNvciAhPT0gbnVsbDtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAvL3ZhciBoZWFkZXJDb2xDb3VudCA9IGdyaWQuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIGlmIChpc0VuYWJsZWQgJiYgaGFzQ3Vyc29yICYmIChncmlkQ2VsbC55IDw9IGhlYWRlclJvd0NvdW50KSkge1xuICAgICAgICAgICAgZ3JpZC5hdXRvc2l6ZUNvbHVtbihncmlkQ2VsbC54IC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaXNFbmFibGVkOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uUmVzaXppbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbi8qKlxuICogRXh0cmEgbXNlY3MgdG8gYXZvaWQgcmFjZSBjb25kaXRpb24gd2l0aCBmaW5jYW52YXMncyBkb3VibGUgY2xpY2sgdGltZXIuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHR2YWx1ZSA1MFxuICogTk9URTogNTAgbXNlY3Mgc2VlbXMgdG8gd29yayB3ZWxsLiAxMCBhbmQgZXZlbiAyNSBwcm92ZWQgaW5zdWZmaWNpZW50IGluIENocm9tZS5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBSQUNFX1RJTUUgPSA1MDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZlYXR1cmVcbiAqL1xudmFyIENvbHVtblNlbGVjdGlvbiA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5TZWxlY3Rpb24nLCB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXIuUG9pbnR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgY3VycmVudERyYWc6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaG9yaXpvbnRhbCBjZWxsIGNvb3JkaW5hdGUgb2YgdGhlIHdoZXJlIHRoZSBtb3VzZSBwb2ludGVyIGlzIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgbGFzdERyYWdDb2x1bW46IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBhIG1pbGxpc2Vjb25kIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgcHJldmlvdXMgdGltZSBhbiBhdXRvc2Nyb2xsIHN0YXJ0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiTGFzdEF1dG86IDAsXG5cbiAgICAvKipcbiAgICAgKiBhIG1pbGxpc2Vjb25kIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgdGltZSB0aGUgY3VycmVudCBhdXRvc2Nyb2xsIHN0YXJ0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiQXV0b1N0YXJ0OiAwLFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZG91YmxlQ2xpY2tUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlQ2xpY2tUaW1lcik7IC8vIHByZXZlbnQgbW91c2VEb3duIGZyb20gY29udGludWluZ1xuICAgICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kb3VibGVDbGlja1RpbWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2RvOiA+PSA1IGRlcGVuZHMgb24gaGVhZGVyIGJlaW5nIHRvcC1tb3N0IHJvdyB3aGljaCBpcyBjdXJyZW50bHkgYWx3YXlzIHRydWUgYnV0IHdlIG1heSBhbGxvdyBoZWFkZXIgXCJzZWN0aW9uXCIgdG8gYmUgYXJiaXRyYXJ5IHBvc2l0aW9uIHdpdGhpbiBxdWFkcmFudCAoc2VlIGFsc28gaGFuZGxlTW91c2VEb3duIGluIENvbHVtbk1vdmluZy5qcylcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZ3JpZC5pc0NvbHVtblNlbGVjdGlvbigpICYmXG4gICAgICAgICAgICBldmVudC5tb3VzZVBvaW50LnkgPj0gNSAmJlxuICAgICAgICAgICAgIWV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2sgJiZcbiAgICAgICAgICAgIGV2ZW50LmlzSGVhZGVyQ2VsbFxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIEhPTEQgT0ZGIFdISUxFIFdBSVRJTkcgRk9SIERPVUJMRS1DTElDS1xuICAgICAgICAgICAgdGhpcy5kb3VibGVDbGlja1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdWJsZUNsaWNrVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRTZWxlY3Rpb24oZ3JpZCwgZXZlbnQuZ3JpZENlbGwueCwgZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmtleXMpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBncmlkLnByb3BlcnRpZXMuZG91YmxlQ2xpY2tEZWxheSArIFJBQ0VfVElNRSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyaWQuaXNDb2x1bW5TZWxlY3Rpb24oKSAmJlxuICAgICAgICAgICAgIXRoaXMuaXNDb2x1bW5EcmFnZ2luZyhncmlkKSAmJlxuICAgICAgICAgICAgIWV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2sgJiZcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIHRoaXMubGFzdERyYWdDb2x1bW4gPSBldmVudC5ncmlkQ2VsbC54O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZyA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tEcmFnU2Nyb2xsKGdyaWQsIHRoaXMuY3VycmVudERyYWcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIHRoaXMubGFzdERyYWdDb2x1bW4sIGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5rZXlzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBoYW5kbGVyO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBncmlkLmdldExhc3RTZWxlY3Rpb25UeXBlKCkgPT09ICdjb2x1bW4nICYmXG4gICAgICAgICAgICAoaGFuZGxlciA9IHRoaXNbJ2hhbmRsZScgKyBldmVudC5kZXRhaWwuY2hhcl0pXG4gICAgICAgICkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGdyaWQsIGV2ZW50LmRldGFpbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgYSBtb3VzZWRyYWcgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgeCwga2V5cykge1xuICAgICAgICB2YXIgbW91c2VYID0gZ3JpZC5nZXRNb3VzZURvd24oKS54O1xuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgZ3JpZC5zZWxlY3RDb2x1bW4obW91c2VYLCB4KTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoeCAtIG1vdXNlWCwgMCkpO1xuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgY2hlY2tzIHdoaWxlIHdlcmUgZHJhZ2dpbmcgaWYgd2UgZ28gb3V0c2lkZSB0aGUgdmlzaWJsZSBib3VuZHMsIGlmIHNvLCBraWNrIG9mZiB0aGUgZXh0ZXJuYWwgYXV0b3Njcm9sbCBjaGVjayBmdW5jdGlvbiAoYWJvdmUpXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGNoZWNrRHJhZ1Njcm9sbDogZnVuY3Rpb24oZ3JpZCwgbW91c2UpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZ3JpZC5wcm9wZXJ0aWVzLnNjcm9sbGluZ0VuYWJsZWQgJiZcbiAgICAgICAgICAgIGdyaWQuZ2V0RGF0YUJvdW5kcygpLmNvbnRhaW5zKG1vdXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRHJhZyhncmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gbWFrZXMgc3VyZSB0aGF0IHdoaWxlIHdlIGFyZSBkcmFnZ2luZyBvdXRzaWRlIG9mIHRoZSBncmlkIHZpc2libGUgYm91bmRzLCB3ZSBzcmNyb2xsIGFjY29yZGluZ2x5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBzY3JvbGxEcmFnOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpLFxuICAgICAgICAgICAgeE9mZnNldDtcblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy54IDwgYi5vcmlnaW4ueCkge1xuICAgICAgICAgICAgeE9mZnNldCA9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudERyYWcueCA+IGIub3JpZ2luLnggKyBiLmV4dGVudC54KSB7XG4gICAgICAgICAgICB4T2Zmc2V0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4T2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0RHJhZ0NvbHVtbiA+PSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdERyYWdDb2x1bW4gKz0geE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyaWQuc2Nyb2xsQnkoeE9mZnNldCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgdGhpcy5sYXN0RHJhZ0NvbHVtbiwgW10pOyAvLyB1cGRhdGUgdGhlIHNlbGVjdGlvblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnNjcm9sbERyYWcuYmluZCh0aGlzLCBncmlkKSwgMjUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGV4dGVuZCBhIHNlbGVjdGlvbiBvciBjcmVhdGUgb25lIGlmIHRoZXJlIGlzbnQgeWV0XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JpZENlbGwgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgZXh0ZW5kU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCB4LCBrZXlzKSB7XG4gICAgICAgIGlmICghZ3JpZC5hYm9ydEVkaXRpbmcoKSkgeyByZXR1cm47IH1cblxuICAgICAgICB2YXIgbW91c2VYID0gZ3JpZC5nZXRNb3VzZURvd24oKS54LFxuICAgICAgICAgICAgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgPiAwO1xuXG4gICAgICAgIGlmICh4IDwgMCkgeyAvLyBvdXRzaWRlIG9mIHRoZSBncmlkP1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBkbyBub3RoaW5nXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Q29sdW1uU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBncmlkLnNlbGVjdENvbHVtbih4LCBtb3VzZVgpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoeCAtIG1vdXNlWCwgMCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JpZC50b2dnbGVTZWxlY3RDb2x1bW4oeCwga2V5cyk7XG4gICAgICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KHgsIDApKTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVBTSElGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVMRUZUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOOiBmdW5jdGlvbihncmlkKSB7XG5cbiAgICAgICAgLy8gdmFyIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGdyaWQuZ2V0RHJhZ0V4dGVudCgpKTtcbiAgICAgICAgLy8gdmFyIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxO1xuXG4gICAgICAgIC8vIHZhciBuZXdYID0gbW91c2VDb3JuZXIueDtcbiAgICAgICAgLy8gdmFyIG5ld1kgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCkgKyBncmlkLmdldFZTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIC8vIG5ld1kgPSBNYXRoLm1pbihtYXhSb3dzLCBuZXdZKTtcblxuICAgICAgICAvLyBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAvLyBncmlkLnNlbGVjdChuZXdYLCBuZXdZLCAwLCAwKTtcbiAgICAgICAgLy8gZ3JpZC5zZXRNb3VzZURvd24obmV3IGdyaWQucmVjdGFuZ3VsYXIuUG9pbnQobmV3WCwgbmV3WSkpO1xuICAgICAgICAvLyBncmlkLnNldERyYWdFeHRlbnQobmV3IGdyaWQucmVjdGFuZ3VsYXIuUG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIC8vIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVMRUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJZiB3ZSBhcmUgaG9sZGluZyBkb3duIHRoZSBzYW1lIG5hdmlnYXRpb24ga2V5LCBhY2NlbGVyYXRlIHRoZSBpbmNyZW1lbnQgd2Ugc2Nyb2xsXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbGFwc2VkID0gdGhpcy5nZXRBdXRvU2Nyb2xsRHVyYXRpb24oKSAvIDIwMDA7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHN0YXJ0IHRpbWUgdG8gcmlnaHQgbm93IHdoZW4gd2UgaW5pdGlhdGUgYW4gYXV0byBzY3JvbGxcbiAgICAgKi9cbiAgICBzZXRBdXRvU2Nyb2xsU3RhcnRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zYkF1dG9TdGFydCA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXBkYXRlIHRoZSBhdXRvc2Nyb2xsIHN0YXJ0IHRpbWUgaWYgd2UgaGF2ZW4ndCBhdXRvc2Nyb2xsZWQgd2l0aGluIHRoZSBsYXN0IDUwMG1zIG90aGVyd2lzZSB1cGRhdGUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCB0aW1lXG4gICAgICovXG4gICAgcGluZ0F1dG9TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKG5vdyAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdXRvU2Nyb2xsU3RhcnRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zYkxhc3RBdXRvID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgaG93IGxvbmcgd2UgaGF2ZSBiZWVuIGF1dG8gc2Nyb2xsaW5nXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgZ2V0QXV0b1Njcm9sbER1cmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zYkF1dG9TdGFydDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBdWdtZW50IHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gZXh0ZW50IGJ5IChvZmZzZXRYLG9mZnNldFkpIGFuZCBzY3JvbGwgaWYgbmVjZXNzYXJ5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaGlmdFNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WCkge1xuICAgICAgICB2YXIgb3JpZ2luID0gZ3JpZC5nZXRNb3VzZURvd24oKSxcbiAgICAgICAgICAgIGV4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpLFxuICAgICAgICAgICAgbmV3WCA9IGV4dGVudC54ICsgb2Zmc2V0WCxcbiAgICAgICAgICAgIG1heFZpZXdhYmxlQ29sdW1ucyA9IGdyaWQucmVuZGVyZXIudmlzaWJsZUNvbHVtbnMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBncmlkLmdldENvbHVtbkNvdW50KCkgLSAxO1xuXG4gICAgICAgIGlmICghZ3JpZC5wcm9wZXJ0aWVzLnNjcm9sbGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWluKG1heENvbHVtbnMgLSBvcmlnaW4ueCwgTWF0aC5tYXgoLW9yaWdpbi54LCBuZXdYKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb24oKTtcbiAgICAgICAgZ3JpZC5zZWxlY3RDb2x1bW4ob3JpZ2luLngsIG9yaWdpbi54ICsgbmV3WCk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KG5ld1gsIDApKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbENvbElzVmlzaWJsZShuZXdYICsgb3JpZ2luLngsIG9mZnNldFgpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXBsYWNlIHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gd2l0aCBhIHNpbmdsZSBjZWxsIHNlbGVjdGlvbiB0aGF0IGlzIG1vdmVkIChvZmZzZXRYLG9mZnNldFkpIGZyb20gdGhlIHByZXZpb3VzIHNlbGVjdGlvbiBleHRlbnQuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WCkge1xuICAgICAgICB2YXIgZXh0ZW50ID0gZ3JpZC5nZXREcmFnRXh0ZW50KCksXG4gICAgICAgICAgICBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhleHRlbnQpLFxuICAgICAgICAgICAgbmV3WCA9IG1vdXNlQ29ybmVyLnggKyBvZmZzZXRYLFxuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDEsXG4gICAgICAgICAgICBtYXhWaWV3YWJsZUNvbHVtbnMgPSBncmlkLmdldFZpc2libGVDb2x1bW5zQ291bnQoKSAtIDE7XG5cbiAgICAgICAgaWYgKCFncmlkLnByb3BlcnRpZXMuc2Nyb2xsaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgbWF4Q29sdW1ucyA9IE1hdGgubWluKG1heENvbHVtbnMsIG1heFZpZXdhYmxlQ29sdW1ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucywgTWF0aC5tYXgoMCwgbmV3WCkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0Q29sdW1uKG5ld1gpO1xuICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KG5ld1gsIDApKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsQ29sSXNWaXNpYmxlKG5ld1gsIG9mZnNldFgpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgaXNDb2x1bW5EcmFnZ2luZzogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB2YXIgZHJhZ2dlciA9IGdyaWQubG9va3VwRmVhdHVyZSgnQ29sdW1uTW92aW5nJyk7XG4gICAgICAgIHJldHVybiBkcmFnZ2VyICYmIGRyYWdnZXIuZHJhZ2dpbmcgJiYgIXRoaXMuZHJhZ2dpbmc7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5TZWxlY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBGZWF0dXJlXG4gKi9cbnZhciBDb2x1bW5Tb3J0aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtblNvcnRpbmcnLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU29ydGluZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG5cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGNvbHVtblByb3BlcnRpZXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGV2ZW50LmlzSGVhZGVyQ2VsbCAmJlxuICAgICAgICAgICAgKGNvbHVtblByb3BlcnRpZXMgPSBncmlkLmJlaGF2aW9yLmdldENvbHVtblByb3BlcnRpZXMoZXZlbnQuZ3JpZENlbGwueCkpICYmXG4gICAgICAgICAgICAhY29sdW1uUHJvcGVydGllcy51bnNvcnRhYmxlXG4gICAgICAgICkge1xuICAgICAgICAgICAgZ3JpZC5maXJlU3ludGhldGljQ29sdW1uU29ydEV2ZW50KGV2ZW50LmdyaWRDZWxsLngsIGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5rZXlzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNvcnRpbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGNvbHVtblByb3BlcnRpZXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGV2ZW50LmlzUm93Rml4ZWQgJiZcbiAgICAgICAgICAgIGV2ZW50LmlzSGVhZGVyQ2VsbCAmJlxuICAgICAgICAgICAgKGNvbHVtblByb3BlcnRpZXMgPSBncmlkLmJlaGF2aW9yLmdldENvbHVtblByb3BlcnRpZXMoZXZlbnQuZ3JpZENlbGwueCkpICYmXG4gICAgICAgICAgICAhY29sdW1uUHJvcGVydGllcy51bnNvcnRhYmxlXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbHVtblNvcnRpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnLi4vQmFzZScpO1xuXG52YXIgd2FybmVkID0ge307XG5cbi8qKlxuICogSW5zdGFuY2VzIG9mIGZlYXR1cmVzIGFyZSBjb25uZWN0ZWQgdG8gb25lIGFub3RoZXIgdG8gbWFrZSBhIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5IGZvciBoYW5kbGluZyBhbGwgdGhlIGlucHV0IHRvIHRoZSBoeXBlcmdyaWQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEZlYXR1cmUgPSBCYXNlLmV4dGVuZCgnRmVhdHVyZScsIHtcblxuICAgIC8qKlxuICAgICAqIHRoZSBuZXh0IGZlYXR1cmUgdG8gYmUgZ2l2ZW4gYSBjaGFuY2UgdG8gaGFuZGxlIGluY29taW5nIGV2ZW50c1xuICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBuZXh0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSB0ZW1wb3JhcnkgaG9sZGluZyBmaWVsZCBmb3IgbXkgbmV4dCBmZWF0dXJlIHdoZW4gSSdtIGluIGEgZGlzY29ubmVjdGVkIHN0YXRlXG4gICAgICogQHR5cGUge0ZlYXR1cmV9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRldGFjaGVkOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGN1cnNvciBJIHdhbnQgdG8gYmUgZGlzcGxheWVkXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICovXG4gICAgY3Vyc29yOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNlbGwgbG9jYXRpb24gd2hlcmUgdGhlIGN1cnNvciBpcyBjdXJyZW50bHlcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnJlbnRIb3ZlckNlbGw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgbXkgbmV4dCBmaWVsZCwgb3IgaWYgaXQncyBwb3B1bGF0ZWQgZGVsZWdhdGUgdG8gdGhlIGZlYXR1cmUgaW4gbXkgbmV4dCBmaWVsZFxuICAgICAqIEBwYXJhbSB7RmVhdHVyZX0gbmV4dEZlYXR1cmUgLSB0aGlzIGlzIGhvdyB3ZSBidWlsZCB0aGUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcHJpdmF0ZSBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgc2V0TmV4dDogZnVuY3Rpb24obmV4dEZlYXR1cmUpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LnNldE5leHQobmV4dEZlYXR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gbmV4dEZlYXR1cmU7XG4gICAgICAgICAgICB0aGlzLmRldGFjaGVkID0gbmV4dEZlYXR1cmU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGlzY29ubmVjdCBteSBjaGlsZFxuICAgICAqL1xuICAgIGRldGFjaENoYWluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmVhdHRhY2ggbXkgY2hpbGQgZnJvbSB0aGUgZGV0YWNoZWQgcmVmZXJlbmNlXG4gICAgICovXG4gICAgYXR0YWNoQ2hhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm5leHQgPSB0aGlzLmRldGFjaGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgbW91c2UgbW92ZSBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlIE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcHJpdmF0ZSBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VFeGl0OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VFeGl0KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGUgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRW50ZXI6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZUVudGVyKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGUgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlIE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlIE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlIE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVLZXlVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGUgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZVdoZWVsTW92ZWQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVXaGVlbE1vdmVkKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGUgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGhhbmRsZURvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcHJpdmF0ZSBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwcml2YXRlIE5vdCByZWFsbHkgcHJpdmF0ZSBidXQgd2FzIGNsdXR0ZXJpbmcgdXAgYWxsIHRoZSBmZWF0dXJlIGRvYyBwYWdlcy5cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcHJpdmF0ZSBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgaGFuZGxlQ29udGV4dE1lbnU6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVDb250ZXh0TWVudShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgdG9nZ2xlIHRoZSBjb2x1bW4gcGlja2VyXG4gICAgICogQHByaXZhdGUgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIG1vdmVTaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0Lm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRml4ZWRSb3c6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICghd2FybmVkLmlzRml4ZWRSb3cpIHtcbiAgICAgICAgICAgIHdhcm5lZC5pc0ZpeGVkUm93ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignaXNGaXhlZFJvdyhncmlkLCBldmVudCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2MS4yLjAgaW4gZmF2b3Igb2YgZXZlbnQuaXNSb3dGaXhlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50LmlzUm93Rml4ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpcnN0Rml4ZWRSb3c6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5ncmlkQ2VsbC55IDwgMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRml4ZWRDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICghd2FybmVkLmlzRml4ZWRDb2x1bW4pIHtcbiAgICAgICAgICAgIHdhcm5lZC5pc0ZpeGVkQ29sdW1uID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignaXNGaXhlZENvbHVtbihncmlkLCBldmVudCkgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2MS4yLjAgaW4gZmF2b3Igb2YgZXZlbnQuaXNDb2x1bW5GaXhlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50LmlzQ29sdW1uRml4ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpcnN0Rml4ZWRDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5ncmlkQ2VsbC54ID09PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaXNUb3BMZWZ0OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoIXdhcm5lZC5pc1RvcExlZnQpIHtcbiAgICAgICAgICAgIHdhcm5lZC5pc1RvcExlZnQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdpc1RvcExlZnQoZ3JpZCwgZXZlbnQpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdjEuMi4wIGluIGZhdm9yIG9mIGV2ZW50LmlzQ2VsbEZpeGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnQuaXNDZWxsRml4ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcHJpdmF0ZSBOb3QgcmVhbGx5IHByaXZhdGUgYnV0IHdhcyBjbHV0dGVyaW5nIHVwIGFsbCB0aGUgZmVhdHVyZSBkb2MgcGFnZXMuXG4gICAgICovXG4gICAgc2V0Q3Vyc29yOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICBncmlkLmJlQ3Vyc29yKHRoaXMuY3Vyc29yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHByaXZhdGUgTm90IHJlYWxseSBwcml2YXRlIGJ1dCB3YXMgY2x1dHRlcmluZyB1cCBhbGwgdGhlIGZlYXR1cmUgZG9jIHBhZ2VzLlxuICAgICAqL1xuICAgIGluaXRpYWxpemVPbjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBGZWF0dXJlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRmlsdGVycyA9IEZlYXR1cmUuZXh0ZW5kKCdGaWx0ZXJzJywge1xuXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5pc0ZpbHRlckNlbGwpIHtcbiAgICAgICAgICAgIGdyaWQub25FZGl0b3JBY3RpdmF0ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaXNGaWx0ZXJDZWxsKSB7XG4gICAgICAgICAgICBncmlkLm9uRWRpdG9yQWN0aXZhdGUoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVycztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUnKTtcblxudmFyIGNvbW1hbmRzID0ge1xuICAgIFBBR0VET1dOOiBmdW5jdGlvbihncmlkKSB7IGdyaWQucGFnZURvd24oKTsgfSxcbiAgICBQQUdFVVA6IGZ1bmN0aW9uKGdyaWQpIHsgZ3JpZC5wYWdlVXAoKTsgfSxcbiAgICBQQUdFTEVGVDogZnVuY3Rpb24oZ3JpZCkgeyBncmlkLnBhZ2VMZWZ0KCk7IH0sXG4gICAgUEFHRVJJR0hUOiBmdW5jdGlvbihncmlkKSB7IGdyaWQucGFnZVJpZ2h0KCk7IH1cbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBLZXlQYWdpbmcgPSBGZWF0dXJlLmV4dGVuZCgnS2V5UGFnaW5nJywge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBtZW1iZXJPZiBLZXlQYWdpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjb21tYW5kc1tldmVudC5kZXRhaWwuY2hhcl07XG4gICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICBmdW5jKGdyaWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUtleURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlQYWdpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBPbkhvdmVyID0gRmVhdHVyZS5leHRlbmQoJ09uSG92ZXInLCB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQG1lbWJlck9mIE9uSG92ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaG92ZXJDZWxsID0gZ3JpZC5ob3ZlckNlbGw7XG4gICAgICAgIGlmICghZXZlbnQuZ3JpZENlbGwuZXF1YWxzKGhvdmVyQ2VsbCkpIHtcbiAgICAgICAgICAgIGlmIChob3ZlckNlbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRXhpdChncmlkLCBob3ZlckNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZUVudGVyKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIGdyaWQuc2V0SG92ZXJDZWxsKGV2ZW50LmdyaWRDZWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZU1vdmUoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBPbkhvdmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29sdW1uUmVzaXppbmcgPSByZXF1aXJlKCcuL0NvbHVtblJlc2l6aW5nJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBDb2x1bW5SZXNpemluZ1xuICovXG52YXIgUm93UmVzaXppbmcgPSBDb2x1bW5SZXNpemluZy5leHRlbmQoJ1Jvd1Jlc2l6aW5nJywge1xuXG4gICAgLyoqXG4gICAgICogdGhlIGluZGV4IG9mIHRoZSByb3cvY29sdW1uIHdlIGFyZSBkcmFnZ2luZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0FyZWE6IC0xLFxuXG4gICAgLyoqXG4gICAgICogdGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSB3aGVyZSB0aGUgZHJhZyB3YXMgaW5pdGlhdGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnU3RhcnQ6IC0xLFxuXG4gICAgLyoqXG4gICAgICogdGhlIHN0YXJ0aW5nIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiB3ZSBhcmUgZHJhZ2dpbmdcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdBcmVhU3RhcnRpbmdTaXplOiAtMSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXQgdGhlIG1vdXNlIHgseSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gdGhlIG1vdXNlIGV2ZW50IHRvIHF1ZXJ5XG4gICAgICovXG4gICAgZ2V0TW91c2VWYWx1ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IHRoZSBncmlkIGNlbGwgeCx5IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGdyaWRDZWxsXG4gICAgICovXG4gICAgZ2V0R3JpZENlbGxWYWx1ZTogZnVuY3Rpb24oZ3JpZENlbGwpIHtcbiAgICAgICAgcmV0dXJuIGdyaWRDZWxsLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGdyaWRzIHgseSBzY3JvbGwgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0VlNjcm9sbFZhbHVlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgcm93L2NvbHVtbiBvZiBpbnRlcmVzdFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgcm93L2NvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldEFyZWFTaXplOiBmdW5jdGlvbihncmlkLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRSb3dIZWlnaHQoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gYXQgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgd2lkdGgvaGVpZ2h0IHRvIHNldCB0b1xuICAgICAqL1xuICAgIHNldEFyZWFTaXplOiBmdW5jdGlvbihncmlkLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgZ3JpZC5zZXRSb3dIZWlnaHQoaW5kZXgsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybnMgdGhlIGluZGV4IG9mIHdoaWNoIGRpdmlkZXIgSSdtIG92ZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvdmVyQXJlYURpdmlkZXI6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBncmlkLm92ZXJSb3dEaXZpZGVyKGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGFtIEkgb3ZlciB0aGUgY29sdW1uL3JvdyBhcmVhXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRmlyc3RGaXhlZE90aGVyQXJlYTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGaXJzdEZpeGVkQ29sdW1uKGdyaWQsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgY3Vyc29yIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldEN1cnNvck5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJ3Jvdy1yZXNpemUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSByZWNlbnRseSByZW5kZXJlZCBhcmVhJ3Mgd2lkdGgvaGVpZ2h0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSByb3cvY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0UHJldmlvdXNBYnNvbHV0ZVNpemU6IGZ1bmN0aW9uKGdyaWQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldFJlbmRlcmVkSGVpZ2h0KGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgZml4ZWQgYXJlYSByb3dzL2NvbHVtbnMgY291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZ2V0T3RoZXJGaXhlZEFyZWFDb3VudDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0yXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEZpeGVkQXJlYUNvdW50OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldEZpeGVkUm93Q291bnQoKSArIGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IC0yXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGlzRW5hYmxlZDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5pc1Jvd1Jlc2l6ZWFibGUoKTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvd1Jlc2l6aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUm93U2VsZWN0aW9uID0gRmVhdHVyZS5leHRlbmQoJ1Jvd1NlbGVjdGlvbicsIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgY3VycmVudERyYWc6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2VsbCBjb29yZGluYXRlcyBvZiB0aGUgd2hlcmUgdGhlIG1vdXNlIHBvaW50ZXIgaXMgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBsYXN0RHJhZ0NlbGw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBhIG1pbGxpc2Vjb25kIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgcHJldmlvdXMgdGltZSBhbiBhdXRvc2Nyb2xsIHN0YXJ0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiTGFzdEF1dG86IDAsXG5cbiAgICAvKipcbiAgICAgKiBhIG1pbGxpc2Vjb25kIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgdGltZSB0aGUgY3VycmVudCBhdXRvc2Nyb2xsIHN0YXJ0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiQXV0b1N0YXJ0OiAwLFxuXG4gICAgZHJhZ0FybWVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdBcm1lZCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnQXJtZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY1Jvd1NlbGVjdGlvbkNoYW5nZWRFdmVudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY1Jvd1NlbGVjdGlvbkNoYW5nZWRFdmVudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIHJvd1NlbGVjdGFibGUgPSBncmlkLmlzUm93U2VsZWN0aW9uKCkgJiZcbiAgICAgICAgICAgICFldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrICYmXG4gICAgICAgICAgICBncmlkLmlzU2hvd1Jvd051bWJlcnMoKSAmJlxuICAgICAgICAgICAgZXZlbnQuaXNIYW5kbGVDb2x1bW47XG5cbiAgICAgICAgaWYgKHJvd1NlbGVjdGFibGUgJiYgZXZlbnQuaXNIZWFkZXJIYW5kbGUpIHtcbiAgICAgICAgICAgIC8vZ2xvYmFsIHJvdyBzZWxlY3Rpb25cbiAgICAgICAgICAgIGdyaWQudG9nZ2xlU2VsZWN0QWxsUm93cygpO1xuICAgICAgICB9IGVsc2UgaWYgKHJvd1NlbGVjdGFibGUgJiYgZXZlbnQuaXNHcmlkUm93KSAge1xuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGluIHRoZSBmaXhlZCBhcmVhLCBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIHRoaXMuZHJhZ0FybWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kU2VsZWN0aW9uKGdyaWQsIGV2ZW50LmRhdGFDZWxsLnksIGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5rZXlzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5kcmFnQXJtZWQgJiZcbiAgICAgICAgICAgIGdyaWQuaXNSb3dTZWxlY3Rpb24oKSAmJlxuICAgICAgICAgICAgIWV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5pc1JpZ2h0Q2xpY2tcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIHRoaXMubGFzdERyYWdSb3cgPSBldmVudC5kYXRhQ2VsbC55O1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREcmFnID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdGhpcy5jaGVja0RyYWdTY3JvbGwoZ3JpZCwgdGhpcy5jdXJyZW50RHJhZyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgdGhpcy5sYXN0RHJhZ1JvdywgZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmtleXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGhhbmRsZXI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGdyaWQuZ2V0TGFzdFNlbGVjdGlvblR5cGUoKSA9PT0gJ3JvdycgJiZcbiAgICAgICAgICAgIChoYW5kbGVyID0gdGhpc1snaGFuZGxlJyArIGV2ZW50LmRldGFpbC5jaGFyXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZ3JpZCwgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSBhIG1vdXNlZHJhZyBzZWxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCB5LCBrZXlzKSB7XG4gICAgICAgIHZhciBtb3VzZVkgPSBncmlkLmdldE1vdXNlRG93bigpLnk7XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb24oKTtcblxuICAgICAgICBncmlkLnNlbGVjdFJvdyhtb3VzZVksIHkpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCB5IC0gbW91c2VZKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBjaGVja3Mgd2hpbGUgd2VyZSBkcmFnZ2luZyBpZiB3ZSBnbyBvdXRzaWRlIHRoZSB2aXNpYmxlIGJvdW5kcywgaWYgc28sIGtpY2sgb2ZmIHRoZSBleHRlcm5hbCBhdXRvc2Nyb2xsIGNoZWNrIGZ1bmN0aW9uIChhYm92ZSlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgY2hlY2tEcmFnU2Nyb2xsOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBncmlkLnByb3BlcnRpZXMuc2Nyb2xsaW5nRW5hYmxlZCAmJlxuICAgICAgICAgICAgZ3JpZC5nZXREYXRhQm91bmRzKCkuY29udGFpbnMobW91c2UpXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3codHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxEcmFnKGdyaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBtYWtlcyBzdXJlIHRoYXQgd2hpbGUgd2UgYXJlIGRyYWdnaW5nIG91dHNpZGUgb2YgdGhlIGdyaWQgdmlzaWJsZSBib3VuZHMsIHdlIHNyY3JvbGwgYWNjb3JkaW5nbHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHNjcm9sbERyYWc6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCksXG4gICAgICAgICAgICB5T2Zmc2V0O1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnkgPCBiLm9yaWdpbi55KSB7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50RHJhZy55ID4gYi5vcmlnaW4ueSArIGIuZXh0ZW50LnkpIHtcbiAgICAgICAgICAgIHlPZmZzZXQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHlPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3REcmFnUm93ID49IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0RHJhZ1JvdyArPSB5T2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JpZC5zY3JvbGxCeSgwLCB5T2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCB0aGlzLmxhc3REcmFnUm93LCBbXSk7IC8vIHVwZGF0ZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuc2Nyb2xsRHJhZy5iaW5kKHRoaXMsIGdyaWQpLCAyNSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgZXh0ZW5kIGEgc2VsZWN0aW9uIG9yIGNyZWF0ZSBvbmUgaWYgdGhlcmUgaXNudCB5ZXRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmlkQ2VsbCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBleHRlbmRTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIHksIGtleXMpIHtcbiAgICAgICAgaWYgKCFncmlkLmFib3J0RWRpdGluZygpKSB7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciBtb3VzZVkgPSBncmlkLmdldE1vdXNlRG93bigpLnksXG4gICAgICAgICAgICBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSA+IDA7XG5cbiAgICAgICAgaWYgKHkgPCAwKSB7IC8vIG91dHNpZGUgb2YgdGhlIGdyaWQ/XG4gICAgICAgICAgICByZXR1cm47IC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNTSElGVCkge1xuICAgICAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0Um93KHksIG1vdXNlWSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCB5IC0gbW91c2VZKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmlkLnRvZ2dsZVNlbGVjdFJvdyh5LCBrZXlzKTtcbiAgICAgICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQoMCwgeSkpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGhhbmRsZURPV05TSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVBTSElGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaGlmdFNlbGVjdChncmlkLCAtMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlRTSElGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVFNISUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURPV046IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVMRUZUOiBmdW5jdGlvbihncmlkKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHZhciBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSksXG4gICAgICAgICAgICBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMSxcbiAgICAgICAgICAgIG5ld1ggPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpLFxuICAgICAgICAgICAgbmV3WSA9IG1vdXNlQ29ybmVyLnk7XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWluKG1heENvbHVtbnMsIG5ld1gpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0KG5ld1gsIG5ld1ksIDAsIDApO1xuICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KG5ld1gsIG5ld1kpKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIElmIHdlIGFyZSBob2xkaW5nIGRvd24gdGhlIHNhbWUgbmF2aWdhdGlvbiBrZXksIGFjY2VsZXJhdGUgdGhlIGluY3JlbWVudCB3ZSBzY3JvbGxcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICBnZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMTtcbiAgICAgICAgdmFyIGVsYXBzZWQgPSB0aGlzLmdldEF1dG9TY3JvbGxEdXJhdGlvbigpIC8gMjAwMDtcbiAgICAgICAgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQpKTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgc3RhcnQgdGltZSB0byByaWdodCBub3cgd2hlbiB3ZSBpbml0aWF0ZSBhbiBhdXRvIHNjcm9sbFxuICAgICAqL1xuICAgIHNldEF1dG9TY3JvbGxTdGFydFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNiQXV0b1N0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGF1dG9zY3JvbGwgc3RhcnQgdGltZSBpZiB3ZSBoYXZlbid0IGF1dG9zY3JvbGxlZCB3aXRoaW4gdGhlIGxhc3QgNTAwbXMgb3RoZXJ3aXNlIHVwZGF0ZSB0aGUgY3VycmVudCBhdXRvc2Nyb2xsIHRpbWVcbiAgICAgKi9cbiAgICBwaW5nQXV0b1Njcm9sbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF1dG9TY3JvbGxTdGFydFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNiTGFzdEF1dG8gPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGFuc3dlciBob3cgbG9uZyB3ZSBoYXZlIGJlZW4gYXV0byBzY3JvbGxpbmdcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICBnZXRBdXRvU2Nyb2xsRHVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnNiQXV0b1N0YXJ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEF1Z21lbnQgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiBleHRlbnQgYnkgKG9mZnNldFgsb2Zmc2V0WSkgYW5kIHNjcm9sbCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WCAtIHggY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0geSBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICovXG4gICAgbW92ZVNoaWZ0U2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRZKSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSBncmlkLmdldE1vdXNlRG93bigpLFxuICAgICAgICAgICAgZXh0ZW50ID0gZ3JpZC5nZXREcmFnRXh0ZW50KCksXG4gICAgICAgICAgICBtYXhWaWV3YWJsZVJvd3MgPSBncmlkLnJlbmRlcmVyLnZpc2libGVSb3dzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBtYXhSb3dzID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gMTtcblxuICAgICAgICBpZiAoIWdyaWQucHJvcGVydGllcy5zY3JvbGxpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICBtYXhSb3dzID0gTWF0aC5taW4obWF4Um93cywgbWF4Vmlld2FibGVSb3dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdZID0gZXh0ZW50LnkgKyBvZmZzZXRZO1xuXG4gICAgICAgIG5ld1kgPSBNYXRoLm1pbihtYXhSb3dzIC0gb3JpZ2luLnksIE1hdGgubWF4KC1vcmlnaW4ueSwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0Um93KG9yaWdpbi55LCBvcmlnaW4ueSArIG5ld1kpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCBuZXdZKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxSb3dJc1Zpc2libGUobmV3WSArIG9yaWdpbi55LCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVwbGFjZSB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIHdpdGggYSBzaW5nbGUgY2VsbCBzZWxlY3Rpb24gdGhhdCBpcyBtb3ZlZCAob2Zmc2V0WCxvZmZzZXRZKSBmcm9tIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gZXh0ZW50LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFkpIHtcbiAgICAgICAgdmFyIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxLFxuICAgICAgICAgICAgbWF4Vmlld2FibGVSb3dzID0gZ3JpZC5nZXRWaXNpYmxlUm93c0NvdW50KCkgLSAxLFxuICAgICAgICAgICAgbW91c2VDb3JuZXIgPSBncmlkLmdldE1vdXNlRG93bigpLnBsdXMoZ3JpZC5nZXREcmFnRXh0ZW50KCkpLFxuICAgICAgICAgICAgbmV3WSA9IG1vdXNlQ29ybmVyLnkgKyBvZmZzZXRZO1xuXG4gICAgICAgIGlmICghZ3JpZC5wcm9wZXJ0aWVzLnNjcm9sbGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIG1heFJvd3MgPSBNYXRoLm1pbihtYXhSb3dzLCBtYXhWaWV3YWJsZVJvd3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3WSA9IE1hdGgubWluKG1heFJvd3MsIE1hdGgubWF4KDAsIG5ld1kpKTtcblxuICAgICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICBncmlkLnNlbGVjdFJvdyhuZXdZKTtcbiAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCgwLCBuZXdZKSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIDApKTtcblxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbFJvd0lzVmlzaWJsZShuZXdZLCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5maXJlU3ludGhldGljUm93U2VsZWN0aW9uQ2hhbmdlZEV2ZW50KCk7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBpc1NpbmdsZVJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUm93U2VsZWN0aW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVGh1bWJ3aGVlbFNjcm9sbGluZyA9IEZlYXR1cmUuZXh0ZW5kKCdUaHVtYndoZWVsU2Nyb2xsaW5nJywge1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFRodW1id2hlZWxTY3JvbGxpbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVdoZWVsTW92ZWQ6IGZ1bmN0aW9uKGdyaWQsIGUpIHtcbiAgICAgICAgaWYgKCFncmlkLnByb3BlcnRpZXMuc2Nyb2xsaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByaW1FdmVudCA9IGUucHJpbWl0aXZlRXZlbnQsXG4gICAgICAgICAgICBkZWx0YVggPSBNYXRoLnNpZ24ocHJpbUV2ZW50LndoZWVsRGVsdGFYIHx8IC1wcmltRXZlbnQuZGVsdGFYKSxcbiAgICAgICAgICAgIGRlbHRhWSA9IE1hdGguc2lnbihwcmltRXZlbnQud2hlZWxEZWx0YVkgfHwgLXByaW1FdmVudC5kZWx0YVkpO1xuXG4gICAgICAgIGlmIChkZWx0YVggfHwgZGVsdGFZKSB7XG4gICAgICAgICAgICBncmlkLnNjcm9sbEJ5KFxuICAgICAgICAgICAgICAgIC1kZWx0YVggfHwgMCwgLy8gMCBpZiBOYU5cbiAgICAgICAgICAgICAgICAtZGVsdGFZIHx8IDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gVGh1bWJ3aGVlbFNjcm9sbGluZztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRmVhdHVyZTogcmVxdWlyZSgnLi9GZWF0dXJlJyksIC8vIGFic3RyYWN0IGJhc2UgY2xhc3NcbiAgICBDZWxsQ2xpY2s6IHJlcXVpcmUoJy4vQ2VsbENsaWNrJyksXG4gICAgQ2VsbEVkaXRpbmc6IHJlcXVpcmUoJy4vQ2VsbEVkaXRpbmcnKSxcbiAgICBDZWxsU2VsZWN0aW9uOiByZXF1aXJlKCcuL0NlbGxTZWxlY3Rpb24nKSxcbiAgICBDb2x1bW5BdXRvc2l6aW5nOiByZXF1aXJlKCcuL0NvbHVtbkF1dG9zaXppbmcnKSxcbiAgICBDb2x1bW5Nb3Zpbmc6IHJlcXVpcmUoJy4vQ29sdW1uTW92aW5nJyksXG4gICAgQ29sdW1uUmVzaXppbmc6IHJlcXVpcmUoJy4vQ29sdW1uUmVzaXppbmcnKSxcbiAgICBDb2x1bW5TZWxlY3Rpb246IHJlcXVpcmUoJy4vQ29sdW1uU2VsZWN0aW9uJyksXG4gICAgQ29sdW1uU29ydGluZzogcmVxdWlyZSgnLi9Db2x1bW5Tb3J0aW5nJyksXG4gICAgRmlsdGVyczogcmVxdWlyZSgnLi9GaWx0ZXJzJyksXG4gICAgS2V5UGFnaW5nOiByZXF1aXJlKCcuL0tleVBhZ2luZycpLFxuICAgIE9uSG92ZXI6IHJlcXVpcmUoJy4vT25Ib3ZlcicpLFxuICAgIENvbHVtblBpY2tlcjogcmVxdWlyZSgnLi9Db2x1bW5QaWNrZXInKSxcbiAgICBSb3dSZXNpemluZzogcmVxdWlyZSgnLi9Sb3dSZXNpemluZycpLFxuICAgIFJvd1NlbGVjdGlvbjogcmVxdWlyZSgnLi9Sb3dTZWxlY3Rpb24nKSxcbiAgICBUaHVtYndoZWVsU2Nyb2xsaW5nOiByZXF1aXJlKCcuL1RodW1id2hlZWxTY3JvbGxpbmcnKVxufTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtjb250YWluaW5nRWw9ZG9jdW1lbnRdXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwYXJhdG9yPScnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtzdWZmaXg9JyddXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbdHJhbnNmb3JtZXI9bXVsdGlMaW5lVHJpbV0gLSBGdW5jdGlvbiB0byB0cmFuc2Zvcm0gZWFjaCBpbnB1dCBjb250cm9sJ3MgdGV4dCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY29weUFsbChjb250YWluaW5nRWwsIHByZWZpeCwgc2VwYXJhdG9yLCBzdWZmaXgsIHRyYW5zZm9ybWVyKSB7XG4gICAgdmFyIHRleHRzID0gW10sIGxhc3RUZXh0RWwsIHRleHQ7XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKChjb250YWluaW5nRWwgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoY29weUFsbC5zZWxlY3RvciksIGZ1bmN0aW9uKHRleHRFbCkge1xuICAgICAgICB0ZXh0ID0gKHRyYW5zZm9ybWVyIHx8IG11bHRpTGluZVRyaW0pKHRleHRFbC52YWx1ZSk7XG4gICAgICAgIGlmICh0ZXh0KSB7IHRleHRzLnB1c2godGV4dCk7IH1cbiAgICAgICAgbGFzdFRleHRFbCA9IHRleHRFbDtcbiAgICB9KTtcblxuICAgIGlmIChsYXN0VGV4dEVsKSB7XG4gICAgICAgIGNvcHkobGFzdFRleHRFbCwgKHByZWZpeCB8fCAnJykgKyB0ZXh0cy5qb2luKHNlcGFyYXRvciB8fCAnJykgKyAoc3VmZml4IHx8ICcnKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIDEuIFRyaW0gdGhlIHRleHQgaW4gdGhlIGdpdmVuIGlucHV0IGVsZW1lbnRcbiAqIDIuIHNlbGVjdCBpdFxuICogMy4gY29weSBpdCB0byB0aGUgY2xpcGJvYXJkXG4gKiA0LiBkZXNlbGVjdCBpdFxuICogNS4gcmV0dXJuIGl0XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxUZXh0QXJlYUVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RleHQ9ZWwudmFsdWVdIC0gVGV4dCB0byBjb3B5LlxuICogQHJldHVybnMge3VuZGVmaW5lZHxzdHJpbmd9IFRyaW1tZWQgdGV4dCBpbiBlbGVtZW50IG9yIHVuZGVmaW5lZCBpZiB1bmFibGUgdG8gY29weS5cbiAqL1xuZnVuY3Rpb24gY29weShlbCwgdGV4dCkge1xuICAgIHZhciByZXN1bHQsIHRleHRXYXM7XG5cbiAgICBpZiAodGV4dCkge1xuICAgICAgICB0ZXh0V2FzID0gZWwudmFsdWU7XG4gICAgICAgIGVsLnZhbHVlID0gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZWwudmFsdWU7XG4gICAgfVxuXG4gICAgZWwudmFsdWUgPSBtdWx0aUxpbmVUcmltKHRleHQpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZWwuc2VsZWN0KCk7XG4gICAgICAgIHJlc3VsdCA9IGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0ZXh0V2FzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsLnZhbHVlID0gdGV4dFdhcztcbiAgICAgICAgfVxuICAgICAgICBlbC5ibHVyKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG11bHRpTGluZVRyaW0ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL15cXHMqKC4qPylcXHMqJC8sICckMScpO1xufVxuXG5jb3B5LmFsbCA9IGNvcHlBbGw7XG5jb3B5Lm11bHRpTGluZVRyaW0gPSBtdWx0aUxpbmVUcmltO1xuY29weS5zZWxlY3RvclRleHRDb250cm9scyA9ICdpbnB1dDpub3QoW3R5cGVdKSwgaW5wdXRbdHlwZT10ZXh0XSwgdGV4dGFyZWEnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHk7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqIEBtb2R1bGUgZWZmZWN0cyAqL1xuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9ufSBlZmZlY3RGdW5jdGlvblxuICogQGRlc2MgRWxlbWVudCB0byBwZXJmb3JtIHRyYW5zaXRpb25zIHVwb24gaXMgYG9wdGlvbnMuZWxgIGlmIGRlZmluZWQgb3IgYHRoaXMuZWxgLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW29wdGlvbnMuZWw9dGhpcy5lbF1cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXSBGdW5jdGlvbiB0byBjYWxsIGF0IGNvbmNsdXNpb24gb2YgdHJhbnNpdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZHVyYXRpb249JzAuMDY1cyddIC0gRHVyYXRpb24gb2YgZWFjaCB0cmFuc2l0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnN0eWxlcz1kZWZhdWx0R2xvd2VyU3R5bGVzXSAtIEhhc2ggb2YgQ1NTIHN0eWxlcyBhbmQgdmFsdWVzIHRvIHRyYW5zaXRpb24uIChGb3Ige0BsaW5rIGVmZmVjdHN+Z2xvd2VyfGdsb3dlcn0gb25seS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2hha2UgZWxlbWVudCBiYWNrIGFuZCBmb3VydGggYSBmZXcgdGltZXMgYXMgaWYgdG8gc2F5LCBcIk5vcGUhXCJcbiAqIEB0eXBlIHtlZmZlY3RGdW5jdGlvbn1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZWZmZWN0c1xuICovXG5leHBvcnRzLnNoYWtlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsXG4gICAgICAgIGVsID0gb3B0aW9ucy5lbCB8fCBjb250ZXh0LmVsLFxuICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgJzAuMDY1cycsXG4gICAgICAgIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCksXG4gICAgICAgIHRyYW5zaXRpb25zID0gY29tcHV0ZWRTdHlsZS50cmFuc2l0aW9uLnNwbGl0KCcsJyksXG4gICAgICAgIHBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5wb3NpdGlvbixcbiAgICAgICAgeCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUubGVmdCksXG4gICAgICAgIGR4ID0gLTMsXG4gICAgICAgIHNoYWtlcyA9IDY7XG5cbiAgICB0cmFuc2l0aW9ucy5wdXNoKCdsZWZ0ICcgKyBkdXJhdGlvbik7XG4gICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25zLmpvaW4oJywnKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgc2hha2VyKTtcbiAgICBzaGFrZXIoKTtcbiAgICBmdW5jdGlvbiBzaGFrZXIoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudCB8fCBldmVudC5wcm9wZXJ0eU5hbWUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgZWwuc3R5bGUubGVmdCA9IHggKyBkeCArICdweCc7XG4gICAgICAgICAgICBpZiAoIXNoYWtlcy0tKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHNoYWtlcik7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25zLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2suY2FsbChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkeCA9IHNoYWtlcyA/IC1keCA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZGVmYXVsdEdsb3dlclN0eWxlcyA9IHtcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6ICd5ZWxsb3cnLFxuICAgICdib3gtc2hhZG93JzogJzAgMCAxMHB4IHJlZCdcbn07XG5cbi8qKlxuICogVHJhbnNpdGlvbiBzdHlsZXMgb24gZWxlbWVudCBmb3IgYSBtb21lbnQgYW5kIHJldmVydCBhcyBpZiB0byBzYXksIFwiV2hvYSEuXCJcbiAqIEB0eXBlIHtlZmZlY3RGdW5jdGlvbn1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6ZWZmZWN0c1xuICovXG5leHBvcnRzLmdsb3dlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsXG4gICAgICAgIGVsID0gb3B0aW9ucy5lbCB8fCBjb250ZXh0LmVsLFxuICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgJzAuMjVzJyxcbiAgICAgICAgc3R5bGVzID0gb3B0aW9ucy5zdHlsZXMgfHwgZGVmYXVsdEdsb3dlclN0eWxlcyxcbiAgICAgICAgdmFsdWVzID0gc3R5bGVzLmxlbmd0aCxcbiAgICAgICAgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKSxcbiAgICAgICAgc3R5bGVXYXMgPSB7fSxcbiAgICAgICAgdHJhbnNpdGlvbiA9IGNvbXB1dGVkU3R5bGUudHJhbnNpdGlvbixcbiAgICAgICAgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uLnNwbGl0KCcsJyk7XG5cbiAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgc3R5bGVXYXNbc3R5bGVdID0ge1xuICAgICAgICAgICAgc3R5bGU6IGNvbXB1dGVkU3R5bGVbc3R5bGVdLFxuICAgICAgICAgICAgdW5kbzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICB0cmFuc2l0aW9ucy5wdXNoKHN0eWxlICsgJyAnICsgZHVyYXRpb24pO1xuICAgIH0pO1xuXG4gICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25zLmpvaW4oJywnKTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZ2xvd2VyKTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgZWwuc3R5bGVbc3R5bGVdID0gc3R5bGVzW3N0eWxlXTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdsb3dlcihldmVudCkge1xuICAgICAgICB2YXIgd2FzID0gc3R5bGVXYXNbZXZlbnQucHJvcGVydHlOYW1lXTtcbiAgICAgICAgaWYgKHdhcy51bmRvKSB7XG4gICAgICAgICAgICBlbC5zdHlsZVtldmVudC5wcm9wZXJ0eU5hbWVdID0gd2FzLnN0eWxlO1xuICAgICAgICAgICAgd2FzLnVuZG8gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghLS12YWx1ZXMpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBnbG93ZXIpO1xuICAgICAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2suY2FsbChjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cy5lYWNoID0gZnVuY3Rpb24oc2VsZWN0b3IsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoKGNvbnRleHQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBpdGVyYXRlZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5maW5kID0gZnVuY3Rpb24oc2VsZWN0b3IsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwoKGNvbnRleHQgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBpdGVyYXRlZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBRdWV1ZWxlc3MoZWxlbWVudCwgY29udGV4dCkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbn1cblxuUXVldWVsZXNzLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24gZW5kKHRyYW5zRXZlbnQpIHtcbiAgICAgICAgc2VsZi5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBlbmQpO1xuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB0cmFuc0V2ZW50LCBzZWxmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZWxlc3M7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBAbW9kdWxlIGxvY2FsaXphdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuLi9CYXNlJyk7XG52YXIgZGVwcmVjYXRlZCA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlZCcpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRMb2NhbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbG9jYWxlPWRlZmF1bHRsb2NhbGVdXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEZvcm1hdHRlciA9IEJhc2UuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkZWZhdWx0TG9jYWxlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW52YWxpZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZCA9IG9wdGlvbnMuaW52YWxpZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdGF0aW9uID0gb3B0aW9ucy5leHBlY3RhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cbi8vIFNhZmFyaSBoYXMgbm8gSW50bCBpbXBsZW1lbnRhdGlvblxuaWYgKCF3aW5kb3cuSW50bCkge1xuICAgIHdpbmRvdy5JbnRsID0ge1xuICAgICAgICBOdW1iZXJGb3JtYXQ6IGZ1bmN0aW9uKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGRpZ2l0cyA9ICcwMTIzNDU2Nzg5JztcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgIHZhciBzID0gbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLnVzZUdyb3VwaW5nID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy51c2VHcm91cGluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHAgPSBzLmluZGV4T2YoJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRwIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHAgPSBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGRwIC09IDMpID4gMCAmJiBkaWdpdHMuaW5kZXhPZihzW2RwIC0gMV0pID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzLnN1YnN0cigwLCBkcCkgKyAnLCcgKyBzLnN1YnN0cihkcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBEYXRlVGltZUZvcm1hdDogZnVuY3Rpb24obG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gZGF0ZS5nZXRNb250aCgpICsgMSArICctJyArIGRhdGUuZ2V0RGF0ZSgpICsgJy0nICsgZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8qKlxuICogQHN1bW1hcnkgQ3JlYXRlIGEgbnVtYmVyIGxvY2FsaXplci5cbiAqIEBpbXBsZW1lbnRzIGxvY2FsaXplckludGVyZmFjZVxuICogQGRlc2MgQ3JlYXRlIGFuIG9iamVjdCBjb25mb3JtaW5nIHRvIHtAbGluayBsb2NhbGl6ZXJJbnRlcmZhY2V9IGZvciBudW1iZXJzLCB1c2luZyB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyRm9ybWF0fEludGwuTnVtYmVyRm9ybWF0fS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0TG9jYWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xvY2FsZT1kZWZhdWx0TG9jYWxlXSAtIFBhc3NlZCB0byB0aGUge0BsaW5rIEludGwuTnVtYmVyRm9ybWF0fGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlckZvcm1hdH0gY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBgSW50bC5OdW1iZXJGb3JtYXRgIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0cz1mYWxzZV0gLSBBY2NlcHQgc3RhbmRhcmQgZGlnaXRzIGFuZCBkZWNpbWFsIHBvaW50IGludGVyY2hhbmdlYWJseSB3aXRoIGxvY2FsaXplZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQuIChUaGlzIG9wdGlvbiBpcyBpbnRlcnByZXRlZCBoZXJlOyBpdCBpcyBub3QgdXNlZCBieSBgSW50bC5OdW1iZXJGb3JtYXRgLilcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRm9ybWF0dGVyXG4gKiBAdHV0b3JpYWwgbG9jYWxpemF0aW9uXG4gKi9cbnZhciBOdW1iZXJGb3JtYXR0ZXIgPSBGb3JtYXR0ZXIuZXh0ZW5kKCdOdW1iZXJGb3JtYXR0ZXInLCB7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGVmYXVsdExvY2FsZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGxvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuZm9ybWF0ID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlLCBvcHRpb25zKS5mb3JtYXQ7XG5cbiAgICAgICAgdmFyIG1hcHBlck9wdGlvbnMgPSB7IHVzZUdyb3VwaW5nOiBmYWxzZSB9LFxuICAgICAgICAgICAgbWFwcGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlLCBtYXBwZXJPcHRpb25zKS5mb3JtYXQ7XG5cbiAgICAgICAgdGhpcy5kZW1hcHBlciA9IGRlbWFwLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICAgICAqIEBkZXNjIENvbnRhaW5zIGFsbCBsb2NhbGl6ZWQgZGlnaXRzICsgbG9jYWxpemVkIGRlY2ltYWwgcG9pbnQuXG4gICAgICAgICAqIElmIHdlJ3JlIGFjY2VwdGluZyBzdGFuZGFyZCBkaWdpdHMsIHdpbGwgYWxzbyBjb250YWluIGFsbCB0aGUgc3RhbmRhcmQgZGlnaXRzICsgc3RhbmRhcmQgZGVjaW1hbCBwb2ludCAoaWYgZGlmZmVyZW50IHRoYW4gbG9jYWxpemVkIHZlcnNpb25zKS5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGRlc2MgTG9jYWxpemVkIGRpZ2l0cyBhbmQgZGVjaW1hbCBwb2ludC4gV2lsbCBhbHNvIGluY2x1ZGUgc3RhbmRhcmRpemVkIGRpZ2l0cyBhbmQgZGVjaW1hbCBwb2ludCBpZiBgb3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0c2AgaXMgdHJ1dGh5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBGb3IgaW50ZXJuYWwgdXNlIGJ5IHRoZSB7QGxpbmsgTnVtYmVyRm9ybWF0dGVyI3BhcnNlfHBhcnNlfSBtZXRob2QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBOdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcCA9IG1hcHBlcigxMDEyMzQ1Njc4OS41KS5zdWJzdHIoMSwgMTEpOyAvLyBsb2NhbGl6ZWQgJzAxMjM0NTY3ODkuJ1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzICYmIHRoaXMubWFwICE9PSAnMDEyMzQ1Njc4OS4nKSB7XG4gICAgICAgICAgICB0aGlzLm1hcCArPSAnMDEyMzQ1Njc4OS4nOyAgLy8gc3RhbmRhcmQgJzAxMjM0NTY3ODkuJ1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBzdW1tYXJ5IEEgcmVnZXggdGhhdCB0ZXN0cyBgdHJ1ZWAgb24gZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIuXG4gICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZXNjIFZhbGlkIGNoYXJhY3RlcnMgaW5jbHVkZTpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBMb2NhbGl6ZWQgZGlnaXRzXG4gICAgICAgICAqICogTG9jYWxpemVkIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgICogKiBTdGFuZGFyZCBkaWdpdHMgKHdoZW4gYG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHNgIGlzIHRydXRoeSlcbiAgICAgICAgICogKiBTdGFuZGFyZCBkZWNpbWFsIHBvaW50ICh3aGVuIGBvcHRpb25zLmFjY2VwdFN0YW5kYXJkRGlnaXRzYCBpcyB0cnV0aHkpXG4gICAgICAgICAqICogQ29zbWV0aWMgY2hhcmFjdGVycyBhZGRlZCBieSBmb3JtYXR0ZXIgYXMgcGVyIGBvcHRpb25zYCAoZm9yIGh1bWFuLWZyaWVuZGx5IHJlYWRhYmlsaXR5KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQW55IGNoYXJhY3RlcnMgb3V0c2lkZSB0aGlzIHNldCBhcmUgY29uc2lkZXJlZCBpbnZhbGlkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yOyBjb25zdW1lZCBieSB0aGUge0BsaW5rIG1vZHVsZTpsb2NhbGl6YXRpb25+TnVtYmVyRm9ybWF0dGVyI2ludmFsaWR8aW52YWxpZH0gbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUZXN0aW5nIGEgc3RyaW5nIGFnYWluc3QgdGhpcyBwYXR0ZXJuIHlpZWxkcyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIGludmFsaWQgY2hhcmFjdGVyIG9yIGBmYWxzZWAgaWYgYWxsIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnZhbGlkcyA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnW14nICtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0KDExMTExKS5yZXBsYWNlKHRoaXMubWFwWzFdLCAnJykgKyAvLyB0aG91c2FuZHMgc2VwYXJhdG9yIGlmIGluIHVzZVxuICAgICAgICAgICAgdGhpcy5tYXAgKyAvLyBkaWdpdHMgKyBkZWNpbWFsIHBvaW50XG4gICAgICAgICAgICAnXSdcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFRlc3RzIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICogQGRlc2MgVGVzdHMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbnVtYmVyIHRoYXQgaXQgY29udGFpbnMgYW55IGludmFsaWQgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIFRoZSBudW1iZXIgbWF5IGJlIHVuZm9ybWF0dGVkIG9yIGl0IG1heSBiZSBmb3JtYXR0ZWQgd2l0aCBhbnkgb2YgdGhlIHBlcm1pdHRlZCBmb3JtYXR0aW5nIGNoYXJhY3RlcnMsIGFzIGltcGxpZWQgYnkgdGhlIGNvbnN0cnVjdG9yJ3MgYG9wdGlvbnNgIChwYXNzZWQgdG8gYEludGwuTnVtYmVyRm9ybWF0YCkuIEFueSBvdGhlciBjaGFyYWN0ZXJzIGFyZSBjb25zaWRlcmVkIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCBzdGFuZGFyZCBkaWdpdHMgYW5kIHRoZSBzdGFuZGFyZCBkZWNpbWFsIHBvaW50IGFyZSBjb25zaWRlcmVkIHZhbGlkIGlmIHRoZSB2YWx1ZSBvZiBgb3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0c2AgYXMgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yIHdhcyB0cnV0aHkuIChPZiBjb3Vyc2UsIHRoZXNlIGFyZSBhbHdheXMgdmFsaWQgZm9yIGxvY2FsZXMgdGhhdCB1c2UgdGhlbS4pXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG86XG4gICAgICogMS4gRmlsdGVyIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgb24gYSBgb25rZXlkb3duYCBldmVudDsgb3JcbiAgICAgKiAyLiBUZXN0IGFuIGVkaXRlZCBzdHJpbmcgcHJpb3IgdG8gY2FsbGluZyB0aGUge0BsaW5rIG1vZHVsZTpsb2NhbGl6YXRpb25+TnVtYmVyRm9ybWF0dGVyI3BhcnNlfHBhcnNlfS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgbWV0aG9kIGRvZXMgbm90IGNoZWNrIGdyYW1tYXRpY2FsIHN5bnRheDsgaXQgb25seSBjaGVja3MgZm9yIGludmFsaWQgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBudW1iZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxzdHJpbmd9IEZhbHN5IG1lYW5zIHZhbGlkIHdoaWNoIGluIHRoaXMgY2FzZSBtZWFucyBjb250YWlucyBvbmx5IHZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICogQG1lbWJlck9mIE51bWJlckZvcm1hdHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbnZhbGlkOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52YWxpZHMudGVzdChudW1iZXIpO1xuICAgIH0sXG5cbiAgICBleHBlY3RhdGlvbjpcbiAgICAgICAgJ0V4cGVjdGVkIGEgbnVtYmVyIHdpdGggb3B0aW9uYWwgY29tbWFzICh0aG91c2FuZHMgZ3JvdXBpbmcgc2VwYXJhdG9yKSwgb3B0aW9uYWwgZGVjaW1hbCBwb2ludCwgYW5kIGFuIG9wdGlvbmFsIGZyYWN0aW9uYWwgcGFydC5cXG4nICtcbiAgICAgICAgJ0NvbW1hIHNlcGFyYXRvcnMgYXJlIHBhcnQgb2YgdGhlIGZvcm1hdCBhbmQgd2lsbCBhbHdheXMgYmUgZGlzcGxheWVkIGZvciB2YWx1ZXMgPj0gMTAwMC5cXG4nICtcbiAgICAgICAgJ0VkaXRlZCB2YWx1ZXMgYXJlIGFsd2F5cyBzYXZlZCBpbiB0aGVpciBlbnRpcmV0eSBldmVuIHRob3VnaCB0aGUgZm9ybWF0dGVkIHZhbHVlIGlzIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuJyxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGw6XG4gICAgICogKiBDb252ZXJ0IGxvY2FsaXplZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQgY2hhcmFjdGVycyB0byBzdGFuZGFyZCBkaWdpdHMgYW5kIGRlY2ltYWwgcG9pbnQgY2hhcmFjdGVycy5cbiAgICAgKiAqIFwiQ2xlYW5cIiB0aGUgc3RyaW5nIGJ5IGlnbm9yaW5nIGFsbCBvdGhlciBjaGFyYWN0ZXJzLlxuICAgICAqICogQ29lcmNlIHRoZSBzdHJpbmcgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXR0ZWRMb2NhbGl6ZWROdW1iZXIgLSBNYXkgb3IgbWF5IG5vdCBiZSBmb3JtYXR0ZWQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIHByaW1pdGl2ZS5cbiAgICAgKiBAdGhyb3dzIHtzdHJpbmd9IEludmFsaWQgbnVtYmVyLlxuICAgICAqIEBtZW1iZXJPZiBOdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGZvcm1hdHRlZExvY2FsaXplZE51bWJlcikge1xuICAgICAgICB2YXIgbnVtYmVyID0gTnVtYmVyKFxuICAgICAgICAgICAgZm9ybWF0dGVkTG9jYWxpemVkTnVtYmVyLnNwbGl0KCcnKS5tYXAodGhpcy5kZW1hcHBlcikuam9pbignJylcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaXNOYU4obnVtYmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgJ0ludmFsaWQgTnVtYmVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGRlbWFwKGMpIHtcbiAgICB2YXIgZCA9IHRoaXMubWFwLmluZGV4T2YoYykgJSAxMTtcbiAgICByZXR1cm4gZCA8IDAgPyAnJyA6IGQgPCAxMCA/IGQgOiAnLic7XG59XG5cbi8qKlxuICogQGltcGxlbWVudHMgbG9jYWxpemVySW50ZXJmYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdExvY2FsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtsb2NhbGU9ZGVmYXVsdGxvY2FsZV0gLSBQYXNzZWQgdG8gdGhlIHtAbGluayBJbnRsLkRhdGVGb3JtYXR8aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZUZvcm1hdH0gY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gUGFzc2VkIHRvIHRoZSBgSW50bC5EYXRlRm9ybWF0YCBjb25zdHJ1Y3Rvci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRm9ybWF0dGVyXG4gKi9cbnZhciBEYXRlRm9ybWF0dGVyID0gRm9ybWF0dGVyLmV4dGVuZCgnRGF0ZUZvcm1hdHRlcicsIHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkZWZhdWx0TG9jYWxlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLyoqIEBzdW1tYXJ5IFRyYW5zZm9ybSBhIGRhdGUgb2JqZWN0IGludG8gaHVtYW4tZnJpZW5kbHkgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCBvcHRpb25zKS5mb3JtYXQ7XG5cbiAgICAgICAgLy8gR2V0IGRpZ2l0cyBiZWNhdXNlIG1heSBiZSBjaGluZXNlIG9yIFwicmVhbCBBcmFiaWNcIiBudW1lcmFscy5cbiAgICAgICAgdmFyIHRlc3RPcHRpb25zID0geyB1c2VHcm91cGluZzogZmFsc2UsIHN0eWxlOiAnZGVjaW1hbCcgfSxcbiAgICAgICAgICAgIGxvY2FsaXplTnVtYmVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlLCB0ZXN0T3B0aW9ucykuZm9ybWF0LFxuICAgICAgICAgICAgbG9jYWxpemVkRGlnaXRzID0gdGhpcy5sb2NhbGl6ZWREaWdpdHMgPSBsb2NhbGl6ZU51bWJlcigxMDEyMzQ1Njc4OSkuc3Vic3RyKDEsIDEwKTsgLy8gYWxsIGxvY2FsaXplZCBkaWdpdHMgaW4gbnVtZXJpY2FsIG9yZGVyXG5cbiAgICAgICAgdGhpcy5kaWdpdEZvcm1hdHRlciA9IGZvcm1hdERpZ2l0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGlnaXRQYXJzZXIgPSBwYXJzZURpZ2l0LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gTG9jYWxpemUgYSB0ZXN0IGRhdGUgd2l0aCB0aGUgZGVmYXVsdCBudW1lcmljIHBhcnRzIHRvIGZpbmQgb3V0IHRoZSByZXN1bHRpbmcgb3JkZXIgb2YgdGhlc2UgcGFydHMuXG4gICAgICAgIHZhciB5eSA9IDE5ODcsXG4gICAgICAgICAgICBtbSA9IDEyLFxuICAgICAgICAgICAgZGQgPSAzMCxcbiAgICAgICAgICAgIFlZID0gdGhpcy50cmFuc2Zvcm1OdW1iZXIodGhpcy5kaWdpdEZvcm1hdHRlciwgeXkpLFxuICAgICAgICAgICAgTU0gPSB0aGlzLnRyYW5zZm9ybU51bWJlcih0aGlzLmRpZ2l0Rm9ybWF0dGVyLCBtbSksXG4gICAgICAgICAgICBERCA9IHRoaXMudHJhbnNmb3JtTnVtYmVyKHRoaXMuZGlnaXRGb3JtYXR0ZXIsIGRkKSxcbiAgICAgICAgICAgIHRlc3REYXRlID0gbmV3IERhdGUoeXksIG1tIC0gMSwgZGQpLFxuICAgICAgICAgICAgbG9jYWxpemVEYXRlID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUpLmZvcm1hdCxcbiAgICAgICAgICAgIGxvY2FsaXplZERhdGUgPSBsb2NhbGl6ZURhdGUodGVzdERhdGUpLCAvLyBhbGwgbG9jYWxpemVkIGRpZ2l0cyArIGxvY2FsaXplZCBwdW5jdHVhdGlvblxuICAgICAgICAgICAgbWlzc2luZ0RpZ2l0cyA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCh0aGlzLmxvY2FsZSkuZm9ybWF0KDQ1NiksXG4gICAgICAgICAgICBsb2NhbGl6ZWROdW1iZXJQYXR0ZXJuID0gdGhpcy5sb2NhbGl6ZWROdW1iZXJQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnWycgKyBsb2NhbGl6ZWREaWdpdHMgKyAnXSsnLCAnZycpLFxuICAgICAgICAgICAgcGFydHMgPSBsb2NhbGl6ZWREYXRlLm1hdGNoKGxvY2FsaXplZE51bWJlclBhdHRlcm4pO1xuXG4gICAgICAgIHRoaXMucGFydHNNYXAgPSB7XG4gICAgICAgICAgICB5eTogcGFydHMuaW5kZXhPZihZWSksXG4gICAgICAgICAgICBtbTogcGFydHMuaW5kZXhPZihNTSksXG4gICAgICAgICAgICBkZDogcGFydHMuaW5kZXhPZihERClcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0cykge1xuICAgICAgICAgICAgbWlzc2luZ0RpZ2l0cyArPSAnMTIzNDU2Nzg5MCc7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHN1bW1hcnkgQSByZWdleCB0aGF0IHRlc3RzIGB0cnVlYCBvbiBmaXJzdCBpbnZhbGlkIGNoYXJhY3Rlci5cbiAgICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGRlc2MgVmFsaWQgY2hhcmFjdGVycyBpbmNsdWRlOlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIExvY2FsaXplZCBkaWdpdHNcbiAgICAgICAgICogKiBTdGFuZGFyZCBkaWdpdHMgKHdoZW4gYG9wdGlvbnMuYWNjZXB0U3RhbmRhcmREaWdpdHNgIGlzIHRydXRoeSlcbiAgICAgICAgICogKiBMb2NhbGl6ZWQgcHVuY3R1YXRpb24gdG8gZGVsaW1pdCBkYXRlIHBhcnRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBjaGFyYWN0ZXJzIG91dHNpZGUgdGhpcyBzZXQgYXJlIGNvbnNpZGVyZWQgaW52YWxpZC4gTm90ZSB0aGF0IHRoaXMgb25seSBjdXJyZW50bHkgaW1wbGVtZW50ZWQgd2hlbiBhbGwgdGhyZWUgZGF0ZSBwYXJ0cyBhcmUgbnVtZXJpY1xuICAgICAgICAgKlxuICAgICAgICAgKiBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yOyBjb25zdW1lZCBieSB0aGUge0BsaW5rIE51bWJlckZvcm1hdHRlciN2YWxpZHx2YWxpZH0gbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUZXN0aW5nIGEgc3RyaW5nIGFnYWluc3QgdGhpcyBwYXR0ZXJuIHlpZWxkcyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIGludmFsaWQgY2hhcmFjdGVyIG9yIGBmYWxzZWAgaWYgYWxsIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgRGF0ZUZvcm1hdHRlci5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW52YWxpZHMgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ1teJyArXG4gICAgICAgICAgICBsb2NhbGl6ZWREYXRlLnJlcGxhY2UoLy0vZywgJ1xcXFwtJykgK1xuICAgICAgICAgICAgbWlzc2luZ0RpZ2l0cyArXG4gICAgICAgICAgICAnXSdcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqIEBzdW1tYXJ5IFRlc3RzIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICogQGRlc2MgVGVzdHMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbnVtYmVyIHRoYXQgaXQgY29udGFpbnMgYW55IGludmFsaWQgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqIFRoZSBkYXRlIGlzIGFzc3VtZWQgdG8gY29udGFpbiBsb2NhbGl6ZWQgZGlnaXRzIGFuZCBwdW5jdHVhdGlvbiBhcyB3b3VsZCBiZSByZXR1cm5lZCBieSBgSW50bC5EYXRlRm9ybWF0YCB3aXRoIHRoZSBnaXZlbiBgbG9jYWxlYCBhbmQgYG9wdGlvbnNgLiBBbnkgb3RoZXIgY2hhcmFjdGVycyBhcmUgY29uc2lkZXJlZCBpbnZhbGlkLlxuICAgICAqXG4gICAgICogSG93ZXZlciwgc3RhbmRhcmQgZGlnaXRzIGFuZCB0aGUgc3RhbmRhcmQgZGVjaW1hbCBwb2ludCBhcmUgYWxzbyBjb25zaWRlcmVkIHZhbGlkIGlmIHRoZSB2YWx1ZSBvZiBgb3B0aW9ucy5hY2NlcHRTdGFuZGFyZERpZ2l0c2AgYXMgcHJvdmlkZWQgdG8gdGhlIGNvbnN0cnVjdG9yIHdhcyB0cnV0aHkuIChPZiBjb3Vyc2UsIHRoZXNlIGFyZSBhbHdheXMgdmFsaWQgZm9yIGxvY2FsZXMgdGhhdCB1c2UgdGhlbS4pXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBtZXRob2QgdG86XG4gICAgICogMS4gRmlsdGVyIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgb24gYSBgb25rZXlkb3duYCBldmVudDsgb3JcbiAgICAgKiAyLiBUZXN0IGFuIGVkaXRlZCBzdHJpbmcgcHJpb3IgdG8gY2FsbGluZyB0aGUge0BsaW5rIG1vZHVsZTpsb2NhbGl6YXRpb25+RGF0ZUZvcm1hdHRlciNwYXJzZXxwYXJzZX0uXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIGRhdGUgZm9ybWF0cyB1c2luZyBhbGwgbnVtZXJpY3MgKHdoaWNoIGlzIHRoZSBkZWZhdWx0IGZvciBgSW50bC5EYXRlRm9ybWF0YCkuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBkb2VzIG5vdCBjaGVjayBncmFtbWF0aWNhbCBzeW50YXg7IGl0IG9ubHkgY2hlY2tzIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbnVtYmVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IENvbnRhaW5zIG9ubHkgdmFsaWQgY2hhcmFjdGVycy5cbiAgICAgKiBAbWVtYmVyT2YgRGF0ZUZvcm1hdHRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbnZhbGlkOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52YWxpZHMudGVzdChudW1iZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsOlxuICAgICAqICogQ29udmVydCBsb2NhbGl6ZWQgZGF0ZSB0byBEYXRlIG9iamVjdC5cbiAgICAgKiAqIFwiQ2xlYW5cIiB0aGUgc3RyaW5nIGJ5IGlnbm9yaW5nIGFsbCBvdGhlciBjaGFyYWN0ZXJzLlxuICAgICAqICogQ29lcmNlIHRoZSBzdHJpbmcgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGl6ZWREYXRlXG4gICAgICogQHJldHVybnMge0RhdGV9XG4gICAgICogQHRocm93cyB7c3RyaW5nfSBJbnZhbGlkIGRhdGUuXG4gICAgICogQG1lbWJlck9mIERhdGVGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGxvY2FsaXplZERhdGUpIHtcbiAgICAgICAgdmFyIGRhdGUsXG4gICAgICAgICAgICBwYXJ0cyA9IGxvY2FsaXplZERhdGUubWF0Y2godGhpcy5sb2NhbGl6ZWROdW1iZXJQYXR0ZXJuKTtcblxuICAgICAgICBpZiAocGFydHMgJiYgcGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMudHJhbnNmb3JtTnVtYmVyKHRoaXMuZGlnaXRQYXJzZXIsIHBhcnRzW3RoaXMucGFydHNNYXAueXldKSxcbiAgICAgICAgICAgICAgICBtID0gdGhpcy50cmFuc2Zvcm1OdW1iZXIodGhpcy5kaWdpdFBhcnNlciwgcGFydHNbdGhpcy5wYXJ0c01hcC5tbV0pIC0gMSxcbiAgICAgICAgICAgICAgICBkID0gdGhpcy50cmFuc2Zvcm1OdW1iZXIodGhpcy5kaWdpdFBhcnNlciwgcGFydHNbdGhpcy5wYXJ0c01hcC5kZF0pO1xuXG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnSW52YWxpZCBEYXRlJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYSBudW1iZXIgdG8gb3IgZnJvbSBhIHN0cmluZyByZXByZXNlbnRhdGlvbiB3aXRoIGxvY2FsaXplZCBkaWdpdHMuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZGlnaXRUcmFuc2Zvcm1lciAtIEEgZnVuY3Rpb24gYm91bmQgdG8gYHRoaXNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG1lbWJlck9mIERhdGVGb3JtYXR0ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgdHJhbnNmb3JtTnVtYmVyOiBmdW5jdGlvbihkaWdpdFRyYW5zZm9ybWVyLCBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlci50b1N0cmluZygpLnNwbGl0KCcnKS5tYXAoZGlnaXRUcmFuc2Zvcm1lcikuam9pbignJyk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGZvcm1hdERpZ2l0KGQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGl6ZWREaWdpdHNbZF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGlnaXQoYykge1xuICAgIHZhciBkID0gdGhpcy5sb2NhbGl6ZWREaWdpdHMuaW5kZXhPZihjKTtcbiAgICBpZiAoZCA8IDApIHsgZCA9ICcnOyB9XG4gICAgcmV0dXJuIGQ7XG59XG5cbi8qKlxuICogQWxsIG1lbWJlcnMgYXJlIGxvY2FsaXplcnMgKGNvbmZvcm0gdG8ge0BsaW5rIGxvY2FsaXplckludGVyZmFjZX0pIHdpdGggZXhjZXB0aW9uIG9mIGBnZXRgLCBgc2V0YCwgYW5kIGxvY2FsaXplciBjb25zdHJ1Y3RvcnMgd2hpY2ggYXJlIG5hbWVkIChieSBjb252ZW50aW9uKSBlbmRpbmcgaW4gXCJGb3JtbWF0dGVyXCIuXG4gKlxuICogVGhlIGFwcGxpY2F0aW9uIGRldmVsb3BlciBpcyBmcmVlIHRvIGFkZCBsb2NhbGl6ZXJzIGFuZCBsb2NhbGl6ZXIgZmFjdG9yeSBtZXRob2RzLiBTZWUgdGhlIHtAbGluayBMb2NhbGl6YXRpb24jY29uc3RydWN0fGNvbnN0cnVjdH0gY29udmVuaWVuY2UgbWV0aG9kIHdoaWNoIG1heSBiZSBoZWxwZnVsIGluIHRoaXMgcmVnYXJkLlxuICogQHBhcmFtIGxvY2FsZVxuICogQHBhcmFtIHtvYmplY3R9IFtudW1iZXJPcHRpb25zXVxuICogQHBhcmFtIHtvYmplY3R9IFtkYXRlT3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMb2NhbGl6YXRpb24obG9jYWxlLCBudW1iZXJPcHRpb25zLCBkYXRlT3B0aW9ucykge1xuICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgbnVtYmVyXG4gICAgICogQHNlZSBUaGUge0BsaW5rIE51bWJlckZvcm1hdHRlcnxOdW1iZXJGb3JtYXR0ZXJ9IGNsYXNzXG4gICAgICogQG1lbWJlck9mIExvY2FsaXphdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLmludCA9IHRoaXMuZmxvYXQgPSB0aGlzLmNvbnN0cnVjdCgnbnVtYmVyJywgTnVtYmVyRm9ybWF0dGVyLCBudW1iZXJPcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEBzZWUgVGhlIHtAbGluayBEYXRlRm9ybWF0dGVyfERhdGVGb3JtYXR0ZXJ9IGNsYXNzXG4gICAgICogQG1lbWJlck9mIExvY2FsaXphdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLmNvbnN0cnVjdCgnZGF0ZScsIERhdGVGb3JtYXR0ZXIsIGRhdGVPcHRpb25zKTtcbn1cblxuTG9jYWxpemF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogTG9jYWxpemF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvcixcblxuICAgIC8qKiBAc3VtbWFyeSBDcmVhdGVzIGEgbG9jYWxpemVyIGZyb20gYSBsb2NhbGl6ZXIgZmFjdG9yeSBvYmplY3QgdXNpbmcgdGhlIGRlZmF1bHQgbG9jYWxlLlxuICAgICAqIEBkZXNjIFBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgYWN0aW9uczpcbiAgICAgKiAxLiBCaW5kcyBgQ29uc3RydWN0b3JgIHRvIGBsb2NhbGVgLlxuICAgICAqIDIuIEFkZHMgdGhlIG5ld2x5IGJvdW5kIGNvbnN0cnVjdG9yIHRvIHRoaXMgb2JqZWN0IChmb3IgZnV0dXJlIHJlZmVyZW5jZSkgd2l0aCB0aGUga2V5IFwiTmFtZUZvcm1hdHRlclwiICh3aGVyZSBcIk5hbWVcIiBpcyB0aGUgbG9jYWxpemVyIG5hbWUsIGFsbCBsb3dlciBjYXNlIGJ1dCB3aXRoIGFuIGluaXRpYWwgY2FwaXRhbCkuXG4gICAgICogMy4gVXNlcyB0aGUgbmV3bHkgYm91bmQgY29uc3RydWN0b3IgdG8gY3JlYXRlIGEgbmV3IGxvY2FsaXplZCBsb2NhbGl6ZXIgd2l0aCB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKiA0LiBBZGRzIG5ldyBsb2NhbGl6ZXIgdG8gdGhpcyBvYmplY3QgdmlhIHtAbGluayBMb2NhbGl6YXRpb24jYWRkfGFkZH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxpemVyTmFtZVxuICAgICAqIEBwYXJhbSB7Q29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0ge2ZhY3RvcnlPcHRpb25zfVxuICAgICAqIEByZXR1cm5zIHtsb2NhbGl6ZUluZXJmYWNlfSBUaGUgbmV3IGxvY2FsaXplci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKGxvY2FsaXplck5hbWUsIENvbnN0cnVjdG9yLCBmYWN0b3J5T3B0aW9ucykge1xuICAgICAgICB2YXIgY29uc3RydWN0b3JOYW1lID0gbG9jYWxpemVyTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbG9jYWxpemVyTmFtZS5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKSArICdGb3JtYXR0ZXInLFxuICAgICAgICAgICAgQm91bmRDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yLmJpbmQobnVsbCwgdGhpcy5sb2NhbGUpLFxuICAgICAgICAgICAgbG9jYWxpemVyID0gbmV3IEJvdW5kQ29uc3RydWN0b3IoZmFjdG9yeU9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXNbY29uc3RydWN0b3JOYW1lXSA9IEJvdW5kQ29uc3RydWN0b3I7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGxvY2FsaXplck5hbWUsIGxvY2FsaXplcik7XG4gICAgfSxcblxuICAgIC8qKiBAc3VtbWFyeSBSZWdpc3RlciBhIGxvY2FsaXplci5cbiAgICAgKiBAZGVzYyBDaGVja3MgdGhlIHByb3ZpZGVkIGxvY2FsaXplciB0aGF0IGl0IGNvbmZvcm1zIHRvIHtAbGluayBsb2NhbGl6ZXJJbnRlcmZhY2V9XG4gICAgICogYW5kIGFkZHMgaXQgdG8gdGhlIG9iamVjdCB1c2luZyBsb2NhbGl6ZXJOYW1lIGFsbCBsb3dlciBjYXNlIGFzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge2xvY2FsaXplckludGVyZmFjZX0gbG9jYWxpemVyXG4gICAgICogQG1lbWJlck9mIExvY2FsaXphdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bG9jYWxpemVJbmVyZmFjZX0gVGhlIHByb3ZpZGVkIGxvY2FsaXplci5cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKG5hbWUsIGxvY2FsaXplcikge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBsb2NhbGl6ZXIgPSBuYW1lO1xuICAgICAgICAgICAgbmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBsb2NhbGl6ZXIgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgbG9jYWxpemVyLmZvcm1hdCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgdHlwZW9mIGxvY2FsaXplci5wYXJzZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgbG9jYWxpemVyLmludmFsaWQgJiYgdHlwZW9mIGxvY2FsaXplci5pbnZhbGlkICE9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBsb2NhbGl6ZXIuZXhwZWN0YXRpb24gJiYgdHlwZW9mIGxvY2FsaXplci5leHBlY3RhdGlvbiAhPT0gJ3N0cmluZydcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgbG9jYWxpemVyIG9iamVjdCB0byBjb25mb3JtIHRvIGludGVyZmFjZS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZSA9IG5hbWUgfHwgbG9jYWxpemVyLm5hbWU7XG4gICAgICAgIG5hbWUgPSBuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpc1tuYW1lXSA9IGxvY2FsaXplcjtcblxuICAgICAgICByZXR1cm4gbG9jYWxpemVyO1xuICAgIH0sXG4gICAgZGVwcmVjYXRlZDogZGVwcmVjYXRlZCxcbiAgICBzZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwcmVjYXRlZCgnc2V0KG5hbWUsIGxvY2FsaXplciknLCAnYWRkKG5hbWUsIGxvY2FsaXplciknLCAnMS4wLjYnLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbGl6ZXJOYW1lXG4gICAgICogQHJldHVybnMge2xvY2FsaXplckludGVyZmFjZX1cbiAgICAgKiBAbWVtYmVyT2YgTG9jYWxpemF0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpc1tuYW1lICYmIG5hbWUudG9Mb3dlckNhc2UoKV0gfHwgdGhpcy5zdHJpbmc7XG4gICAgfSxcblxuICAgIC8vLyAgLy8vICAvLy8gIC8vLyAgLy8vICAgIExPQ0FMSVpFUlMgICAgLy8vICAvLy8gIC8vLyAgLy8vICAvLy9cblxuICAgIC8vIFNwZWNpYWwgbG9jYWxpemVyIGZvciB1c2UgYnkgQ2hyb21lJ3MgZGF0ZSBpbnB1dCBjb250cm9sLlxuICAgIGNocm9tZURhdGU6IHtcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHl5ID0gZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgICAgICBtID0gZGF0ZS5nZXRNb250aCgpICsgMSwgbW0gPSBtIDwgMTAgPyAnMCcgKyBtIDogbSxcbiAgICAgICAgICAgICAgICAgICAgZCA9IGRhdGUuZ2V0RGF0ZSgpLCBkZCA9IGQgPCAxMCA/ICcwJyArIGQgOiBkO1xuXG4gICAgICAgICAgICAgICAgZGF0ZSA9IHl5ICsgJy0nICsgbW0gKyAnLScgKyBkZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIGRhdGUsXG4gICAgICAgICAgICAgICAgcGFydHMgPSBzdHIuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGlmIChwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUocGFydHNbMF0sIHBhcnRzWzFdIC0gMSwgcGFydHNbMl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG51bGw6IHtcbiAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHN0cmluZzoge1xuICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgKyAnJztcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ciArICcnO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbGl6YXRpb247XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qIGdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxudmFyIEJhc2UgPSByZXF1aXJlKCcuLi9CYXNlJyk7XG52YXIgaW1hZ2VzID0gcmVxdWlyZSgnLi4vLi4vaW1hZ2VzJyk7XG5cbi8qKiBAdHlwZWRlZiB7b2JqZWN0fSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAqIEBzZWUgW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAqL1xuXG4vKiogQHR5cGVkZWYge29iamVjdH0gdmlzaWJsZUNvbHVtbkRlc2NyaXB0b3JcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleCAtIEEgYmFjayByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQncyBhcnJheSBpbmRleCBpbiB7QGxpbmsgUmVuZGVyZXIjdmlzaWJsZUNvbHVtbnN9LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gRGVyZWZlcmVuY2VzIHtAbGluayBCZWhhdmlvciNjb2x1bW5zfSwgdGhlIHN1YnNldCBvZiBfYWN0aXZlXyBjb2x1bW5zLCBzcGVjaWZ5aW5nIHdoaWNoIGNvbHVtbiB0byBzaG93IGluIHRoYXQgcG9zaXRpb24uXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGVmdCAtIFBpeGVsIGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgZWRnZSBvZiB0aGlzIGNvbHVtbiwgcm91bmRlZCB0byBuZWFyZXN0IGludGVnZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmlnaHQgLSBQaXhlbCBjb29yZGluYXRlIG9mIHRoZSByaWdodCBlZGdlIG9mIHRoaXMgY29sdW1uLCByb3VuZGVkIHRvIG5lYXJlc3QgaW50ZWdlci5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHRoaXMgY29sdW1uIGluIHBpeGVscywgcm91bmRlZCB0byBuZWFyZXN0IGludGVnZXIuXG4gKi9cblxuLyoqIEB0eXBlZGVmIHtvYmplY3R9IHZpc2libGVSb3dEZXNjcmlwdG9yXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggLSBBIGJhY2sgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50J3MgYXJyYXkgaW5kZXggaW4ge0BsaW5rIFJlbmRlcmVyI3Zpc2libGVSb3dzfS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByb3dJbmRleCAtIExvY2FsIHZlcnRpY2FsIHJvdyBjb29yZGluYXRlIHdpdGhpbiB0aGUgc3ViZ3JpZCB0byB3aGljaCB0aGUgcm93IGJlbG9uZ3MsIGFkanVzdGVkIGZvciBzY3JvbGxpbmcuXG4gKiBAcHJvcGVydHkge0RhdGFNb2RlbH0gc3ViZ3JpZCAtIEEgcmVmZXJlbmNlIHRvIHRoZSBzdWJncmlkIHRvIHdoaWNoIHRoZSByb3cgYmVsb25ncy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3AgLSBQaXhlbCBjb29yZGluYXRlIG9mIHRoZSB0b3AgZWRnZSBvZiB0aGlzIHJvdywgcm91bmRlZCB0byBuZWFyZXN0IGludGVnZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm90dG9tIC0gUGl4ZWwgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhpcyByb3csIHJvdW5kZWQgdG8gbmVhcmVzdCBpbnRlZ2VyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGlzIHJvdyBpbiBwaXhlbHMsIHJvdW5kZWQgdG8gbmVhcmVzdCBpbnRlZ2VyLlxuICovXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZGVzYyBmaW4taHlwZXJncmlkLXJlbmRlcmVyIGlzIHRoZSBjYW52YXMgZW5hYmxlZCB0b3AgbGV2ZWwgc3ViIGNvbXBvbmVudCB0aGF0IGhhbmRsZXMgdGhlIHJlbmRlcmVyaW5nIG9mIHRoZSBHcmlkLlxuICpcbiAqIEl0IHJlbGllcyBvbiB0d28gb3RoZXIgZXh0ZXJuYWwgc3VicHJvamVjdHNcbiAqXG4gKiAxLiBmaW4tY2FudmFzOiBhIHdyYXBwZXIgdG8gcHJvdmlkZSBhIHNpbXBsZXIgaW50ZXJmYWNlIHRvIHRoZSBIVE1MNSBjYW52YXMgY29tcG9uZW50XG4gKiAyLiByZWN0YW5ndWxhcjogYSBzbWFsbCBucG0gbW9kdWxlIHByb3ZpZGluZyBQb2ludCBhbmQgUmVjdGFuZ2xlIG9iamVjdHNcbiAqXG4gKiBUaGUgZmluLWh5cGVyZ3JpZC1yZW5kZXJlciBpcyBpbiBhIHVuaXF1ZSBwb3NpdGlvbiB0byBwcm92aWRlIGNyaXRpY2FsIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIGZpbi1oeXBlcmdyaWQgaW4gYSBoaWdodGx5IHBlcmZvcm1hbnQgbWFubmVyLlxuICogQmVjYXVzZSBpdCBNVVNUIGl0ZXJhdGUgb3ZlciBhbGwgdGhlIHZpc2libGUgY2VsbHMgaXQgY2FuIHN0b3JlIHZhcmlvdXMgYml0cyBvZiBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBlbmNhcHN1bGF0ZWQgYXMgYSBzZXJ2aWNlIGZvciBjb25zdW1wdGlvbiBieSB0aGUgZmluLWh5cGVyZ3JpZCBjb21wb25lbnQuXG4gKlxuICogSW5zdGFuY2VzIG9mIHRoaXMgb2JqZWN0IGhhdmUgYmFzaWNhbGx5IGZvdXIgbWFpbiBmdW5jdGlvbnMuXG4gKlxuICogMS4gcmVuZGVyIGZpeGVkIHJvdyBoZWFkZXJzXG4gKiAyLiByZW5kZXIgZml4ZWQgY29sIGhlYWRlcnNcbiAqIDMuIHJlbmRlciBtYWluIGRhdGEgY2VsbHNcbiAqIDQuIHJlbmRlciBncmlkIGxpbmVzXG4gKlxuICogU2FtZSBwYXJhbWV0ZXJzIGFzIHtAbGluayBSZW5kZXJlciNpbml0aWFsaXplfGluaXRpYWxpemV9LCB3aGljaCBpcyBjYWxsZWQgYnkgdGhpcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKi9cbnZhciBSZW5kZXJlciA9IEJhc2UuZXh0ZW5kKCdSZW5kZXJlcicsIHtcblxuICAgIC8vdGhlIHNoYXJlZCBzaW5nbGUgaXRlbSBcInBvb2xlZFwiIGNlbGwgb2JqZWN0IGZvciBkcmF3aW5nIGVhY2ggY2VsbFxuICAgIGNlbGw6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgIH0sXG5cbiAgICBzY3JvbGxIZWlnaHQ6IDAsXG5cbiAgICB2aWV3SGVpZ2h0OiAwLFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJvdW5kcyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVuZGVyZWRDb2x1bW5NaW5XaWR0aHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgb3JkZXJlZCBzZXQgb2YgdmlzaWJsZSBjb2x1bW5zLiBBcnJheSBzaXplIGlzIGFsd2F5cyB0aGUgZXhhY3QgbnVtYmVyIG9mIHZpc2libGUgY29sdW1ucywgdGhlIGxhc3Qgb2Ygd2hpY2ggbWF5IG9ubHkgYmUgcGFydGlhbGx5IHZpc2libGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgc2VxdWVuY2Ugb2YgZWxlbWVudHMnIGBjb2x1bW5JbmRleGAgdmFsdWVzIGFzc3VtZXMgb25lIG9mIHRocmVlIHBhdHRlcm5zLiBXaGljaCBwYXR0ZXJuIGlzIGJhc2Ugb24gdGhlIGZvbGxvd2luZyB0d28gcXVlc3Rpb25zOlxuICAgICAgICAgKiAqIEFyZSB0aGVyZSBcImZpeGVkXCIgY29sdW1ucyBvbiB0aGUgbGVmdD9cbiAgICAgICAgICogKiBJcyB0aGUgZ3JpZCBob3Jpem9udGFsbHkgc2Nyb2xsZWQ/XG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzZXQgb2YgYGNvbHVtbkluZGV4YCB2YWx1ZXMgY29uc2lzdHMgb2Y6XG4gICAgICAgICAqIDEuIFRoZSBmaXJzdCBlbGVtZW50IHdpbGwgYmUgLTEgaWYgdGhlIHJvdyBoYW5kbGUgY29sdW1uIGlzIGJlaW5nIHJlbmRlcmVkLlxuICAgICAgICAgKiAyLiBBIHplcm8tYmFzZWQgbGlzdCBvZiBjb25zZWN1dGl2ZSBvZiBpbnRlZ2VycyByZXByZXNlbnRpbmcgdGhlIGZpeGVkIGNvbHVtbnMgKGlmIGFueSkuXG4gICAgICAgICAqIDMuIEFuIG4tYmFzZWQgbGlzdCBvZiBjb25zZWN1dGl2ZSBvZiBpbnRlZ2VycyByZXByZXNlbnRpbmcgdGhlIHNjcm9sbGFibGUgY29sdW1ucyAod2hlcmUgbiA9IG51bWJlciBvZiBmaXhlZCBjb2x1bW5zICsgdGhlIG51bWJlciBvZiBjb2x1bW5zIHNjcm9sbGVkIG9mZiB0byB0aGUgbGVmdCkuXG4gICAgICAgICAqIEB0eXBlIHt2aXNpYmxlQ29sdW1uRGVzY3JpcHRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgb3JkZXJlZCBzZXQgb2YgdmlzaWJsZSByb3dzLiBBcnJheSBzaXplIGlzIGFsd2F5cyB0aGUgZXhhY3QgbnVtYmVyIG9mIHZpc2libGUgcm93cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHNlcXVlbmNlIG9mIGVsZW1lbnRzJyBgcm93SW5kZXhgIHZhbHVlcyBpcyBsb2NhbCB0byBlYWNoIHN1YmdyaWQuXG4gICAgICAgICAqICogKipGb3IgZWFjaCBub24tc2Nyb2xsYWJsZSBzdWJncmlkOioqIFRoZSBzZXF1ZW5jZSBpcyBhIHplcm8tYmFzZWQgbGlzdCBvZiBjb25zZWN1dGl2ZSBpbnRlZ2Vycy5cbiAgICAgICAgICogKiAqKkZvciB0aGUgc2Nyb2xsYWJsZSBzdWJncmlkOioqXG4gICAgICAgICAqICAgMS4gQSB6ZXJvLWJhc2VkIGxpc3Qgb2YgY29uc2VjdXRpdmUgb2YgaW50ZWdlcnMgcmVwcmVzZW50aW5nIHRoZSBmaXhlZCByb3dzIChpZiBhbnkpLlxuICAgICAgICAgKiAgIDIuIEFuIG4tYmFzZWQgbGlzdCBvZiBjb25zZWN1dGl2ZSBvZiBpbnRlZ2VycyByZXByZXNlbnRpbmcgdGhlIHNjcm9sbGFibGUgcm93cyAod2hlcmUgbiA9IG51bWJlciBvZiBmaXhlZCByb3dzICsgdGhlIG51bWJlciBvZiByb3dzIHNjcm9sbGVkIG9mZiB0aGUgdG9wKS5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0IG5vbi1zY3JvbGxhYmxlIHN1YmdyaWRzIGNhbiBjb21lIGJvdGggYmVmb3JlIF9hbmRfIGFmdGVyIHRoZSBzY3JvbGxhYmxlIHN1YmdyaWQuXG4gICAgICAgICAqIEB0eXBlIHt2aXNpYmxlUm93RGVzY3JpcHRvcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlzaWJsZVJvd3MgPSBbXTtcblxuICAgICAgICB0aGlzLmluc2VydGlvbkJvdW5kcyA9IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb25zdHJ1Y3RvciBsb2dpY1xuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHVwb24gaW5zdGFudGlhdGlvbiBvZiB0aGlzIGNsYXNzIG9yIG9mIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgZnJvbSB0aGlzIGNsYXNzLlxuICAgICAqID4gQWxsIGBpbml0aWFsaXplKClgIG1ldGhvZHMgaW4gdGhlIGluaGVyaXRhbmNlIGNoYWluIGFyZSBjYWxsZWQsIGluIHR1cm4sIGVhY2ggd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBiZWdpbm5pbmcgd2l0aCB0aGF0IG9mIHRoZSBtb3N0IFwic2VuaW9yXCIgY2xhc3MgdGhyb3VnaCB0aGF0IG9mIHRoZSBjbGFzcyBvZiB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIHNldmVyYWwgZGF0YSBzdHJ1Y3R1cmVzOlxuICAgICAqICoge0BsaW5rIFJlbmRlcmVyI3Zpc2libGVDb2x1bW5zfVxuICAgICAqIE9yaWdpbmFsIGNvbW1lbnQ6XG4gICAgICogXCJ0aGlzIGZ1bmN0aW9uIGNvbXB1dGVzIHRoZSBncmlkIGNvb3JkaW5hdGVzIHVzZWQgZm9yIGV4dHJlbWVseSBmYXN0IGl0ZXJhdGlvbiBvdmVyXG4gICAgICogcGFpbnRpbmcgdGhlIGdyaWQgY2VsbHMuIHRoaXMgZnVuY3Rpb24gaXMgdmVyeSBmYXN0LCBmb3IgdGhvdXNhbmQgcm93cyBYIDEwMCBjb2x1bW5zXG4gICAgICogb24gYSBtb2Rlc3QgbWFjaGluZSB0YWtpbmcgdXN1YWxseSAwbXMgYW5kIG5vIG1vcmUgdGhhdCAzIG1zLlwiXG4gICAgICovXG4gICAgY29tcHV0ZUNlbGxzQm91bmRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvL3ZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLmdldFNjcm9sbFRvcCgpLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IHRoaXMuZ2V0U2Nyb2xsTGVmdCgpLFxuXG4gICAgICAgICAgICBmaXhlZENvbHVtbkNvdW50ID0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICBmaXhlZFJvd0NvdW50ID0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCksXG5cbiAgICAgICAgICAgIG51bVJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCksXG4gICAgICAgICAgICBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuICAgICAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZCxcbiAgICAgICAgICAgIGJlaGF2aW9yID0gZ3JpZC5iZWhhdmlvcixcbiAgICAgICAgICAgIGVkaXRvckNlbGxFdmVudCA9IGdyaWQuY2VsbEVkaXRvciAmJiBncmlkLmNlbGxFZGl0b3IuZXZlbnQsXG4gICAgICAgICAgICBkeCA9IGVkaXRvckNlbGxFdmVudCAmJiBlZGl0b3JDZWxsRXZlbnQuZ3JpZENlbGwueCxcbiAgICAgICAgICAgIGR5ID0gZWRpdG9yQ2VsbEV2ZW50ICYmIGVkaXRvckNlbGxFdmVudC5kYXRhQ2VsbC55LFxuICAgICAgICAgICAgdmNFZCxcbiAgICAgICAgICAgIHZyRWQsXG5cbiAgICAgICAgICAgIGluc2VydGlvbkJvdW5kc0N1cnNvciA9IDAsXG4gICAgICAgICAgICBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlID0gMCxcblxuICAgICAgICAgICAgbGluZVdpZHRoID0gZ3JpZC5wcm9wZXJ0aWVzLmxpbmVXaWR0aCxcblxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLmdyaWQuaXNTaG93Um93TnVtYmVycygpID8gLTEgOiAwLFxuICAgICAgICAgICAgeCwgWCwgLy8gaG9yaXpvbnRhbCBwaXhlbCBsb29wIGluZGV4IGFuZCBsaW1pdFxuICAgICAgICAgICAgeSwgWSwgLy8gdmVydGljYWwgcGl4ZWwgbG9vcCBpbmRleCBhbmQgbGltaXRcbiAgICAgICAgICAgIGMsIEMsIC8vIGNvbHVtbiBsb29wIGluZGV4IGFuZCBsaW1pdFxuICAgICAgICAgICAgZywgRywgLy8gc3ViZ3JpZCBsb29wIGluZGV4IGFuZCBsaW1pdFxuICAgICAgICAgICAgciwgUiwgLy8gcm93IGxvb3AgaW5kZXggYW5kIGxpbWl0cm93cyBpbiBjdXJyZW50IHN1YmdyaWRcbiAgICAgICAgICAgIHN1YnJvd3MsIC8vIHJvd3MgaW4gc3ViZ3JpZCBnXG4gICAgICAgICAgICBiYXNlLCAvLyBzdW0gb2Ygcm93cyBmb3IgYWxsIHN1YmdyaWRzIHNvIGZhclxuICAgICAgICAgICAgc3ViZ3JpZHMgPSBiZWhhdmlvci5zdWJncmlkcyxcbiAgICAgICAgICAgIHN1YmdyaWQsXG4gICAgICAgICAgICByb3dJbmRleCxcbiAgICAgICAgICAgIHNjcm9sbGFibGVTdWJncmlkLFxuICAgICAgICAgICAgZm9vdGVySGVpZ2h0LFxuICAgICAgICAgICAgdngsIHZ5LFxuICAgICAgICAgICAgdnIsIHZjLFxuICAgICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgIGZpcnN0VlgsIGxhc3RWWCxcbiAgICAgICAgICAgIGZpcnN0VlksIGxhc3RWWSxcbiAgICAgICAgICAgIHRvcFIsXG4gICAgICAgICAgICB4U3BhY2VkLCB3aWR0aFNwYWNlZCwgaGVpZ2h0U3BhY2VkOyAvLyBhZGp1c3RlZCBmb3IgY2VsbCBzcGFjaW5nXG5cbiAgICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSAwO1xuXG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy52aXNpYmxlUm93cy5sZW5ndGggPSAwO1xuXG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnNCeUluZGV4ID0gW107IC8vIGFycmF5IGJlY2F1c2UgbnVtYmVyIG9mIGNvbHVtbnMgd2lsbCBhbHdheXMgYmUgcmVhc29uYWJsZVxuICAgICAgICB0aGlzLnZpc2libGVSb3dzQnlEYXRhUm93SW5kZXggPSB7fTsgLy8gaGFzaCBiZWNhdXNlIGtleWVkIGJ5IChmaXhlZCBhbmQpIHNjcm9sbGVkIHJvdyBpbmRleGVzXG5cbiAgICAgICAgdGhpcy5pbnNlcnRpb25Cb3VuZHMgPSBbXTtcblxuICAgICAgICBmb3IgKFxuICAgICAgICAgICAgeCA9IDAsIGMgPSBzdGFydCwgQyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSwgWCA9IGJvdW5kcy53aWR0aCB8fCBncmlkLmNhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIGMgPCBDICYmIHggPD0gWDtcbiAgICAgICAgICAgIGMrK1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHZ4ID0gYztcbiAgICAgICAgICAgIGlmIChjID49IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgICAgICBsYXN0VlggPSB2eCArPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFZYID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RWWCA9IGxhc3RWWDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodnggPj0gQykge1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBzY3JvbGxlZCBiZXlvbmQgbGFzdCBjb2x1bW5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2lkdGggPSBncmlkLmdldENvbHVtbldpZHRoKHZ4KTtcblxuICAgICAgICAgICAgeFNwYWNlZCA9IHggPyB4ICsgbGluZVdpZHRoIDogeDtcbiAgICAgICAgICAgIHdpZHRoU3BhY2VkID0geCA/IHdpZHRoIC0gbGluZVdpZHRoIDogd2lkdGg7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVDb2x1bW5zW2NdID0gdGhpcy52aXNpYmxlQ29sdW1uc0J5SW5kZXhbdnhdID0gdmMgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGMsXG4gICAgICAgICAgICAgICAgY29sdW1uSW5kZXg6IHZ4LFxuICAgICAgICAgICAgICAgIGxlZnQ6IHhTcGFjZWQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoU3BhY2VkLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB4U3BhY2VkICsgd2lkdGhTcGFjZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZHggPT09IHZ4KSB7XG4gICAgICAgICAgICAgICAgdmNFZCA9IHZjO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4ICs9IHdpZHRoO1xuXG4gICAgICAgICAgICBpbnNlcnRpb25Cb3VuZHNDdXJzb3IgKz0gTWF0aC5yb3VuZCh3aWR0aCAvIDIpICsgcHJldmlvdXNJbnNlcnRpb25Cb3VuZHNDdXJzb3JWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0aW9uQm91bmRzLnB1c2goaW5zZXJ0aW9uQm91bmRzQ3Vyc29yKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5zZXJ0aW9uQm91bmRzQ3Vyc29yVmFsdWUgPSBNYXRoLnJvdW5kKHdpZHRoIC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICBmb290ZXJIZWlnaHQgPSBncmlkLnByb3BlcnRpZXMuZGVmYXVsdFJvd0hlaWdodCAqIHN1YmdyaWRzLnJlZHVjZShmdW5jdGlvbihyb3dzLCBzdWJncmlkKSB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsYWJsZVN1YmdyaWQpIHtcbiAgICAgICAgICAgICAgICByb3dzICs9IHN1YmdyaWQuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsYWJsZVN1YmdyaWQgPSAhc3ViZ3JpZC50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgICBiYXNlID0gciA9IGcgPSB5ID0gMCwgRyA9IHN1YmdyaWRzLmxlbmd0aCwgWSA9IGJvdW5kcy5oZWlnaHQgLSBmb290ZXJIZWlnaHQ7XG4gICAgICAgICAgICBnIDwgRztcbiAgICAgICAgICAgIGcrKywgYmFzZSArPSBzdWJyb3dzXG4gICAgICAgICkge1xuICAgICAgICAgICAgc3ViZ3JpZCA9IHN1YmdyaWRzW2ddO1xuICAgICAgICAgICAgc3Vicm93cyA9IHN1YmdyaWQuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgICAgIHNjcm9sbGFibGVTdWJncmlkID0gIXN1YmdyaWQudHlwZTtcbiAgICAgICAgICAgIHRvcFIgPSByO1xuXG4gICAgICAgICAgICAvLyBGb3IgZWFjaCByb3cgb2YgZWFjaCBzdWJncmlkLi4uXG4gICAgICAgICAgICBmb3IgKFIgPSBNYXRoLm1pbihudW1Sb3dzLCByICsgc3Vicm93cyk7IHIgPCBSICYmIHkgPCBZOyByKyspIHtcbiAgICAgICAgICAgICAgICB2eSA9IHI7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGFibGVTdWJncmlkICYmIHIgPj0gZml4ZWRSb3dDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICB2eSArPSBzY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RWWSA9IHZ5IC0gYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0VlkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RWWSA9IGxhc3RWWTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodnkgPj0gUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIHNjcm9sbGVkIGJleW9uZCBsYXN0IHJvd1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICByb3dJbmRleCA9IHZ5IC0gYmFzZTtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBiZWhhdmlvci5nZXRSb3dIZWlnaHQocm93SW5kZXgsIHN1YmdyaWQpO1xuXG4gICAgICAgICAgICAgICAgaGVpZ2h0U3BhY2VkID0gaGVpZ2h0IC0gbGluZVdpZHRoO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaWJsZVJvd3Nbcl0gPSB2ciA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHIsXG4gICAgICAgICAgICAgICAgICAgIHN1YmdyaWQ6IHN1YmdyaWQsXG4gICAgICAgICAgICAgICAgICAgIHJvd0luZGV4OiByb3dJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB5LFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodFNwYWNlZCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiB5ICsgaGVpZ2h0U3BhY2VkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsYWJsZVN1YmdyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlUm93c0J5RGF0YVJvd0luZGV4W3Z5IC0gYmFzZV0gPSB2cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR5ID09PSByb3dJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdnJFZCA9IHZyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeSArPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JvbGxhYmxlU3ViZ3JpZCkge1xuICAgICAgICAgICAgICAgIHN1YnJvd3MgPSByIC0gdG9wUjtcbiAgICAgICAgICAgICAgICBZICs9IGZvb3RlckhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGl0b3JDZWxsRXZlbnQpIHtcbiAgICAgICAgICAgIGVkaXRvckNlbGxFdmVudC52aXNpYmxlQ29sdW1uID0gdmNFZDtcbiAgICAgICAgICAgIGVkaXRvckNlbGxFdmVudC52aXNpYmxlUm93ID0gdnJFZDtcbiAgICAgICAgICAgIGVkaXRvckNlbGxFdmVudC5ncmlkQ2VsbC55ID0gdnJFZCAmJiB2ckVkLmluZGV4O1xuICAgICAgICAgICAgZWRpdG9yQ2VsbEV2ZW50Ll9ib3VuZHMgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aWV3SGVpZ2h0ID0gWTtcblxuICAgICAgICB0aGlzLmRhdGFXaW5kb3cgPSB0aGlzLmdyaWQubmV3UmVjdGFuZ2xlKGZpcnN0VlgsIGZpcnN0VlksIGxhc3RWWCAtIGZpcnN0VlgsIGxhc3RWWSAtIGZpcnN0VlkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBLZWVwIGluIHBsYWNlISBVc2VkIGJ5IGZpbi1jYW52YXMuXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGEgcHJvcGVydHkgdmFsdWUgYXQgYSBrZXksIGRlbGVnYXRlcyB0byB0aGUgZ3JpZFxuICAgICAqL1xuICAgIHJlc29sdmVQcm9wZXJ0eTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQucHJvcGVydGllc1trZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgTm90aWZ5IHRoZSBmaW4taHlwZXJncmlkIGV2ZXJ5dGltZSB3ZSd2ZSByZXBhaW50ZWQuXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHBhaW50OiBmdW5jdGlvbihnYykge1xuICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzRGF0YSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmdyaWQucHJvcGVydGllcy5ub0RhdGFNZXNzYWdlO1xuICAgICAgICAgICAgICAgIGdjLmZvbnQgPSAnMjBweCBBcmlhbCc7XG4gICAgICAgICAgICAgICAgZ2MuZmlsbFRleHQobWVzc2FnZSwgMjAsIDMwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJHcmlkKGdjKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFzRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ncmlkLmJlaGF2aW9yLmdldERhdGEoKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQW5zd2VyIGhvdyBtYW55IHJvd3Mgd2UgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93c0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVJvd3MubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgZ2V0VmlzaWJsZVNjcm9sbEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdIZWlnaHQgLSB0aGlzLmdyaWQuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IFJvd3Mgd2UganVzdCByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHdhcm4oJ2dldFZpc2libGVSb3dzJywgJ1RoZSBnZXRWaXNpYmxlUm93cygpIG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHYxLjIuMCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIFByZXZpb3VzbHkgcmV0dXJuZWQgdGhlIHRoaXMudmlzaWJsZVJvd3MgYXJyYXkgYnV0IGJlY2F1c2UgdGhpcy52aXNpYmxlUm93cyBpcyBubyBsb25nZXIgYSBzaW1wbGUgYXJyYXkgb2YgaW50ZWdlcnMgYnV0IGlzIG5vdyBhbiBhcnJheSBvZiBvYmplY3RzLCBpdCBub3cgcmV0dXJucyBhbiBhcnJheSBtYXBwZWQgdG8gdGhpcy52aXNpYmxlUm93c1sqXS5yb3dJbmRleC4gTm90ZSBob3dldmVyIHRoYXQgdGhpcyBtYXBwaW5nIGlzIG5vdCBlcXVpdmFsZW50IHRvIHdoYXQgdGhpcyBtZXRob2QgcHJldmlvdXNseSByZXR1cm5lZCBiZWNhdXNlIHdoaWxlIGVhY2ggb2JqZWN0XFwncyAucm93SW5kZXggcHJvcGVydHkgaXMgc3RpbGwgYWRqdXN0ZWQgZm9yIHNjcm9sbGluZyB3aXRoaW4gdGhlIGRhdGEgc3ViZ3JpZCwgdGhlIGluZGV4IGlzIG5vdyBsb2NhbCB0byAoemVyby1iYXNlZCB3aXRoaW4pIGVhY2ggc3ViZ3JpZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlUm93cy5tYXAoZnVuY3Rpb24odnIpIHsgcmV0dXJuIHZyLnJvd0luZGV4OyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBjb2x1bW5zIHdlIGp1c3QgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnNDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aCAtIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDb2x1bW5zIHdlIGp1c3QgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB3YXJuKCd2aXNpYmxlQ29sdW1ucycsICdUaGUgZ2V0VmlzaWJsZUNvbHVtbnMoKSBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2MS4yLjAgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBQcmV2aW91c2x5IHJldHVybmVkIHRoZSB0aGlzLnZpc2libGVDb2x1bW5zIGJ1dCBiZWNhdXNlIHRoaXMudmlzaWJsZUNvbHVtbnMgaXMgbm8gbG9uZ2VyIGEgc2ltcGxlIGFycmF5IG9mIGludGVnZXJzIGJ1dCBpcyBub3cgYW4gYXJyYXkgb2Ygb2JqZWN0cywgaXQgbm93IHJldHVybnMgYW4gYXJyYXkgbWFwcGVkIHRvIHRoZSBlcXVpdmFsZW50IHZpc2libGVDb2x1bW5zWypdLmNvbHVtbkluZGV4LicpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQ29sdW1ucy5tYXAoZnVuY3Rpb24odmMpIHsgcmV0dXJuIHZjLmNvbHVtbkluZGV4OyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjb2x1bW4gaW5kZXggd2hlbiB0aGUgbW91c2VFdmVudCBjb29yZGluYXRlcyBhcmUgb3ZlciBhIGNvbHVtbiBkaXZpZGVyLlxuICAgICAqL1xuICAgIG92ZXJDb2x1bW5EaXZpZGVyOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciB2YyA9IHRoaXMudmlzaWJsZUNvbHVtbnMsXG4gICAgICAgICAgICB4aSA9IE1hdGgucm91bmQoeCksXG4gICAgICAgICAgICB4MSA9IHhpIC0gMyxcbiAgICAgICAgICAgIHgyID0geGkgKyAxO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSAoLTEgaW4gdmMgPyAtMSA6IDApLCBDID0gdmMubGVuZ3RoOyBjIDwgQzsgKytjKSB7XG4gICAgICAgICAgICB4ID0gdmNbY10ucmlnaHQ7XG4gICAgICAgICAgICBpZiAoeDEgPD0geCAmJiB4IDw9IHgyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdyBpbmRleCB3aGVuIHRoZSBtb3VzZUV2ZW50IGNvb3JkaW5hdGVzIGFyZSBvdmVyIGEgcm93IGRpdmlkZXIuXG4gICAgICovXG4gICAgb3ZlclJvd0RpdmlkZXI6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdmFyIHZyID0gdGhpcy52aXNpYmxlUm93cyxcbiAgICAgICAgICAgIHlpID0gTWF0aC5yb3VuZCh5KSxcbiAgICAgICAgICAgIHkxID0geWkgLSAzLFxuICAgICAgICAgICAgeTIgPSB5aSArIDE7XG5cbiAgICAgICAgZm9yICh2YXIgciA9IDAsIFIgPSB2ci5sZW5ndGg7IHIgPCBSOyArK3IpIHtcbiAgICAgICAgICAgIHkgPSB2cltyXS5ib3R0b207XG4gICAgICAgICAgICBpZiAoeTEgPD0geSAmJiB5IDw9IHkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtDZWxsRXZlbnR8bnVtYmVyfSB4IC0gQ2VsbEV2ZW50IG9iamVjdCBvciBncmlkIGNvbHVtbiBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeV0gLSBHcmlkIHJvdyBjb29yZGluYXRlLiBPbWl0IGlmIGB4T3JDZWxsRXZlbnRgIGlzIGEgQ2VsbEV2ZW50LlxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IEJvdW5kaW5nIHJlY3Qgb2YgY2VsbCB3aXRoIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBnZXRCb3VuZHNPZkNlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHZjID0gdGhpcy52aXNpYmxlQ29sdW1uc1t4XSxcbiAgICAgICAgICAgIHZyID0gdGhpcy52aXNpYmxlUm93c1t5XTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogdmMubGVmdCxcbiAgICAgICAgICAgIHk6IHZyLnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiB2Yy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdnIuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbnN3ZXIgdGhlIGNvbHVtbiBpbmRleCB1bmRlciB0aGUgY29vcmRpbmF0ZSBhdCBwaXhlbFhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxYIC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY29sdW1uIGluZGV4IHVuZGVyIHRoZSBjb29yZGluYXRlIGF0IHBpeGVsWC5cbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Gcm9tUGl4ZWxYOiBmdW5jdGlvbihwaXhlbFgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gMCxcbiAgICAgICAgICAgIGZpeGVkQ29sdW1uQ291bnQgPSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSB0aGlzLmdyaWQuZ2V0SFNjcm9sbFZhbHVlKCksXG4gICAgICAgICAgICB2aXNpYmxlQ29sdW1ucyA9IHRoaXMudmlzaWJsZUNvbHVtbnM7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDE7IGMgPCB2aXNpYmxlQ29sdW1ucy5sZW5ndGggLSAxOyBjKyspIHtcbiAgICAgICAgICAgIHdpZHRoID0gdmlzaWJsZUNvbHVtbnNbY10ubGVmdCAtICh2aXNpYmxlQ29sdW1uc1tjXS5sZWZ0IC0gdmlzaWJsZUNvbHVtbnNbYyAtIDFdLmxlZnQpIC8gMjtcbiAgICAgICAgICAgIGlmIChwaXhlbFggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIGlmIChjID4gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgICAgICAgICBjICs9IHNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA+IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIGMgKz0gc2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYyAtIDE7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFuc3dlciBzcGVjaWZpYyBkYXRhIGNlbGwgY29vcmRpbmF0ZXMgZ2l2ZW4gbW91c2UgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gICAgICogQHJldHVybnMge1BvaW50fSBDZWxsIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICAgICAgeSA9IHBvaW50LnksXG4gICAgICAgICAgICB2cnMgPSB0aGlzLnZpc2libGVSb3dzLFxuICAgICAgICAgICAgdmNzID0gdGhpcy52aXNpYmxlQ29sdW1ucyxcbiAgICAgICAgICAgIGZpcnN0Q29sdW1uID0gdmNzW3RoaXMuZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkgPyAtMSA6IDBdLFxuICAgICAgICAgICAgaW5GaXJzdENvbHVtbiA9IHggPCBmaXJzdENvbHVtbi5yaWdodCxcbiAgICAgICAgICAgIHZjID0gaW5GaXJzdENvbHVtbiA/IGZpcnN0Q29sdW1uIDogdmNzLmZpbmQoZnVuY3Rpb24odmMpIHsgcmV0dXJuIHggPCB2Yy5yaWdodDsgfSkgfHwgdmNzW3Zjcy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHZyID0gdnJzLmZpbmQoZnVuY3Rpb24odnIpIHsgcmV0dXJuIHkgPCB2ci5ib3R0b207IH0pIHx8IHZyc1t2cnMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBtb3VzZVBvaW50ID0gdGhpcy5ncmlkLm5ld1BvaW50KHggLSB2Yy5sZWZ0LCB5IC0gdnIudG9wKSxcbiAgICAgICAgICAgIGNlbGxFdmVudCA9IG5ldyB0aGlzLmdyaWQuYmVoYXZpb3IuQ2VsbEV2ZW50KHZjLmNvbHVtbkluZGV4LCB2ci5pbmRleCk7XG5cbiAgICAgICAgLy8gY2VsbEV2ZW50LnZpc2libGVDb2x1bW4gPSB2YztcbiAgICAgICAgLy8gY2VsbEV2ZW50LnZpc2libGVSb3cgPSB2cjtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNlbGxFdmVudCwgJ21vdXNlUG9pbnQnLCB7IHZhbHVlOiBtb3VzZVBvaW50IH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbiBpcyB2aXNpYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleCAtIHRoZSBjb2x1bW4gaW5kZXgqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjb2x1bW4gaXMgZnVsbHkgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc0NvbHVtblZpc2libGU6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMudmlzaWJsZUNvbHVtbnMuZmluZChmdW5jdGlvbih2YykgeyByZXR1cm4gdmMuY29sdW1uSW5kZXggPT09IGNvbHVtbkluZGV4OyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB3aWR0aCB4IGNvb3JkaW5hdGUgb2YgdGhlIGxhc3QgcmVuZGVyZWQgY29sdW1uXG4gICAgICovXG4gICAgZ2V0RmluYWxWaXNpYmxlQ29sdW1uQm91bmRhcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hvcCA9IHRoaXMuaXNMYXN0Q29sdW1uVmlzaWJsZSgpID8gMiA6IDE7XG4gICAgICAgIHZhciBjb2xXYWxsID0gdGhpcy52aXNpYmxlQ29sdW1uc1t0aGlzLnZpc2libGVDb2x1bW5zLmxlbmd0aCAtIGNob3BdLnJpZ2h0O1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oY29sV2FsbCwgdGhpcy5nZXRCb3VuZHMoKS53aWR0aCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIHZpc2liaWxpdHkgb2YgYSByb3cuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgcGh5c2ljYWwgKHVuc2Nyb2xsZWQpIGdyaWQgcm93IGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gcm93IGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICovXG4gICAgaXNSb3dWaXNpYmxlOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMudmlzaWJsZVJvd3NbeV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBEZXRlcm1pbmVzIGlmIGEgY2VsbCBpcyBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IGNlbGwgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgY2VsbCBjb29yZGluYXRlKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY2VsbCBpcyBmdWxseSB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5pc1NlbGVjdGVkKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgbWFpbiBmb3JraW5nIG9mIHRoZSByZW5kZXJlcmluZyB0YXNrLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnY1xuICAgICAqL1xuICAgIHJlbmRlckdyaWQ6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHRoaXMucGFpbnRDZWxscyhnYyk7XG4gICAgICAgIHRoaXMucmVuZGVyT3ZlcnJpZGVzKGdjKTtcbiAgICAgICAgdGhpcy5yZW5kZXJMYXN0U2VsZWN0aW9uKGdjKTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIHJlbmRlckxhc3RTZWxlY3Rpb246IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJMYXN0U2VsZWN0aW9uKGdjKTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIF9yZW5kZXJMYXN0U2VsZWN0aW9uOiBmdW5jdGlvbihnYykge1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ3JpZC5zZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmICghc2VsZWN0aW9ucyB8fCBzZWxlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdyaWQuc2VsZWN0aW9uTW9kZWwuZ2V0TGFzdFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24ub3JpZ2luLnggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBubyBzZWxlY3RlZCBhcmVhLCBsZXRzIGV4aXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2Y2kgPSB0aGlzLnZpc2libGVDb2x1bW5zQnlJbmRleCxcbiAgICAgICAgICAgIHZyaSA9IHRoaXMudmlzaWJsZVJvd3NCeURhdGFSb3dJbmRleCxcbiAgICAgICAgICAgIGxhc3RDb2x1bW4gPSB0aGlzLnZpc2libGVDb2x1bW5zW3RoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoIC0gMV0sIC8vIGxhc3QgY29sdW1uIGluIHNjcm9sbGFibGUgc2VjdGlvblxuICAgICAgICAgICAgbGFzdFJvdyA9IHZyaVt0aGlzLmRhdGFXaW5kb3cuY29ybmVyLnldOyAvLyBsYXN0IHJvdyBpbiBzY3JvbGxhYmxlIGRhdGEgc2VjdGlvblxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFsYXN0Q29sdW1uIHx8ICFsYXN0Um93IHx8XG4gICAgICAgICAgICBzZWxlY3Rpb24ub3JpZ2luLnggPiBsYXN0Q29sdW1uLmNvbHVtbkluZGV4IHx8XG4gICAgICAgICAgICBzZWxlY3Rpb24ub3JpZ2luLnkgPiBsYXN0Um93LnJvd0luZGV4XG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIGFyZWEgYmVnaW5zIHRvIHJpZ2h0IG9yIGJlbG93IGdyaWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2Y09yaWdpbiA9IHZjaVtzZWxlY3Rpb24ub3JpZ2luLnhdLFxuICAgICAgICAgICAgdmNDb3JuZXIgPSB2Y2lbc2VsZWN0aW9uLmNvcm5lci54XSxcbiAgICAgICAgICAgIHZyT3JpZ2luID0gdnJpW3NlbGVjdGlvbi5vcmlnaW4ueV0sXG4gICAgICAgICAgICB2ckNvcm5lciA9IHZyaVtzZWxlY3Rpb24uY29ybmVyLnldO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEodmNPcmlnaW4gfHwgdmNDb3JuZXIpIHx8IC8vIGVudGlyZSBzZWxlY3Rpb24gc2Nyb2xsZWQgb3V0IG9mIHZpZXcgdG8gbGVmdCBvZiBzY3JvbGxhYmxlIHJlZ2lvblxuICAgICAgICAgICAgISh2ck9yaWdpbiB8fCB2ckNvcm5lcikgICAgLy8gZW50aXJlIHNlbGVjdGlvbiBzY3JvbGxlZCBvdXQgb2YgdmlldyBhYm92ZSBzY3JvbGxhYmxlIHJlZ2lvblxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMuZ3JpZC5wcm9wZXJ0aWVzO1xuICAgICAgICB2Y09yaWdpbiA9IHZjT3JpZ2luIHx8IGxhc3RDb2x1bW47XG4gICAgICAgIHZjQ29ybmVyID0gdmNDb3JuZXIgfHwgc2VsZWN0aW9uLmNvcm5lci54ID4gbGFzdENvbHVtbi5jb2x1bW5JbmRleFxuICAgICAgICAgICAgPyBsYXN0Q29sdW1uLmNvbHVtbkluZGV4XG4gICAgICAgICAgICA6IHZjaVtwcm9wcy5maXhlZENvbHVtbkNvdW50IC0gMV07XG4gICAgICAgIHZyT3JpZ2luID0gdnJPcmlnaW4gfHwgbGFzdFJvdztcbiAgICAgICAgdnJDb3JuZXIgPSB2ckNvcm5lciB8fCBzZWxlY3Rpb24uY29ybmVyLnkgPiBsYXN0Um93LnJvd0luZGV4XG4gICAgICAgICAgICA/IGxhc3RSb3cucm93SW5kZXhcbiAgICAgICAgICAgIDogdnJpW3Byb3BzLmZpeGVkUm93Q291bnQgLSAxXTtcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIHNlbGVjdGlvbiBtb2RlbCBhcm91bmQgdGhlIGJvdW5kc1xuICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgYm91bmRzOiB7XG4gICAgICAgICAgICAgICAgeDogdmNPcmlnaW4ubGVmdCxcbiAgICAgICAgICAgICAgICB5OiB2ck9yaWdpbi50b3AsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHZjQ29ybmVyLnJpZ2h0IC0gdmNPcmlnaW4ubGVmdCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHZyQ29ybmVyLmJvdHRvbSAtIHZyT3JpZ2luLnRvcFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdGlvblJlZ2lvbk92ZXJsYXlDb2xvcjogdGhpcy5ncmlkLnByb3BlcnRpZXMuc2VsZWN0aW9uUmVnaW9uT3ZlcmxheUNvbG9yLFxuICAgICAgICAgICAgc2VsZWN0aW9uUmVnaW9uT3V0bGluZUNvbG9yOiB0aGlzLmdyaWQucHJvcGVydGllcy5zZWxlY3Rpb25SZWdpb25PdXRsaW5lQ29sb3JcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ncmlkLmNlbGxSZW5kZXJlcnMuZ2V0KCdsYXN0c2VsZWN0aW9uJykucGFpbnQoZ2MsIGNvbmZpZyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBpdGVyYXRlIHRoZSByZW5kZXJlcmluZyBvdmVycmlkZXMgYW5kIG1hbmlmZXN0IGVhY2hcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAgICAgKi9cbiAgICByZW5kZXJPdmVycmlkZXM6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIHZhciBjYWNoZSA9IHRoaXMuZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgICAgICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBvdmVycmlkZSA9IGNhY2hlW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyT3ZlcnJpZGUoZ2MsIG92ZXJyaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNvcHkgZWFjaCBvdmVycmlkZXMgc3BlY2lmaWVkIGFyZWEgdG8gaXQncyB0YXJnZXQgYW5kIGJsYW5rIG91dCB0aGUgc291cmNlIGFyZWFcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAgICAgKiBAcGFyYW0ge092ZXJyaWRlT2JqZWN0fSBvdmVycmlkZSAtIGFuIG9iamVjdCB3aXRoIGRldGFpbHMgY29udGFpbiBhbiBhcmVhIGFuZCBhIHRhcmdldCBjb250ZXh0XG4gICAgICovXG4gICAgcmVuZGVyT3ZlcnJpZGU6IGZ1bmN0aW9uKGdjLCBvdmVycmlkZSkge1xuICAgICAgICAvL2xldHMgYmxhbmsgb3V0IHRoZSBkcmFnIHJvd1xuICAgICAgICB2YXIgaGRwaVJhdGlvID0gb3ZlcnJpZGUuaGRwaXJhdGlvO1xuICAgICAgICB2YXIgc3RhcnRYID0gb3ZlcnJpZGUuc3RhcnRYOyAvL2hkcGlSYXRpbyAqIGVkZ2VzW292ZXJyaWRlLmNvbHVtbkluZGV4XTtcbiAgICAgICAgdmFyIHdpZHRoID0gb3ZlcnJpZGUud2lkdGggKyAxO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gb3ZlcnJpZGUuaGVpZ2h0O1xuICAgICAgICB2YXIgdGFyZ2V0Q1RYID0gb3ZlcnJpZGUuY3R4O1xuICAgICAgICB2YXIgaW1nRGF0YSA9IGdjLmdldEltYWdlRGF0YShzdGFydFgsIDAsIE1hdGgucm91bmQod2lkdGggKiBoZHBpUmF0aW8pLCBNYXRoLnJvdW5kKGhlaWdodCAqIGhkcGlSYXRpbykpO1xuICAgICAgICB0YXJnZXRDVFgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSB0aGlzLmdyaWQucHJvcGVydGllcy5iYWNrZ3JvdW5kQ29sb3IyO1xuICAgICAgICBnYy5maWxsUmVjdChNYXRoLnJvdW5kKHN0YXJ0WCAvIGhkcGlSYXRpbyksIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gQ3VycmVudCB2ZXJ0aWNhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsVG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEN1cnJlbnQgaG9yaXpvbnRhbCBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0U2Nyb2xsTGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkVkZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgd2FybignY29sdW1uRWRnZXMnLCAnVGhlIGdldENvbHVtbkVkZ2VzKCkgbWVodG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYXMgb2YgdmVyc2lvbiAxLjIuMCBpbiBmYXZvciBvZiB2aXNpYmxlQ29sdW1uc1sqXS50b3AgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBOb3RlIGhvd2V2ZXIgdGhhdCBjb2x1bW5FZGdlcyBoYWQgb25lIGFkZGl0aW9uYWwgZWxlbWVudCAocmVwcmVzZW50aW5nIHRoZSByaWdodCBlZGdlIG9mIHRoZSBsYXN0IHZpc2libGUgY29sdW1uKSB3aGljaCB2aXNpYmxlQ29sdW1ucyBsYWNrcy4gSW5zdGVhZCB5b3UgY2FuIHJlZmVyZW5jZSB2aXNpYmxlQ29sdW1uc1sqXS5ib3R0b20uJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb2x1bW5zLm1hcChmdW5jdGlvbih2YykgeyByZXR1cm4gdmMubGVmdDsgfSkuY29uY2F0KFt0aGlzLnZpc2libGVDb2x1bW5zW3RoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoIC0gMV0ucmlnaHRdKTtcbiAgICB9LFxuXG4gICAgZ2V0Um93RWRnZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB3YXJuKCdyb3dFZGdlcycsICdUaGUgZ2V0Um93RWRnZXMoKSBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2ZXJzaW9uIDEuMi4wIGluIGZhdm9yIG9mIHZpc2libGVSb3dzWypdLnRvcCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIE5vdGUgaG93ZXZlciB0aGF0IHJvd0VkZ2VzIGhhZCBvbmUgYWRkaXRpb25hbCBlbGVtZW50IChyZXByZXNlbnRpbmcgdGhlIGJvdHRvbSBlZGdlIG9mIHRoZSBsYXN0IHZpc2libGUgcm93KSB3aGljaCB2aXNpYmxlUm93cyBsYWNrcy4gSW5zdGVhZCB5b3UgY2FuIHJlZmVyZW5jZSB2aXNpYmxlUm93c1sqXS5ib3R0b20uJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVSb3dzLm1hcChmdW5jdGlvbih2cikgeyByZXR1cm4gdnIudG9wOyB9KS5jb25jYXQoW3RoaXMudmlzaWJsZVJvd3NbdGhpcy52aXNpYmxlUm93cy5sZW5ndGggLSAxXS5ib3R0b21dKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgbGFzdCBjb2wgd2FzIHJlbmRlcmVkIChpcyB2aXNpYmxlKVxuICAgICAqL1xuICAgIGlzTGFzdENvbHVtblZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGFzdENvbHVtbkluZGV4ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpIC0gMTtcbiAgICAgICAgcmV0dXJuICEhdGhpcy52aXNpYmxlQ29sdW1ucy5maW5kKGZ1bmN0aW9uKHZjKSB7IHJldHVybiB2Yy5jb2x1bW5JbmRleCA9PT0gbGFzdENvbHVtbkluZGV4OyB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByZW5kZXJlZCBjb2x1bW4gd2lkdGggYXQgaW5kZXhcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZFdpZHRoOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgY29sdW1ucyA9IHRoaXMudmlzaWJsZUNvbHVtbnM7XG5cbiAgICAgICAgaWYgKGluZGV4ID49IGNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb2x1bW5zW2NvbHVtbnMubGVuZ3RoIC0gMV0ucmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb2x1bW5zW2luZGV4XS5sZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByZW5kZXJlZCByb3cgaGVpZ2h0IGF0IGluZGV4XG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRIZWlnaHQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgICByb3dzID0gdGhpcy52aXNpYmxlUm93cztcblxuICAgICAgICBpZiAoaW5kZXggPj0gcm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gcm93c1tyb3dzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcmVzdWx0ID0gbGFzdC5ib3R0b207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByb3dzW2luZGV4XS50b3A7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Zpbi1jYW52YXN9IG15IFtmaW4tY2FudmFzXShodHRwczovL2dpdGh1Yi5jb20vc3RldmV3aXJ0cy9maW4tY2FudmFzKVxuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZ2V0Q2FudmFzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVXNlciBpcyBjdXJyZW50bHkgZHJhZ2dpbmcgYSBjb2x1bW4gZm9yIHJlb3JkZXJpbmcuXG4gICAgICovXG4gICAgaXNEcmFnZ2luZ0NvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuaXNEcmFnZ2luZ0NvbHVtbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdyB0byBnbyB0byBmb3IgYSBwYWdlIHVwLlxuICAgICAqL1xuICAgIGdldFBhZ2VVcFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5nZXRWaXNpYmxlU2Nyb2xsSGVpZ2h0KCksXG4gICAgICAgICAgICB0b3AgPSB0aGlzLmRhdGFXaW5kb3cub3JpZ2luLnkgLSB0aGlzLmdyaWQucHJvcGVydGllcy5maXhlZFJvd0NvdW50IC0gMSxcbiAgICAgICAgICAgIHNjYW5IZWlnaHQgPSAwO1xuICAgICAgICB3aGlsZSAoc2NhbkhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiB0b3AgPj0gMCkge1xuICAgICAgICAgICAgc2NhbkhlaWdodCArPSBncmlkLmdldFJvd0hlaWdodCh0b3ApO1xuICAgICAgICAgICAgdG9wLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcCArIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IHRvIGdvdG8gZm9yIGEgcGFnZSBkb3duLlxuICAgICAqL1xuICAgIGdldFBhZ2VEb3duUm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVdpbmRvdy5jb3JuZXIueSAtIHRoaXMuZ3JpZC5wcm9wZXJ0aWVzLmZpeGVkUm93Q291bnQgKyAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiByb3dzLlxuICAgICAqL1xuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgcm93cy5cbiAgICAgKi9cbiAgICBnZXRGaXhlZFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGhlYWRlciByb3dzLlxuICAgICAqL1xuICAgIGdldEhlYWRlclJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKiogQHN1bW1hcnkgU21hcnQgcmVuZGVyIHRoZSBncmlkLlxuICAgICAqIEBkZXNjIFBhaW50IGFsbCB0aGUgY2VsbHMgb2YgYSBncmlkLCBpbmNsdWRpbmcgYWxsIFwiZml4ZWRcIiBjb2x1bW5zIGFuZCByb3dzLlxuICAgICAqIFdlIHNuYXBzaG90IHRoZSBjb250ZXh0IHRvIGluc3VyZSBhZ2FpbnN0IGl0cyBwb2xsdXRpb24uXG4gICAgICogYHRyeS4uLmNhdGNoYCBzdXJyb3VuZHMgZWFjaCBjZWxsIHBhaW50IGluIGNhc2UgYSBjZWxsIHJlbmRlcmVyIHRocm93cyBhbiBlcnJvci5cbiAgICAgKiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBlcnJvci1sb2dnZWQgdG8gY29uc29sZSBBTkQgZGlzcGxheWVkIGluIGNlbGwuXG4gICAgICpcbiAgICAgKiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgZG8gbm90IGNyZWF0ZSBhIG5ldyBgQ2VsbEV2ZW50YCBvbiBmb3IgZWFjaCBgX3BhaW50Q2VsbGAgY2FsbC5cbiAgICAgKiBSYXRoZXIsIHdlIGNyZWF0ZSBvbmUgZm9yIGFsbCB0aGUgY2FsbHMgYW5kIG1haW50YWluIHRoZSBpbnN0YW5jZSB2YXJpYWJsZXMgaW4gdGhlIGxvb3BzXG4gICAgICogKHdoaWNoIGlzIHdoeSBgQ2VsbEV2ZW50YCB1c2VzIGBXcml0YWJsZVBvaW50YCBpbnN0ZWFkIG9mIGBQb2ludGAgZm9yIGBncmlkQ2VsbGAgYW5kIGBkYXRhQ2VsbGApOlxuICAgICAqICogU2V0IGluIGNvbHVtbiBsb29wOlxuICAgICAqICAgKiBgY2VsbEV2ZW50LmNvbHVtbmBcbiAgICAgKiAgICogYGNlbGxFdmVudC5ncmlkQ2VsbC54YFxuICAgICAqICAgKiBgY2VsbEV2ZW50LmRhdGFDZWxsLnhgXG4gICAgICogICAqIGBjZWxsRXZlbnQuYm91bmRzLnhgXG4gICAgICogICAqIGBjZWxsRXZlbnQuYm91bmRzLndpZHRoYFxuICAgICAqICogU2V0IGluIHN1YmdyaWQgbG9vcDpcbiAgICAgKiAgICogYGNlbGxFdmVudC5zdWJncmlkYFxuICAgICAqICogU2V0IGluIHJvdyBsb29wOlxuICAgICAqICAgKiBgY2VsbEV2ZW50LmdyaWRDZWxsLnlgXG4gICAgICogICAqIGBjZWxsRXZlbnQuZGF0YUNlbGwueWBcbiAgICAgKiAgICogYGNlbGxFdmVudC5ib3VuZHMueWBcbiAgICAgKiAgICogYGNlbGxFdmVudC5ib3VuZHMuaGVpZ2h0YFxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2NcbiAgICAgKi9cbiAgICBwYWludENlbGxzOiBmdW5jdGlvbihnYykge1xuICAgICAgICB2YXIgbWVzc2FnZSxcbiAgICAgICAgICAgIGJlaGF2aW9yID0gdGhpcy5ncmlkLmJlaGF2aW9yLFxuICAgICAgICAgICAgYywgQywgLy8gY29sdW1uIGxvb3AgaW5kZXggYW5kIGxpbWl0XG4gICAgICAgICAgICByLCBSLCAvLyByb3cgbG9vcCBpbmRleCBhbmQgbGltaXRcbiAgICAgICAgICAgIGNlbGxFdmVudCA9IG5ldyBiZWhhdmlvci5DZWxsRXZlbnQoMCwgMCksXG4gICAgICAgICAgICBib3VuZHMgPSBjZWxsRXZlbnQuX2JvdW5kcyA9IHsgeDowLCB5OjAsIHdpZHRoOjAsIGhlaWdodDowIH0sXG4gICAgICAgICAgICBncmlkQ2VsbCA9IGNlbGxFdmVudC5ncmlkQ2VsbCxcbiAgICAgICAgICAgIGRhdGFDZWxsID0gY2VsbEV2ZW50LmRhdGFDZWxsLFxuICAgICAgICAgICAgdmMsIHZpc2libGVDb2x1bW5zID0gdGhpcy52aXNpYmxlQ29sdW1ucyxcbiAgICAgICAgICAgIHZyLCB2aXNpYmxlUm93cyA9IHRoaXMudmlzaWJsZVJvd3MsXG4gICAgICAgICAgICBjbGlwSGVpZ2h0ID0gdGhpcy5nZXRCb3VuZHMoKS5oZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5idXR0b25DZWxscyA9IHt9O1xuXG4gICAgICAgIC8vIEZvciBlYWNoIGNvbHVtbi4uLlxuICAgICAgICBmb3IgKFxuICAgICAgICAgICAgYyA9IHRoaXMuZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkgPyAtMSA6IDAsIEMgPSB2aXNpYmxlQ29sdW1ucy5sZW5ndGg7XG4gICAgICAgICAgICBjIDwgQztcbiAgICAgICAgICAgIGMrK1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGNlbGxFdmVudC52aXNpYmxlQ29sdW1uID0gdmMgPSB2aXNpYmxlQ29sdW1uc1tjXTtcbiAgICAgICAgICAgIGNlbGxFdmVudC5jb2x1bW4gPSBiZWhhdmlvci5nZXRBY3RpdmVDb2x1bW4odmMuY29sdW1uSW5kZXgpO1xuXG4gICAgICAgICAgICBncmlkQ2VsbC54ID0gdmMuY29sdW1uSW5kZXg7XG4gICAgICAgICAgICBkYXRhQ2VsbC54ID0gY2VsbEV2ZW50LmNvbHVtbiAmJiBjZWxsRXZlbnQuY29sdW1uLmluZGV4O1xuXG4gICAgICAgICAgICBib3VuZHMueCA9IHZjLmxlZnQ7XG4gICAgICAgICAgICBib3VuZHMud2lkdGggPSB2Yy53aWR0aDtcblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbk1pbldpZHRoc1tncmlkQ2VsbC54XSA9IDA7XG5cbiAgICAgICAgICAgIGdjLnNhdmUoKTtcblxuICAgICAgICAgICAgLy8gQ2xpcCB0byB2aXNpYmxlIHBvcnRpb24gb2YgY29sdW1uIHRvIHByZXZlbnQgb3ZlcmZsb3cgdG8gcmlnaHQuIFByZXZpb3VzbHkgd2UgY2xpcHBlZCB0byBlbnRpcmUgdmlzaWJsZSBncmlkIGFuZCBkZWFsdCB3aXRoIG92ZXJmbG93IGJ5IG92ZXJwYWludGluZyB3aXRoIG5leHQgY29sdW1uLiBIb3dldmVyLCB0aGlzIHN0cmF0ZWd5IGZhaWxzIHdoZW4gdHJhbnNwYXJlbnQgYmFja2dyb3VuZCAobm8gYmFja2dyb3VuZCBjb2xvcikuXG4gICAgICAgICAgICAvLyBUT0RPOiBpZiBleHRyYSBjbGlwKCkgY2FsbHMgcGVyIGNvbHVtbiBhZmZlY3QgcGVyZm9ybWFuY2UgKG5vdCB0aGUgY2xpcHBpbmcgaXRzZWxmIHdoaWNoIHdhcyBoYXBwZW5pbmcgYW55d2F5LCBidXQgdGhlIGNsaXAgY2FsbHMgd2hpY2ggc2V0IHVwIHRoZSBjbGlwcGluZyksIHVzZSBwcmV2aW91cyBzdHJhdGVneSB3aGVuIHRoZXJlIGlzIGEgYmFja2dyb3VuZCBjb2xvclxuICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBnYy5yZWN0KDAsIDAsIGJvdW5kcy54ICsgYm91bmRzLndpZHRoLCBjbGlwSGVpZ2h0KTtcbiAgICAgICAgICAgIGdjLmNsaXAoKTtcblxuICAgICAgICAgICAgLy8gRm9yIGVhY2ggcm93IG9mIGVhY2ggc3ViZ3JpZCAob2YgZWFjaCBjb2x1bW4pLi4uXG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIHIgPSAwLCBSID0gdmlzaWJsZVJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHIgPCBSO1xuICAgICAgICAgICAgICAgIHIrK1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY2VsbEV2ZW50LnZpc2libGVSb3cgPSB2ciA9IHZpc2libGVSb3dzW3JdO1xuXG4gICAgICAgICAgICAgICAgYm91bmRzLnkgPSB2ci50b3A7XG4gICAgICAgICAgICAgICAgYm91bmRzLmhlaWdodCA9IHZyLmhlaWdodDtcblxuICAgICAgICAgICAgICAgIGdyaWRDZWxsLnkgPSB2ci5pbmRleDtcbiAgICAgICAgICAgICAgICBkYXRhQ2VsbC55ID0gdnIucm93SW5kZXg7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYWludENlbGwoZ2MsIGNlbGxFdmVudCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gZSAmJiAoZS5tZXNzYWdlIHx8IGUpIHx8ICdVbmtub3duIGVycm9yLic7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3R2MgPSBnYy5nYyB8fCBnYywgLy8gRG9uJ3QgbG9nIHRoZXNlIGNhbnZhcyBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyWCA9IHZjLmxlZnQsIGVycldpZHRoID0gdmMucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJZID0gdnIudG9wLCBlcnJIZWlnaHQgPSB2ci5ib3R0b20sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcgPSB7IGJvdW5kczogeyBjOiBlcnJYLCB5OiBlcnJZLCB3aWR0aDogZXJyV2lkdGgsIGhlaWdodDogZXJySGVpZ2h0IH0gfTtcblxuICAgICAgICAgICAgICAgICAgICByYXdHYy5zYXZlKCk7IC8vIGRlZmluZSBjbGlwcGluZyByZWdpb25cbiAgICAgICAgICAgICAgICAgICAgcmF3R2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd0djLnJlY3QoZXJyWCwgZXJyWSwgZXJyV2lkdGgsIGVyckhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd0djLmNsaXAoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWQuY2VsbFJlbmRlcmVycy5nZXQoJ2Vycm9yY2VsbCcpLnBhaW50KHJhd0djLCBjb25maWcsIG1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJhd0djLnJlc3RvcmUoKTsgLy8gZGlzY2FyZCBjbGlwcGluZyByZWdpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdjLnJlc3RvcmUoKTsgLy8gUmVtb3ZlIGNvbHVtbidzIGNsaXAgcmVnaW9uIChhbmQgYW55dGhpbmcgZWxzZSByZW5kZXJDZWxsRXJyb3IoKSBtaWdodCBoYXZlIHNldClcbiAgICAgICAgfVxuXG4gICAgICAgIHNldE51bWJlckNvbHVtbldpZHRoKGdjLCBiZWhhdmlvciwgdGhpcy5ncmlkLmdldFJvd0NvdW50KCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqL1xuICAgIHBhaW50Q2VsbDogZnVuY3Rpb24oZ2MsIHgsIHkpIHtcbiAgICAgICAgZ2MubW92ZVRvKDAsIDApO1xuXG4gICAgICAgIHZhciBjID0gdGhpcy52aXNpYmxlQ29sdW1uc1t4XS5pbmRleCwgLy8gdG9kbyByZWZhY1xuICAgICAgICAgICAgciA9IHRoaXMudmlzaWJsZVJvd3NbeV0uaW5kZXg7XG5cbiAgICAgICAgaWYgKGMpIHsgLy9zb21ldGhpbmcgaXMgYmVpbmcgdmlld2VkIGF0IGF0IHRoZSBtb21lbnQgKG90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuX3BhaW50Q2VsbChnYywgYywgcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3BhaW50Q2VsbDogZnVuY3Rpb24oZ2MsIGNlbGxFdmVudCkge1xuXG4gICAgICAgIHZhciBncmlkID0gdGhpcy5ncmlkLFxuICAgICAgICAgICAgYmVoYXZpb3IgPSBncmlkLmJlaGF2aW9yLFxuICAgICAgICAgICAgeCA9IGNlbGxFdmVudC5ncmlkQ2VsbC54LFxuICAgICAgICAgICAgLy8geSA9IGNlbGxFdmVudC5ncmlkQ2VsbC55LFxuICAgICAgICAgICAgYyA9IGNlbGxFdmVudC5kYXRhQ2VsbC54LFxuICAgICAgICAgICAgciA9IGNlbGxFdmVudC5kYXRhQ2VsbC55LFxuXG4gICAgICAgICAgICBpc0hhbmRsZUNvbHVtbiA9IGNlbGxFdmVudC5pc0hhbmRsZUNvbHVtbixcbiAgICAgICAgICAgIGlzSGllcmFyY2h5Q29sdW1uID0gY2VsbEV2ZW50LmlzSGllcmFyY2h5Q29sdW1uLFxuICAgICAgICAgICAgaXNDb2x1bW5TZWxlY3RlZCA9IGNlbGxFdmVudC5pc0NvbHVtblNlbGVjdGVkLFxuXG4gICAgICAgICAgICBpc1Nob3dSb3dOdW1iZXJzID0gZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCksXG4gICAgICAgICAgICBpc1Jvd0hhbmRsZU9ySGllcmFyY2h5Q29sdW1uID0gaXNTaG93Um93TnVtYmVycyAmJiBpc0hhbmRsZUNvbHVtbiB8fCBpc0hpZXJhcmNoeUNvbHVtbixcblxuICAgICAgICAgICAgaXNHcmlkUm93ID0gY2VsbEV2ZW50LmlzR3JpZFJvdyxcbiAgICAgICAgICAgIGlzUm93U2VsZWN0ZWQgPSBjZWxsRXZlbnQuaXNSb3dTZWxlY3RlZCxcbiAgICAgICAgICAgIGlzQ2VsbFNlbGVjdGVkID0gY2VsbEV2ZW50LmlzQ2VsbFNlbGVjdGVkLFxuXG4gICAgICAgICAgICBpc0hlYWRlclJvdyA9IGNlbGxFdmVudC5pc0hlYWRlclJvdyxcbiAgICAgICAgICAgIGlzRmlsdGVyUm93ID0gY2VsbEV2ZW50LmlzRmlsdGVyUm93LFxuXG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcyA9IGJlaGF2aW9yLmdldENlbGxPd25Qcm9wZXJ0aWVzKGNlbGxFdmVudCksXG4gICAgICAgICAgICBiYXNlUHJvcGVydGllcyxcbiAgICAgICAgICAgIG5vbkdyaWRDZWxsUHJvcHMsXG4gICAgICAgICAgICBjb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICBpZiAoY2VsbFByb3BlcnRpZXMgJiYgY2VsbFByb3BlcnRpZXMuYXBwbHlDZWxsUHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5jID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uZmlnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYmFzZVByb3BlcnRpZXMgPSBjZWxsUHJvcGVydGllcztcbiAgICAgICAgICAgIG5vbkdyaWRDZWxsUHJvcHMgPSAhaXNHcmlkUm93O1xuICAgICAgICB9IGVsc2UgaWYgKCFjb25maWcgfHwgYyAhPT0gdGhpcy5jKSB7XG4gICAgICAgICAgICB0aGlzLmMgPSBjO1xuICAgICAgICAgICAgY29uZmlnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbmZpZ1R5cGU7XG4gICAgICAgIGlmIChpc1Jvd0hhbmRsZU9ySGllcmFyY2h5Q29sdW1uKSB7XG4gICAgICAgICAgICBjb25maWdUeXBlID0gaXNSb3dTZWxlY3RlZCA/IDEgOiAyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzR3JpZFJvdykge1xuICAgICAgICAgICAgY29uZmlnVHlwZSA9IDM7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGaWx0ZXJSb3cpIHtcbiAgICAgICAgICAgIGNvbmZpZ1R5cGUgPSA0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ29sdW1uU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZ1R5cGUgPSA1O1xuICAgICAgICB9IGVsc2UgeyAvLyBoZWFkZXIgb3Igc3VtbWFyeSBvciBvdGhlclxuICAgICAgICAgICAgY29uZmlnVHlwZSA9IDY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbmZpZyB8fCBjb25maWdUeXBlICE9PSB0aGlzLmNvbmZpZ1R5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnVHlwZSA9IGNvbmZpZ1R5cGU7XG4gICAgICAgICAgICBpZiAoIWJhc2VQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgYmFzZVByb3BlcnRpZXMgPSBiZWhhdmlvci5nZXRDb2x1bW5Qcm9wZXJ0aWVzKGMpO1xuICAgICAgICAgICAgICAgIGlmICghYmFzZVByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbmZpZ1R5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IGNvbmZpZyA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3BlcnRpZXMucm93SGVhZGVyUm93U2VsZWN0aW9uKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiBjb25maWcgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzLnJvd0hlYWRlcik7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogY29uZmlnID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcyk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogY29uZmlnID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcy5maWx0ZXJQcm9wZXJ0aWVzKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBjb25maWcgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzLmNvbHVtbkhlYWRlckNvbHVtblNlbGVjdGlvbik7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogY29uZmlnID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcy5jb2x1bW5IZWFkZXIpOyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgdGhpcy5iYXNlUHJvcGVydGllcyA9IGJhc2VQcm9wZXJ0aWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGBjb25maWdgIChyZW5kZXIgcHJvcHMpIG9iamVjdFxuICAgICAgICAvLyAqIHdpdGggYXBwcm9wcmlhdGUgcHJvdG90eXBlXG4gICAgICAgIC8vICogc2V0IGBpc1NlbGVjdGVkYCAoYWRkZWQgdG8gYGNvbmZpZ2AgYmVsb3cgYXMgYSByZWFkLW9ubHkgcHJvcGVydHkpXG4gICAgICAgIC8vICogZm9yIHJvdyBoYW5kbGUgY29sdW1uLCBzZXQgYGNvbmZpZy5oYWxpZ25gIHRvIGAncmlnaHQnYFxuICAgICAgICAvLyAqIGZvciBoaWVyYXJjaHkgY29sdW1uLCBzZXQgYGNvbmZpZy5oYWxpZ25gIHRvIGAnbGVmdCdgXG4gICAgICAgIHZhciBpc1NlbGVjdGVkO1xuICAgICAgICBpZiAoaXNSb3dIYW5kbGVPckhpZXJhcmNoeUNvbHVtbikge1xuICAgICAgICAgICAgaXNTZWxlY3RlZCA9IGlzUm93U2VsZWN0ZWQgfHwgZ3JpZC5pc0NlbGxTZWxlY3RlZEluUm93KHIpO1xuICAgICAgICAgICAgY29uZmlnLmhhbGlnbiA9IGlzSGllcmFyY2h5Q29sdW1uID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChpc0dyaWRSb3cpIHtcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBpc0NlbGxTZWxlY3RlZCB8fCBpc1Jvd1NlbGVjdGVkIHx8IGlzQ29sdW1uU2VsZWN0ZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGaWx0ZXJSb3cpIHtcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0NvbHVtblNlbGVjdGVkKSB7XG4gICAgICAgICAgICBpc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHsgLy8gaGVhZGVyIG9yIHN1bW1hcnkgb3Igb3RoZXJcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBncmlkLmlzQ2VsbFNlbGVjdGVkSW5Db2x1bW4oeCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgY2VsbCBjb250ZW50czpcbiAgICAgICAgLy8gKiBGb3IgYWxsIGNlbGxzOiBzZXQgYGNvbmZpZy52YWx1ZWAgKHdyaXRhYmxlIHByb3BlcnR5KVxuICAgICAgICAvLyAqIEZvciBjZWxscyBvdXRzaWRlIG9mIHJvdyBoYW5kbGUgY29sdW1uOiBhbHNvIHNldCBgY29uZmlnLmRhdGFSb3dgIGZvciB1c2UgYnkgdmFsT3JGdW5jXG4gICAgICAgIGlmICghaXNIYW5kbGVDb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5kYXRhUm93ID0gZ3JpZC5nZXRSb3cocik7XG4gICAgICAgICAgICBjb25maWcudmFsdWUgPSBjZWxsRXZlbnQudmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNHcmlkUm93KSB7XG4gICAgICAgICAgICAvLyByb3cgaGFuZGxlIGZvciBhIGRhdGEgcm93XG4gICAgICAgICAgICBjb25maWcudmFsdWUgPSBbaW1hZ2VzLmNoZWNrYm94KGlzUm93U2VsZWN0ZWQpLCByICsgMSwgbnVsbF07IC8vIHJvdyBudW1iZXIgaXMgMS1iYXNlZFxuICAgICAgICB9IGVsc2UgaWYgKGlzSGVhZGVyUm93KSB7XG4gICAgICAgICAgICAvLyByb3cgaGFuZGxlIGZvciBoZWFkZXIgcm93OiBnZXRzIFwibWFzdGVyXCIgY2hlY2tib3hcbiAgICAgICAgICAgIGNvbmZpZy52YWx1ZSA9IFtpbWFnZXMuY2hlY2tib3goZ3JpZC5hcmVBbGxSb3dzU2VsZWN0ZWQoKSksICcnLCBudWxsXTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0ZpbHRlclJvdykge1xuICAgICAgICAgICAgLy8gcm93IGhhbmRsZSBmb3IgZmlsdGVyIHJvdzogZ2V0cyBmaWx0ZXIgaWNvblxuICAgICAgICAgICAgY29uZmlnLnZhbHVlID0gW2ltYWdlcy5maWx0ZXIoZmFsc2UpLCAnJywgbnVsbF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyByb3cgaGFuZGxlcyBmb3IgXCJzdW1tYXJ5XCIgb3Igb3RoZXIgcm93czogZW1wdHlcbiAgICAgICAgICAgIGNvbmZpZy52YWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLmlzU2VsZWN0ZWQgPSBpc1NlbGVjdGVkO1xuICAgICAgICBjb25maWcuaXNHcmlkQ29sdW1uID0gIWlzUm93SGFuZGxlT3JIaWVyYXJjaHlDb2x1bW47XG4gICAgICAgIGNvbmZpZy5pc0dyaWRSb3cgPSBpc0dyaWRSb3c7XG4gICAgICAgIGNvbmZpZy5pc0hlYWRlclJvdyA9IGlzSGVhZGVyUm93O1xuICAgICAgICBjb25maWcuaXNGaWx0ZXJSb3cgPSBpc0ZpbHRlclJvdztcbiAgICAgICAgY29uZmlnLmlzVXNlckRhdGFBcmVhID0gIWlzUm93SGFuZGxlT3JIaWVyYXJjaHlDb2x1bW4gJiYgaXNHcmlkUm93O1xuICAgICAgICBjb25maWcuaXNDb2x1bW5Ib3ZlcmVkID0gY2VsbEV2ZW50LmlzQ29sdW1uSG92ZXJlZDtcbiAgICAgICAgY29uZmlnLmlzUm93SG92ZXJlZCA9IGNlbGxFdmVudC5pc1Jvd0hvdmVyZWQ7XG4gICAgICAgIGNvbmZpZy5pc0NlbGxIb3ZlcmVkID0gY2VsbEV2ZW50LmlzQ2VsbEhvdmVyZWQ7XG4gICAgICAgIGNvbmZpZy5ib3VuZHMgPSBjZWxsRXZlbnQuYm91bmRzO1xuICAgICAgICBjb25maWcuaXNDZWxsU2VsZWN0ZWQgPSBpc0NlbGxTZWxlY3RlZDtcbiAgICAgICAgY29uZmlnLmlzUm93U2VsZWN0ZWQgPSBpc1Jvd1NlbGVjdGVkO1xuICAgICAgICBjb25maWcuaXNDb2x1bW5TZWxlY3RlZCA9IGlzQ29sdW1uU2VsZWN0ZWQ7XG4gICAgICAgIGNvbmZpZy5pc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZSA9IGdyaWQuaXNJbkN1cnJlbnRTZWxlY3Rpb25SZWN0YW5nbGUoeCwgcik7XG5cbiAgICAgICAgaWYgKGdyaWQubW91c2VEb3duU3RhdGUpIHtcbiAgICAgICAgICAgIGNvbmZpZy5tb3VzZURvd24gPSBncmlkLm1vdXNlRG93blN0YXRlLmdyaWRDZWxsLmVxdWFscyhjZWxsRXZlbnQuZ3JpZENlbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBjYWxsJ3MgZGF0YU1vZGVsLmdldENlbGwgd2hpY2ggZGV2ZWxvcGVyIGNhbiBvdmVycmlkZSB0bzpcbiAgICAgICAgLy8gKiBtdXRhdGUgdGhlICh3cml0YWJsZSkgcHJvcGVydGllcyBvZiBgY29uZmlnYFxuICAgICAgICAvLyAqIG11dGF0ZSBjZWxsIHJlbmRlcmVyIGNob2ljZSAoaW5zdGFuY2Ugb2Ygd2hpY2ggaXMgcmV0dXJuZWQpXG4gICAgICAgIHZhciBjZWxsUmVuZGVyZXIgPSBiZWhhdmlvci5nZXRDZWxsUmVuZGVyZXIoY29uZmlnLCBjZWxsRXZlbnQpO1xuXG4gICAgICAgIC8vIE92ZXJ3cml0ZSBwb3NzaWJseSBtdXRhdGVkIGNlbGwgcHJvcGVydGllcywgaWYgcmVxdWVzdGVkIHRvIGRvIHNvIGJ5IGBnZXRDZWxsYCBvdmVycmlkZVxuICAgICAgICBpZiAoY29uZmlnLnJlYXBwbHlDZWxsUHJvcGVydGllcyB8fCBub25HcmlkQ2VsbFByb3BzKSB7XG4gICAgICAgICAgICBfKGNvbmZpZykuZXh0ZW5kT3duKGNlbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlaGF2aW9yLmNlbGxQcm9wZXJ0aWVzUHJlUGFpbnROb3RpZmljYXRpb24oY29uZmlnKTtcblxuICAgICAgICAvL2FsbG93IHRoZSByZW5kZXJlciB0byBpZGVudGlmeSBpdHNlbGYgaWYgaXQncyBhIGJ1dHRvblxuICAgICAgICBjb25maWcuYnV0dG9uQ2VsbHMgPSB0aGlzLmJ1dHRvbkNlbGxzO1xuXG4gICAgICAgIGNvbmZpZy5mb3JtYXRWYWx1ZSA9IGdyaWQuZ2V0Rm9ybWF0dGVyKGNvbmZpZy5pc1VzZXJEYXRhQXJlYSAmJiBjb25maWcuZm9ybWF0KTtcblxuICAgICAgICBjZWxsUmVuZGVyZXIucGFpbnQoZ2MsIGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbk1pbldpZHRoc1t4XSA9IE1hdGgubWF4KGNvbmZpZy5taW5XaWR0aCB8fCAwLCB0aGlzLnJlbmRlcmVkQ29sdW1uTWluV2lkdGhzW3hdKTtcbiAgICAgICAgdGhpcy5iYXNlUHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCA9IHRoaXMucmVuZGVyZWRDb2x1bW5NaW5XaWR0aHNbeF07XG4gICAgfSxcblxuICAgIGlzVmlld2FibGVCdXR0b246IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgdmFyIGtleSA9IGMgKyAnLCcgKyByO1xuICAgICAgICByZXR1cm4gdGhpcy5idXR0b25DZWxsc1trZXldID09PSB0cnVlO1xuICAgIH0sXG5cbiAgICBzdGFydEFuaW1hdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICAgICAgICAgIHNlbGYuYW5pbWF0ZSgpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmdldENhbnZhcygpLmNhbnZhc0NUWDtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLnJlbmRlckxhc3RTZWxlY3Rpb24oY3R4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHM7XG4gICAgfSxcblxuICAgIHNldEJvdW5kczogZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5ib3VuZHMgPSBib3VuZHMpO1xuICAgIH1cblxufSk7XG5cbmZ1bmN0aW9uIHNldE51bWJlckNvbHVtbldpZHRoKGdjLCBiZWhhdmlvciwgbWF4Um93KSB7XG4gICAgdmFyIGNvbHVtblByb3BlcnRpZXMgPSBiZWhhdmlvci5nZXRDb2x1bW5Qcm9wZXJ0aWVzKC0xKSxcbiAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBjb2x1bW5Qcm9wZXJ0aWVzLnJvd0hlYWRlcixcbiAgICAgICAgaWNvbiA9IGltYWdlcy5jaGVja2VkO1xuXG4gICAgZ2MuZm9udCA9IGNlbGxQcm9wZXJ0aWVzLmZvbnQ7XG5cbiAgICBjb2x1bW5Qcm9wZXJ0aWVzLnByZWZlcnJlZFdpZHRoID0gaWNvbi53aWR0aCArIDcgKyBjZWxsUHJvcGVydGllcy5nZXRUZXh0V2lkdGgoZ2MsIG1heFJvdyArIDEpO1xufVxuXG52YXIgd2FybmluZ3MgPSB7fTtcbmZ1bmN0aW9uIHdhcm4obmFtZSwgbWVzc2FnZSkge1xuICAgIGlmICghd2FybmluZ3NbbmFtZV0pIHtcbiAgICAgICAgd2FybmluZ3NbbmFtZV0gPSB0cnVlO1xuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmFuZ2VTZWxlY3Rpb25Nb2RlbCA9IHJlcXVpcmUoJ3NwYXJzZS1ib29sZWFuLWFycmF5Jyk7XG5cbi8qKlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgV2UgcmVwcmVzZW50IHNlbGVjdGlvbnMgYXMgYSBsaXN0IG9mIHJlY3RhbmdsZXMgYmVjYXVzZSBsYXJnZSBhcmVhcyBjYW4gYmUgcmVwcmVzZW50ZWQgYW5kIHRlc3RlZCBhZ2FpbnN0IHF1aWNrbHkgd2l0aCBhIG1pbmltYWwgYW1vdW50IG9mIG1lbW9yeSB1c2FnZS4gQWxzbyB3ZSBuZWVkIHRvIG1haW50YWluIHRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcyBmbGF0dGVuZWQgY291bnRlciBwYXJ0cyBzbyB3ZSBjYW4gdGVzdCBmb3Igc2luZ2xlIGRpbWVuc2lvbiBjb250YWlucy4gVGhpcyBpcyBob3cgd2Uga25vdyB0byBoaWdobGlnaHQgdGhlIGZpeGVkIHJlZ2lvbnMgb24gdGhlIGVkZ2VzIG9mIHRoZSBncmlkLlxuICovXG5cbmZ1bmN0aW9uIFNlbGVjdGlvbk1vZGVsKGdyaWQpIHtcblxuICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBtdWx0aXBsZVNlbGVjdGlvbnNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAc3VtbWFyeSBDYW4gc2VsZWN0IG11bHRpcGxlIGNlbGwgcmVnaW9ucy5cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5tdWx0aXBsZVNlbGVjdGlvbnMgPSBncmlkW2dyaWQuYmVoYXZpb3IgPyAnZ2V0UHJvcGVydGllcycgOiAnX2dldFByb3BlcnRpZXMnXSgpLm11bHRpcGxlU2VsZWN0aW9ucztcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHNlbGVjdGlvbnNcbiAgICAgKiBAdHlwZSB7UmVjdGFuZ2xlW119XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYW4gZW1wdHkgYXJyYXkgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLnNlbGVjdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGZsYXR0ZW5lZFhcbiAgICAgKiBAdHlwZSB7UmVjdGFuZ2xlW119XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzIGZsYXR0ZW5lZCBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gKG5vIHdpZHRoKS5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGFuIGVtcHR5IGFycmF5IHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5mbGF0dGVuZWRYID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBmbGF0dGVuZWRZXG4gICAgICogQHR5cGUge1JlY3RhbmdsZVtdfVxuICAgICAqIEBzdW1tYXJ5IFRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcyBmbGF0dGVuZWQgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbiAobm8gaGVpZ2h0KS5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGFuIGVtcHR5IGFycmF5IHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5mbGF0dGVuZWRZID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSByb3dTZWxlY3Rpb25Nb2RlbFxuICAgICAqIEB0eXBlIHtSYW5nZVNlbGVjdGlvbk1vZGVsfVxuICAgICAqIEBzdW1tYXJ5IFRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcy5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGEgbmV3IFJhbmdlU2VsZWN0aW9uTW9kZWwgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsID0gbmV3IFJhbmdlU2VsZWN0aW9uTW9kZWwoKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGNvbHVtblNlbGVjdGlvbk1vZGVsXG4gICAgICogQHR5cGUge1JhbmdlU2VsZWN0aW9uTW9kZWx9XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwgPSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCgpO1xuXG4gICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnJyk7XG59XG5cblNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZSA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGUuY29uc3RydWN0b3IsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgYWxsUm93c1NlbGVjdGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRMYXN0U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbHMgPSB0aGlzLnNlbGVjdGlvbnM7XG4gICAgICAgIHZhciBzZWwgPSBzZWxzW3NlbHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBzZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRMYXN0U2VsZWN0aW9uVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RTZWxlY3Rpb25UeXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdHlwZVxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXRMYXN0U2VsZWN0aW9uVHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UeXBlID0gdHlwZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZWxlY3QgdGhlIHJlZ2lvbiBkZXNjcmliZWQgYnkgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG94IC0gb3JpZ2luIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV5IC0gZXh0ZW50IHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50IC0gd2hldGhlciB0byBmaXJlIHNlbGVjdGlvbiBjaGFuZ2VkIGV2ZW50XG4gICAgICovXG4gICAgc2VsZWN0OiBmdW5jdGlvbihveCwgb3ksIGV4LCBleSwgc2lsZW50KSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmdyaWQubmV3UmVjdGFuZ2xlKG94LCBveSwgZXgsIGV5KTtcblxuICAgICAgICAvL0NhY2hlIHRoZSBmaXJzdCBzZWxlY3RlZCBjZWxsIGJlZm9yZSBpdCBnZXRzIG5vcm1hbGl6ZWQgdG8gdG9wLWxlZnQgb3JpZ2luXG4gICAgICAgIG5ld1NlbGVjdGlvbi5maXJzdFNlbGVjdGVkQ2VsbCA9IHRoaXMuZ3JpZC5uZXdQb2ludChveCwgb3kpO1xuXG4gICAgICAgIG5ld1NlbGVjdGlvbi5sYXN0U2VsZWN0ZWRDZWxsID0gKFxuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmZpcnN0U2VsZWN0ZWRDZWxsLnggPT09IG5ld1NlbGVjdGlvbi5vcmlnaW4ueCAmJlxuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmZpcnN0U2VsZWN0ZWRDZWxsLnkgPT09IG5ld1NlbGVjdGlvbi5vcmlnaW4ueVxuICAgICAgICApXG4gICAgICAgICAgICA/IG5ld1NlbGVjdGlvbi5jb3JuZXJcbiAgICAgICAgICAgIDogbmV3U2VsZWN0aW9uLm9yaWdpbjtcblxuICAgICAgICBpZiAodGhpcy5tdWx0aXBsZVNlbGVjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9ucy5wdXNoKG5ld1NlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5lZFgucHVzaChuZXdTZWxlY3Rpb24uZmxhdHRlblhBdCgwKSk7XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5lZFkucHVzaChuZXdTZWxlY3Rpb24uZmxhdHRlbllBdCgwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbnNbMF0gPSBuZXdTZWxlY3Rpb247XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5lZFhbMF0gPSBuZXdTZWxlY3Rpb24uZmxhdHRlblhBdCgwKTtcbiAgICAgICAgICAgIHRoaXMuZmxhdHRlbmVkWVswXSA9IG5ld1NlbGVjdGlvbi5mbGF0dGVuWUF0KDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ2NlbGwnKTtcblxuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG94IC0gb3JpZ2luIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV5IC0gZXh0ZW50IHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIHRvZ2dsZVNlbGVjdDogZnVuY3Rpb24ob3gsIG95LCBleCwgZXkpIHtcblxuICAgICAgICB2YXIgc2VsZWN0ZWQsIGluZGV4O1xuXG4gICAgICAgIHNlbGVjdGVkID0gdGhpcy5zZWxlY3Rpb25zLmZpbmQoZnVuY3Rpb24oc2VsZWN0aW9uLCBpZHgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaWR4O1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ub3JpZ2luLnggPT09IG94ICYmIHNlbGVjdGlvbi5vcmlnaW4ueSA9PT0gb3kgJiZcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZXh0ZW50LnggPT09IGV4ICYmIHNlbGVjdGlvbi5leHRlbnQueSA9PT0gZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5lZFguc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuZmxhdHRlbmVkWS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5ncmlkLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG94LCBveSwgZXgsIGV5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVtb3ZlIHRoZSBsYXN0IHNlbGVjdGlvbiB0aGF0IHdhcyBjcmVhdGVkLlxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbjogZnVuY3Rpb24oZG9udENsZWFyUm93U2VsZWN0aW9ucykge1xuICAgICAgICBkb250Q2xlYXJSb3dTZWxlY3Rpb25zID0gZG9udENsZWFyUm93U2VsZWN0aW9ucyA9PT0gdHJ1ZTtcbiAgICAgICAgaWYgKCFkb250Q2xlYXJSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFsbFJvd3NTZWxlY3RlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9ucy5sZW5ndGgpIHsgLS10aGlzLnNlbGVjdGlvbnMubGVuZ3RoOyB9XG4gICAgICAgIGlmICh0aGlzLmZsYXR0ZW5lZFgubGVuZ3RoKSB7IC0tdGhpcy5mbGF0dGVuZWRYLmxlbmd0aDsgfVxuICAgICAgICBpZiAodGhpcy5mbGF0dGVuZWRZLmxlbmd0aCkgeyAtLXRoaXMuZmxhdHRlbmVkWS5sZW5ndGg7IH1cbiAgICAgICAgLy90aGlzLmdldEdyaWQoKS5zZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdjb2x1bW4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ3JvdycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ3JvdycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlcmUgYXJlIGFjdGl2ZSBzZWxlY3Rpb24ocykuXG4gICAgICovXG4gICAgaGFzU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbnMubGVuZ3RoICE9PSAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUm93U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDb2x1bW5TZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFNlbGVjdGlvbiBjb3ZlcnMgYSBzcGVjaWZpYyBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluUm93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NlbGxTZWxlY3RlZCh0aGlzLmZsYXR0ZW5lZFgsIDAsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgU2VsZWN0aW9uIGNvdmVycyBhIHNwZWNpZmljIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkSW5Db2x1bW46IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2VsbFNlbGVjdGVkKHRoaXMuZmxhdHRlbmVkWSwgeCwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZWxlY3Rpb24gcXVlcnkgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjZWxsIGlzIHNlbGVjdGVkIChwYXJ0IG9mIGFuIGFjdGl2ZSBzZWxlY3Rpb24pLlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlW119IHNlbGVjdGlvbnMgLSBTZWxlY3Rpb24gcmVjdGFuZ2xlcyB0byBzZWFyY2ggdGhyb3VnaC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICovXG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5pc0NvbHVtblNlbGVjdGVkKHgpIHx8XG4gICAgICAgICAgICB0aGlzLmlzUm93U2VsZWN0ZWQoeSkgfHxcbiAgICAgICAgICAgIHRoaXMuX2lzQ2VsbFNlbGVjdGVkKHRoaXMuc2VsZWN0aW9ucywgeCwgeSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDZWxsU2VsZWN0ZWQodGhpcy5zZWxlY3Rpb25zLCB4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25zXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzQ2VsbFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3Rpb25zLCB4LCB5KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuICEhc2VsZWN0aW9ucy5maW5kKGZ1bmN0aW9uKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYucmVjdGFuZ2xlQ29udGFpbnMoc2VsZWN0aW9uLCB4LCB5KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBlbXB0eSBvdXQgYWxsIG91ciBzdGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKGRvbnRDbGVhclJvd1NlbGVjdGlvbnMpIHtcbiAgICAgICAgZG9udENsZWFyUm93U2VsZWN0aW9ucyA9IGRvbnRDbGVhclJvd1NlbGVjdGlvbnMgPT09IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFgubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5mbGF0dGVuZWRZLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgaWYgKCFkb250Q2xlYXJSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFsbFJvd3NTZWxlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy90aGlzLmdldEdyaWQoKS5zZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ggLSBvcmlnaW4geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG95IC0gb3JpZ2luIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleCAtIGV4dGVudCB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXkgLSBleHRlbnQgeSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWN0YW5nbGVTZWxlY3RlZDogZnVuY3Rpb24ob3gsIG95LCBleCwgZXkpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zZWxlY3Rpb25zLmZpbmQoZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5vcmlnaW4ueCA9PT0gb3ggJiYgc2VsZWN0aW9uLm9yaWdpbi55ID09PSBveSAmJlxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5leHRlbnQueCA9PT0gZXggJiYgc2VsZWN0aW9uLmV4dGVudC55ID09PSBleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGlzQ29sdW1uU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuaXNTZWxlY3RlZCh4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW58Kn1cbiAgICAgKi9cbiAgICBpc1Jvd1NlbGVjdGVkOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbFJvd3NTZWxlY3RlZCB8fCB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmlzU2VsZWN0ZWQoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geDFcbiAgICAgKiBAcGFyYW0geDJcbiAgICAgKi9cbiAgICBzZWxlY3RDb2x1bW46IGZ1bmN0aW9uKHgxLCB4Mikge1xuICAgICAgICB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLnNlbGVjdCh4MSwgeDIpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdjb2x1bW4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNlbGVjdEFsbFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc2V0QWxsUm93c1NlbGVjdGVkKHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG5cbiAgICBzZXRBbGxSb3dzU2VsZWN0ZWQ6IGZ1bmN0aW9uKGlzSXQpIHtcbiAgICAgICAgdGhpcy5hbGxSb3dzU2VsZWN0ZWQgPSBpc0l0O1xuICAgIH0sXG5cbiAgICBhcmVBbGxSb3dzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxSb3dzU2VsZWN0ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geTFcbiAgICAgKiBAcGFyYW0geTJcbiAgICAgKi9cbiAgICBzZWxlY3RSb3c6IGZ1bmN0aW9uKHkxLCB5Mikge1xuICAgICAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLnNlbGVjdCh5MSwgeTIpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdyb3cnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4MVxuICAgICAqIEBwYXJhbSB4MlxuICAgICAqL1xuICAgIGRlc2VsZWN0Q29sdW1uOiBmdW5jdGlvbih4MSwgeDIpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdCh4MSwgeDIpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdjb2x1bW4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB5MVxuICAgICAqIEBwYXJhbSB5MlxuICAgICAqL1xuICAgIGRlc2VsZWN0Um93OiBmdW5jdGlvbih5MSwgeTIpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJlQWxsUm93c1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIC8vIFRvIGRlc2VsZWN0IGEgcm93LCB3ZSBtdXN0IGZpcnN0IHJlbW92ZSB0aGUgYWxsIHJvd3MgZmxhZy4uLlxuICAgICAgICAgICAgdGhpcy5zZXRBbGxSb3dzU2VsZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgLy8gLi4uYW5kIGNyZWF0ZSBhIHNpbmdsZSByYW5nZSByZXByZXNlbnRpbmcgYWxsIHJvd3NcbiAgICAgICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuc2VsZWN0KDAsIHRoaXMuZ3JpZC5nZXRSb3dDb3VudCgpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5kZXNlbGVjdCh5MSwgeTIpO1xuICAgICAgICB0aGlzLnNldExhc3RTZWxlY3Rpb25UeXBlKCdyb3cnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFyZUFsbFJvd3NTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyUm93cyA9IHRoaXMuZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5ncmlkLmdldFJvd0NvdW50KCkgLSBoZWFkZXJSb3dzO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBpICsgaGVhZGVyUm93cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuZ2V0U2VsZWN0aW9ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp8QXJyYXkuQXJyYXkubnVtYmVyfVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgICBpc0NvbHVtbk9yUm93U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpIHx8ICF0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRGbGF0dGVuZWRZczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHNldCA9IHt9O1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0b3AgPSBzZWxlY3Rpb24ub3JpZ2luLnk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHNlbGVjdGlvbi5leHRlbnQueSArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHNpemU7IHIrKykge1xuICAgICAgICAgICAgICAgIHZhciB0aSA9IHIgKyB0b3A7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXRbdGldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRpKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0W3RpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LnNvcnQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHggLSB5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKi9cbiAgICBzZWxlY3RSb3dzRnJvbUNlbGxzOiBmdW5jdGlvbihvZmZzZXQsIGRvbnRDbGVhclJvd1NlbGVjdGlvbnMpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICAgIGRvbnRDbGVhclJvd1NlbGVjdGlvbnMgPSBkb250Q2xlYXJSb3dTZWxlY3Rpb25zID09PSB0cnVlO1xuXG4gICAgICAgIHZhciBzbSA9IHRoaXMucm93U2VsZWN0aW9uTW9kZWw7XG5cbiAgICAgICAgaWYgKCFkb250Q2xlYXJSb3dTZWxlY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFsbFJvd3NTZWxlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICBzbS5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdG9wID0gc2VsZWN0aW9uLm9yaWdpbi55LFxuICAgICAgICAgICAgICAgIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQueTtcbiAgICAgICAgICAgIHRvcCArPSBvZmZzZXQ7XG4gICAgICAgICAgICBzbS5zZWxlY3QodG9wLCB0b3AgKyBleHRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKi9cbiAgICBzZWxlY3RDb2x1bW5zRnJvbUNlbGxzOiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgICAgdmFyIHNtID0gdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgc20uY2xlYXIoKTtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gc2VsZWN0aW9uLm9yaWdpbi54LFxuICAgICAgICAgICAgICAgIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQueDtcbiAgICAgICAgICAgIGxlZnQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgc20uc2VsZWN0KGxlZnQsIGxlZnQgKyBleHRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBpc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgbGFzdCA9IHRoaXMuc2VsZWN0aW9uc1t0aGlzLnNlbGVjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBsYXN0ICYmIHRoaXMucmVjdGFuZ2xlQ29udGFpbnMobGFzdCwgeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gcmVjdFxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICByZWN0YW5nbGVDb250YWluczogZnVuY3Rpb24ocmVjdCwgeCwgeSkgeyAvL1RPRE86IGV4cGxvcmUgd2h5IHRoaXMgd29ya3MgYW5kIGNvbnRhaW5zIG9uIHJlY3RhbmdsdWxhciBkb2VzIG5vdFxuICAgICAgICB2YXIgbWluWCA9IHJlY3Qub3JpZ2luLng7XG4gICAgICAgIHZhciBtaW5ZID0gcmVjdC5vcmlnaW4ueTtcbiAgICAgICAgdmFyIG1heFggPSBtaW5YICsgcmVjdC5leHRlbnQueDtcbiAgICAgICAgdmFyIG1heFkgPSBtaW5ZICsgcmVjdC5leHRlbnQueTtcblxuICAgICAgICBpZiAocmVjdC5leHRlbnQueCA8IDApIHtcbiAgICAgICAgICAgIG1pblggPSBtYXhYO1xuICAgICAgICAgICAgbWF4WCA9IHJlY3Qub3JpZ2luLng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVjdC5leHRlbnQueSA8IDApIHtcbiAgICAgICAgICAgIG1pblkgPSBtYXhZO1xuICAgICAgICAgICAgbWF4WSA9IHJlY3Qub3JpZ2luLnk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID1cbiAgICAgICAgICAgIHggPj0gbWluWCAmJlxuICAgICAgICAgICAgeSA+PSBtaW5ZICYmXG4gICAgICAgICAgICB4IDw9IG1heFggJiZcbiAgICAgICAgICAgIHkgPD0gbWF4WTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0aW9uTW9kZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWN0YW5ndWxhciA9IHJlcXVpcmUoJ3JlY3Rhbmd1bGFyJyk7XG5cbi8vIFZhcmlhdGlvbiBvZiByZWN0YW5ndWxhci5Qb2ludCBidXQgd2l0aCB3cml0YWJsZSB4IGFuZCB5OlxuZnVuY3Rpb24gV3JpdGFibGVQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xufVxuXG5Xcml0YWJsZVBvaW50LnByb3RvdHlwZSA9IHJlY3Rhbmd1bGFyLlBvaW50LnByb3RvdHlwZTtcblxuLy8gVGhlIG51bGxTdWJncmlkIGlzIGZvciBDZWxsRXZlbnRzIHJlcHJlc2VudGluZyBjbGlja3MgYmVsb3cgbGFzdCByb3cuXG4vLyB2YXIgbnVsbFN1YmdyaWQgPSB7fTtcblxudmFyIHByb3RvdHlwZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7XG4gICAgdmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmlzaWJsZVJvdy5zdWJncmlkLmdldFZhbHVlKHRoaXMuZGF0YUNlbGwueCwgdGhpcy5kYXRhQ2VsbC55KTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLnZpc2libGVSb3cuc3ViZ3JpZC5zZXRWYWx1ZSh0aGlzLmRhdGFDZWxsLngsIHRoaXMuZGF0YUNlbGwueSwgdmFsdWUpOyB9XG4gICAgfSxcblxuICAgIGZvcm1hdHRlZFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmdyaWQuZm9ybWF0VmFsdWUodGhpcy5nZXRDZWxsUHJvcGVydHkoJ2Zvcm1hdCcpLCB0aGlzLnZhbHVlKTsgfVxuICAgIH0sXG5cbiAgICBib3VuZHM6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHMgfHwgKHRoaXMuX2JvdW5kcyA9IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLnZpc2libGVDb2x1bW4ubGVmdCxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnZpc2libGVSb3cudG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnZpc2libGVDb2x1bW4ud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnZpc2libGVSb3cuaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRDZWxsUHJvcGVydHk6IHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKHByb3BOYW1lKSB7IHJldHVybiB0aGlzLmNvbHVtbi5nZXRDZWxsUHJvcGVydHkodGhpcy5kYXRhQ2VsbC55LCBwcm9wTmFtZSwgdGhpcy52aXNpYmxlUm93LnN1YmdyaWQpOyB9XG4gICAgfSxcblxuICAgIC8vIFwiVmlzaWJsZVwiIG1lYW5zIHNjcm9sbGVkIGludG8gdmlldy5cbiAgICBpc1Jvd1Zpc2libGU6ICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuICEhdGhpcy52aXNpYmxlUm93OyB9IH0sXG4gICAgaXNDb2x1bW5WaXNpYmxlOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAhIXRoaXMudmlzaWJsZUNvbHVtbjsgfSB9LFxuICAgIGlzQ2VsbFZpc2libGU6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc1Jvd1Zpc2libGUgJiYgdGhpcy5pc0NvbHVtblZpc2libGU7IH0gfSxcblxuICAgIGlzR3JpZFJvdzogICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gIXRoaXMudmlzaWJsZVJvdy5zdWJncmlkLnR5cGU7IH0gfSxcbiAgICBpc0dyaWRDb2x1bW46IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZ3JpZENlbGwueCA+PSAwOyB9IH0sXG4gICAgaXNHcmlkQ2VsbDogICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzR3JpZFJvdyAmJiB0aGlzLmlzR3JpZENvbHVtbjsgfSB9LFxuXG4gICAgaXNSb3dTZWxlY3RlZDogICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0dyaWRSb3cgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlbC5pc1Jvd1NlbGVjdGVkKHRoaXMuZGF0YUNlbGwueSk7IH0gfSxcbiAgICBpc0NvbHVtblNlbGVjdGVkOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzR3JpZENvbHVtbiAmJiB0aGlzLnNlbGVjdGlvbk1vZGVsLmlzQ29sdW1uU2VsZWN0ZWQodGhpcy5ncmlkQ2VsbC54KTsgfSB9LFxuICAgIGlzQ2VsbFNlbGVjdGVkOiAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWwuaXNDZWxsU2VsZWN0ZWQodGhpcy5ncmlkQ2VsbC54LCB0aGlzLmRhdGFDZWxsLnkpOyB9IH0sXG5cbiAgICBpc1Jvd0hvdmVyZWQ6ICAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNHcmlkUm93ICYmIHRoaXMuZ3JpZC5ob3ZlckNlbGwgJiYgdGhpcy5ncmlkLmhvdmVyQ2VsbC55ID09PSB0aGlzLmdyaWRDZWxsLnk7IH0gfSxcbiAgICBpc0NvbHVtbkhvdmVyZWQ6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNHcmlkQ29sdW1uICYmIHRoaXMuZ3JpZC5ob3ZlckNlbGwgJiYgdGhpcy5ncmlkLmhvdmVyQ2VsbC54ID09PSB0aGlzLmdyaWRDZWxsLng7IH0gfSxcbiAgICBpc0NlbGxIb3ZlcmVkOiAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNSb3dIb3ZlcmVkICYmIHRoaXMuaXNDb2x1bW5Ib3ZlcmVkOyB9IH0sXG5cbiAgICBpc1Jvd0ZpeGVkOiAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzR3JpZFJvdyAmJiB0aGlzLmRhdGFDZWxsLnkgPCB0aGlzLmdyaWQucHJvcGVydGllcy5maXhlZFJvd0NvdW50OyB9IH0sXG4gICAgaXNDb2x1bW5GaXhlZDogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0dyaWRDb2x1bW4gJiYgdGhpcy5ncmlkQ2VsbC54IDwgdGhpcy5ncmlkLnByb3BlcnRpZXMuZml4ZWRDb2x1bW5Db3VudDsgfSB9LFxuICAgIGlzQ2VsbEZpeGVkOiAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNSb3dGaXhlZCAmJiB0aGlzLmlzQ29sdW1uRml4ZWQ7IH0gfSxcblxuICAgIGlzSGFuZGxlQ29sdW1uOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiAhdGhpcy5pc0dyaWRDb2x1bW47IH0gfSxcbiAgICBpc0hhbmRsZUNlbGw6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0hhbmRsZUNvbHVtbiAmJiB0aGlzLmlzR3JpZFJvdzsgfSB9LFxuXG4gICAgaXNIaWVyYXJjaHlDb2x1bW46IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZ3JpZENlbGwueCA9PT0gMCAmJiB0aGlzLmdyaWQucHJvcGVydGllcy5zaG93VHJlZUNvbHVtbiAmJiB0aGlzLmRhdGFNb2RlbC5pc0RyaWxsRG93bih0aGlzLmRhdGFDZWxsLngpOyB9IH0sXG5cbiAgICBpc0hlYWRlclJvdzogICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy52aXNpYmxlUm93LnN1YmdyaWQudHlwZSA9PT0gJ2hlYWRlcic7IH0gfSxcbiAgICBpc0hlYWRlckhhbmRsZTogeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0hlYWRlclJvdyAmJiB0aGlzLmlzSGFuZGxlQ29sdW1uOyB9IH0sXG4gICAgaXNIZWFkZXJDZWxsOiAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNIZWFkZXJSb3cgJiYgdGhpcy5pc0dyaWRDb2x1bW47IH0gfSxcblxuICAgIGlzRmlsdGVyUm93OiAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpc2libGVSb3cuc3ViZ3JpZC50eXBlID09PSAnZmlsdGVyJzsgfSB9LFxuICAgIGlzRmlsdGVySGFuZGxlOiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzRmlsdGVyUm93ICYmIHRoaXMuaXNIYW5kbGVDb2x1bW47IH0gfSxcbiAgICBpc0ZpbHRlckNlbGw6ICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pc0ZpbHRlclJvdyAmJiB0aGlzLmlzR3JpZENvbHVtbjsgfSB9LFxuXG4gICAgaXNTdW1tYXJ5Um93OiAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpc2libGVSb3cuc3ViZ3JpZC50eXBlID09PSAnc3VtbWFyeSc7IH0gfSxcbiAgICBpc1N1bW1hcnlIYW5kbGU6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNTdW1tYXJ5Um93ICYmIHRoaXMuaXNIYW5kbGVDb2x1bW47IH0gfSxcbiAgICBpc1N1bW1hcnlDZWxsOiAgIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNTdW1tYXJ5Um93ICYmIHRoaXMuaXNHcmlkQ29sdW1uOyB9IH0sXG5cbiAgICBpc1RvcFRvdGFsc1JvdzogICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy52aXNpYmxlUm93LnN1YmdyaWQgPT09IHRoaXMuYmVoYXZpb3Iuc3ViZ3JpZHMudG9wVG90YWxzOyB9IH0sXG4gICAgaXNUb3BUb3RhbHNIYW5kbGU6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNUb3BUb3RhbHNSb3cgJiYgdGhpcy5pc0hhbmRsZUNvbHVtbjsgfSB9LFxuICAgIGlzVG9wVG90YWxzQ2VsbDogICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzVG9wVG90YWxzUm93ICYmIHRoaXMuaXNHcmlkQ29sdW1uOyB9IH0sXG5cbiAgICBpc0JvdHRvbVRvdGFsc1JvdzogICAgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy52aXNpYmxlUm93LnN1YmdyaWQgPT09IHRoaXMuYmVoYXZpb3Iuc3ViZ3JpZHMuYm90dG9tVG90YWxzOyB9IH0sXG4gICAgaXNCb3R0b21Ub3RhbHNIYW5kbGU6IHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaXNCb3R0b21Ub3RhbHNSb3cgJiYgdGhpcy5pc0hhbmRsZUNvbHVtbjsgfSB9LFxuICAgIGlzQm90dG9tVG90YWxzQ2VsbDogICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlzQm90dG9tVG90YWxzUm93ICYmIHRoaXMuaXNHcmlkQ29sdW1uOyB9IH1cbn0pO1xuXG4vKipcbiAqIEBjbGFzc2Rlc2MgYENlbGxFdmVudGAgaXMgYSB2ZXJ5IGxvdy1sZXZlbCBvYmplY3QgdGhhdCBuZWVkcyB0byBiZSBzdXBlci1lZmZpY2llbnQuIEphdmFTY3JpcHQgb2JqZWN0cyBhcmUgd2VsbCBrbm93biB0byBiZSBsaWdodCB3ZWlnaHQgaW4gZ2VuZXJhbCwgYnV0IGF0IHRoaXMgbGV2ZWwgd2UgbmVlZCB0byBiZSBjYXJlZnVsLlxuICpcbiAqIFRoZXNlIG9iamVjdHMgd2VyZSBvcmlnaW5hbGx5IG9ubHkgYmVpbmcgY3JlYXRlZCBvbiBtb3VzZSBldmVudHMuIFRoaXMgd2FzIG5vIGJpZyBkZWFsIGFzIG1vdXNlIGV2ZW50cyBhcmUgZmV3IGFuZCBmYXIgYmV0d2Vlbi4gSG93ZXZlciwgYXMgb2YgdjEuMi4wLCB0aGUgcmVuZGVyZXIgbm93IGFsc28gY3JlYXRlcyBvbmUgZm9yIGVhY2ggdmlzaWJsZSBjZWxsIG9uIGVhY2ggYW5kIGV2ZXJ5IGdyaWQgcGFpbnQuXG4gKlxuICogRm9yIHRoaXMgcmVhc29uLCB0byBtYWludGFpbiBwZXJmb3JtYW5jZSwgZWFjaCBncmlkIGdldHMgYSBjdXN0b20gZGVmaW5pdGlvbiBvZiBgQ2VsbEV2ZW50YCwgY3JlYXRlZCBieSB0aGlzIGNsYXNzIGZhY3RvcnksIHdpdGggdGhlIGZvbGxvd2luZyBvcHRpbWl6YXRpb25zOlxuICpcbiAqICogVXNlIG9mIGBleHRlbmQtbWVgIGlzIGF2b2lkZWQgYmVjYXVzZSBpdHMgYGluaXRpYWxpemVgIGNoYWluIGlzIGEgYml0IHRvbyBoZWF2eSBoZXJlLlxuICogKiBDdXN0b20gdmVyc2lvbnMgb2YgYENlbGxFdmVudGAgZm9yIGVhY2ggZ3JpZCBsaWdodGVucyB0aGUgbG9hZCBvbiB0aGUgY29uc3RydWN0b3IuXG4gKlxuICogQHN1bW1hcnkgQ3JlYXRlIGEgY3VzdG9tIGBDZWxsRXZlbnRgIGNsYXNzLlxuICpcbiAqIEBkZXNjIENyZWF0ZSBhIGN1c3RvbSBkZWZpbml0aW9uIG9mIGBDZWxsRXZlbnRgIGZvciBlYWNoIGdyaWQgaW5zdGFuY2UsIHNldHRpbmcgdGhlIGBncmlkYCwgYGJlaGF2aW9yYCwgYW5kIGBkYXRhTW9kZWxgIHByb3BlcnRpZXMgb24gdGhlIHByb3RvdHlwZS4gQXMgdGhpcyBoYXBwZW5zIG9uY2UgcGVyIGdyaWQgaW5zdGFudGlhdGlvbiwgaXQgYXZvaWRzIGhhdmluZyB0byBwZXJmb3JtIHRoaXMgc2V0IHVwIHdvcmsgb24gZXZlcnkgYENlbGxFdmVudGAgaW5zdGFudGlhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0h5cGVyR3JpZH0gZ3JpZFxuICpcbiAqIEByZXR1cm5zIHtDZWxsRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIENlbGxFdmVudChncmlkKSB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgQ2VsbEV2ZW50IG9iamVjdC5cbiAgICAgKiBAZGVzYyBBbGwgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgbWl4ZWQgaW50byBjZWxsIGVkaXRvcjpcbiAgICAgKiAqIEluY2x1ZGVzIGB0aGlzLmNvbHVtbmAgZGVmaW5lZCBieSBjb25zdHJ1Y3RvciAoYXMgZW51bWVyYWJsZSkuXG4gICAgICogKiBFeGNsdWRlcyBgdGhpcy5ncmlkQ2VsbGAsIGB0aGlzLmRhdGFDZWxsYCwgYHRoaXMudmlzaWJsZVJvdy5zdWJncmlkYCBkZWZpbmVkIGJ5IGNvbnN0cnVjdG9yIChhcyBub24tZW51bWVyYWJsZSkuXG4gICAgICogKiBBbnkgYWRkaXRpb25hbCAoZW51bWVyYWJsZSkgbWVtYmVycyBtaXhlZCBpbiBieSBhcHBsaWNhdGlvbidzIGBnZXRDZWxsRWRpdG9yQXRgIG92ZXJyaWRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gZ3JpZCBjZWxsIGNvb3JkaW5hdGUgKGFkanVzdGVkIGZvciBob3Jpem9udGFsIHNjcm9sbGluZyBhZnRlciBmaXhlZCBjb2x1bW5zKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gZ3JpZCBjZWxsIGNvb3JkaW5hdGUsIGFkanVzdGVkIChhZGp1c3RlZCBmb3IgdmVydGljYWwgc2Nyb2xsaW5nIGlmIGRhdGEgc3ViZ3JpZClcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDZWxsRXZlbnQoeCwgeSkge1xuICAgICAgICB2YXIgdmlzaWJsZVJvdyA9IGdyaWQucmVuZGVyZXIudmlzaWJsZVJvd3NbeV07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlZmVyZW5jZSB0byBjb2x1bW4ncyB7QGxpbmsgQ29sdW1ufSBvYmplY3QuXG4gICAgICAgICAqIEBkZXNjIE5vdGVzOlxuICAgICAgICAgKiAqIERlZmluZWQgYXMgZW51bWVyYWJsZSBzbyB0aGF0IGBDZWxsRWRpdG9yYCBjb25zdHJ1Y3RvciBtaXhlcyBpbnRvIGl0c2VsZi5cbiAgICAgICAgICogKiBEZWZpbmVkIGFzIHdyaXRhYmxlIHNvIGl0IGNhbiBiZSBvdmVyd3JpdHRlbiBpbiBgcmVuZGVyZXIucGFpbnRDZWxsc2AuXG4gICAgICAgICAqIEBuYW1lIGNvbHVtblxuICAgICAgICAgKiBAdHlwZSB7Q29sdW1ufVxuICAgICAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW4gPSBncmlkLmJlaGF2aW9yLmdldEFjdGl2ZUNvbHVtbih4KTtcblxuXG4gICAgICAgIC8vIHJlbWFpbmluZyBpbnN0YW5jZSB2YXJzIGFyZSBub24tZW51bWVyYWJsZSBzbyBgQ2VsbEVkaXRvcmAgY29uc3RydWN0b3Igd29uJ3QgbWl4IHRoZW0gaW4gKGZvciBtdXN0YWNoZSB1c2UpLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBuYW1lIHZpc2libGVDb2x1bW5cbiAgICAgICAgICAgICAqIEB0eXBlIHt2aXNpYmxlQ29sdW1uRGVzY3JpcHRvcn1cbiAgICAgICAgICAgICAqIEBtZW1iZXJPZiBDZWxsRXZlbnQjXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZpc2libGVDb2x1bW46IHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSwgLy8gQWxsb3cgdG8gYmUgb3ZlcndyaXR0ZW4gaW4gYHJlbmRlcmVyLnBhaW50Q2VsbHNgIGFuZCBgLmNvbXB1dGVDZWxsc0JvdW5kc2AuXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuZ3JpZC5yZW5kZXJlci52aXNpYmxlQ29sdW1ucy5maW5kKGZ1bmN0aW9uKHZjKSB7IHJldHVybiB2Yy5jb2x1bW5JbmRleCA9PT0geDsgfSlcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG5hbWUgdmlzaWJsZVJvd1xuICAgICAgICAgICAgICogQHR5cGUge3Zpc2libGVSb3dEZXNjcmlwdG9yfVxuICAgICAgICAgICAgICogQG1lbWJlck9mIENlbGxFdmVudCNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlzaWJsZVJvdzoge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLCAvLyBBbGxvdyB0byBiZSBvdmVyd3JpdHRlbiBpbiBgcmVuZGVyZXIucGFpbnRDZWxsc2AgYW5kIGAuY29tcHV0ZUNlbGxzQm91bmRzYC5cbiAgICAgICAgICAgICAgICB2YWx1ZTogdmlzaWJsZVJvd1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbmFtZSBncmlkQ2VsbFxuICAgICAgICAgICAgICogQHR5cGUge1dyaXRhYmxlUG9pbnR9XG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBncmlkQ2VsbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgV3JpdGFibGVQb2ludCh4LCB5KVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbmFtZSBkYXRhQ2VsbFxuICAgICAgICAgICAgICogQHR5cGUge1dyaXRhYmxlUG9pbnR9XG4gICAgICAgICAgICAgKiBAbWVtYmVyT2YgQ2VsbEV2ZW50I1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBkYXRhQ2VsbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgV3JpdGFibGVQb2ludCh0aGlzLmNvbHVtbiAmJiB0aGlzLmNvbHVtbi5pbmRleCwgdmlzaWJsZVJvdy5yb3dJbmRleClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgQ2VsbEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENlbGxFdmVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IENlbGxFdmVudCB9LFxuICAgICAgICBncmlkOiB7IHZhbHVlOiBncmlkIH0sXG4gICAgICAgIHJlbmRlcmVyOiB7IHZhbHVlOiBncmlkLnJlbmRlcmVyIH0sXG4gICAgICAgIHNlbGVjdGlvbk1vZGVsOiB7IHZhbHVlOiBncmlkLnNlbGVjdGlvbk1vZGVsIH0sXG4gICAgICAgIGJlaGF2aW9yOiB7IHZhbHVlOiBncmlkLmJlaGF2aW9yIH0sXG4gICAgICAgIGRhdGFNb2RlbDogeyB2YWx1ZTogZ3JpZC5iZWhhdmlvci5kYXRhTW9kZWwgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIENlbGxFdmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsRXZlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGNvbnNvbGUud2FybiBwb2x5ZmlsbCBhcyBuZWVkZWRcbi8vIHVzZWQgZm9yIGRlcHJlY2F0aW9uIHdhcm5pbmdzXG5pZiAoIWNvbnNvbGUud2Fybikge1xuICAgIGNvbnNvbGUud2FybiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBbJ1dBUk5JTkc6J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xufVxuXG52YXIgd2FybmVkID0ge307XG5cbnZhciByZWdleElzTWV0aG9kID0gL1xcKSQvO1xuXG4vKipcbiAqIFVzZXIgaXMgd2FybmVkIGFuZCBuZXcgcHJvcGVydHkgaXMgcmV0dXJuZWQgb3IgbmV3IG1ldGhvZCBpcyBjYWxsZWQgYW5kIHRoZSByZXN1bHQgaXMgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSAtIERlcHJlY2F0ZWQgbWV0aG9kIG5hbWUgd2l0aCBwYXJlbnRoZXNlcyAocmVxdWlyZWQpIGNvbnRhaW5pbmcgYXJndW1lbnQgbGlzdCAob3B0aW9uYWw7IHNlZSBgYXJnc2AgYmVsb3cpLlxuICogQHBhcmFtIHtzdHJpbmd9IGRvdFByb3BzIC0gRG90LXNlcGFyYXRlZCBuZXcgcHJvcGVydHkgbmFtZSB0byBpbnZva2Ugb3IgbWV0aG9kIG5hbWUgdG8gY2FsbC4gTWV0aG9kIG5hbWVzIGFyZSBpbmRpY2F0ZWQgYnkgaW5jbHVkaW5nIHBhcmVudGhlc2VzIHdpdGggb3B0aW9uYWwgYXJndW1lbnQgbGlzdC4gVGhlIGFyZ3VtZW50cyBpbiBlYWNoIGxpc3QgYXJlIGRyYXduIGZyb20gdGhlIGFyZ3VtZW50cyBwcmVzZW50ZWQgaW4gdGhlIGBtZXRob2ROYW1lYCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2luY2UgLSBWZXJzaW9uIGluIHdoaWNoIHRoZSBuYW1lIHdhcyBkZXByZWNhdGVkLlxuICogQHBhcmFtIHtBcmd1bWVudHN8QXJyYXl9IFthcmdzXSAtIFRoZSBhY3R1YWwgYXJndW1lbnRzIGluIHRoZSBvcmRlciBsaXN0ZWQgaW4gYG1ldGhvZE5hbWVgLiBPbmx5IG5lZWRlZCB3aGVuIGFyZ3VtZW50cyBuZWVkIHRvIGJlIGZvcndhcmRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbm90ZXNdIC0gTm90ZXMgdG8gYWRkIHRvIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJuIHZhbHVlIG9mIG5ldyBwcm9wZXJ0eSBvciBtZXRob2QgY2FsbC5cbiAqL1xudmFyIGRlcHJlY2F0ZWQgPSBmdW5jdGlvbihtZXRob2ROYW1lLCBkb3RQcm9wcywgc2luY2UsIGFyZ3MsIG5vdGVzKSB7XG4gICAgaWYgKCFyZWdleElzTWV0aG9kLnRlc3QobWV0aG9kTmFtZSkpIHtcbiAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIG1ldGhvZCBuYW1lIHRvIGhhdmUgcGFyZW50aGVzZXMuJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGBhcmdzYCBvbWl0dGVkXG4gICAgICAgIG5vdGVzID0gYXJncztcbiAgICAgICAgYXJncyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgY2hhaW4gPSBkb3RQcm9wcy5zcGxpdCgnLicpLFxuICAgICAgICBmb3JtYWxBcmdMaXN0ID0gYXJnTGlzdChtZXRob2ROYW1lKSxcbiAgICAgICAgcmVzdWx0ID0gdGhpcztcblxuICAgIGlmICghKG1ldGhvZE5hbWUgaW4gd2FybmVkKSkge1xuICAgICAgICB3YXJuZWRbbWV0aG9kTmFtZV0gPSBkZXByZWNhdGVkLndhcm5pbmdzO1xuICAgIH1cbiAgICBpZiAod2FybmVkW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIHZhciBtZW1iZXJUeXBlID0gcmVnZXhJc01ldGhvZC50ZXN0KGRvdFByb3BzKSA/ICdtZXRob2QnIDogJ3Byb3BlcnR5JztcbiAgICAgICAgdmFyIHdhcm5pbmcgPSAnVGhlIC4nICsgbWV0aG9kTmFtZSArICcgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYXMgb2YgdicgKyBzaW5jZSArXG4gICAgICAgICAgICAnIGluIGZhdm9yIG9mIHRoZSAuJyArIGNoYWluLmpvaW4oJy4nKSArICcgJyArIG1lbWJlclR5cGUgKyAnLicgK1xuICAgICAgICAgICAgJyAoV2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UuKSc7XG5cbiAgICAgICAgaWYgKG5vdGVzKSB7XG4gICAgICAgICAgICB3YXJuaW5nICs9ICcgJyArIG5vdGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuXG4gICAgICAgIC0td2FybmVkW21ldGhvZE5hbWVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcFRvRm9ybWFsQXJnKGFyZ05hbWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZm9ybWFsQXJnTGlzdC5pbmRleE9mKGFyZ05hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyAnQWN0dWFsIGFyZyBcIicgKyBhcmdOYW1lICsgJ1wiIG5vdCBmb3VuZCBpbiBmb3JtYWwgYXJnIGxpc3QgJyArIGZvcm1hbEFyZ0xpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbaW5kZXhdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsYXN0ID0gY2hhaW4ubGVuZ3RoIC0gMTsgaSA8PSBsYXN0OyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmsgPSBjaGFpbltpXSxcbiAgICAgICAgICAgIG5hbWUgPSBsaW5rLm1hdGNoKC9cXHcrLylbMF0sXG4gICAgICAgICAgICBpc01ldGhvZCA9IHJlZ2V4SXNNZXRob2QudGVzdChsaW5rKSxcbiAgICAgICAgICAgIGFjdHVhbEFyZ0xpc3QgPSBpc01ldGhvZCA/IGFyZ0xpc3QobGluaykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhY3R1YWxBcmdzID0gW107XG5cbiAgICAgICAgaWYgKGFjdHVhbEFyZ0xpc3QpIHtcbiAgICAgICAgICAgIGFjdHVhbEFyZ3MgPSBhY3R1YWxBcmdMaXN0Lm1hcChtYXBUb0Zvcm1hbEFyZyk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbbmFtZV0uYXBwbHkocmVzdWx0LCBhY3R1YWxBcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01ldGhvZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0W25hbWVdKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZGVwcmVjYXRlZC53YXJuaW5ncyA9IDE7IC8vIDMgb3IgNSB3b3VsZCBnZXQgbW9yZSBhdHRlbnRpb25cblxuZnVuY3Rpb24gYXJnTGlzdChzKSB7XG4gICAgcmV0dXJuIHMubWF0Y2goL15cXHcrXFwoKC4qKVxcKSQvKVsxXS5tYXRjaCgvKFxcdyspL2cpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEh5cGVyZ3JpZEVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG4vLyBleHRlbmQgZnJvbSBgRXJyb3JgXG5IeXBlcmdyaWRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbi8vIG92ZXJyaWRlIGVycm9yIG5hbWUgZGlzcGxheWVkIGluIGNvbnNvbGVcbkh5cGVyZ3JpZEVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0h5cGVyZ3JpZEVycm9yJztcblxubW9kdWxlLmV4cG9ydHMgPSBIeXBlcmdyaWRFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG4vKiBJTVBPUlRBTlQgTk9URTpcbiAqIElmIGFueSBvZiB0aGUgbW9kdWxlcyBsaXN0ZWQgYmVsb3cgaXMgcmVtb3ZlZCBmcm9tIEh5cGVyZ3JpZCwgdGhlIHBvbHlmaWxsKHMpIHRoZXkgZGVmaW5lIG11c3QgYmUgYWRkZWQgaGVyZSEhIVxuICpcbiAqIDEuIG9iamVjdC1pdGVyYXRvcnMgZGVmaW5lcyBBcnJheS5wcm90b3R5cGUuZmluZFxuICovXG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tZXh0ZW5kLW5hdGl2ZSAqL1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL3NpZ24jUG9seWZpbGxcbk1hdGguc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7XG4gICAgeCA9ICt4OyAvLyBjb252ZXJ0IHRvIGEgbnVtYmVyXG4gICAgaWYgKHggPT09IDAgfHwgaXNOYU4oeCkpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIHJldHVybiB4ID4gMCA/IDEgOiAtMTtcbn07XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbmRJbmRleFxuaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZEluZGV4IGNhbGxlZCBvbiBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcmVkaWNhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3QgPSBPYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgdmFsdWUsIGksIGxpc3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG59XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXV0b21hdCA9IHJlcXVpcmUoJ2F1dG9tYXQnKTtcblxudmFyIGNzcyA9IHJlcXVpcmUoJy4uLy4uL2NzcycpO1xuXG4vLyBub3RlIHRoZSBwb3NpdGlvbiBvZiB0aGUgIGZpcnN0IFwibmF0dXJhbFwiIHN0eWxlc2hlZXQuIFdlIHdpbGwgaW5zZXJ0IG91ciBzdHlsZXNoZWV0cyBiZWZvcmUgdGhpcyBub2RlLlxudmFyIGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJyk7XG52YXIgcmVmTm9kZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGhlYWQuY2hpbGRyZW4pLmZpbmQoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQudGFnTmFtZSA9PT0gJ1NUWUxFJyB8fFxuICAgICAgICBjaGlsZC50YWdOYW1lID09PSAnTElOSycgJiZcbiAgICAgICAgY2hpbGQuZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ3N0eWxlc2hlZXQnICYmXG4gICAgICAgIGNoaWxkLmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAndGV4dC9jc3MnO1xufSk7XG5cbmV4cG9ydHMucHJlZml4ID0gJ2luamVjdGVkLXN0eWxlc2hlZXQtJztcblxuZXhwb3J0cy5pbmplY3QgPSBmdW5jdGlvbihpZCwgcmVwbGFjZW1lbnRzKSB7XG4gICAgdmFyIHN0eWxlc2hlZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIHRoaXMucHJlZml4ICsgaWQpO1xuXG4gICAgaWYgKCFzdHlsZXNoZWV0KSB7XG4gICAgICAgIHN0eWxlc2hlZXQgPSBjc3NbaWRdO1xuICAgICAgICBzdHlsZXNoZWV0ID0gJzxzdHlsZT5cXG4nICsgc3R5bGVzaGVldCArICdcXG48L3N0eWxlPlxcbic7XG4gICAgICAgIHZhciBhcmdzID0gW3N0eWxlc2hlZXQsIGhlYWQsIHJlZk5vZGVdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgc3R5bGVzaGVldCA9IGF1dG9tYXQuYXBwZW5kLmFwcGx5KG51bGwsIGFyZ3MpWzBdO1xuICAgICAgICBzdHlsZXNoZWV0LmlkID0gdGhpcy5wcmVmaXggKyBpZDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVzaGVldDtcbn07XG4iXX0=
